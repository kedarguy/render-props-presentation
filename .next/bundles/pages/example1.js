
          window.__NEXT_REGISTER_PAGE('/example1', function() {
            var comp = module.exports =
webpackJsonp([6],[
/* 0 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(3);
var core = __webpack_require__(0);
var ctx = __webpack_require__(8);
var hide = __webpack_require__(9);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(41)('wks');
var uid = __webpack_require__(26);
var Symbol = __webpack_require__(3).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(7);
var IE8_DOM_DEFINE = __webpack_require__(61);
var toPrimitive = __webpack_require__(38);
var dP = Object.defineProperty;

exports.f = __webpack_require__(6) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(10)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(24);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(4);
var createDesc = __webpack_require__(19);
module.exports = __webpack_require__(6) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 11 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(39);
var defined = __webpack_require__(36);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(36);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(85);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {
  module.exports = require('./cjs/react.production.min.js');
} else {
  module.exports = __webpack_require__(127);
}


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(90)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(37)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(63);
var enumBugKeys = __webpack_require__(42);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(4).f;
var has = __webpack_require__(11);
var TAG = __webpack_require__(2)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(8);
var call = __webpack_require__(73);
var isArrayIter = __webpack_require__(74);
var anObject = __webpack_require__(7);
var toLength = __webpack_require__(30);
var getIterFn = __webpack_require__(54);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 23 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(7);
var dPs = __webpack_require__(92);
var enumBugKeys = __webpack_require__(42);
var IE_PROTO = __webpack_require__(40)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(50)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(72).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 26 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(96);
var global = __webpack_require__(3);
var hide = __webpack_require__(9);
var Iterators = __webpack_require__(13);
var TO_STRING_TAG = __webpack_require__(2)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 28 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(35);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(23);
var TAG = __webpack_require__(2)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (true) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(31);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (true) {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),
/* 35 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 36 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(29);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(62);
var hide = __webpack_require__(9);
var has = __webpack_require__(11);
var Iterators = __webpack_require__(13);
var $iterCreate = __webpack_require__(91);
var setToStringTag = __webpack_require__(21);
var getPrototypeOf = __webpack_require__(64);
var ITERATOR = __webpack_require__(2)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(5);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(23);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(41)('keys');
var uid = __webpack_require__(26);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(3);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 42 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 43 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(109), __esModule: true };

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(55);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(2);


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(26)('meta');
var isObject = __webpack_require__(5);
var has = __webpack_require__(11);
var setDesc = __webpack_require__(4).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(10)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(3);
var core = __webpack_require__(0);
var LIBRARY = __webpack_require__(29);
var wksExt = __webpack_require__(46);
var defineProperty = __webpack_require__(4).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(120);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(124);

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(55);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
var document = __webpack_require__(3).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 51 */
/***/ (function(module, exports) {



/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(9);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(32);
var ITERATOR = __webpack_require__(2)('iterator');
var Iterators = __webpack_require__(13);
module.exports = __webpack_require__(0).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(111);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(113);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  var invariant = __webpack_require__(33);
  var warning = __webpack_require__(34);
  var ReactPropTypesSecret = __webpack_require__(69);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(128)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}


/***/ }),
/* 59 */,
/* 60 */,
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(6) && !__webpack_require__(10)(function () {
  return Object.defineProperty(__webpack_require__(50)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(9);


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(11);
var toIObject = __webpack_require__(12);
var arrayIndexOf = __webpack_require__(93)(false);
var IE_PROTO = __webpack_require__(40)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(11);
var toObject = __webpack_require__(14);
var IE_PROTO = __webpack_require__(40)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(23);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(63);
var hiddenKeys = __webpack_require__(42).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(28);
var createDesc = __webpack_require__(19);
var toIObject = __webpack_require__(12);
var toPrimitive = __webpack_require__(38);
var has = __webpack_require__(11);
var IE8_DOM_DEFINE = __webpack_require__(61);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(6) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(169), __esModule: true };

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(3).document;
module.exports = document && document.documentElement;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(7);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(13);
var ITERATOR = __webpack_require__(2)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(1);
var core = __webpack_require__(0);
var fails = __webpack_require__(10);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(106), __esModule: true };

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadGetInitialProps = undefined;

var _regenerator = __webpack_require__(87);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(88);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _assign = __webpack_require__(76);

var _assign2 = _interopRequireDefault(_assign);

var loadGetInitialProps = exports.loadGetInitialProps = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(Component, ctx) {
    var props, compName, message;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (Component.getInitialProps) {
              _context.next = 2;
              break;
            }

            return _context.abrupt('return', {});

          case 2:
            _context.next = 4;
            return Component.getInitialProps(ctx);

          case 4:
            props = _context.sent;

            if (!(!props && (!ctx.res || !ctx.res.finished))) {
              _context.next = 9;
              break;
            }

            compName = getDisplayName(Component);
            message = '"' + compName + '.getInitialProps()" should resolve to an object. But found "' + props + '" instead.';
            throw new Error(message);

          case 9:
            return _context.abrupt('return', props);

          case 10:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function loadGetInitialProps(_x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

exports.warn = warn;
exports.execOnce = execOnce;
exports.deprecated = deprecated;
exports.printAndExit = printAndExit;
exports.getDisplayName = getDisplayName;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function warn(message) {
  if (true) {
    console.error(message);
  }
}

function execOnce(fn) {
  var _this = this;

  var used = false;
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (!used) {
      used = true;
      fn.apply(_this, args);
    }
  };
}

function deprecated(fn, message) {
  if (false) return fn;

  var warned = false;
  var newFn = function newFn() {
    if (!warned) {
      warned = true;
      console.error(message);
    }

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return fn.apply(this, args);
  };

  // copy all properties
  (0, _assign2.default)(newFn, fn);

  return newFn;
}

function printAndExit(message) {
  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  if (code === 0) {
    console.log(message);
  } else {
    console.error(message);
  }

  process.exit(code);
}

function getDisplayName(Component) {
  return Component.displayName || Component.name || 'Unknown';
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;

  return protocol + '//' + hostname + (port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;

  var origin = getLocationOrigin();
  return href.substring(origin.length);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(129)))

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(24);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(3);
var core = __webpack_require__(0);
var dP = __webpack_require__(4);
var DESCRIPTORS = __webpack_require__(6);
var SPECIES = __webpack_require__(2)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(175), __esModule: true };

/***/ }),
/* 81 */,
/* 82 */,
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(162), __esModule: true };

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(99);
exports.encode = exports.stringify = __webpack_require__(100);


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(103), __esModule: true };

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (true) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(167);


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(70);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),
/* 89 */,
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(35);
var defined = __webpack_require__(36);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(25);
var descriptor = __webpack_require__(19);
var setToStringTag = __webpack_require__(21);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(9)(IteratorPrototype, __webpack_require__(2)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(4);
var anObject = __webpack_require__(7);
var getKeys = __webpack_require__(20);

module.exports = __webpack_require__(6) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(12);
var toLength = __webpack_require__(30);
var toAbsoluteIndex = __webpack_require__(94);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(35);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(2)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(97);
var step = __webpack_require__(65);
var Iterators = __webpack_require__(13);
var toIObject = __webpack_require__(12);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(37)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Router = exports.createRouter = exports.withRouter = undefined;

var _slicedToArray2 = __webpack_require__(102);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _defineProperty = __webpack_require__(85);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _withRouter = __webpack_require__(231);

Object.defineProperty(exports, 'withRouter', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_withRouter).default;
  }
});
exports._notifyBuildIdMismatch = _notifyBuildIdMismatch;
exports._rewriteUrlForNextExport = _rewriteUrlForNextExport;
exports.makePublicRouterInstance = makePublicRouterInstance;

var _router = __webpack_require__(233);

var _router2 = _interopRequireDefault(_router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SingletonRouter = {
  router: null, // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();
    if (typeof window !== 'undefined') {
      this.readyCallbacks.push(cb);
    }
  }
};

// Create public properties and methods of the router in the SingletonRouter
/* global window */
var propertyFields = ['components', 'pathname', 'route', 'query', 'asPath'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError'];

propertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  (0, _defineProperty2.default)(SingletonRouter, field, {
    get: function get() {
      throwIfNoRouter();
      return SingletonRouter.router[field];
    }
  });
});

coreMethodFields.forEach(function (field) {
  SingletonRouter[field] = function () {
    var _SingletonRouter$rout;

    throwIfNoRouter();
    return (_SingletonRouter$rout = SingletonRouter.router)[field].apply(_SingletonRouter$rout, arguments);
  };
});

routerEvents.forEach(function (event) {
  SingletonRouter.ready(function () {
    SingletonRouter.router.events.on(event, function () {
      var eventField = 'on' + event.charAt(0).toUpperCase() + event.substring(1);
      if (SingletonRouter[eventField]) {
        try {
          SingletonRouter[eventField].apply(SingletonRouter, arguments);
        } catch (err) {
          console.error('Error when running the Router event: ' + eventField);
          console.error(err.message + '\n' + err.stack);
        }
      }
    });
  });
});

function throwIfNoRouter() {
  if (!SingletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }
}

// Export the SingletonRouter and this is the public API.
exports.default = SingletonRouter;

// Reexport the withRoute HOC

// INTERNAL APIS
// -------------
// (do not use following exports inside the app)

// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.
var createRouter = exports.createRouter = function createRouter() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  SingletonRouter.router = new (Function.prototype.bind.apply(_router2.default, [null].concat(args)))();
  SingletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  SingletonRouter.readyCallbacks = [];

  return SingletonRouter.router;
};

// Export the actual Router class, which is usually used inside the server
var Router = exports.Router = _router2.default;

function _notifyBuildIdMismatch(nextRoute) {
  if (SingletonRouter.onAppUpdated) {
    SingletonRouter.onAppUpdated(nextRoute);
  } else {
    console.warn('An app update detected. Loading the SSR version of "' + nextRoute + '"');
    window.location.href = nextRoute;
  }
}

function _rewriteUrlForNextExport(url) {
  var _url$split = url.split('#'),
      _url$split2 = (0, _slicedToArray3.default)(_url$split, 2),
      hash = _url$split2[1];

  url = url.replace(/#.*/, '');

  var _url$split3 = url.split('?'),
      _url$split4 = (0, _slicedToArray3.default)(_url$split3, 2),
      path = _url$split4[0],
      qs = _url$split4[1];

  path = path.replace(/\/$/, '');

  var newPath = path;
  // Append a trailing slash if this path does not have an extension
  if (!/\.[^/]+\/?$/.test(path)) {
    newPath = path + '/';
  }

  if (qs) {
    newPath = newPath + '?' + qs;
  }

  if (hash) {
    newPath = newPath + '#' + hash;
  }

  return newPath;
}

function makePublicRouterInstance(router) {
  var instance = {};

  propertyFields.forEach(function (field) {
    // Here we need to use Object.defineProperty because, we need to return
    // the property assigned to the actual router
    // The value might get changed as we change routes and this is the
    // proper way to access it
    (0, _defineProperty2.default)(instance, field, {
      get: function get() {
        return router[field];
      }
    });
  });

  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return router[field].apply(router, arguments);
    };
  });

  return instance;
}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _isIterable2 = __webpack_require__(164);

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__(83);

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(104);
var $Object = __webpack_require__(0).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(6), 'Object', { defineProperty: __webpack_require__(4).f });


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(76);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(107);
module.exports = __webpack_require__(0).Object.assign;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(1);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(108) });


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(20);
var gOPS = __webpack_require__(43);
var pIE = __webpack_require__(28);
var toObject = __webpack_require__(14);
var IObject = __webpack_require__(39);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(10)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(110);
module.exports = __webpack_require__(0).Object.getPrototypeOf;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(14);
var $getPrototypeOf = __webpack_require__(64);

__webpack_require__(75)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(112), __esModule: true };

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(18);
__webpack_require__(27);
module.exports = __webpack_require__(46).f('iterator');


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(114), __esModule: true };

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(115);
__webpack_require__(51);
__webpack_require__(118);
__webpack_require__(119);
module.exports = __webpack_require__(0).Symbol;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(3);
var has = __webpack_require__(11);
var DESCRIPTORS = __webpack_require__(6);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(62);
var META = __webpack_require__(47).KEY;
var $fails = __webpack_require__(10);
var shared = __webpack_require__(41);
var setToStringTag = __webpack_require__(21);
var uid = __webpack_require__(26);
var wks = __webpack_require__(2);
var wksExt = __webpack_require__(46);
var wksDefine = __webpack_require__(48);
var enumKeys = __webpack_require__(116);
var isArray = __webpack_require__(66);
var anObject = __webpack_require__(7);
var isObject = __webpack_require__(5);
var toIObject = __webpack_require__(12);
var toPrimitive = __webpack_require__(38);
var createDesc = __webpack_require__(19);
var _create = __webpack_require__(25);
var gOPNExt = __webpack_require__(117);
var $GOPD = __webpack_require__(68);
var $DP = __webpack_require__(4);
var $keys = __webpack_require__(20);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(67).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(28).f = $propertyIsEnumerable;
  __webpack_require__(43).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(29)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(9)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(20);
var gOPS = __webpack_require__(43);
var pIE = __webpack_require__(28);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(12);
var gOPN = __webpack_require__(67).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(48)('asyncIterator');


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(48)('observable');


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(121), __esModule: true };

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(122);
module.exports = __webpack_require__(0).Object.setPrototypeOf;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(1);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(123).set });


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(5);
var anObject = __webpack_require__(7);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(8)(Function.call, __webpack_require__(68).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(125), __esModule: true };

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(126);
var $Object = __webpack_require__(0).Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(25) });


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(56);
var emptyObject = __webpack_require__(86);
var invariant = __webpack_require__(33);
var warning = __webpack_require__(34);
var emptyFunction = __webpack_require__(31);
var checkPropTypes = __webpack_require__(57);

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.2.0';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var constructor = publicInstance.constructor;
    var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;
    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }
    warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
Component.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

/**
 * Base class helpers for the updating state of a component.
 */
function PureComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
// Avoid an extra prototype jump for these methods.
_assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

function AsyncComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
asyncComponentPrototype.constructor = AsyncComponent;
// Avoid an extra prototype jump for these methods.
_assign(asyncComponentPrototype, Component.prototype);
asyncComponentPrototype.unstable_isAsyncReactComponent = true;
asyncComponentPrototype.render = function () {
  return this.props.children;
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown;
var specialPropRefWarningShown;

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    });
    // self and source are DEV only properties.
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    });
    // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
function createElement(type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}

/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */


function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
}

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */
function cloneElement(element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}

/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var ReactDebugCurrentFrame = {};

{
  // Component that is being worked on
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var impl = ReactDebugCurrentFrame.getCurrentStack;
    if (impl) {
      return impl();
    }
    return null;
  };
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */
function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];
function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;
  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;
      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_CALL_TYPE:
          case REACT_RETURN_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }
    }
  }

  if (invokeCallback) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (typeof iteratorFn === 'function') {
      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }
      var childrenString = '' + children;
      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
  return children;
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

{
  var currentlyValidatingElement = null;

  var propTypesMisspellWarningShown = false;

  var getDisplayName = function (element) {
    if (element == null) {
      return '#empty';
    } else if (typeof element === 'string' || typeof element === 'number') {
      return '#text';
    } else if (typeof element.type === 'string') {
      return element.type;
    } else if (element.type === REACT_FRAGMENT_TYPE) {
      return 'React.Fragment';
    } else {
      return element.type.displayName || element.type.name || 'Unknown';
    }
  };

  var getStackAddendum = function () {
    var stack = '';
    if (currentlyValidatingElement) {
      var name = getDisplayName(currentlyValidatingElement);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
    }
    stack += ReactDebugCurrentFrame.getStackAddendum() || '';
    return stack;
  };

  var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current);
    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = '\n\nCheck the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
  }

  currentlyValidatingElement = element;
  {
    warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
  }
  currentlyValidatingElement = null;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  var propTypes = componentClass.propTypes;
  if (propTypes) {
    currentlyValidatingElement = element;
    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
    currentlyValidatingElement = null;
  } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
    propTypesMisspellWarningShown = true;
    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
  }
}

/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */
function validateFragmentProps(fragment) {
  currentlyValidatingElement = fragment;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (!VALID_FRAGMENT_PROPS.has(key)) {
        warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (fragment.ref !== null) {
    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
  }

  currentlyValidatingElement = null;
}

function createElementWithValidation(type, props, children) {
  var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number';
  // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.
  if (!validType) {
    var info = '';
    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(props);
    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    info += getStackAddendum() || '';

    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  var element = createElement.apply(this, arguments);

  // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.
  if (element == null) {
    return element;
  }

  // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)
  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}

function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  // Legacy hook TODO: Warn if this is accessed
  validatedFactory.type = type;

  {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}

function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);
  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }
  validatePropTypes(newElement);
  return newElement;
}

var React = {
  Children: {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  },

  Component: Component,
  PureComponent: PureComponent,
  unstable_AsyncComponent: AsyncComponent,

  Fragment: REACT_FRAGMENT_TYPE,

  createElement: createElementWithValidation,
  cloneElement: cloneElementWithValidation,
  createFactory: createFactoryWithValidation,
  isValidElement: isValidElement,

  version: ReactVersion,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentOwner: ReactCurrentOwner,
    // Used by renderers to avoid bundling object-assign twice in UMD bundles:
    assign: _assign
  }
};

{
  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}



var React$2 = Object.freeze({
	default: React
});

var React$3 = ( React$2 && React ) || React$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var react = React$3['default'] ? React$3['default'] : React$3;

module.exports = react;
  })();
}


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(31);
var invariant = __webpack_require__(33);
var warning = __webpack_require__(34);
var assign = __webpack_require__(56);

var ReactPropTypesSecret = __webpack_require__(69);
var checkPropTypes = __webpack_require__(57);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if ("development" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
       true ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 129 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(7);
var aFunction = __webpack_require__(24);
var SPECIES = __webpack_require__(2)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(8);
var invoke = __webpack_require__(171);
var html = __webpack_require__(72);
var cel = __webpack_require__(50);
var global = __webpack_require__(3);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(23)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(7);
var isObject = __webpack_require__(5);
var newPromiseCapability = __webpack_require__(78);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(4).f;
var create = __webpack_require__(25);
var redefineAll = __webpack_require__(53);
var ctx = __webpack_require__(8);
var anInstance = __webpack_require__(52);
var forOf = __webpack_require__(22);
var $iterDefine = __webpack_require__(37);
var step = __webpack_require__(65);
var setSpecies = __webpack_require__(79);
var DESCRIPTORS = __webpack_require__(6);
var fastKey = __webpack_require__(47).fastKey;
var validate = __webpack_require__(71);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(3);
var $export = __webpack_require__(1);
var meta = __webpack_require__(47);
var fails = __webpack_require__(10);
var hide = __webpack_require__(9);
var redefineAll = __webpack_require__(53);
var forOf = __webpack_require__(22);
var anInstance = __webpack_require__(52);
var isObject = __webpack_require__(5);
var setToStringTag = __webpack_require__(21);
var dP = __webpack_require__(4).f;
var each = __webpack_require__(136)(0);
var DESCRIPTORS = __webpack_require__(6);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(8);
var IObject = __webpack_require__(39);
var toObject = __webpack_require__(14);
var toLength = __webpack_require__(30);
var asc = __webpack_require__(137);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(138);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(5);
var isArray = __webpack_require__(66);
var SPECIES = __webpack_require__(2)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(32);
var from = __webpack_require__(140);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(22);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(1);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(1);
var aFunction = __webpack_require__(24);
var ctx = __webpack_require__(8);
var forOf = __webpack_require__(22);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(160), __esModule: true };

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(161);
module.exports = __webpack_require__(0).Object.keys;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(14);
var $keys = __webpack_require__(20);

__webpack_require__(75)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27);
__webpack_require__(18);
module.exports = __webpack_require__(163);


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(7);
var get = __webpack_require__(54);
module.exports = __webpack_require__(0).getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(165), __esModule: true };

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27);
__webpack_require__(18);
module.exports = __webpack_require__(166);


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(32);
var ITERATOR = __webpack_require__(2)('iterator');
var Iterators = __webpack_require__(13);
module.exports = __webpack_require__(0).isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(168);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 168 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(51);
__webpack_require__(18);
__webpack_require__(27);
__webpack_require__(170);
__webpack_require__(173);
__webpack_require__(174);
module.exports = __webpack_require__(0).Promise;


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(29);
var global = __webpack_require__(3);
var ctx = __webpack_require__(8);
var classof = __webpack_require__(32);
var $export = __webpack_require__(1);
var isObject = __webpack_require__(5);
var aFunction = __webpack_require__(24);
var anInstance = __webpack_require__(52);
var forOf = __webpack_require__(22);
var speciesConstructor = __webpack_require__(130);
var task = __webpack_require__(131).set;
var microtask = __webpack_require__(172)();
var newPromiseCapabilityModule = __webpack_require__(78);
var perform = __webpack_require__(132);
var promiseResolve = __webpack_require__(133);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(2)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(53)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(21)($Promise, PROMISE);
__webpack_require__(79)(PROMISE);
Wrapper = __webpack_require__(0)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(95)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 171 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(3);
var macrotask = __webpack_require__(131).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(23)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(1);
var core = __webpack_require__(0);
var global = __webpack_require__(3);
var speciesConstructor = __webpack_require__(130);
var promiseResolve = __webpack_require__(133);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(1);
var newPromiseCapability = __webpack_require__(78);
var perform = __webpack_require__(132);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(51);
__webpack_require__(18);
__webpack_require__(27);
__webpack_require__(176);
__webpack_require__(177);
__webpack_require__(178);
__webpack_require__(179);
module.exports = __webpack_require__(0).Set;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(134);
var validate = __webpack_require__(71);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(135)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(1);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(139)('Set') });


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(141)('Set');


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(142)('Set');


/***/ }),
/* 180 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(80);

var _set2 = _interopRequireDefault(_set);

var _classCallCheck2 = __webpack_require__(15);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(16);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EventEmitter = function () {
  function EventEmitter() {
    (0, _classCallCheck3.default)(this, EventEmitter);
    this.listeners = {};
  }

  (0, _createClass3.default)(EventEmitter, [{
    key: "on",
    value: function on(event, cb) {
      if (!this.listeners[event]) {
        this.listeners[event] = new _set2.default();
      }

      if (this.listeners[event].has(cb)) {
        throw new Error("The listener already exising in event: " + event);
      }

      this.listeners[event].add(cb);
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      if (!this.listeners[event]) return;
      this.listeners[event].forEach(function (cb) {
        return cb.apply(undefined, data);
      });
    }
  }, {
    key: "off",
    value: function off(event, cb) {
      this.listeners[event].delete(cb);
    }
  }]);
  return EventEmitter;
}();

exports.default = EventEmitter;

/***/ }),
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shallowEquals;
function shallowEquals(a, b) {
  for (var i in a) {
    if (b[i] !== a[i]) return false;
  }

  for (var _i in b) {
    if (b[_i] !== a[_i]) return false;
  }

  return true;
}

/***/ }),
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(105);

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = __webpack_require__(44);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(15);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(16);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(45);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(49);

var _inherits3 = _interopRequireDefault(_inherits2);

exports.default = withRouter;

var _react = __webpack_require__(17);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(58);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _hoistNonReactStatics = __webpack_require__(232);

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _utils = __webpack_require__(77);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function withRouter(ComposedComponent) {
  var displayName = (0, _utils.getDisplayName)(ComposedComponent);

  var WithRouteWrapper = function (_Component) {
    (0, _inherits3.default)(WithRouteWrapper, _Component);

    function WithRouteWrapper() {
      (0, _classCallCheck3.default)(this, WithRouteWrapper);
      return (0, _possibleConstructorReturn3.default)(this, (WithRouteWrapper.__proto__ || (0, _getPrototypeOf2.default)(WithRouteWrapper)).apply(this, arguments));
    }

    (0, _createClass3.default)(WithRouteWrapper, [{
      key: 'render',
      value: function render() {
        var props = (0, _extends3.default)({
          router: this.context.router
        }, this.props);

        return _react2.default.createElement(ComposedComponent, props);
      }
    }]);
    return WithRouteWrapper;
  }(_react.Component);

  WithRouteWrapper.contextTypes = {
    router: _propTypes2.default.object
  };
  WithRouteWrapper.displayName = 'withRoute(' + displayName + ')';


  return (0, _hoistNonReactStatics2.default)(WithRouteWrapper, ComposedComponent);
}

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
};


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __webpack_require__(102);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _typeof2 = __webpack_require__(55);

var _typeof3 = _interopRequireDefault(_typeof2);

var _extends2 = __webpack_require__(105);

var _extends3 = _interopRequireDefault(_extends2);

var _regenerator = __webpack_require__(87);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(88);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _set = __webpack_require__(80);

var _set2 = _interopRequireDefault(_set);

var _classCallCheck2 = __webpack_require__(15);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(16);

var _createClass3 = _interopRequireDefault(_createClass2);

var _url2 = __webpack_require__(234);

var _EventEmitter = __webpack_require__(181);

var _EventEmitter2 = _interopRequireDefault(_EventEmitter);

var _shallowEquals = __webpack_require__(195);

var _shallowEquals2 = _interopRequireDefault(_shallowEquals);

var _pQueue = __webpack_require__(237);

var _pQueue2 = _interopRequireDefault(_pQueue);

var _utils = __webpack_require__(77);

var _ = __webpack_require__(101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global __NEXT_DATA__ */

var Router = function () {
  function Router(pathname, query, as) {
    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        pageLoader = _ref.pageLoader,
        Component = _ref.Component,
        ErrorComponent = _ref.ErrorComponent,
        err = _ref.err;

    (0, _classCallCheck3.default)(this, Router);

    // represents the current component key
    this.route = toRoute(pathname);

    // set up the component cache (by route keys)
    this.components = {};
    // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.
    if (Component !== ErrorComponent) {
      this.components[this.route] = { Component: Component, err: err };
    }

    // Handling Router Events
    this.events = new _EventEmitter2.default();

    this.pageLoader = pageLoader;
    this.prefetchQueue = new _pQueue2.default({ concurrency: 2 });
    this.ErrorComponent = ErrorComponent;
    this.pathname = pathname;
    this.query = query;
    this.asPath = as;
    this.subscriptions = new _set2.default();
    this.componentLoadCancel = null;
    this.onPopState = this.onPopState.bind(this);

    if (typeof window !== 'undefined') {
      // in order for `e.state` to work on the `onpopstate` event
      // we have to register the initial route upon initialization
      this.changeState('replaceState', (0, _url2.format)({ pathname: pathname, query: query }), (0, _utils.getURL)());

      window.addEventListener('popstate', this.onPopState);
    }
  }

  (0, _createClass3.default)(Router, [{
    key: 'onPopState',
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(e) {
        var pathname, query, _e$state, url, as, options;

        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (e.state) {
                  _context.next = 4;
                  break;
                }

                // We get state as undefined for two reasons.
                //  1. With older safari (< 8) and older chrome (< 34)
                //  2. When the URL changed with #
                //
                // In the both cases, we don't need to proceed and change the route.
                // (as it's already changed)
                // But we can simply replace the state with the new changes.
                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
                // So, doing the following for (1) does no harm.
                pathname = this.pathname, query = this.query;

                this.changeState('replaceState', (0, _url2.format)({ pathname: pathname, query: query }), (0, _utils.getURL)());
                return _context.abrupt('return');

              case 4:
                _e$state = e.state, url = _e$state.url, as = _e$state.as, options = _e$state.options;

                this.replace(url, as, options);

              case 6:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function onPopState(_x2) {
        return _ref2.apply(this, arguments);
      }

      return onPopState;
    }()
  }, {
    key: 'update',
    value: function update(route, Component) {
      var data = this.components[route];
      if (!data) {
        throw new Error('Cannot update unavailable route: ' + route);
      }

      var newData = (0, _extends3.default)({}, data, { Component: Component });
      this.components[route] = newData;

      if (route === this.route) {
        this.notify(newData);
      }
    }
  }, {
    key: 'reload',
    value: function () {
      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(route) {
        var pathname, query, url, routeInfo, error;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                delete this.components[route];
                this.pageLoader.clearCache(route);

                if (!(route !== this.route)) {
                  _context2.next = 4;
                  break;
                }

                return _context2.abrupt('return');

              case 4:
                pathname = this.pathname, query = this.query;
                url = window.location.href;


                this.events.emit('routeChangeStart', url);
                _context2.next = 9;
                return this.getRouteInfo(route, pathname, query, url);

              case 9:
                routeInfo = _context2.sent;
                error = routeInfo.error;

                if (!(error && error.cancelled)) {
                  _context2.next = 13;
                  break;
                }

                return _context2.abrupt('return');

              case 13:

                this.notify(routeInfo);

                if (!error) {
                  _context2.next = 17;
                  break;
                }

                this.events.emit('routeChangeError', error, url);
                throw error;

              case 17:

                this.events.emit('routeChangeComplete', url);

              case 18:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function reload(_x3) {
        return _ref3.apply(this, arguments);
      }

      return reload;
    }()
  }, {
    key: 'back',
    value: function back() {
      window.history.back();
    }
  }, {
    key: 'push',
    value: function push(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      return this.change('pushState', url, as, options);
    }
  }, {
    key: 'replace',
    value: function replace(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      return this.change('replaceState', url, as, options);
    }
  }, {
    key: 'change',
    value: function () {
      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(method, _url, _as, options) {
        var url, as, _parse, pathname, query, route, _options$shallow, shallow, routeInfo, _routeInfo, error, hash;

        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // If url and as provided as an object representation,
                // we'll format them into the string version here.
                url = (typeof _url === 'undefined' ? 'undefined' : (0, _typeof3.default)(_url)) === 'object' ? (0, _url2.format)(_url) : _url;
                as = (typeof _as === 'undefined' ? 'undefined' : (0, _typeof3.default)(_as)) === 'object' ? (0, _url2.format)(_as) : _as;

                // Add the ending slash to the paths. So, we can serve the
                // "<page>/index.html" directly for the SSR page.

                if (__NEXT_DATA__.nextExport) {
                  as = (0, _._rewriteUrlForNextExport)(as);
                }

                this.abortComponentLoad(as);
                _parse = (0, _url2.parse)(url, true), pathname = _parse.pathname, query = _parse.query;

                // If the url change is only related to a hash change
                // We should not proceed. We should only change the state.

                if (!this.onlyAHashChange(as)) {
                  _context3.next = 9;
                  break;
                }

                this.changeState(method, url, as);
                this.scrollToHash(as);
                return _context3.abrupt('return');

              case 9:

                // If asked to change the current URL we should reload the current page
                // (not location.reload() but reload getInitalProps and other Next.js stuffs)
                // We also need to set the method = replaceState always
                // as this should not go into the history (That's how browsers work)
                if (!this.urlIsNew(pathname, query)) {
                  method = 'replaceState';
                }

                route = toRoute(pathname);
                _options$shallow = options.shallow, shallow = _options$shallow === undefined ? false : _options$shallow;
                routeInfo = null;


                this.events.emit('routeChangeStart', as);

                // If shallow === false and other conditions met, we reuse the
                // existing routeInfo for this route.
                // Because of this, getInitialProps would not run.

                if (!(shallow && this.isShallowRoutingPossible(route))) {
                  _context3.next = 18;
                  break;
                }

                routeInfo = this.components[route];
                _context3.next = 21;
                break;

              case 18:
                _context3.next = 20;
                return this.getRouteInfo(route, pathname, query, as);

              case 20:
                routeInfo = _context3.sent;

              case 21:
                _routeInfo = routeInfo, error = _routeInfo.error;

                if (!(error && error.cancelled)) {
                  _context3.next = 24;
                  break;
                }

                return _context3.abrupt('return', false);

              case 24:

                this.events.emit('beforeHistoryChange', as);
                this.changeState(method, url, as, options);
                hash = window.location.hash.substring(1);


                this.set(route, pathname, query, as, (0, _extends3.default)({}, routeInfo, { hash: hash }));

                if (!error) {
                  _context3.next = 31;
                  break;
                }

                this.events.emit('routeChangeError', error, as);
                throw error;

              case 31:

                this.events.emit('routeChangeComplete', as);
                return _context3.abrupt('return', true);

              case 33:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function change(_x8, _x9, _x10, _x11) {
        return _ref4.apply(this, arguments);
      }

      return change;
    }()
  }, {
    key: 'changeState',
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        window.history[method]({ url: url, as: as, options: options }, null, as);
      }
    }
  }, {
    key: 'getRouteInfo',
    value: function () {
      var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(route, pathname, query, as) {
        var routeInfo, _routeInfo2, Component, ctx, _Component, _ctx;

        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                routeInfo = null;
                _context4.prev = 1;

                routeInfo = this.components[route];

                if (routeInfo) {
                  _context4.next = 8;
                  break;
                }

                _context4.next = 6;
                return this.fetchComponent(route, as);

              case 6:
                _context4.t0 = _context4.sent;
                routeInfo = {
                  Component: _context4.t0
                };

              case 8:
                _routeInfo2 = routeInfo, Component = _routeInfo2.Component;
                ctx = { pathname: pathname, query: query, asPath: as };
                _context4.next = 12;
                return this.getInitialProps(Component, ctx);

              case 12:
                routeInfo.props = _context4.sent;


                this.components[route] = routeInfo;
                _context4.next = 32;
                break;

              case 16:
                _context4.prev = 16;
                _context4.t1 = _context4['catch'](1);

                if (!_context4.t1.cancelled) {
                  _context4.next = 20;
                  break;
                }

                return _context4.abrupt('return', { error: _context4.t1 });

              case 20:
                if (!_context4.t1.buildIdMismatched) {
                  _context4.next = 24;
                  break;
                }

                // Now we need to reload the page or do the action asked by the user
                (0, _._notifyBuildIdMismatch)(as);
                // We also need to cancel this current route change.
                // We do it like this.
                _context4.t1.cancelled = true;
                return _context4.abrupt('return', { error: _context4.t1 });

              case 24:

                if (_context4.t1.statusCode === 404) {
                  // Indicate main error display logic to
                  // ignore rendering this error as a runtime error.
                  _context4.t1.ignore = true;
                }

                _Component = this.ErrorComponent;

                routeInfo = { Component: _Component, err: _context4.t1 };
                _ctx = { err: _context4.t1, pathname: pathname, query: query };
                _context4.next = 30;
                return this.getInitialProps(_Component, _ctx);

              case 30:
                routeInfo.props = _context4.sent;


                routeInfo.error = _context4.t1;

              case 32:
                return _context4.abrupt('return', routeInfo);

              case 33:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this, [[1, 16]]);
      }));

      function getRouteInfo(_x13, _x14, _x15, _x16) {
        return _ref5.apply(this, arguments);
      }

      return getRouteInfo;
    }()
  }, {
    key: 'set',
    value: function set(route, pathname, query, as, data) {
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      this.notify(data);
    }
  }, {
    key: 'onlyAHashChange',
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _asPath$split = this.asPath.split('#'),
          _asPath$split2 = (0, _slicedToArray3.default)(_asPath$split, 2),
          oldUrlNoHash = _asPath$split2[0],
          oldHash = _asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = (0, _slicedToArray3.default)(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1];

      // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      }

      // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.
      return oldHash !== newHash;
    }
  }, {
    key: 'scrollToHash',
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = (0, _slicedToArray3.default)(_as$split3, 2),
          hash = _as$split4[1];

      var el = document.getElementById(hash);
      if (el) {
        el.scrollIntoView();
      }
    }
  }, {
    key: 'urlIsNew',
    value: function urlIsNew(pathname, query) {
      return this.pathname !== pathname || !(0, _shallowEquals2.default)(query, this.query);
    }
  }, {
    key: 'isShallowRoutingPossible',
    value: function isShallowRoutingPossible(route) {
      return (
        // If there's cached routeInfo for the route.
        Boolean(this.components[route]) &&
        // If the route is already rendered on the screen.
        this.route === route
      );
    }
  }, {
    key: 'prefetch',
    value: function () {
      var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(url) {
        var _this = this;

        var _parse2, pathname, route;

        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (false) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt('return');

              case 2:
                _parse2 = (0, _url2.parse)(url), pathname = _parse2.pathname;
                route = toRoute(pathname);
                return _context5.abrupt('return', this.prefetchQueue.add(function () {
                  return _this.fetchRoute(route);
                }));

              case 5:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function prefetch(_x17) {
        return _ref6.apply(this, arguments);
      }

      return prefetch;
    }()
  }, {
    key: 'fetchComponent',
    value: function () {
      var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(route, as) {
        var cancelled, cancel, Component, error;
        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                cancelled = false;

                cancel = this.componentLoadCancel = function () {
                  cancelled = true;
                };

                _context6.prev = 2;
                _context6.next = 5;
                return this.fetchRoute(route);

              case 5:
                Component = _context6.sent;

                if (!cancelled) {
                  _context6.next = 10;
                  break;
                }

                error = new Error('Abort fetching component for route: "' + route + '"');

                error.cancelled = true;
                throw error;

              case 10:

                if (cancel === this.componentLoadCancel) {
                  this.componentLoadCancel = null;
                }

                return _context6.abrupt('return', Component);

              case 14:
                _context6.prev = 14;
                _context6.t0 = _context6['catch'](2);

                // There's an error in loading the route.
                // Usually this happens when there's a failure in the webpack build
                // So in that case, we need to load the page with full SSR
                // That'll clean the invalid exising client side information.
                // (Like cached routes)
                window.location.href = as;
                throw _context6.t0;

              case 18:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this, [[2, 14]]);
      }));

      function fetchComponent(_x18, _x19) {
        return _ref7.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: 'getInitialProps',
    value: function () {
      var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(Component, ctx) {
        var cancelled, cancel, props, err;
        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                cancelled = false;

                cancel = function cancel() {
                  cancelled = true;
                };

                this.componentLoadCancel = cancel;

                _context7.next = 5;
                return (0, _utils.loadGetInitialProps)(Component, ctx);

              case 5:
                props = _context7.sent;


                if (cancel === this.componentLoadCancel) {
                  this.componentLoadCancel = null;
                }

                if (!cancelled) {
                  _context7.next = 11;
                  break;
                }

                err = new Error('Loading initial props cancelled');

                err.cancelled = true;
                throw err;

              case 11:
                return _context7.abrupt('return', props);

              case 12:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getInitialProps(_x20, _x21) {
        return _ref8.apply(this, arguments);
      }

      return getInitialProps;
    }()
  }, {
    key: 'fetchRoute',
    value: function () {
      var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(route) {
        return _regenerator2.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.pageLoader.loadPage(route);

              case 2:
                return _context8.abrupt('return', _context8.sent);

              case 3:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function fetchRoute(_x22) {
        return _ref9.apply(this, arguments);
      }

      return fetchRoute;
    }()
  }, {
    key: 'abortComponentLoad',
    value: function abortComponentLoad(as) {
      if (this.componentLoadCancel) {
        this.events.emit('routeChangeError', new Error('Route Cancelled'), as);
        this.componentLoadCancel();
        this.componentLoadCancel = null;
      }
    }
  }, {
    key: 'notify',
    value: function notify(data) {
      this.subscriptions.forEach(function (fn) {
        return fn(data);
      });
    }
  }, {
    key: 'subscribe',
    value: function subscribe(fn) {
      var _this2 = this;

      this.subscriptions.add(fn);
      return function () {
        return _this2.subscriptions.delete(fn);
      };
    }
  }]);
  return Router;
}();

exports.default = Router;


function toRoute(path) {
  return path.replace(/\/$/, '') || '/';
}

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(235);
var util = __webpack_require__(236);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(84);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(98)(module), __webpack_require__(180)))

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(70);

var _promise2 = _interopRequireDefault(_promise);

var _assign = __webpack_require__(76);

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = __webpack_require__(15);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(16);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// based on https://github.com/sindresorhus/p-queue (MIT)
// modified for browser support

var Queue = function () {
  function Queue() {
    (0, _classCallCheck3.default)(this, Queue);

    this._queue = [];
  }

  (0, _createClass3.default)(Queue, [{
    key: 'enqueue',
    value: function enqueue(run) {
      this._queue.push(run);
    }
  }, {
    key: 'dequeue',
    value: function dequeue() {
      return this._queue.shift();
    }
  }, {
    key: 'size',
    get: function get() {
      return this._queue.length;
    }
  }]);
  return Queue;
}();

var PQueue = function () {
  function PQueue(opts) {
    (0, _classCallCheck3.default)(this, PQueue);

    opts = (0, _assign2.default)({
      concurrency: Infinity,
      queueClass: Queue
    }, opts);

    if (opts.concurrency < 1) {
      throw new TypeError('Expected `concurrency` to be a number from 1 and up');
    }

    this.queue = new opts.queueClass(); // eslint-disable-line new-cap
    this._pendingCount = 0;
    this._concurrency = opts.concurrency;
    this._resolveEmpty = function () {};
  }

  (0, _createClass3.default)(PQueue, [{
    key: '_next',
    value: function _next() {
      this._pendingCount--;

      if (this.queue.size > 0) {
        this.queue.dequeue()();
      } else {
        this._resolveEmpty();
      }
    }
  }, {
    key: 'add',
    value: function add(fn, opts) {
      var _this = this;

      return new _promise2.default(function (resolve, reject) {
        var run = function run() {
          _this._pendingCount++;

          fn().then(function (val) {
            resolve(val);
            _this._next();
          }, function (err) {
            reject(err);
            _this._next();
          });
        };

        if (_this._pendingCount < _this._concurrency) {
          run();
        } else {
          _this.queue.enqueue(run, opts);
        }
      });
    }
  }, {
    key: 'onEmpty',
    value: function onEmpty() {
      var _this2 = this;

      return new _promise2.default(function (resolve) {
        var existingResolve = _this2._resolveEmpty;
        _this2._resolveEmpty = function () {
          existingResolve();
          resolve();
        };
      });
    }
  }, {
    key: 'size',
    get: function get() {
      return this.queue.size;
    }
  }, {
    key: 'pending',
    get: function get() {
      return this._pendingCount;
    }
  }]);
  return PQueue;
}();

exports.default = PQueue;

/***/ }),
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _map = __webpack_require__(382);

var _map2 = _interopRequireDefault(_map);

var _slicedToArray2 = __webpack_require__(102);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getPrototypeOf = __webpack_require__(44);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(15);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(16);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(45);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(49);

var _inherits3 = _interopRequireDefault(_inherits2);

exports.flush = flush;

var _react = __webpack_require__(17);

var _stylesheetRegistry = __webpack_require__(388);

var _stylesheetRegistry2 = _interopRequireDefault(_stylesheetRegistry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var styleSheetRegistry = new _stylesheetRegistry2.default();

var JSXStyle = function (_Component) {
  (0, _inherits3.default)(JSXStyle, _Component);

  function JSXStyle() {
    (0, _classCallCheck3.default)(this, JSXStyle);
    return (0, _possibleConstructorReturn3.default)(this, (JSXStyle.__proto__ || (0, _getPrototypeOf2.default)(JSXStyle)).apply(this, arguments));
  }

  (0, _createClass3.default)(JSXStyle, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      styleSheetRegistry.add(this.props);
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      return this.props.css !== nextProps.css;
    }

    // To avoid FOUC, we process new changes
    // on `componentWillUpdate` rather than `componentDidUpdate`.

  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      styleSheetRegistry.update(this.props, nextProps);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      styleSheetRegistry.remove(this.props);
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }], [{
    key: 'dynamic',
    value: function dynamic(info) {
      return info.map(function (tagInfo) {
        var _tagInfo = (0, _slicedToArray3.default)(tagInfo, 2),
            baseId = _tagInfo[0],
            props = _tagInfo[1];

        return styleSheetRegistry.computeId(baseId, props);
      }).join(' ');
    }
  }]);
  return JSXStyle;
}(_react.Component);

exports.default = JSXStyle;
function flush() {
  var cssRules = styleSheetRegistry.cssRules();
  styleSheetRegistry.flush();
  return new _map2.default(cssRules);
}

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(383), __esModule: true };

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(51);
__webpack_require__(18);
__webpack_require__(27);
__webpack_require__(384);
__webpack_require__(385);
__webpack_require__(386);
__webpack_require__(387);
module.exports = __webpack_require__(0).Map;


/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(134);
var validate = __webpack_require__(71);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(135)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(1);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(139)('Map') });


/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(141)('Map');


/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(142)('Map');


/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(159);

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = __webpack_require__(15);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(16);

var _createClass3 = _interopRequireDefault(_createClass2);

var _stringHash = __webpack_require__(389);

var _stringHash2 = _interopRequireDefault(_stringHash);

var _stylesheet = __webpack_require__(390);

var _stylesheet2 = _interopRequireDefault(_stylesheet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StyleSheetRegistry = function () {
  function StyleSheetRegistry() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$styleSheet = _ref.styleSheet,
        styleSheet = _ref$styleSheet === undefined ? null : _ref$styleSheet,
        _ref$optimizeForSpeed = _ref.optimizeForSpeed,
        optimizeForSpeed = _ref$optimizeForSpeed === undefined ? false : _ref$optimizeForSpeed,
        _ref$isBrowser = _ref.isBrowser,
        isBrowser = _ref$isBrowser === undefined ? typeof window !== 'undefined' : _ref$isBrowser;

    (0, _classCallCheck3.default)(this, StyleSheetRegistry);

    this._sheet = styleSheet || new _stylesheet2.default({
      name: 'styled-jsx',
      optimizeForSpeed: optimizeForSpeed
    });
    this._sheet.inject();
    this._isBrowser = isBrowser;

    this._fromServer = undefined;
    this._indices = {};
    this._instancesCounts = {};

    this.computeId = this.createComputeId();
    this.computeSelector = this.createComputeSelector();
  }

  (0, _createClass3.default)(StyleSheetRegistry, [{
    key: 'add',
    value: function add(props) {
      var _this = this;

      if (undefined === this._optimizeForSpeed) {
        this._optimizeForSpeed = Array.isArray(props.css);
        this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);
        this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();
      }

      if (this._isBrowser && !this._fromServer) {
        this._fromServer = this.selectFromServer();
        this._instancesCounts = (0, _keys2.default)(this._fromServer).reduce(function (acc, tagName) {
          acc[tagName] = 0;
          return acc;
        }, {});
      }

      var _getIdAndRules = this.getIdAndRules(props),
          styleId = _getIdAndRules.styleId,
          rules = _getIdAndRules.rules;

      // Deduping: just increase the instances count.


      if (styleId in this._instancesCounts) {
        this._instancesCounts[styleId] += 1;
        return;
      }

      var indices = rules.map(function (rule) {
        return _this._sheet.insertRule(rule);
      })
      // Filter out invalid rules
      .filter(function (index) {
        return index !== -1;
      });

      if (indices.length > 0) {
        this._indices[styleId] = indices;
        this._instancesCounts[styleId] = 1;
      }
    }
  }, {
    key: 'remove',
    value: function remove(props) {
      var _this2 = this;

      var _getIdAndRules2 = this.getIdAndRules(props),
          styleId = _getIdAndRules2.styleId;

      invariant(styleId in this._instancesCounts, 'styleId: `' + styleId + '` not found');
      this._instancesCounts[styleId] -= 1;

      if (this._instancesCounts[styleId] < 1) {
        var tagFromServer = this._fromServer && this._fromServer[styleId];
        if (tagFromServer) {
          tagFromServer.parentNode.removeChild(tagFromServer);
          delete this._fromServer[styleId];
        } else {
          this._indices[styleId].forEach(function (index) {
            return _this2._sheet.deleteRule(index);
          });
          delete this._indices[styleId];
        }
        delete this._instancesCounts[styleId];
      }
    }
  }, {
    key: 'update',
    value: function update(props, nextProps) {
      this.add(nextProps);
      this.remove(props);
    }
  }, {
    key: 'flush',
    value: function flush() {
      this._sheet.flush();
      this._sheet.inject();
      this._fromServer = undefined;
      this._indices = {};
      this._instancesCounts = {};

      this.computeId = this.createComputeId();
      this.computeSelector = this.createComputeSelector();
    }
  }, {
    key: 'cssRules',
    value: function cssRules() {
      var _this3 = this;

      var fromServer = this._fromServer ? (0, _keys2.default)(this._fromServer).map(function (styleId) {
        return [styleId, _this3._fromServer[styleId]];
      }) : [];
      var cssRules = this._sheet.cssRules();

      return fromServer.concat((0, _keys2.default)(this._indices).map(function (styleId) {
        return [styleId, _this3._indices[styleId].map(function (index) {
          return cssRules[index].cssText;
        }).join('\n')];
      }));
    }

    /**
     * createComputeId
     *
     * Creates a function to compute and memoize a jsx id from a basedId and optionally props.
     */

  }, {
    key: 'createComputeId',
    value: function createComputeId() {
      var cache = {};
      return function (baseId, props) {
        if (!props) {
          return 'jsx-' + baseId;
        }
        var propsToString = String(props);
        var key = baseId + propsToString;
        // return `jsx-${hashString(`${baseId}-${propsToString}`)}`
        if (!cache[key]) {
          cache[key] = 'jsx-' + (0, _stringHash2.default)(baseId + '-' + propsToString);
        }
        return cache[key];
      };
    }

    /**
     * createComputeSelector
     *
     * Creates a function to compute and memoize dynamic selectors.
     */

  }, {
    key: 'createComputeSelector',
    value: function createComputeSelector() {
      var selectoPlaceholderRegexp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /__jsx-style-dynamic-selector/g;

      var cache = {};
      return function (id, css) {
        var idcss = id + css;
        if (!cache[idcss]) {
          cache[idcss] = css.replace(selectoPlaceholderRegexp, id);
        }
        return cache[idcss];
      };
    }
  }, {
    key: 'getIdAndRules',
    value: function getIdAndRules(props) {
      var _this4 = this;

      if (props.dynamic) {
        var styleId = this.computeId(props.styleId, props.dynamic);
        return {
          styleId: styleId,
          rules: Array.isArray(props.css) ? props.css.map(function (rule) {
            return _this4.computeSelector(styleId, rule);
          }) : [this.computeSelector(styleId, props.css)]
        };
      }

      return {
        styleId: this.computeId(props.styleId),
        rules: Array.isArray(props.css) ? props.css : [props.css]
      };
    }

    /**
     * selectFromServer
     *
     * Collects style tags from the document with id __jsx-XXX
     */

  }, {
    key: 'selectFromServer',
    value: function selectFromServer() {
      var elements = Array.prototype.slice.call(document.querySelectorAll('[id^="__jsx-"]'));

      return elements.reduce(function (acc, element) {
        var id = element.id.slice(2);
        acc[id] = element;
        return acc;
      }, {});
    }
  }]);
  return StyleSheetRegistry;
}();

exports.default = StyleSheetRegistry;


function invariant(condition, message) {
  if (!condition) {
    throw new Error('StyleSheetRegistry: ' + message + '.');
  }
}

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function hash(str) {
  var hash = 5381,
      i    = str.length;

  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }

  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */
  return hash >>> 0;
}

module.exports = hash;


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(15);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(16);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
Based on Glamor's sheet
https://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js
*/

var isProd = process.env && "development" === 'production';
var isString = function isString(o) {
  return Object.prototype.toString.call(o) === '[object String]';
};

var StyleSheet = function () {
  function StyleSheet() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$name = _ref.name,
        name = _ref$name === undefined ? 'stylesheet' : _ref$name,
        _ref$optimizeForSpeed = _ref.optimizeForSpeed,
        optimizeForSpeed = _ref$optimizeForSpeed === undefined ? isProd : _ref$optimizeForSpeed,
        _ref$isBrowser = _ref.isBrowser,
        isBrowser = _ref$isBrowser === undefined ? typeof window !== 'undefined' : _ref$isBrowser;

    (0, _classCallCheck3.default)(this, StyleSheet);

    invariant(isString(name), '`name` must be a string');
    this._name = name;
    this._deletedRulePlaceholder = '#' + name + '-deleted-rule____{}';

    invariant(typeof optimizeForSpeed === 'boolean', '`optimizeForSpeed` must be a boolean');
    this._optimizeForSpeed = optimizeForSpeed;
    this._isBrowser = isBrowser;

    this._serverSheet = undefined;
    this._tags = [];
    this._injected = false;
    this._rulesCount = 0;
  }

  (0, _createClass3.default)(StyleSheet, [{
    key: 'setOptimizeForSpeed',
    value: function setOptimizeForSpeed(bool) {
      invariant(typeof bool === 'boolean', '`setOptimizeForSpeed` accepts a boolean');

      invariant(this._rulesCount === 0, 'optimizeForSpeed cannot be when rules have already been inserted');
      this.flush();
      this._optimizeForSpeed = bool;
      this.inject();
    }
  }, {
    key: 'isOptimizeForSpeed',
    value: function isOptimizeForSpeed() {
      return this._optimizeForSpeed;
    }
  }, {
    key: 'inject',
    value: function inject() {
      var _this = this;

      invariant(!this._injected, 'sheet already injected');
      this._injected = true;
      if (this._isBrowser && this._optimizeForSpeed) {
        this._tags[0] = this.makeStyleTag(this._name);
        this._optimizeForSpeed = 'insertRule' in this.getSheet();
        if (!this._optimizeForSpeed) {
          if (!isProd) {
            console.warn('StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.'); // eslint-disable-line no-console
          }
          this.flush();
          this._injected = true;
        }
        return;
      }

      this._serverSheet = {
        cssRules: [],
        insertRule: function insertRule(rule, index) {
          if (typeof index === 'number') {
            _this._serverSheet.cssRules[index] = { cssText: rule };
          } else {
            _this._serverSheet.cssRules.push({ cssText: rule });
          }
          return index;
        },
        deleteRule: function deleteRule(index) {
          _this._serverSheet.cssRules[index] = null;
        }
      };
    }
  }, {
    key: 'getSheetForTag',
    value: function getSheetForTag(tag) {
      if (tag.sheet) {
        return tag.sheet;
      }

      // this weirdness brought to you by firefox
      for (var i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].ownerNode === tag) {
          return document.styleSheets[i];
        }
      }
    }
  }, {
    key: 'getSheet',
    value: function getSheet() {
      return this.getSheetForTag(this._tags[this._tags.length - 1]);
    }
  }, {
    key: 'insertRule',
    value: function insertRule(rule, index) {
      invariant(isString(rule), '`insertRule` accepts only strings');

      if (!this._isBrowser) {
        if (typeof index !== 'number') {
          index = this._serverSheet.cssRules.length;
        }
        this._serverSheet.insertRule(rule, index);
        return this._rulesCount++;
      }

      if (this._optimizeForSpeed) {
        var sheet = this.getSheet();
        if (typeof index !== 'number') {
          index = sheet.cssRules.length;
        }
        // this weirdness for perf, and chrome's weird bug
        // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule
        try {
          sheet.insertRule(rule, index);
        } catch (err) {
          if (!isProd) {
            console.warn('StyleSheet: illegal rule: \n\n' + rule + '\n\nSee https://stackoverflow.com/q/20007992 for more info'); // eslint-disable-line no-console
          }
          return -1;
        }
      } else {
        var insertionPoint = this._tags[index];
        this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));
      }

      return this._rulesCount++;
    }
  }, {
    key: 'replaceRule',
    value: function replaceRule(index, rule) {
      if (this._optimizeForSpeed || !this._isBrowser) {
        var sheet = this._isBrowser ? this.getSheet() : this._serverSheet;
        if (!rule.trim()) {
          rule = this._deletedRulePlaceholder;
        }

        if (!sheet.cssRules[index]) {
          // @TBD Should we throw an error?
          return index;
        }

        sheet.deleteRule(index);

        try {
          sheet.insertRule(rule, index);
        } catch (err) {
          if (!isProd) {
            console.warn('StyleSheet: illegal rule: \n\n' + rule + '\n\nSee https://stackoverflow.com/q/20007992 for more info'); // eslint-disable-line no-console
          }
          // In order to preserve the indices we insert a deleteRulePlaceholder
          sheet.insertRule(this._deletedRulePlaceholder, index);
        }
      } else {
        var tag = this._tags[index];
        invariant(tag, 'old rule at index `' + index + '` not found');
        tag.textContent = rule;
      }
      return index;
    }
  }, {
    key: 'deleteRule',
    value: function deleteRule(index) {
      if (!this._isBrowser) {
        this._serverSheet.deleteRule(index);
        return;
      }

      if (this._optimizeForSpeed) {
        this.replaceRule(index, '');
      } else {
        var tag = this._tags[index];
        invariant(tag, 'rule at index `' + index + '` not found');
        tag.parentNode.removeChild(tag);
        this._tags[index] = null;
      }
    }
  }, {
    key: 'flush',
    value: function flush() {
      this._injected = false;
      this._rulesCount = 0;
      if (this._isBrowser) {
        this._tags.forEach(function (tag) {
          return tag && tag.parentNode.removeChild(tag);
        });
        this._tags = [];
      } else {
        // simpler on server
        this._serverSheet.cssRules = [];
      }
    }
  }, {
    key: 'cssRules',
    value: function cssRules() {
      var _this2 = this;

      if (!this._isBrowser) {
        return this._serverSheet.cssRules;
      }
      return this._tags.reduce(function (rules, tag) {
        if (tag) {
          rules = rules.concat(_this2.getSheetForTag(tag).cssRules.map(function (rule) {
            return rule.cssText === _this2._deletedRulePlaceholder ? null : rule;
          }));
        } else {
          rules.push(null);
        }
        return rules;
      }, []);
    }
  }, {
    key: 'makeStyleTag',
    value: function makeStyleTag(name, cssString, relativeToTag) {
      if (cssString) {
        invariant(isString(cssString), 'makeStyleTag acceps only strings as second parameter');
      }
      var tag = document.createElement('style');
      tag.type = 'text/css';
      tag.setAttribute('data-' + name, '');
      if (cssString) {
        tag.appendChild(document.createTextNode(cssString));
      }
      var head = document.head || document.getElementsByTagName('head')[0];
      if (relativeToTag) {
        head.insertBefore(tag, relativeToTag);
      } else {
        head.appendChild(tag);
      }
      return tag;
    }
  }, {
    key: 'length',
    get: function get() {
      return this._rulesCount;
    }
  }]);
  return StyleSheet;
}();

exports.default = StyleSheet;


function invariant(condition, message) {
  if (!condition) {
    throw new Error('StyleSheet: ' + message + '.');
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(129)))

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(381)


/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys = __webpack_require__(393);
var foreach = __webpack_require__(407);
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

var toStr = Object.prototype.toString;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
        /* eslint-disable no-unused-vars, no-restricted-syntax */
        for (var _ in obj) { return false; }
        /* eslint-enable no-unused-vars, no-restricted-syntax */
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = props.concat(Object.getOwnPropertySymbols(map));
	}
	foreach(props, function (name) {
		defineProperty(object, name, map[name], predicates[name]);
	});
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = __webpack_require__(406);
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) {
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// modified from https://github.com/es-shims/es6-shim
var keys = __webpack_require__(393);
var bind = __webpack_require__(395);
var canBeObject = function (obj) {
	return typeof obj !== 'undefined' && obj !== null;
};
var hasSymbols = __webpack_require__(409)();
var toObject = Object;
var push = bind.call(Function.call, Array.prototype.push);
var propIsEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

module.exports = function assign(target, source1) {
	if (!canBeObject(target)) { throw new TypeError('target must be an object'); }
	var objTarget = toObject(target);
	var s, source, i, props, syms, value, key;
	for (s = 1; s < arguments.length; ++s) {
		source = toObject(arguments[s]);
		props = keys(source);
		var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
		if (getSymbols) {
			syms = getSymbols(source);
			for (i = 0; i < syms.length; ++i) {
				key = syms[i];
				if (propIsEnumerable(source, key)) {
					push(props, key);
				}
			}
		}
		for (i = 0; i < props.length; ++i) {
			key = props[i];
			value = source[key];
			if (propIsEnumerable(source, key)) {
				objTarget[key] = value;
			}
		}
	}
	return objTarget;
};


/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(408);

module.exports = Function.prototype.bind || implementation;


/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(394);

var lacksProperEnumerationOrder = function () {
	if (!Object.assign) {
		return false;
	}
	// v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	// note: this does not detect the bug unless there's 20 characters
	var str = 'abcdefghijklmnopqrst';
	var letters = str.split('');
	var map = {};
	for (var i = 0; i < letters.length; ++i) {
		map[letters[i]] = letters[i];
	}
	var obj = Object.assign({}, map);
	var actual = '';
	for (var k in obj) {
		actual += k;
	}
	return str !== actual;
};

var assignHasPendingExceptions = function () {
	if (!Object.assign || !Object.preventExtensions) {
		return false;
	}
	// Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	// which is 72% slower than our shim, and Firefox 40's native implementation.
	var thrower = Object.preventExtensions({ 1: 2 });
	try {
		Object.assign(thrower, 'xy');
	} catch (e) {
		return thrower[1] === 'y';
	}
	return false;
};

module.exports = function getPolyfill() {
	if (!Object.assign) {
		return implementation;
	}
	if (lacksProperEnumerationOrder()) {
		return implementation;
	}
	if (assignHasPendingExceptions()) {
		return implementation;
	}
	return Object.assign;
};


/***/ }),
/* 397 */,
/* 398 */,
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(17);

var _react2 = _interopRequireDefault(_react);

var _header = __webpack_require__(400);

var _header2 = _interopRequireDefault(_header);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _jsxFileName = "/opt/guydev/study/render-props-presentation-next/layouts/main.js";

exports.default = function (_ref) {
  var children = _ref.children;
  return _react2.default.createElement("div", {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 3
    }
  }, _react2.default.createElement(_header2.default, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 4
    }
  }), children);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxheW91dHMvbWFpbi5qcyJdLCJuYW1lcyI6WyJIZWFkZXIiLCJjaGlsZHJlbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLEFBQU8sQUFBWSxBQUNuQjs7Ozs7Ozs7a0JBQWUsZ0JBQUE7TUFBQSxBQUFHLGdCQUFILEFBQUc7eUJBQ2hCLGNBQUE7O2dCQUFBO2tCQUFBLEFBQ0U7QUFERjtBQUFBLEdBQUEsa0JBQ0UsQUFBQzs7Z0JBQUQ7a0JBREYsQUFDRSxBQUNDO0FBREQ7QUFBQSxNQUZXLEFBQ2I7QUFERiIsImZpbGUiOiJtYWluLmpzIiwic291cmNlUm9vdCI6Ii9vcHQvZ3V5ZGV2L3N0dWR5L3JlbmRlci1wcm9wcy1wcmVzZW50YXRpb24tbmV4dCJ9

 ;(function register() { /* react-hot-loader/webpack */ if (true) { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } /* eslint-disable camelcase, no-undef */ var webpackExports = typeof __webpack_exports__ !== 'undefined' ? __webpack_exports__ : module.exports; /* eslint-enable camelcase, no-undef */ if (typeof webpackExports === 'function') { __REACT_HOT_LOADER__.register(webpackExports, 'module.exports', "/opt/guydev/study/render-props-presentation-next/layouts/main.js"); return; } /* eslint-disable no-restricted-syntax */ for (var key in webpackExports) { /* eslint-enable no-restricted-syntax */ if (!Object.prototype.hasOwnProperty.call(webpackExports, key)) { continue; } var namedExport = void 0; try { namedExport = webpackExports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, "/opt/guydev/study/render-props-presentation-next/layouts/main.js"); } } })();

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _style = __webpack_require__(391);

var _style2 = _interopRequireDefault(_style);

var _react = __webpack_require__(17);

var _react2 = _interopRequireDefault(_react);

var _link = __webpack_require__(401);

var _link2 = _interopRequireDefault(_link);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _jsxFileName = "/opt/guydev/study/render-props-presentation-next/components/header.js";


var Index = function Index() {
  return _react2.default.createElement("div", {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 4
    }
  }, _react2.default.createElement(_link2.default, { href: "/about", __source: {
      fileName: _jsxFileName,
      lineNumber: 5
    }
  }, _react2.default.createElement("a", {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 6
    }
  }, "About Page")), _react2.default.createElement("p", {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 8
    }
  }, "Hello Next.js"));
};

function Header() {
  var exampleNumbers = [];

  for (var i = 1; i <= 6; i++) {
    exampleNumbers.push(i);
  }
  return _react2.default.createElement("div", {
    className: "jsx-604253383" + " " + "cont",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19
    }
  }, _react2.default.createElement("h1", {
    className: "jsx-604253383" + " " + "hello",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 20
    }
  }, "Render props presentation"), _react2.default.createElement(_link2.default, { href: "/", __source: {
      fileName: _jsxFileName,
      lineNumber: 21
    }
  }, _react2.default.createElement("button", {
    className: "jsx-604253383",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 22
    }
  }, "Home")), _react2.default.createElement("h5", {
    className: "jsx-604253383" + " " + "hello",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 24
    }
  }, "examples:"), exampleNumbers.map(function (number) {
    return _react2.default.createElement(_link2.default, { href: "/example" + number, __source: {
        fileName: _jsxFileName,
        lineNumber: 26
      }
    }, _react2.default.createElement("button", {
      className: "jsx-604253383",
      __source: {
        fileName: _jsxFileName,
        lineNumber: 27
      }
    }, "Example ", number));
  }), _react2.default.createElement(_style2.default, {
    styleId: "604253383",
    css: ".cont.jsx-604253383{background:#22a0f2;padding:100px;text-align:center;-webkit-transition:100ms ease-in background;transition:100ms ease-in background;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvaGVhZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZCa0IsQUFHOEIsbUJBQ0wsY0FDSSxrQkFDa0IsZ0ZBQ3RDIiwiZmlsZSI6ImNvbXBvbmVudHMvaGVhZGVyLmpzIiwic291cmNlUm9vdCI6Ii9vcHQvZ3V5ZGV2L3N0dWR5L3JlbmRlci1wcm9wcy1wcmVzZW50YXRpb24tbmV4dCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIjtcblxuY29uc3QgSW5kZXggPSAoKSA9PiAoXG4gIDxkaXY+XG4gICAgPExpbmsgaHJlZj1cIi9hYm91dFwiPlxuICAgICAgPGE+QWJvdXQgUGFnZTwvYT5cbiAgICA8L0xpbms+XG4gICAgPHA+SGVsbG8gTmV4dC5qczwvcD5cbiAgPC9kaXY+XG4pO1xuXG5mdW5jdGlvbiBIZWFkZXIoKSB7XG4gIGxldCBleGFtcGxlTnVtYmVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IDY7IGkrKykge1xuICAgIGV4YW1wbGVOdW1iZXJzLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRcIj5cbiAgICAgIDxoMSBjbGFzc05hbWU9XCJoZWxsb1wiPlJlbmRlciBwcm9wcyBwcmVzZW50YXRpb248L2gxPlxuICAgICAgPExpbmsgaHJlZj1cIi9cIj5cbiAgICAgICAgPGJ1dHRvbj5Ib21lPC9idXR0b24+XG4gICAgICA8L0xpbms+XG4gICAgICA8aDUgY2xhc3NOYW1lPVwiaGVsbG9cIj5leGFtcGxlczo8L2g1PlxuICAgICAge2V4YW1wbGVOdW1iZXJzLm1hcChudW1iZXIgPT4gKFxuICAgICAgICA8TGluayBocmVmPXtgL2V4YW1wbGUke251bWJlcn1gfT5cbiAgICAgICAgICA8YnV0dG9uPkV4YW1wbGUge251bWJlcn08L2J1dHRvbj5cbiAgICAgICAgPC9MaW5rPlxuICAgICAgKSl9XG4gICAgICA8c3R5bGUganN4PntgXG4gICAgICAgIC5jb250IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAjMjJhMGYyO1xuICAgICAgICAgIHBhZGRpbmc6IDEwMHB4O1xuICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICB0cmFuc2l0aW9uOiAxMDBtcyBlYXNlLWluIGJhY2tncm91bmQ7XG4gICAgICAgIH1cbiAgICAgIGB9PC9zdHlsZT5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSGVhZGVyO1xuIl19 */\n/*@ sourceURL=components/header.js */"
  }));
}

exports.default = Header;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvaGVhZGVyLmpzIl0sIm5hbWVzIjpbIkxpbmsiLCJJbmRleCIsIkhlYWRlciIsImV4YW1wbGVOdW1iZXJzIiwiaSIsInB1c2giLCJtYXAiLCJudW1iZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsQUFBTzs7Ozs7Ozs7O0FBRVAsSUFBTSxRQUFRLFNBQVIsQUFBUSxRQUFBO3lCQUNaLGNBQUE7O2dCQUFBO2tCQUFBLEFBQ0U7QUFERjtBQUFBLEdBQUEsa0JBQ0UsQUFBQyxnQ0FBSyxNQUFOLEFBQVc7Z0JBQVg7a0JBQUEsQUFDRTtBQURGO3FCQUNFLGNBQUE7O2dCQUFBO2tCQUFBO0FBQUE7QUFBQSxLQUZKLEFBQ0UsQUFDRSxBQUVGLGdDQUFBLGNBQUE7O2dCQUFBO2tCQUFBO0FBQUE7QUFBQSxLQUxVLEFBQ1osQUFJRTtBQUxKOztBQVNBLFNBQUEsQUFBUyxTQUFTLEFBQ2hCO01BQUksaUJBQUosQUFBcUIsQUFFckI7O09BQUssSUFBSSxJQUFULEFBQWEsR0FBRyxLQUFoQixBQUFxQixHQUFyQixBQUF3QixLQUFLLEFBQzNCO21CQUFBLEFBQWUsS0FBZixBQUFvQixBQUNyQjtBQUNEO3lCQUNFLGNBQUE7dUNBQUEsQUFBZTs7Z0JBQWY7a0JBQUEsQUFDRTtBQURGO0FBQUEsR0FBQSxrQkFDRSxjQUFBO3VDQUFBLEFBQWM7O2dCQUFkO2tCQUFBO0FBQUE7QUFBQSxLQURGLEFBQ0UsQUFDQSw4Q0FBQSxBQUFDLGdDQUFLLE1BQU4sQUFBVztnQkFBWDtrQkFBQSxBQUNFO0FBREY7cUJBQ0UsY0FBQTtlQUFBOztnQkFBQTtrQkFBQTtBQUFBO0FBQUEsS0FISixBQUVFLEFBQ0UsQUFFRiwwQkFBQSxjQUFBO3VDQUFBLEFBQWM7O2dCQUFkO2tCQUFBO0FBQUE7QUFBQSxLQUxGLEFBS0UsQUFDQyw2QkFBQSxBQUFlLElBQUksa0JBQUE7MkJBQ2xCLEFBQUMsZ0NBQUssbUJBQU4sQUFBdUI7a0JBQXZCO29CQUFBLEFBQ0U7QUFERjtLQUFBLGtCQUNFLGNBQUE7aUJBQUE7O2tCQUFBO29CQUFBO0FBQUE7QUFBQSxPQUFpQixZQUZELEFBQ2xCLEFBQ0U7QUFSTixBQU1HO2FBTkg7U0FERixBQUNFLEFBcUJIO0FBckJHO0FBdUJKOztrQkFBQSxBQUFlIiwiZmlsZSI6ImhlYWRlci5qcyIsInNvdXJjZVJvb3QiOiIvb3B0L2d1eWRldi9zdHVkeS9yZW5kZXItcHJvcHMtcHJlc2VudGF0aW9uLW5leHQifQ==

 ;(function register() { /* react-hot-loader/webpack */ if (true) { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } /* eslint-disable camelcase, no-undef */ var webpackExports = typeof __webpack_exports__ !== 'undefined' ? __webpack_exports__ : module.exports; /* eslint-enable camelcase, no-undef */ if (typeof webpackExports === 'function') { __REACT_HOT_LOADER__.register(webpackExports, 'module.exports', "/opt/guydev/study/render-props-presentation-next/components/header.js"); return; } /* eslint-disable no-restricted-syntax */ for (var key in webpackExports) { /* eslint-enable no-restricted-syntax */ if (!Object.prototype.hasOwnProperty.call(webpackExports, key)) { continue; } var namedExport = void 0; try { namedExport = webpackExports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, "/opt/guydev/study/render-props-presentation-next/components/header.js"); } } })();

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__(55);

var _typeof3 = _interopRequireDefault(_typeof2);

var _stringify = __webpack_require__(402);

var _stringify2 = _interopRequireDefault(_stringify);

var _getPrototypeOf = __webpack_require__(44);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(15);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(16);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(45);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(49);

var _inherits3 = _interopRequireDefault(_inherits2);

var _url = __webpack_require__(234);

var _react = __webpack_require__(17);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(58);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _propTypesExact = __webpack_require__(404);

var _propTypesExact2 = _interopRequireDefault(_propTypesExact);

var _router = __webpack_require__(101);

var _router2 = _interopRequireDefault(_router);

var _utils = __webpack_require__(77);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global __NEXT_DATA__ */

var Link = function (_Component) {
  (0, _inherits3.default)(Link, _Component);

  function Link(props) {
    var _ref;

    (0, _classCallCheck3.default)(this, Link);

    for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = Link.__proto__ || (0, _getPrototypeOf2.default)(Link)).call.apply(_ref, [this, props].concat(rest)));

    _this.linkClicked = _this.linkClicked.bind(_this);
    _this.formatUrls(props);
    return _this;
  }

  (0, _createClass3.default)(Link, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.formatUrls(nextProps);
    }
  }, {
    key: 'linkClicked',
    value: function linkClicked(e) {
      var _this2 = this;

      if (e.currentTarget.nodeName === 'A' && (e.metaKey || e.ctrlKey || e.shiftKey || e.nativeEvent && e.nativeEvent.which === 2)) {
        // ignore click for new tab / new window behavior
        return;
      }

      var shallow = this.props.shallow;
      var href = this.href,
          as = this.as;


      if (!isLocal(href)) {
        // ignore click if it's outside our scope
        return;
      }

      var pathname = window.location.pathname;

      href = (0, _url.resolve)(pathname, href);
      as = as ? (0, _url.resolve)(pathname, as) : href;

      e.preventDefault();

      //  avoid scroll for urls with anchor refs
      var scroll = this.props.scroll;

      if (scroll == null) {
        scroll = as.indexOf('#') < 0;
      }

      // replace state instead of push if prop is present
      var replace = this.props.replace;

      var changeMethod = replace ? 'replace' : 'push';

      // straight up redirect
      _router2.default[changeMethod](href, as, { shallow: shallow }).then(function (success) {
        if (!success) return;
        if (scroll) window.scrollTo(0, 0);
      }).catch(function (err) {
        if (_this2.props.onError) _this2.props.onError(err);
      });
    }
  }, {
    key: 'prefetch',
    value: function prefetch() {
      if (!this.props.prefetch) return;
      if (typeof window === 'undefined') return;

      // Prefetch the JSON page if asked (only in the client)
      var pathname = window.location.pathname;

      var href = (0, _url.resolve)(pathname, this.href);
      _router2.default.prefetch(href);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.prefetch();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if ((0, _stringify2.default)(this.props.href) !== (0, _stringify2.default)(prevProps.href)) {
        this.prefetch();
      }
    }

    // We accept both 'href' and 'as' as objects which we can pass to `url.format`.
    // We'll handle it here.

  }, {
    key: 'formatUrls',
    value: function formatUrls(props) {
      this.href = props.href && (0, _typeof3.default)(props.href) === 'object' ? (0, _url.format)(props.href) : props.href;
      this.as = props.as && (0, _typeof3.default)(props.as) === 'object' ? (0, _url.format)(props.as) : props.as;
    }
  }, {
    key: 'render',
    value: function render() {
      var children = this.props.children;
      var href = this.href,
          as = this.as;
      // Deprecated. Warning shown by propType check. If the childen provided is a string (<Link>example</Link>) we wrap it in an <a> tag

      if (typeof children === 'string') {
        children = _react2.default.createElement(
          'a',
          null,
          children
        );
      }

      // This will return the first child, if multiple are provided it will throw an error
      var child = _react.Children.only(children);
      var props = {
        onClick: this.linkClicked

        // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
        // defined, we specify the current 'href', so that repetition is not needed by the user
      };if (this.props.passHref || child.type === 'a' && !('href' in child.props)) {
        props.href = as || href;
      }

      // Add the ending slash to the paths. So, we can serve the
      // "<page>/index.html" directly.
      if (props.href && typeof __NEXT_DATA__ !== 'undefined' && __NEXT_DATA__.nextExport) {
        props.href = (0, _router._rewriteUrlForNextExport)(props.href);
      }

      return _react2.default.cloneElement(child, props);
    }
  }]);
  return Link;
}(_react.Component);

Link.propTypes = (0, _propTypesExact2.default)({
  href: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired,
  as: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
  prefetch: _propTypes2.default.bool,
  replace: _propTypes2.default.bool,
  shallow: _propTypes2.default.bool,
  passHref: _propTypes2.default.bool,
  scroll: _propTypes2.default.bool,
  children: _propTypes2.default.oneOfType([_propTypes2.default.element, function (props, propName) {
    var value = props[propName];

    if (typeof value === 'string') {
      warnLink('Warning: You\'re using a string directly inside <Link>. This usage has been deprecated. Please add an <a> tag as child of <Link>');
    }

    return null;
  }]).isRequired
});
exports.default = Link;


function isLocal(href) {
  var url = (0, _url.parse)(href, false, true);
  var origin = (0, _url.parse)((0, _utils.getLocationOrigin)(), false, true);
  return !url.host || url.protocol === origin.protocol && url.host === origin.host;
}

var warnLink = (0, _utils.execOnce)(_utils.warn);

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(403), __esModule: true };

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(0);
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = forbidExtraProps;

var _object = __webpack_require__(405);

var _object2 = _interopRequireDefault(_object);

var _has = __webpack_require__(411);

var _has2 = _interopRequireDefault(_has);

var _isPlainObject = __webpack_require__(412);

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var zeroWidthSpace = '\u200B';
var specialProperty = 'prop-types-exact: ' + zeroWidthSpace;
var semaphore = {};

function brand(fn) {
  return (0, _object2['default'])(fn, _defineProperty({}, specialProperty, semaphore));
}

function isBranded(value) {
  return value && value[specialProperty] === semaphore;
}

function forbidExtraProps(propTypes) {
  if (!(0, _isPlainObject2['default'])(propTypes)) {
    throw new TypeError('given propTypes must be an object');
  }
  if ((0, _has2['default'])(propTypes, specialProperty) && !isBranded(propTypes[specialProperty])) {
    throw new TypeError('Against all odds, you created a propType for a prop that uses both the zero-width space and our custom string - which, sadly, conflicts with `prop-types-exact`');
  }

  return (0, _object2['default'])({}, propTypes, _defineProperty({}, specialProperty, brand(function () {
    function forbidUnknownProps(props, _, componentName) {
      var unknownProps = Object.keys(props).filter(function (prop) {
        return !(0, _has2['default'])(propTypes, prop);
      });
      if (unknownProps.length > 0) {
        return new TypeError(String(componentName) + ': unknown props found: ' + String(unknownProps.join(', ')));
      }
      return null;
    }

    return forbidUnknownProps;
  }())));
}
module.exports = exports['default'];
//# sourceMappingURL=index.js.map

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defineProperties = __webpack_require__(392);

var implementation = __webpack_require__(394);
var getPolyfill = __webpack_require__(396);
var shim = __webpack_require__(410);

var polyfill = getPolyfill();

defineProperties(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),
/* 407 */
/***/ (function(module, exports) {


var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};



/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint complexity: [2, 17], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(392);
var getPolyfill = __webpack_require__(396);

module.exports = function shimAssign() {
	var polyfill = getPolyfill();
	define(
		Object,
		{ assign: polyfill },
		{ assign: function () { return Object.assign !== polyfill; } }
	);
	return polyfill;
};


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__(395);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),
/* 412 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = isPlainObject;
function isPlainObject(x) {
  return x && (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && !Array.isArray(x);
}
module.exports = exports['default'];
//# sourceMappingURL=isPlainObject.js.map

/***/ }),
/* 413 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(global, Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Editor", function() { return Editor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LiveProvider", function() { return LiveProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LiveEditor", function() { return LiveEditor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LiveError", function() { return LiveError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LivePreview", function() { return LivePreview; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withLive", function() { return withLive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateElement", function() { return generateElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderElementAsync", function() { return renderElementAsync; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);


var cn = function cn() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return args.filter(Boolean).join(' ');
};

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var prismCore = createCommonjsModule(function (module) {
	var _self = typeof window !== 'undefined' ? window // if in browser
	: typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self // if in worker
	: {};

	/**
  * Prism: Lightweight, robust, elegant syntax highlighting
  * MIT license http://www.opensource.org/licenses/mit-license.php/
  * @author Lea Verou http://lea.verou.me
  */

	var Prism = function () {

		// Private helper vars
		var lang = /\blang(?:uage)?-(\w+)\b/i;
		var uniqueId = 0;

		var _ = _self.Prism = {
			util: {
				encode: function encode(tokens) {
					if (tokens instanceof Token) {
						return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
					} else if (_.util.type(tokens) === 'Array') {
						return tokens.map(_.util.encode);
					} else {
						return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
					}
				},

				type: function type(o) {
					return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
				},

				objId: function objId(obj) {
					if (!obj['__id']) {
						Object.defineProperty(obj, '__id', { value: ++uniqueId });
					}
					return obj['__id'];
				},

				// Deep clone a language definition (e.g. to extend it)
				clone: function clone(o) {
					var type = _.util.type(o);

					switch (type) {
						case 'Object':
							var clone = {};

							for (var key in o) {
								if (o.hasOwnProperty(key)) {
									clone[key] = _.util.clone(o[key]);
								}
							}

							return clone;

						case 'Array':
							// Check for existence for IE8
							return o.map && o.map(function (v) {
								return _.util.clone(v);
							});
					}

					return o;
				}
			},

			languages: {
				extend: function extend(id, redef) {
					var lang = _.util.clone(_.languages[id]);

					for (var key in redef) {
						lang[key] = redef[key];
					}

					return lang;
				},

				/**
     * Insert a token before another token in a language literal
     * As this needs to recreate the object (we cannot actually insert before keys in object literals),
     * we cannot just provide an object, we need anobject and a key.
     * @param inside The key (or language id) of the parent
     * @param before The key to insert before. If not provided, the function appends instead.
     * @param insert Object with the key/value pairs to insert
     * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
     */
				insertBefore: function insertBefore(inside, before, insert, root) {
					root = root || _.languages;
					var grammar = root[inside];

					if (arguments.length == 2) {
						insert = arguments[1];

						for (var newToken in insert) {
							if (insert.hasOwnProperty(newToken)) {
								grammar[newToken] = insert[newToken];
							}
						}

						return grammar;
					}

					var ret = {};

					for (var token in grammar) {

						if (grammar.hasOwnProperty(token)) {

							if (token == before) {

								for (var newToken in insert) {

									if (insert.hasOwnProperty(newToken)) {
										ret[newToken] = insert[newToken];
									}
								}
							}

							ret[token] = grammar[token];
						}
					}

					// Update references in other language definitions
					_.languages.DFS(_.languages, function (key, value) {
						if (value === root[inside] && key != inside) {
							this[key] = ret;
						}
					});

					return root[inside] = ret;
				},

				// Traverse a language definition with Depth First Search
				DFS: function DFS(o, callback, type, visited) {
					visited = visited || {};
					for (var i in o) {
						if (o.hasOwnProperty(i)) {
							callback.call(o, i, o[i], type || i);

							if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
								visited[_.util.objId(o[i])] = true;
								_.languages.DFS(o[i], callback, null, visited);
							} else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
								visited[_.util.objId(o[i])] = true;
								_.languages.DFS(o[i], callback, i, visited);
							}
						}
					}
				}
			},
			plugins: {},

			highlightAll: function highlightAll(async, callback) {
				var env = {
					callback: callback,
					selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
				};

				_.hooks.run("before-highlightall", env);

				var elements = env.elements || document.querySelectorAll(env.selector);

				for (var i = 0, element; element = elements[i++];) {
					_.highlightElement(element, async === true, env.callback);
				}
			},

			highlightElement: function highlightElement(element, async, callback) {
				// Find language
				var language,
				    grammar,
				    parent = element;

				while (parent && !lang.test(parent.className)) {
					parent = parent.parentNode;
				}

				if (parent) {
					language = (parent.className.match(lang) || [, ''])[1].toLowerCase();
					grammar = _.languages[language];
				}

				// Set language on the element, if not present
				element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

				// Set language on the parent, for styling
				parent = element.parentNode;

				if (/pre/i.test(parent.nodeName)) {
					parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
				}

				var code = element.textContent;

				var env = {
					element: element,
					language: language,
					grammar: grammar,
					code: code
				};

				_.hooks.run('before-sanity-check', env);

				if (!env.code || !env.grammar) {
					if (env.code) {
						env.element.textContent = env.code;
					}
					_.hooks.run('complete', env);
					return;
				}

				_.hooks.run('before-highlight', env);

				if (async && _self.Worker) {
					var worker = new Worker(_.filename);

					worker.onmessage = function (evt) {
						env.highlightedCode = evt.data;

						_.hooks.run('before-insert', env);

						env.element.innerHTML = env.highlightedCode;

						callback && callback.call(env.element);
						_.hooks.run('after-highlight', env);
						_.hooks.run('complete', env);
					};

					worker.postMessage(JSON.stringify({
						language: env.language,
						code: env.code,
						immediateClose: true
					}));
				} else {
					env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

					_.hooks.run('before-insert', env);

					env.element.innerHTML = env.highlightedCode;

					callback && callback.call(element);

					_.hooks.run('after-highlight', env);
					_.hooks.run('complete', env);
				}
			},

			highlight: function highlight(text, grammar, language) {
				var tokens = _.tokenize(text, grammar);
				return Token.stringify(_.util.encode(tokens), language);
			},

			tokenize: function tokenize(text, grammar, language) {
				var Token = _.Token;

				var strarr = [text];

				var rest = grammar.rest;

				if (rest) {
					for (var token in rest) {
						grammar[token] = rest[token];
					}

					delete grammar.rest;
				}

				tokenloop: for (var token in grammar) {
					if (!grammar.hasOwnProperty(token) || !grammar[token]) {
						continue;
					}

					var patterns = grammar[token];
					patterns = _.util.type(patterns) === "Array" ? patterns : [patterns];

					for (var j = 0; j < patterns.length; ++j) {
						var pattern = patterns[j],
						    inside = pattern.inside,
						    lookbehind = !!pattern.lookbehind,
						    greedy = !!pattern.greedy,
						    lookbehindLength = 0,
						    alias = pattern.alias;

						if (greedy && !pattern.pattern.global) {
							// Without the global flag, lastIndex won't work
							var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
							pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
						}

						pattern = pattern.pattern || pattern;

						// Don’t cache length as it changes during the loop
						for (var i = 0, pos = 0; i < strarr.length; pos += strarr[i].length, ++i) {

							var str = strarr[i];

							if (strarr.length > text.length) {
								// Something went terribly wrong, ABORT, ABORT!
								break tokenloop;
							}

							if (str instanceof Token) {
								continue;
							}

							pattern.lastIndex = 0;

							var match = pattern.exec(str),
							    delNum = 1;

							// Greedy patterns can override/remove up to two previously matched tokens
							if (!match && greedy && i != strarr.length - 1) {
								pattern.lastIndex = pos;
								match = pattern.exec(text);
								if (!match) {
									break;
								}

								var from = match.index + (lookbehind ? match[1].length : 0),
								    to = match.index + match[0].length,
								    k = i,
								    p = pos;

								for (var len = strarr.length; k < len && p < to; ++k) {
									p += strarr[k].length;
									// Move the index i to the element in strarr that is closest to from
									if (from >= p) {
										++i;
										pos = p;
									}
								}

								/*
         * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
         * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
         */
								if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
									continue;
								}

								// Number of tokens to delete and replace with the new match
								delNum = k - i;
								str = text.slice(pos, p);
								match.index -= pos;
							}

							if (!match) {
								continue;
							}

							if (lookbehind) {
								lookbehindLength = match[1].length;
							}

							var from = match.index + lookbehindLength,
							    match = match[0].slice(lookbehindLength),
							    to = from + match.length,
							    before = str.slice(0, from),
							    after = str.slice(to);

							var args = [i, delNum];

							if (before) {
								args.push(before);
							}

							var wrapped = new Token(token, inside ? _.tokenize(match, inside) : match, alias, match, greedy);

							args.push(wrapped);

							if (after) {
								args.push(after);
							}

							Array.prototype.splice.apply(strarr, args);
						}
					}
				}

				return strarr;
			},

			hooks: {
				all: {},

				add: function add(name, callback) {
					var hooks = _.hooks.all;

					hooks[name] = hooks[name] || [];

					hooks[name].push(callback);
				},

				run: function run(name, env) {
					var callbacks = _.hooks.all[name];

					if (!callbacks || !callbacks.length) {
						return;
					}

					for (var i = 0, callback; callback = callbacks[i++];) {
						callback(env);
					}
				}
			}
		};

		var Token = _.Token = function (type, content, alias, matchedStr, greedy) {
			this.type = type;
			this.content = content;
			this.alias = alias;
			// Copy of the full string this token was created from
			this.length = (matchedStr || "").length | 0;
			this.greedy = !!greedy;
		};

		Token.stringify = function (o, language, parent) {
			if (typeof o == 'string') {
				return o;
			}

			if (_.util.type(o) === 'Array') {
				return o.map(function (element) {
					return Token.stringify(element, language, o);
				}).join('');
			}

			var env = {
				type: o.type,
				content: Token.stringify(o.content, language, parent),
				tag: 'span',
				classes: ['token', o.type],
				attributes: {},
				language: language,
				parent: parent
			};

			if (env.type == 'comment') {
				env.attributes['spellcheck'] = 'true';
			}

			if (o.alias) {
				var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
				Array.prototype.push.apply(env.classes, aliases);
			}

			_.hooks.run('wrap', env);

			var attributes = Object.keys(env.attributes).map(function (name) {
				return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
			}).join(' ');

			return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';
		};

		if (!_self.document) {
			if (!_self.addEventListener) {
				// in Node.js
				return _self.Prism;
			}
			// In worker
			_self.addEventListener('message', function (evt) {
				var message = JSON.parse(evt.data),
				    lang = message.language,
				    code = message.code,
				    immediateClose = message.immediateClose;

				_self.postMessage(_.highlight(code, _.languages[lang], lang));
				if (immediateClose) {
					_self.close();
				}
			}, false);

			return _self.Prism;
		}

		//Get current script and highlight
		var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

		if (script) {
			_.filename = script.src;

			if (document.addEventListener && !script.hasAttribute('data-manual')) {
				if (document.readyState !== "loading") {
					if (window.requestAnimationFrame) {
						window.requestAnimationFrame(_.highlightAll);
					} else {
						window.setTimeout(_.highlightAll, 16);
					}
				} else {
					document.addEventListener('DOMContentLoaded', _.highlightAll);
				}
			}
		}

		return _self.Prism;
	}();

	if ('object' !== 'undefined' && module.exports) {
		module.exports = Prism;
	}

	// hack for components to work correctly in node.js
	if (typeof commonjsGlobal !== 'undefined') {
		commonjsGlobal.Prism = Prism;
	}
});

var prismCore_1 = prismCore.highlight;
var prismCore_2 = prismCore.languages;

Prism.languages.clike = {
	'comment': [{
		pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
		lookbehind: true
	}, {
		pattern: /(^|[^\\:])\/\/.*/,
		lookbehind: true
	}],
	'string': {
		pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /(\.|\\)/
		}
	},
	'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(true|false)\b/,
	'function': /[a-z0-9_]+(?=\()/i,
	'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	'punctuation': /[{}[\];(),.:]/
};

Prism.languages.javascript = Prism.languages.extend('clike', {
	'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
	'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
});

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
		lookbehind: true,
		greedy: true
	}
});

Prism.languages.insertBefore('javascript', 'string', {
	'template-string': {
		pattern: /`(?:\\\\|\\?[^\\])*?`/,
		greedy: true,
		inside: {
			'interpolation': {
				pattern: /\$\{[^}]+\}/,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'script': {
			pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript,
			alias: 'language-javascript'
		}
	});
}

Prism.languages.js = Prism.languages.javascript;

Prism.languages.markup = {
	'comment': /<!--[\w\W]*?-->/,
	'prolog': /<\?[\w\W]+?\?>/,
	'doctype': /<!DOCTYPE[\w\W]+?>/i,
	'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/i,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
				inside: {
					'punctuation': /[=>"']/
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': /&#?[\da-z]{1,8};/i
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function (env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;

(function (Prism) {

	var javascript = Prism.util.clone(Prism.languages.javascript);

	Prism.languages.jsx = Prism.languages.extend('markup', javascript);
	Prism.languages.jsx.tag.pattern = /<\/?[\w\.:-]+\s*(?:\s+[\w\.:-]+(?:=(?:("|')(\\?[\w\W])*?\1|[^\s'">=]+|(\{[\w\W]*?\})))?\s*)*\/?>/i;

	Prism.languages.jsx.tag.inside['attr-value'].pattern = /=[^\{](?:('|")[\w\W]*?(\1)|[^\s>]+)/i;

	var jsxExpression = Prism.util.clone(Prism.languages.jsx);

	delete jsxExpression.punctuation;

	jsxExpression = Prism.languages.insertBefore('jsx', 'operator', {
		'punctuation': /=(?={)|[{}[\];(),.:]/
	}, { jsx: jsxExpression });

	Prism.languages.insertBefore('inside', 'attr-value', {
		'script': {
			// Allow for one level of nesting
			pattern: /=(\{(?:\{[^}]*\}|[^}])+\})/i,
			inside: jsxExpression,
			'alias': 'language-javascript'
		}
	}, Prism.languages.jsx.tag);
})(Prism);

var prism = function prism(code) {
  return prismCore_1(code, prismCore_2.jsx);
};

var indentRegex = /^\s+/;

var getIndent = function getIndent(plain, cursorPos) {
  var startSlice = plain.slice(0, cursorPos);
  var lastNewline = startSlice.lastIndexOf('\n') + 1;
  var lineSlice = startSlice.slice(lastNewline);
  var matches = lineSlice.match(indentRegex);
  if (matches === null) {
    return '';
  }

  return matches[0] || '';
};

var normalizeCode = function normalizeCode(code) {
  return code.replace(/^((  )+)/mg, function (_, p1) {
    return '\t'.repeat(p1.length / 2);
  });
};

var normalizeHtml = function normalizeHtml(html) {
  return html.replace('\n', '<br>');
};

var index = createCommonjsModule(function (module) {
  'use strict';

  var cache;

  /**
   * Convert HTML entities to HTML characters.
   *
   * @param  {String} `str` String with HTML entities to un-escape.
   * @return {String}
   */

  var unescape = module.exports = function (str) {
    if (str == null) return '';

    var re = cache || (cache = new RegExp('(' + Object.keys(chars).join('|') + ')', 'g'));
    return String(str).replace(re, function (match) {
      return chars[match];
    });
  };

  var chars = unescape.chars = {
    '&apos;': '\'',
    '&#39;': '\'',
    '&amp;': '&',
    '&gt;': '>',
    '&lt;': '<',
    '&quot;': '"'
  };
});

var htmlToPlain = function htmlToPlain(html) {
  return index(html.replace(/<br>/gm, '\n').replace(/<\/?[^>]*>/gm, ''));
};

/**
 * Expose `xor`
 */

var index$2 = xor$1;

/**
 * XOR utility
 *
 * T T F
 * T F T
 * F T T
 * F F F
 *
 * @param {Boolean} a
 * @param {Boolean} b
 * @return {Boolean}
 */

function xor$1(a, b) {
  return !a != !b;
}

/**
 * Global Names
 */

var globals = /\b(Array|Date|Object|Math|JSON)\b/g;

/**
 * Return immediate identifiers parsed from `str`.
 *
 * @param {String} str
 * @param {String|Function} map function or prefix
 * @return {Array}
 * @api public
 */

var index$4 = function index(str, fn) {
  var p = unique(props$1(str));
  if (fn && 'string' == typeof fn) fn = prefixed(fn);
  if (fn) return map(str, p, fn);
  return p;
};

/**
 * Return immediate identifiers in `str`.
 *
 * @param {String} str
 * @return {Array}
 * @api private
 */

function props$1(str) {
  return str.replace(/\.\w+|\w+ *\(|"[^"]*"|'[^']*'|\/([^/]+)\//g, '').replace(globals, '').match(/[a-zA-Z_]\w*/g) || [];
}

/**
 * Return `str` with `props` mapped with `fn`.
 *
 * @param {String} str
 * @param {Array} props
 * @param {Function} fn
 * @return {String}
 * @api private
 */

function map(str, props, fn) {
  var re = /\.\w+|\w+ *\(|"[^"]*"|'[^']*'|\/([^/]+)\/|[a-zA-Z_]\w*/g;
  return str.replace(re, function (_) {
    if ('(' == _[_.length - 1]) return fn(_);
    if (!~props.indexOf(_)) return _;
    return fn(_);
  });
}

/**
 * Return unique array.
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */

function unique(arr) {
  var ret = [];

  for (var i = 0; i < arr.length; i++) {
    if (~ret.indexOf(arr[i])) continue;
    ret.push(arr[i]);
  }

  return ret;
}

/**
 * Map with prefix `str`.
 */

function prefixed(str) {
  return function (_) {
    return str + _;
  };
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};









var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};









var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/**
 * Module Dependencies
 */

var xor;
var props;

try {
  xor = index$2;
} catch (e) {
  xor = index$2;
}

try {
  props = index$4;
} catch (e) {
  props = index$4;
}

/**
 * Export `Iterator`
 */

var index$1 = Iterator;

/**
 * Initialize `Iterator`
 *
 * @param {Node} node
 * @param {Node} root
 * @return {Iterator} self
 * @api public
 */

function Iterator(node, root) {
  if (!(this instanceof Iterator)) return new Iterator(node, root);
  this.node = this.start = this.peeked = node;
  this.root = root;
  this.closingTag = false;
  this._revisit = true;
  this._selects = [];
  this._rejects = [];

  if (node && this.higher(node)) {
    throw new Error('root must be a parent or ancestor to node');
  }
}

/**
 * Reset the Iterator
 *
 * @param {Node} node (optional)
 * @return {Iterator} self
 * @api public
 */

Iterator.prototype.reset = function (node) {
  this.node = node || this.start;
  return this;
};

/**
 * Revisit element nodes. Defaults to `true`
 */

Iterator.prototype.revisit = function (revisit) {
  this._revisit = undefined == revisit ? true : revisit;
  return this;
};

/**
 * Jump to the opening tag
 */

Iterator.prototype.opening = function () {
  if (1 == this.node.nodeType) this.closingTag = false;
  return this;
};

/**
 * Jump to the closing tag
 */

Iterator.prototype.atOpening = function () {
  return !this.closingTag;
};

/**
 * Jump to the closing tag
 */

Iterator.prototype.closing = function () {
  if (1 == this.node.nodeType) this.closingTag = true;
  return this;
};

/**
 * Jump to the closing tag
 */

Iterator.prototype.atClosing = function () {
  return this.closingTag;
};

/**
 * Next node
 *
 * @param {Number} type
 * @return {Node|null}
 * @api public
 */

Iterator.prototype.next = traverse('nextSibling', 'firstChild');

/**
 * Previous node
 *
 * @param {Number} type
 * @return {Node|null}
 * @api public
 */

Iterator.prototype.previous = Iterator.prototype.prev = traverse('previousSibling', 'lastChild');

/**
 * Make traverse function
 *
 * @param {String} dir
 * @param {String} child
 * @return {Function}
 * @api private
 */

function traverse(dir, child) {
  var next = dir == 'nextSibling';
  return function walk(expr, n, peek) {
    expr = this.compile(expr);
    n = n && n > 0 ? n : 1;
    var node = this.node;
    var closing = this.closingTag;
    var revisit = this._revisit;

    while (node) {
      if (xor(next, closing) && node[child]) {
        // element with children: <em>...</em>
        node = node[child];
        closing = !next;
      } else if (1 == node.nodeType && !node[child] && xor(next, closing)) {
        // empty element tag: <em></em>
        closing = next;
        if (!revisit) continue;
      } else if (node[dir]) {
        // element has a neighbor: ...<em></em>...
        node = node[dir];
        closing = !next;
      } else {
        // done with current layer, move up.
        node = node.parentNode;
        closing = next;
        if (!revisit) continue;
      }

      if (!node || this.higher(node, this.root)) break;

      if (expr(node) && this.selects(node, peek) && this.rejects(node, peek)) {
        if (--n) continue;
        if (!peek) this.node = node;
        this.closingTag = closing;
        return node;
      }
    }

    return null;
  };
}

/**
 * Select nodes that cause `expr(node)`
 * to be truthy
 *
 * @param {Number|String|Function} expr
 * @return {Iterator} self
 * @api public
 */

Iterator.prototype.select = function (expr) {
  expr = this.compile(expr);
  this._selects.push(expr);
  return this;
};

/**
 * Run through the selects ORing each
 *
 * @param {Node} node
 * @param {Boolean} peek
 * @return {Boolean}
 * @api private
 */

Iterator.prototype.selects = function (node, peek) {
  var exprs = this._selects;
  var len = exprs.length;
  if (!len) return true;

  for (var i = 0; i < len; i++) {
    if (exprs[i].call(this, node, peek)) return true;
  }

  return false;
};

/**
 * Select nodes that cause `expr(node)`
 * to be falsy
 *
 * @param {Number|String|Function} expr
 * @return {Iterator} self
 * @api public
 */

Iterator.prototype.reject = function (expr) {
  expr = this.compile(expr);
  this._rejects.push(expr);
  return this;
};

/**
 * Run through the reject expressions ANDing each
 *
 * @param {Node} node
 * @param {Boolean} peek
 * @return {Boolean}
 * @api private
 */

Iterator.prototype.rejects = function (node, peek) {
  var exprs = this._rejects;
  var len = exprs.length;
  if (!len) return true;

  for (var i = 0; i < len; i++) {
    if (exprs[i].call(this, node, peek)) return false;
  }

  return true;
};

/**
 * Check if node is higher
 * than root.
 *
 * @param {Node} node
 * @param {Node} root
 * @return {Boolean}
 * @api private
 */

Iterator.prototype.higher = function (node) {
  var root = this.root;
  if (!root) return false;
  node = node.parentNode;
  while (node && node != root) {
    node = node.parentNode;
  }return node != root;
};

/**
 * Compile an expression
 *
 * @param {String|Function|Number} expr
 * @return {Function}
 */

Iterator.prototype.compile = function (expr) {
  switch (typeof expr === 'undefined' ? 'undefined' : _typeof(expr)) {
    case 'number':
      return function (node) {
        return expr == node.nodeType;
      };
    case 'string':
      return new Function('node', 'return ' + props(expr, 'node.'));
    case 'function':
      return expr;
    default:
      return function () {
        return true;
      };
  }
};

/**
 * Peek in either direction
 * `n` nodes. Peek backwards
 * using negative numbers.
 *
 * @param {Number} n (optional)
 * @return {Node|null}
 * @api public
 */

Iterator.prototype.peak = Iterator.prototype.peek = function (expr, n) {
  if (arguments.length == 1) n = expr, expr = true;
  n = undefined == n ? 1 : n;
  if (!n) return this.node;else if (n > 0) return this.next(expr, n, true);else return this.prev(expr, Math.abs(n), true);
};

/**
 * Add a plugin
 *
 * @param {Function} fn
 * @return {Iterator}
 * @api public
 */

Iterator.prototype.use = function (fn) {
  fn(this);
  return this;
};

function position(el, pos) {
  var selection = window.getSelection();

  if (1 == arguments.length) {
    if (!selection.rangeCount) return;
    var indexes = {};
    var range = selection.getRangeAt(0);
    var clone = range.cloneRange();
    clone.selectNodeContents(el);
    clone.setEnd(range.endContainer, range.endOffset);
    indexes.end = clone.toString().length;
    clone.setStart(range.startContainer, range.startOffset);
    indexes.start = indexes.end - clone.toString().length;
    indexes.atStart = clone.startOffset === 0;
    indexes.commonAncestorContainer = clone.commonAncestorContainer;
    indexes.endContainer = clone.endContainer;
    indexes.startContainer = clone.startContainer;
    return indexes;
  }

  var setSelection = pos.end && pos.end !== pos.start;
  var length = 0;
  var range = document.createRange();
  var it = index$1(el).select(Node.TEXT_NODE).revisit(false);
  var next;
  var startindex;
  var start = pos.start > el.textContent.length ? el.textContent.length : pos.start;
  var end = pos.end > el.textContent.length ? el.textContent.length : pos.end;
  var atStart = pos.atStart;

  while (next = it.next()) {
    var olen = length;
    length += next.textContent.length;

    // Set start point of selection
    var atLength = atStart ? length > start : length >= start;
    if (!startindex && atLength) {
      startindex = true;
      range.setStart(next, start - olen);
      if (!setSelection) {
        range.collapse(true);
        makeSelection(el, range);
        break;
      }
    }

    // Set end point of selection
    if (setSelection && length >= end) {
      range.setEnd(next, end - olen);
      makeSelection(el, range);
      break;
    }
  }
}

function makeSelection(el, range) {
  var selection = window.getSelection();
  el.focus();
  selection.removeAllRanges();
  selection.addRange(range);
}

var Editor = function (_Component) {
  inherits(Editor, _Component);

  function Editor() {
    var _temp, _this, _ret;

    classCallCheck(this, Editor);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.undoStack = [], _this.undoOffset = 0, _this.undoTimestamp = 0, _this.state = {
      html: ''
    }, _this.onRef = function (node) {
      _this.ref = node;
    }, _this.getPlain = function () {
      if (_this._innerHTML === _this.ref.innerHTML) {
        return _this._plain;
      }

      var plain = htmlToPlain(normalizeHtml(_this.ref.innerHTML));

      _this._plain = plain;
      _this._innerHTML = _this.ref.innerHTML;

      return _this._plain;
    }, _this.recordChange = function (plain, selection) {
      if (plain === _this.undoStack[_this.undoStack.length - 1]) {
        return;
      }

      if (_this.undoOffset > 0) {
        _this.undoStack = _this.undoStack.slice(0, -_this.undoOffset);
        _this.undoOffset = 0;
      }

      var timestamp = Date.now();
      var record = { plain: plain, selection: selection };

      // Overwrite last record if threshold is not crossed
      if (timestamp - _this.undoTimestamp < 3000) {
        _this.undoStack[_this.undoStack.length - 1] = record;
      } else {
        _this.undoStack.push(record);

        if (_this.undoStack.length > 50) {
          _this.undoStack.shift();
        }
      }

      _this.undoTimestamp = timestamp;
    }, _this.updateContent = function (plain) {
      _this.setState({ html: prism(plain) });

      if (_this.props.onChange) {
        _this.props.onChange(plain);
      }
    }, _this.restoreStackState = function (offset) {
      var _this$undoStack = _this.undoStack[_this.undoStack.length - 1 - offset],
          plain = _this$undoStack.plain,
          selection = _this$undoStack.selection;


      _this.selection = selection;
      _this.undoOffset = offset;
      _this.updateContent(plain);
    }, _this.undo = function () {
      var offset = _this.undoOffset + 1;
      if (offset >= _this.undoStack.length) {
        return;
      }

      _this.restoreStackState(offset);
    }, _this.redo = function () {
      var offset = _this.undoOffset - 1;
      if (offset < 0) {
        return;
      }

      _this.restoreStackState(offset);
    }, _this.onKeyDown = function (evt) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(evt);
      }
      if (evt.keyCode === 9 && !_this.props.ignoreTabKey) {
        // Tab Key
        document.execCommand('insertHTML', false, '&#009');
        evt.preventDefault();
      } else if (evt.keyCode === 13) {
        // Enter Key
        var _selectionRange = position(_this.ref),
            cursorPos = _selectionRange.start;

        var indentation = getIndent(_this.getPlain(), cursorPos);

        document.execCommand('insertHTML', false, '\n' + indentation);
        evt.preventDefault();
      } else if (
      // Undo / Redo
      evt.keyCode === 90 && evt.metaKey !== evt.ctrlKey && !evt.altKey) {
        if (evt.shiftKey) {
          _this.redo();
        } else {
          _this.undo();
        }

        evt.preventDefault();
      }
    }, _this.onKeyUp = function (evt) {
      if (_this.props.onKeyUp) {
        _this.props.onKeyUp(evt);
      }
      if (evt.keyCode === 91 || // left cmd
      evt.keyCode === 93 || // right cmd
      evt.ctrlKey || evt.metaKey) {
        return;
      }

      // Enter key
      if (evt.keyCode === 13) {
        _this.undoTimestamp = 0;
      }

      _this.selection = position(_this.ref);

      if (evt.keyCode !== 37 && // left
      evt.keyCode !== 38 && // up
      evt.keyCode !== 39 && // right
      evt.keyCode !== 40 // down
      ) {
          var plain = _this.getPlain();

          _this.recordChange(plain, _this.selection);
          _this.updateContent(plain);
        } else {
        _this.undoTimestamp = 0;
      }
    }, _this.onClick = function (evt) {
      if (_this.props.onClick) {
        _this.props.onClick(evt);
      }
      _this.undoTimestamp = 0; // Reset timestamp
      _this.selection = position(_this.ref);
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  Editor.prototype.componentWillMount = function componentWillMount() {
    var html = prism(normalizeCode(this.props.code));
    this.setState({ html: html });
  };

  Editor.prototype.componentDidMount = function componentDidMount() {
    this.recordChange(this.getPlain());
    this.undoTimestamp = 0; // Reset timestamp
  };

  Editor.prototype.componentWillReceiveProps = function componentWillReceiveProps(_ref) {
    var code = _ref.code;

    if (code !== this.props.code) {
      var html = prism(normalizeCode(code));
      this.setState({ html: html });
    }
  };

  Editor.prototype.componentDidUpdate = function componentDidUpdate() {
    var selection = this.selection;

    if (selection) {
      position(this.ref, selection);
    }
  };

  Editor.prototype.render = function render() {
    var _props = this.props,
        contentEditable = _props.contentEditable,
        className = _props.className,
        style = _props.style,
        rest = objectWithoutProperties(_props, ['contentEditable', 'className', 'style']);
    var html = this.state.html;

    delete rest.code;

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('pre', _extends({}, rest, {
      ref: this.onRef,
      className: cn('prism-code', className),
      style: style,
      spellCheck: 'false',
      contentEditable: contentEditable,
      onKeyDown: contentEditable && this.onKeyDown,
      onKeyUp: contentEditable && this.onKeyUp,
      onClick: contentEditable && this.onClick,
      dangerouslySetInnerHTML: { __html: html }
    }));
  };

  return Editor;
}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

Editor.defaultProps = {
  contentEditable: true
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

var emptyFunction_1 = emptyFunction;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

{
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

var invariant_1 = invariant;

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction_1;

{
  (function () {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return; // Ignore CompositeComponent proptype check.
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  })();
}

var warning_1 = warning;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

var ReactPropTypesSecret_1 = ReactPropTypesSecret;

{
  var invariant$1 = invariant_1;
  var warning$1 = warning_1;
  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant$1(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
        } catch (ex) {
          error = ex;
        }
        warning$1(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning$1(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

var checkPropTypes_1 = checkPropTypes;

var factoryWithTypeCheckers = function factoryWithTypeCheckers(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret_1) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant_1(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
        } else if ("development" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            warning_1(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction_1.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      warning_1(false, 'Invalid argument supplied to oneOf, expected an instance of array.');
      return emptyFunction_1.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      warning_1(false, 'Invalid argument supplied to oneOfType, expected an instance of array.');
      return emptyFunction_1.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes_1;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

var index$6 = createCommonjsModule(function (module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   */

  {
    var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

    var isValidElement = function isValidElement(object) {
      return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    };

    // By explicitly using `prop-types` you are opting into new development behavior.
    // http://fb.me/prop-types-in-prod
    var throwOnDirectAccess = true;
    module.exports = factoryWithTypeCheckers(isValidElement, throwOnDirectAccess);
  }
});

var buble_deps = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
    factory(exports);
  })(commonjsGlobal, function (exports) {
    'use strict';

    var __commonjs_global = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : this;
    function __commonjs(fn, module) {
      return module = { exports: {} }, fn(module, module.exports, __commonjs_global), module.exports;
    }

    var acorn = __commonjs(function (module, exports, global) {
      (function (global, factory) {
        (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  false ? undefined(['exports'], factory) : factory(global.acorn = global.acorn || {});
      })(__commonjs_global, function (exports) {
        'use strict';

        // Reserved word lists for various dialects of the language

        var reservedWords = {
          3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
          5: "class enum extends super const export import",
          6: "enum",
          7: "enum",
          strict: "implements interface let package private protected public static yield",
          strictBind: "eval arguments"
        };

        // And the keywords

        var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

        var keywords = {
          5: ecma5AndLessKeywords,
          6: ecma5AndLessKeywords + " const class extends export import super"
        };

        // ## Character categories

        // Big ugly regular expressions that match characters in the
        // whitespace, identifier, and identifier-start categories. These
        // are only applied when a character is found to actually have a
        // code point above 128.
        // Generated by `bin/generate-identifier-regex.js`.

        var nonASCIIidentifierStartChars = '\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC';
        var nonASCIIidentifierChars = '\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F';

        var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
        var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

        nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

        // These are a run-length and offset encoded representation of the
        // >0xffff code points that are a valid part of identifiers. The
        // offset starts at 0x10000, and each pair of numbers represents an
        // offset to the next range, and then a size of the range. They were
        // generated by bin/generate-identifier-regex.js
        var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];
        var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];

        // This has a complexity linear to the value of the code. The
        // assumption is that looking up astral identifier characters is
        // rare.
        function isInAstralSet(code, set$$1) {
          var pos = 0x10000;
          for (var i = 0; i < set$$1.length; i += 2) {
            pos += set$$1[i];
            if (pos > code) return false;
            pos += set$$1[i + 1];
            if (pos >= code) return true;
          }
        }

        // Test whether a given character code starts an identifier.

        function isIdentifierStart(code, astral) {
          if (code < 65) return code === 36;
          if (code < 91) return true;
          if (code < 97) return code === 95;
          if (code < 123) return true;
          if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
          if (astral === false) return false;
          return isInAstralSet(code, astralIdentifierStartCodes);
        }

        // Test whether a given character is part of an identifier.

        function isIdentifierChar(code, astral) {
          if (code < 48) return code === 36;
          if (code < 58) return true;
          if (code < 65) return false;
          if (code < 91) return true;
          if (code < 97) return code === 95;
          if (code < 123) return true;
          if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
          if (astral === false) return false;
          return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
        }

        // ## Token types

        // The assignment of fine-grained, information-carrying type objects
        // allows the tokenizer to store the information it has about a
        // token in a way that is very cheap for the parser to look up.

        // All token type variables start with an underscore, to make them
        // easy to recognize.

        // The `beforeExpr` property is used to disambiguate between regular
        // expressions and divisions. It is set on all token types that can
        // be followed by an expression (thus, a slash after them would be a
        // regular expression).
        //
        // The `startsExpr` property is used to check if the token ends a
        // `yield` expression. It is set on all token types that either can
        // directly start an expression (like a quotation mark) or can
        // continue an expression (like the body of a string).
        //
        // `isLoop` marks a keyword as starting a loop, which is important
        // to know when parsing a label, in order to allow or disallow
        // continue jumps to that label.

        var TokenType = function TokenType(label, conf) {
          if (conf === void 0) conf = {};

          this.label = label;
          this.keyword = conf.keyword;
          this.beforeExpr = !!conf.beforeExpr;
          this.startsExpr = !!conf.startsExpr;
          this.isLoop = !!conf.isLoop;
          this.isAssign = !!conf.isAssign;
          this.prefix = !!conf.prefix;
          this.postfix = !!conf.postfix;
          this.binop = conf.binop || null;
          this.updateContext = null;
        };

        function binop(name, prec) {
          return new TokenType(name, { beforeExpr: true, binop: prec });
        }
        var beforeExpr = { beforeExpr: true };
        var startsExpr = { startsExpr: true };
        // Map keyword names to token types.

        var keywordTypes = {};

        // Succinct definitions of keyword token types
        function kw(name, options) {
          if (options === void 0) options = {};

          options.keyword = name;
          return keywordTypes[name] = new TokenType(name, options);
        }

        var tt = {
          num: new TokenType("num", startsExpr),
          regexp: new TokenType("regexp", startsExpr),
          string: new TokenType("string", startsExpr),
          name: new TokenType("name", startsExpr),
          eof: new TokenType("eof"),

          // Punctuation token types.
          bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
          bracketR: new TokenType("]"),
          braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
          braceR: new TokenType("}"),
          parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
          parenR: new TokenType(")"),
          comma: new TokenType(",", beforeExpr),
          semi: new TokenType(";", beforeExpr),
          colon: new TokenType(":", beforeExpr),
          dot: new TokenType("."),
          question: new TokenType("?", beforeExpr),
          arrow: new TokenType("=>", beforeExpr),
          template: new TokenType("template"),
          ellipsis: new TokenType("...", beforeExpr),
          backQuote: new TokenType("`", startsExpr),
          dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

          // Operators. These carry several kinds of properties to help the
          // parser use them properly (the presence of these properties is
          // what categorizes them as operators).
          //
          // `binop`, when present, specifies that this operator is a binary
          // operator, and will refer to its precedence.
          //
          // `prefix` and `postfix` mark the operator as a prefix or postfix
          // unary operator.
          //
          // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
          // binary operators with a very low precedence, that should result
          // in AssignmentExpression nodes.

          eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
          assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
          incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
          prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
          logicalOR: binop("||", 1),
          logicalAND: binop("&&", 2),
          bitwiseOR: binop("|", 3),
          bitwiseXOR: binop("^", 4),
          bitwiseAND: binop("&", 5),
          equality: binop("==/!=", 6),
          relational: binop("</>", 7),
          bitShift: binop("<</>>", 8),
          plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
          modulo: binop("%", 10),
          star: binop("*", 10),
          slash: binop("/", 10),
          starstar: new TokenType("**", { beforeExpr: true }),

          // Keyword token types.
          _break: kw("break"),
          _case: kw("case", beforeExpr),
          _catch: kw("catch"),
          _continue: kw("continue"),
          _debugger: kw("debugger"),
          _default: kw("default", beforeExpr),
          _do: kw("do", { isLoop: true, beforeExpr: true }),
          _else: kw("else", beforeExpr),
          _finally: kw("finally"),
          _for: kw("for", { isLoop: true }),
          _function: kw("function", startsExpr),
          _if: kw("if"),
          _return: kw("return", beforeExpr),
          _switch: kw("switch"),
          _throw: kw("throw", beforeExpr),
          _try: kw("try"),
          _var: kw("var"),
          _const: kw("const"),
          _while: kw("while", { isLoop: true }),
          _with: kw("with"),
          _new: kw("new", { beforeExpr: true, startsExpr: true }),
          _this: kw("this", startsExpr),
          _super: kw("super", startsExpr),
          _class: kw("class"),
          _extends: kw("extends", beforeExpr),
          _export: kw("export"),
          _import: kw("import"),
          _null: kw("null", startsExpr),
          _true: kw("true", startsExpr),
          _false: kw("false", startsExpr),
          _in: kw("in", { beforeExpr: true, binop: 7 }),
          _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
          _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
          _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
          _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
        };

        // Matches a whole line break (where CRLF is considered a single
        // line break). Used to count lines.

        var lineBreak = /\r\n?|\n|\u2028|\u2029/;
        var lineBreakG = new RegExp(lineBreak.source, "g");

        function isNewLine(code) {
          return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
        }

        var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

        var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

        function isArray(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        }

        // Checks if an object has a property.

        function has(obj, propName) {
          return Object.prototype.hasOwnProperty.call(obj, propName);
        }

        // These are used when `options.locations` is on, for the
        // `startLoc` and `endLoc` properties.

        var Position = function Position(line, col) {
          this.line = line;
          this.column = col;
        };

        Position.prototype.offset = function offset(n) {
          return new Position(this.line, this.column + n);
        };

        var SourceLocation = function SourceLocation(p, start, end) {
          this.start = start;
          this.end = end;
          if (p.sourceFile !== null) this.source = p.sourceFile;
        };

        // The `getLineInfo` function is mostly useful when the
        // `locations` option is off (for performance reasons) and you
        // want to find the line/column position for a given character
        // offset. `input` should be the code string that the offset refers
        // into.

        function getLineInfo(input, offset) {
          for (var line = 1, cur = 0;;) {
            lineBreakG.lastIndex = cur;
            var match = lineBreakG.exec(input);
            if (match && match.index < offset) {
              ++line;
              cur = match.index + match[0].length;
            } else {
              return new Position(line, offset - cur);
            }
          }
        }

        // A second optional argument can be given to further configure
        // the parser process. These options are recognized:

        var defaultOptions = {
          // `ecmaVersion` indicates the ECMAScript version to parse. Must
          // be either 3, or 5, or 6. This influences support for strict
          // mode, the set of reserved words, support for getters and
          // setters and other features. The default is 6.
          ecmaVersion: 6,
          // Source type ("script" or "module") for different semantics
          sourceType: "script",
          // `onInsertedSemicolon` can be a callback that will be called
          // when a semicolon is automatically inserted. It will be passed
          // th position of the comma as an offset, and if `locations` is
          // enabled, it is given the location as a `{line, column}` object
          // as second argument.
          onInsertedSemicolon: null,
          // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
          // trailing commas.
          onTrailingComma: null,
          // By default, reserved words are only enforced if ecmaVersion >= 5.
          // Set `allowReserved` to a boolean value to explicitly turn this on
          // an off. When this option has the value "never", reserved words
          // and keywords can also not be used as property names.
          allowReserved: null,
          // When enabled, a return at the top level is not considered an
          // error.
          allowReturnOutsideFunction: false,
          // When enabled, import/export statements are not constrained to
          // appearing at the top of the program.
          allowImportExportEverywhere: false,
          // When enabled, hashbang directive in the beginning of file
          // is allowed and treated as a line comment.
          allowHashBang: false,
          // When `locations` is on, `loc` properties holding objects with
          // `start` and `end` properties in `{line, column}` form (with
          // line being 1-based and column 0-based) will be attached to the
          // nodes.
          locations: false,
          // A function can be passed as `onToken` option, which will
          // cause Acorn to call that function with object in the same
          // format as tokens returned from `tokenizer().getToken()`. Note
          // that you are not allowed to call the parser from the
          // callback—that will corrupt its internal state.
          onToken: null,
          // A function can be passed as `onComment` option, which will
          // cause Acorn to call that function with `(block, text, start,
          // end)` parameters whenever a comment is skipped. `block` is a
          // boolean indicating whether this is a block (`/* */`) comment,
          // `text` is the content of the comment, and `start` and `end` are
          // character offsets that denote the start and end of the comment.
          // When the `locations` option is on, two more parameters are
          // passed, the full `{line, column}` locations of the start and
          // end of the comments. Note that you are not allowed to call the
          // parser from the callback—that will corrupt its internal state.
          onComment: null,
          // Nodes have their start and end characters offsets recorded in
          // `start` and `end` properties (directly on the node, rather than
          // the `loc` object, which holds line/column data. To also add a
          // [semi-standardized][range] `range` property holding a `[start,
          // end]` array with the same numbers, set the `ranges` option to
          // `true`.
          //
          // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
          ranges: false,
          // It is possible to parse multiple files into a single AST by
          // passing the tree produced by parsing the first file as
          // `program` option in subsequent parses. This will add the
          // toplevel forms of the parsed file to the `Program` (top) node
          // of an existing parse tree.
          program: null,
          // When `locations` is on, you can pass this to record the source
          // file in every node's `loc` object.
          sourceFile: null,
          // This value, if given, is stored in every node, whether
          // `locations` is on or off.
          directSourceFile: null,
          // When enabled, parenthesized expressions are represented by
          // (non-standard) ParenthesizedExpression nodes
          preserveParens: false,
          plugins: {}
        };

        // Interpret and default an options object

        function getOptions(opts) {
          var options = {};
          for (var opt in defaultOptions) {
            options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
          }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;

          if (isArray(options.onToken)) {
            var tokens = options.onToken;
            options.onToken = function (token) {
              return tokens.push(token);
            };
          }
          if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

          return options;
        }

        function pushComment(options, array) {
          return function (block, text, start, end, startLoc, endLoc) {
            var comment = {
              type: block ? 'Block' : 'Line',
              value: text,
              start: start,
              end: end
            };
            if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
            if (options.ranges) comment.range = [start, end];
            array.push(comment);
          };
        }

        // Registered plugins
        var plugins = {};

        function keywordRegexp(words) {
          return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
        }

        var Parser = function Parser(options, input, startPos) {
          this.options = options = getOptions(options);
          this.sourceFile = options.sourceFile;
          this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
          var reserved = options.allowReserved ? "" : reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
          this.reservedWords = keywordRegexp(reserved);
          var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
          this.reservedWordsStrict = keywordRegexp(reservedStrict);
          this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind);
          this.input = String(input);

          // Used to signal to callers of `readWord1` whether the word
          // contained any escape sequences. This is needed because words with
          // escape sequences must not be interpreted as keywords.
          this.containsEsc = false;

          // Load plugins
          this.loadPlugins(options.plugins);

          // Set up token state

          // The current position of the tokenizer in the input.
          if (startPos) {
            this.pos = startPos;
            this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
          } else {
            this.pos = this.lineStart = 0;
            this.curLine = 1;
          }

          // Properties of the current token:
          // Its type
          this.type = tt.eof;
          // For tokens that include more information than their type, the value
          this.value = null;
          // Its start and end offset
          this.start = this.end = this.pos;
          // And, if locations are used, the {line, column} object
          // corresponding to those offsets
          this.startLoc = this.endLoc = this.curPosition();

          // Position information for the previous token
          this.lastTokEndLoc = this.lastTokStartLoc = null;
          this.lastTokStart = this.lastTokEnd = this.pos;

          // The context stack is used to superficially track syntactic
          // context to predict whether a regular expression is allowed in a
          // given position.
          this.context = this.initialContext();
          this.exprAllowed = true;

          // Figure out if it's a module code.
          this.strict = this.inModule = options.sourceType === "module";

          // Used to signify the start of a potential arrow function
          this.potentialArrowAt = -1;

          // Flags to track whether we are in a function, a generator.
          this.inFunction = this.inGenerator = false;
          // Labels in scope.
          this.labels = [];

          // If enabled, skip leading hashbang line.
          if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!') this.skipLineComment(2);
        };

        // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
        Parser.prototype.isKeyword = function isKeyword(word) {
          return this.keywords.test(word);
        };
        Parser.prototype.isReservedWord = function isReservedWord(word) {
          return this.reservedWords.test(word);
        };

        Parser.prototype.extend = function extend(name, f) {
          this[name] = f(this[name]);
        };

        Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
          var this$1 = this;

          for (var name in pluginConfigs) {
            var plugin = plugins[name];
            if (!plugin) throw new Error("Plugin '" + name + "' not found");
            plugin(this$1, pluginConfigs[name]);
          }
        };

        Parser.prototype.parse = function parse() {
          var node = this.options.program || this.startNode();
          this.nextToken();
          return this.parseTopLevel(node);
        };

        var pp = Parser.prototype;

        // ## Parser utilities

        // Test whether a statement node is the string literal `"use strict"`.

        pp.isUseStrict = function (stmt) {
          return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
        };

        // Predicate that tests whether the next token is of the given
        // type, and if yes, consumes it as a side effect.

        pp.eat = function (type) {
          if (this.type === type) {
            this.next();
            return true;
          } else {
            return false;
          }
        };

        // Tests whether parsed token is a contextual keyword.

        pp.isContextual = function (name) {
          return this.type === tt.name && this.value === name;
        };

        // Consumes contextual keyword if possible.

        pp.eatContextual = function (name) {
          return this.value === name && this.eat(tt.name);
        };

        // Asserts that following token is given contextual keyword.

        pp.expectContextual = function (name) {
          if (!this.eatContextual(name)) this.unexpected();
        };

        // Test whether a semicolon can be inserted at the current position.

        pp.canInsertSemicolon = function () {
          return this.type === tt.eof || this.type === tt.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        };

        pp.insertSemicolon = function () {
          if (this.canInsertSemicolon()) {
            if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
            return true;
          }
        };

        // Consume a semicolon, or, failing that, see if we are allowed to
        // pretend that there is a semicolon at this position.

        pp.semicolon = function () {
          if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected();
        };

        pp.afterTrailingComma = function (tokType) {
          if (this.type == tokType) {
            if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
            this.next();
            return true;
          }
        };

        // Expect a token of a given type. If found, consume it, otherwise,
        // raise an unexpected token error.

        pp.expect = function (type) {
          this.eat(type) || this.unexpected();
        };

        // Raise an unexpected token error.

        pp.unexpected = function (pos) {
          this.raise(pos != null ? pos : this.start, "Unexpected token");
        };

        var DestructuringErrors = function DestructuringErrors() {
          this.shorthandAssign = 0;
          this.trailingComma = 0;
        };

        pp.checkPatternErrors = function (refDestructuringErrors, andThrow) {
          var trailing = refDestructuringErrors && refDestructuringErrors.trailingComma;
          if (!andThrow) return !!trailing;
          if (trailing) this.raise(trailing, "Comma is not permitted after the rest element");
        };

        pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
          var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;
          if (!andThrow) return !!pos;
          if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
        };

        var pp$1 = Parser.prototype;

        // ### Statement parsing

        // Parse a program. Initializes the parser, reads any number of
        // statements, and wraps them in a Program node.  Optionally takes a
        // `program` argument.  If present, the statements will be appended
        // to its body instead of creating a new node.

        pp$1.parseTopLevel = function (node) {
          var this$1 = this;

          var first = true;
          if (!node.body) node.body = [];
          while (this.type !== tt.eof) {
            var stmt = this$1.parseStatement(true, true);
            node.body.push(stmt);
            if (first) {
              if (this$1.isUseStrict(stmt)) this$1.setStrict(true);
              first = false;
            }
          }
          this.next();
          if (this.options.ecmaVersion >= 6) {
            node.sourceType = this.options.sourceType;
          }
          return this.finishNode(node, "Program");
        };

        var loopLabel = { kind: "loop" };
        var switchLabel = { kind: "switch" };
        pp$1.isLet = function () {
          if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != "let") return false;
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length,
              nextCh = this.input.charCodeAt(next);
          if (nextCh === 91 || nextCh == 123) return true; // '{' and '['
          if (isIdentifierStart(nextCh, true)) {
            for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}
            var ident = this.input.slice(next, pos);
            if (!this.isKeyword(ident)) return true;
          }
          return false;
        };

        // Parse a single statement.
        //
        // If expecting a statement and finding a slash operator, parse a
        // regular expression literal. This is to handle cases like
        // `if (foo) /blah/.exec(foo)`, where looking at the previous token
        // does not help.

        pp$1.parseStatement = function (declaration, topLevel) {
          var starttype = this.type,
              node = this.startNode(),
              kind;

          if (this.isLet()) {
            starttype = tt._var;
            kind = "let";
          }

          // Most types of statements are recognized by the keyword they
          // start with. Many are trivial to parse, some require a bit of
          // complexity.

          switch (starttype) {
            case tt._break:case tt._continue:
              return this.parseBreakContinueStatement(node, starttype.keyword);
            case tt._debugger:
              return this.parseDebuggerStatement(node);
            case tt._do:
              return this.parseDoStatement(node);
            case tt._for:
              return this.parseForStatement(node);
            case tt._function:
              if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
              return this.parseFunctionStatement(node);
            case tt._class:
              if (!declaration) this.unexpected();
              return this.parseClass(node, true);
            case tt._if:
              return this.parseIfStatement(node);
            case tt._return:
              return this.parseReturnStatement(node);
            case tt._switch:
              return this.parseSwitchStatement(node);
            case tt._throw:
              return this.parseThrowStatement(node);
            case tt._try:
              return this.parseTryStatement(node);
            case tt._const:case tt._var:
              kind = kind || this.value;
              if (!declaration && kind != "var") this.unexpected();
              return this.parseVarStatement(node, kind);
            case tt._while:
              return this.parseWhileStatement(node);
            case tt._with:
              return this.parseWithStatement(node);
            case tt.braceL:
              return this.parseBlock();
            case tt.semi:
              return this.parseEmptyStatement(node);
            case tt._export:
            case tt._import:
              if (!this.options.allowImportExportEverywhere) {
                if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
                if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
              return starttype === tt._import ? this.parseImport(node) : this.parseExport(node);

            // If the statement does not start with a statement keyword or a
            // brace, it's an ExpressionStatement or LabeledStatement. We
            // simply start parsing an expression, and afterwards, if the
            // next token is a colon and the expression was a simple
            // Identifier node, we switch to interpreting it as a label.
            default:
              var maybeName = this.value,
                  expr = this.parseExpression();
              if (starttype === tt.name && expr.type === "Identifier" && this.eat(tt.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
          }
        };

        pp$1.parseBreakContinueStatement = function (node, keyword) {
          var this$1 = this;

          var isBreak = keyword == "break";
          this.next();
          if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== tt.name) this.unexpected();else {
            node.label = this.parseIdent();
            this.semicolon();
          }

          // Verify that there is an actual destination to break or
          // continue to.
          for (var i = 0; i < this.labels.length; ++i) {
            var lab = this$1.labels[i];
            if (node.label == null || lab.name === node.label.name) {
              if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
              if (node.label && isBreak) break;
            }
          }
          if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
          return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
        };

        pp$1.parseDebuggerStatement = function (node) {
          this.next();
          this.semicolon();
          return this.finishNode(node, "DebuggerStatement");
        };

        pp$1.parseDoStatement = function (node) {
          this.next();
          this.labels.push(loopLabel);
          node.body = this.parseStatement(false);
          this.labels.pop();
          this.expect(tt._while);
          node.test = this.parseParenExpression();
          if (this.options.ecmaVersion >= 6) this.eat(tt.semi);else this.semicolon();
          return this.finishNode(node, "DoWhileStatement");
        };

        // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
        // loop is non-trivial. Basically, we have to parse the init `var`
        // statement or expression, disallowing the `in` operator (see
        // the second parameter to `parseExpression`), and then check
        // whether the next token is `in` or `of`. When there is no init
        // part (semicolon immediately after the opening parenthesis), it
        // is a regular `for` loop.

        pp$1.parseForStatement = function (node) {
          this.next();
          this.labels.push(loopLabel);
          this.expect(tt.parenL);
          if (this.type === tt.semi) return this.parseFor(node, null);
          var isLet = this.isLet();
          if (this.type === tt._var || this.type === tt._const || isLet) {
            var init$1 = this.startNode(),
                kind = isLet ? "let" : this.value;
            this.next();
            this.parseVar(init$1, true, kind);
            this.finishNode(init$1, "VariableDeclaration");
            if ((this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1 && !(kind !== "var" && init$1.declarations[0].init)) return this.parseForIn(node, init$1);
            return this.parseFor(node, init$1);
          }
          var refDestructuringErrors = new DestructuringErrors();
          var init = this.parseExpression(true, refDestructuringErrors);
          if (this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
            this.checkPatternErrors(refDestructuringErrors, true);
            this.toAssignable(init);
            this.checkLVal(init);
            return this.parseForIn(node, init);
          } else {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
          return this.parseFor(node, init);
        };

        pp$1.parseFunctionStatement = function (node) {
          this.next();
          return this.parseFunction(node, true);
        };

        pp$1.parseIfStatement = function (node) {
          this.next();
          node.test = this.parseParenExpression();
          node.consequent = this.parseStatement(false);
          node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null;
          return this.finishNode(node, "IfStatement");
        };

        pp$1.parseReturnStatement = function (node) {
          if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
          this.next();

          // In `return` (and `break`/`continue`), the keywords with
          // optional arguments, we eagerly look for a semicolon or the
          // possibility to insert one.

          if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null;else {
            node.argument = this.parseExpression();this.semicolon();
          }
          return this.finishNode(node, "ReturnStatement");
        };

        pp$1.parseSwitchStatement = function (node) {
          var this$1 = this;

          this.next();
          node.discriminant = this.parseParenExpression();
          node.cases = [];
          this.expect(tt.braceL);
          this.labels.push(switchLabel);

          // Statements under must be grouped (by label) in SwitchCase
          // nodes. `cur` is used to keep the node that we are currently
          // adding statements to.

          for (var cur, sawDefault = false; this.type != tt.braceR;) {
            if (this$1.type === tt._case || this$1.type === tt._default) {
              var isCase = this$1.type === tt._case;
              if (cur) this$1.finishNode(cur, "SwitchCase");
              node.cases.push(cur = this$1.startNode());
              cur.consequent = [];
              this$1.next();
              if (isCase) {
                cur.test = this$1.parseExpression();
              } else {
                if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses");
                sawDefault = true;
                cur.test = null;
              }
              this$1.expect(tt.colon);
            } else {
              if (!cur) this$1.unexpected();
              cur.consequent.push(this$1.parseStatement(true));
            }
          }
          if (cur) this.finishNode(cur, "SwitchCase");
          this.next(); // Closing brace
          this.labels.pop();
          return this.finishNode(node, "SwitchStatement");
        };

        pp$1.parseThrowStatement = function (node) {
          this.next();
          if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
          node.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(node, "ThrowStatement");
        };

        // Reused empty array added for node fields that are always empty.

        var empty = [];

        pp$1.parseTryStatement = function (node) {
          this.next();
          node.block = this.parseBlock();
          node.handler = null;
          if (this.type === tt._catch) {
            var clause = this.startNode();
            this.next();
            this.expect(tt.parenL);
            clause.param = this.parseBindingAtom();
            this.checkLVal(clause.param, true);
            this.expect(tt.parenR);
            clause.body = this.parseBlock();
            node.handler = this.finishNode(clause, "CatchClause");
          }
          node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;
          if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
          return this.finishNode(node, "TryStatement");
        };

        pp$1.parseVarStatement = function (node, kind) {
          this.next();
          this.parseVar(node, false, kind);
          this.semicolon();
          return this.finishNode(node, "VariableDeclaration");
        };

        pp$1.parseWhileStatement = function (node) {
          this.next();
          node.test = this.parseParenExpression();
          this.labels.push(loopLabel);
          node.body = this.parseStatement(false);
          this.labels.pop();
          return this.finishNode(node, "WhileStatement");
        };

        pp$1.parseWithStatement = function (node) {
          if (this.strict) this.raise(this.start, "'with' in strict mode");
          this.next();
          node.object = this.parseParenExpression();
          node.body = this.parseStatement(false);
          return this.finishNode(node, "WithStatement");
        };

        pp$1.parseEmptyStatement = function (node) {
          this.next();
          return this.finishNode(node, "EmptyStatement");
        };

        pp$1.parseLabeledStatement = function (node, maybeName, expr) {
          var this$1 = this;

          for (var i = 0; i < this.labels.length; ++i) {
            if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }var kind = this.type.isLoop ? "loop" : this.type === tt._switch ? "switch" : null;
          for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {
            var label = this$1.labels[i$1];
            if (label.statementStart == node.start) {
              label.statementStart = this$1.start;
              label.kind = kind;
            } else break;
          }
          this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
          node.body = this.parseStatement(true);
          this.labels.pop();
          node.label = expr;
          return this.finishNode(node, "LabeledStatement");
        };

        pp$1.parseExpressionStatement = function (node, expr) {
          node.expression = expr;
          this.semicolon();
          return this.finishNode(node, "ExpressionStatement");
        };

        // Parse a semicolon-enclosed block of statements, handling `"use
        // strict"` declarations when `allowStrict` is true (used for
        // function bodies).

        pp$1.parseBlock = function (allowStrict) {
          var this$1 = this;

          var node = this.startNode(),
              first = true,
              oldStrict;
          node.body = [];
          this.expect(tt.braceL);
          while (!this.eat(tt.braceR)) {
            var stmt = this$1.parseStatement(true);
            node.body.push(stmt);
            if (first && allowStrict && this$1.isUseStrict(stmt)) {
              oldStrict = this$1.strict;
              this$1.setStrict(this$1.strict = true);
            }
            first = false;
          }
          if (oldStrict === false) this.setStrict(false);
          return this.finishNode(node, "BlockStatement");
        };

        // Parse a regular `for` loop. The disambiguation code in
        // `parseStatement` will already have parsed the init statement or
        // expression.

        pp$1.parseFor = function (node, init) {
          node.init = init;
          this.expect(tt.semi);
          node.test = this.type === tt.semi ? null : this.parseExpression();
          this.expect(tt.semi);
          node.update = this.type === tt.parenR ? null : this.parseExpression();
          this.expect(tt.parenR);
          node.body = this.parseStatement(false);
          this.labels.pop();
          return this.finishNode(node, "ForStatement");
        };

        // Parse a `for`/`in` and `for`/`of` loop, which are almost
        // same from parser's perspective.

        pp$1.parseForIn = function (node, init) {
          var type = this.type === tt._in ? "ForInStatement" : "ForOfStatement";
          this.next();
          node.left = init;
          node.right = this.parseExpression();
          this.expect(tt.parenR);
          node.body = this.parseStatement(false);
          this.labels.pop();
          return this.finishNode(node, type);
        };

        // Parse a list of variable declarations.

        pp$1.parseVar = function (node, isFor, kind) {
          var this$1 = this;

          node.declarations = [];
          node.kind = kind;
          for (;;) {
            var decl = this$1.startNode();
            this$1.parseVarId(decl);
            if (this$1.eat(tt.eq)) {
              decl.init = this$1.parseMaybeAssign(isFor);
            } else if (kind === "const" && !(this$1.type === tt._in || this$1.options.ecmaVersion >= 6 && this$1.isContextual("of"))) {
              this$1.unexpected();
            } else if (decl.id.type != "Identifier" && !(isFor && (this$1.type === tt._in || this$1.isContextual("of")))) {
              this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value");
            } else {
              decl.init = null;
            }
            node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"));
            if (!this$1.eat(tt.comma)) break;
          }
          return node;
        };

        pp$1.parseVarId = function (decl) {
          decl.id = this.parseBindingAtom();
          this.checkLVal(decl.id, true);
        };

        // Parse a function declaration or literal (depending on the
        // `isStatement` parameter).

        pp$1.parseFunction = function (node, isStatement, allowExpressionBody) {
          this.initFunction(node);
          if (this.options.ecmaVersion >= 6) node.generator = this.eat(tt.star);
          var oldInGen = this.inGenerator;
          this.inGenerator = node.generator;
          if (isStatement || this.type === tt.name) node.id = this.parseIdent();
          this.parseFunctionParams(node);
          this.parseFunctionBody(node, allowExpressionBody);
          this.inGenerator = oldInGen;
          return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
        };

        pp$1.parseFunctionParams = function (node) {
          this.expect(tt.parenL);
          node.params = this.parseBindingList(tt.parenR, false, false, true);
        };

        // Parse a class declaration or literal (depending on the
        // `isStatement` parameter).

        pp$1.parseClass = function (node, isStatement) {
          var this$1 = this;

          this.next();
          this.parseClassId(node, isStatement);
          this.parseClassSuper(node);
          var classBody = this.startNode();
          var hadConstructor = false;
          classBody.body = [];
          this.expect(tt.braceL);
          while (!this.eat(tt.braceR)) {
            if (this$1.eat(tt.semi)) continue;
            var method = this$1.startNode();
            var isGenerator = this$1.eat(tt.star);
            var isMaybeStatic = this$1.type === tt.name && this$1.value === "static";
            this$1.parsePropertyName(method);
            method.static = isMaybeStatic && this$1.type !== tt.parenL;
            if (method.static) {
              if (isGenerator) this$1.unexpected();
              isGenerator = this$1.eat(tt.star);
              this$1.parsePropertyName(method);
            }
            method.kind = "method";
            var isGetSet = false;
            if (!method.computed) {
              var key = method.key;
              if (!isGenerator && key.type === "Identifier" && this$1.type !== tt.parenL && (key.name === "get" || key.name === "set")) {
                isGetSet = true;
                method.kind = key.name;
                key = this$1.parsePropertyName(method);
              }
              if (!method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
                if (hadConstructor) this$1.raise(key.start, "Duplicate constructor in the same class");
                if (isGetSet) this$1.raise(key.start, "Constructor can't have get/set modifier");
                if (isGenerator) this$1.raise(key.start, "Constructor can't be a generator");
                method.kind = "constructor";
                hadConstructor = true;
              }
            }
            this$1.parseClassMethod(classBody, method, isGenerator);
            if (isGetSet) {
              var paramCount = method.kind === "get" ? 0 : 1;
              if (method.value.params.length !== paramCount) {
                var start = method.value.start;
                if (method.kind === "get") this$1.raiseRecoverable(start, "getter should have no params");else this$1.raiseRecoverable(start, "setter should have exactly one param");
              }
              if (method.kind === "set" && method.value.params[0].type === "RestElement") this$1.raise(method.value.params[0].start, "Setter cannot use rest params");
            }
          }
          node.body = this.finishNode(classBody, "ClassBody");
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        };

        pp$1.parseClassMethod = function (classBody, method, isGenerator) {
          method.value = this.parseMethod(isGenerator);
          classBody.body.push(this.finishNode(method, "MethodDefinition"));
        };

        pp$1.parseClassId = function (node, isStatement) {
          node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
        };

        pp$1.parseClassSuper = function (node) {
          node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;
        };

        // Parses module export declaration.

        pp$1.parseExport = function (node) {
          var this$1 = this;

          this.next();
          // export * from '...'
          if (this.eat(tt.star)) {
            this.expectContextual("from");
            node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
            this.semicolon();
            return this.finishNode(node, "ExportAllDeclaration");
          }
          if (this.eat(tt._default)) {
            // export default ...
            var parens = this.type == tt.parenL;
            var expr = this.parseMaybeAssign();
            var needsSemi = true;
            if (!parens && (expr.type == "FunctionExpression" || expr.type == "ClassExpression")) {
              needsSemi = false;
              if (expr.id) {
                expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
              }
            }
            node.declaration = expr;
            if (needsSemi) this.semicolon();
            return this.finishNode(node, "ExportDefaultDeclaration");
          }
          // export var|const|let|function|class ...
          if (this.shouldParseExportStatement()) {
            node.declaration = this.parseStatement(true);
            node.specifiers = [];
            node.source = null;
          } else {
            // export { x, y as z } [from '...']
            node.declaration = null;
            node.specifiers = this.parseExportSpecifiers();
            if (this.eatContextual("from")) {
              node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
            } else {
              // check for keywords used as local names
              for (var i = 0; i < node.specifiers.length; i++) {
                if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {
                  this$1.unexpected(node.specifiers[i].local.start);
                }
              }

              node.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(node, "ExportNamedDeclaration");
        };

        pp$1.shouldParseExportStatement = function () {
          return this.type.keyword || this.isLet();
        };

        // Parses a comma-separated list of module exports.

        pp$1.parseExportSpecifiers = function () {
          var this$1 = this;

          var nodes = [],
              first = true;
          // export { x, y as z } [from '...']
          this.expect(tt.braceL);
          while (!this.eat(tt.braceR)) {
            if (!first) {
              this$1.expect(tt.comma);
              if (this$1.afterTrailingComma(tt.braceR)) break;
            } else first = false;

            var node = this$1.startNode();
            node.local = this$1.parseIdent(this$1.type === tt._default);
            node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local;
            nodes.push(this$1.finishNode(node, "ExportSpecifier"));
          }
          return nodes;
        };

        // Parses import declaration.

        pp$1.parseImport = function (node) {
          this.next();
          // import '...'
          if (this.type === tt.string) {
            node.specifiers = empty;
            node.source = this.parseExprAtom();
          } else {
            node.specifiers = this.parseImportSpecifiers();
            this.expectContextual("from");
            node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
          }
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        };

        // Parses a comma-separated list of module imports.

        pp$1.parseImportSpecifiers = function () {
          var this$1 = this;

          var nodes = [],
              first = true;
          if (this.type === tt.name) {
            // import defaultObj, { x, y as z } from '...'
            var node = this.startNode();
            node.local = this.parseIdent();
            this.checkLVal(node.local, true);
            nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
            if (!this.eat(tt.comma)) return nodes;
          }
          if (this.type === tt.star) {
            var node$1 = this.startNode();
            this.next();
            this.expectContextual("as");
            node$1.local = this.parseIdent();
            this.checkLVal(node$1.local, true);
            nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
            return nodes;
          }
          this.expect(tt.braceL);
          while (!this.eat(tt.braceR)) {
            if (!first) {
              this$1.expect(tt.comma);
              if (this$1.afterTrailingComma(tt.braceR)) break;
            } else first = false;

            var node$2 = this$1.startNode();
            node$2.imported = this$1.parseIdent(true);
            if (this$1.eatContextual("as")) {
              node$2.local = this$1.parseIdent();
            } else {
              node$2.local = node$2.imported;
              if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start);
              if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raise(node$2.local.start, "The keyword '" + node$2.local.name + "' is reserved");
            }
            this$1.checkLVal(node$2.local, true);
            nodes.push(this$1.finishNode(node$2, "ImportSpecifier"));
          }
          return nodes;
        };

        var pp$2 = Parser.prototype;

        // Convert existing expression atom to assignable pattern
        // if possible.

        pp$2.toAssignable = function (node, isBinding) {
          var this$1 = this;

          if (this.options.ecmaVersion >= 6 && node) {
            switch (node.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
                break;

              case "ObjectExpression":
                node.type = "ObjectPattern";
                for (var i = 0; i < node.properties.length; i++) {
                  var prop = node.properties[i];
                  if (prop.kind !== "init") this$1.raise(prop.key.start, "Object pattern can't contain getter or setter");
                  this$1.toAssignable(prop.value, isBinding);
                }
                break;

              case "ArrayExpression":
                node.type = "ArrayPattern";
                this.toAssignableList(node.elements, isBinding);
                break;

              case "AssignmentExpression":
                if (node.operator === "=") {
                  node.type = "AssignmentPattern";
                  delete node.operator;
                  // falls through to AssignmentPattern
                } else {
                  this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
                  break;
                }

              case "AssignmentPattern":
                if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value");
                break;

              case "ParenthesizedExpression":
                node.expression = this.toAssignable(node.expression, isBinding);
                break;

              case "MemberExpression":
                if (!isBinding) break;

              default:
                this.raise(node.start, "Assigning to rvalue");
            }
          }
          return node;
        };

        // Convert list of expression atoms to binding list.

        pp$2.toAssignableList = function (exprList, isBinding) {
          var this$1 = this;

          var end = exprList.length;
          if (end) {
            var last = exprList[end - 1];
            if (last && last.type == "RestElement") {
              --end;
            } else if (last && last.type == "SpreadElement") {
              last.type = "RestElement";
              var arg = last.argument;
              this.toAssignable(arg, isBinding);
              if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
              --end;
            }

            if (isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
          }
          for (var i = 0; i < end; i++) {
            var elt = exprList[i];
            if (elt) this$1.toAssignable(elt, isBinding);
          }
          return exprList;
        };

        // Parses spread element.

        pp$2.parseSpread = function (refDestructuringErrors) {
          var node = this.startNode();
          this.next();
          node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          return this.finishNode(node, "SpreadElement");
        };

        pp$2.parseRest = function (allowNonIdent) {
          var node = this.startNode();
          this.next();

          // RestElement inside of a function parameter must be an identifier
          if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected();

          return this.finishNode(node, "RestElement");
        };

        // Parses lvalue (assignable) atom.

        pp$2.parseBindingAtom = function () {
          if (this.options.ecmaVersion < 6) return this.parseIdent();
          switch (this.type) {
            case tt.name:
              return this.parseIdent();

            case tt.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(tt.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern");

            case tt.braceL:
              return this.parseObj(true);

            default:
              this.unexpected();
          }
        };

        pp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
          var this$1 = this;

          var elts = [],
              first = true;
          while (!this.eat(close)) {
            if (first) first = false;else this$1.expect(tt.comma);
            if (allowEmpty && this$1.type === tt.comma) {
              elts.push(null);
            } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
              break;
            } else if (this$1.type === tt.ellipsis) {
              var rest = this$1.parseRest(allowNonIdent);
              this$1.parseBindingListItem(rest);
              elts.push(rest);
              if (this$1.type === tt.comma) this$1.raise(this$1.start, "Comma is not permitted after the rest element");
              this$1.expect(close);
              break;
            } else {
              var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
              this$1.parseBindingListItem(elem);
              elts.push(elem);
            }
          }
          return elts;
        };

        pp$2.parseBindingListItem = function (param) {
          return param;
        };

        // Parses assignment pattern around given atom if possible.

        pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
          left = left || this.parseBindingAtom();
          if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left;
          var node = this.startNodeAt(startPos, startLoc);
          node.left = left;
          node.right = this.parseMaybeAssign();
          return this.finishNode(node, "AssignmentPattern");
        };

        // Verify that a node is an lval — something that can be assigned
        // to.

        pp$2.checkLVal = function (expr, isBinding, checkClashes) {
          var this$1 = this;

          switch (expr.type) {
            case "Identifier":
              if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
              if (checkClashes) {
                if (has(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
                checkClashes[expr.name] = true;
              }
              break;

            case "MemberExpression":
              if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
              break;

            case "ObjectPattern":
              for (var i = 0; i < expr.properties.length; i++) {
                this$1.checkLVal(expr.properties[i].value, isBinding, checkClashes);
              }break;

            case "ArrayPattern":
              for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {
                var elem = expr.elements[i$1];
                if (elem) this$1.checkLVal(elem, isBinding, checkClashes);
              }
              break;

            case "AssignmentPattern":
              this.checkLVal(expr.left, isBinding, checkClashes);
              break;

            case "RestElement":
              this.checkLVal(expr.argument, isBinding, checkClashes);
              break;

            case "ParenthesizedExpression":
              this.checkLVal(expr.expression, isBinding, checkClashes);
              break;

            default:
              this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
          }
        };

        var pp$3 = Parser.prototype;

        // Check if property name clashes with already added.
        // Object/class getters and setters are not allowed to clash —
        // either with each other or with an init property — and in
        // strict mode, init properties are also not allowed to be repeated.

        pp$3.checkPropClash = function (prop, propHash) {
          if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
          var key = prop.key;
          var name;
          switch (key.type) {
            case "Identifier":
              name = key.name;break;
            case "Literal":
              name = String(key.value);break;
            default:
              return;
          }
          var kind = prop.kind;
          if (this.options.ecmaVersion >= 6) {
            if (name === "__proto__" && kind === "init") {
              if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              propHash.proto = true;
            }
            return;
          }
          name = "$" + name;
          var other = propHash[name];
          if (other) {
            var isGetSet = kind !== "init";
            if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raiseRecoverable(key.start, "Redefinition of property");
          } else {
            other = propHash[name] = {
              init: false,
              get: false,
              set: false
            };
          }
          other[kind] = true;
        };

        // ### Expression parsing

        // These nest, from the most general expression type at the top to
        // 'atomic', nondivisible expression types at the bottom. Most of
        // the functions will simply let the function(s) below them parse,
        // and, *if* the syntactic construct they handle is present, wrap
        // the AST node that the inner parser gave them in another node.

        // Parse a full expression. The optional arguments are used to
        // forbid the `in` operator (in for loops initalization expressions)
        // and provide reference for storing '=' operator inside shorthand
        // property assignment in contexts where both object expression
        // and object pattern might appear (so it's possible to raise
        // delayed syntax error at correct position).

        pp$3.parseExpression = function (noIn, refDestructuringErrors) {
          var this$1 = this;

          var startPos = this.start,
              startLoc = this.startLoc;
          var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
          if (this.type === tt.comma) {
            var node = this.startNodeAt(startPos, startLoc);
            node.expressions = [expr];
            while (this.eat(tt.comma)) {
              node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors));
            }return this.finishNode(node, "SequenceExpression");
          }
          return expr;
        };

        // Parse an assignment expression. This includes applications of
        // operators like `+=`.

        pp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
          if (this.inGenerator && this.isContextual("yield")) return this.parseYield();

          var ownDestructuringErrors = false;
          if (!refDestructuringErrors) {
            refDestructuringErrors = new DestructuringErrors();
            ownDestructuringErrors = true;
          }
          var startPos = this.start,
              startLoc = this.startLoc;
          if (this.type == tt.parenL || this.type == tt.name) this.potentialArrowAt = this.start;
          var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
          if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
          if (this.type.isAssign) {
            this.checkPatternErrors(refDestructuringErrors, true);
            if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors);
            var node = this.startNodeAt(startPos, startLoc);
            node.operator = this.value;
            node.left = this.type === tt.eq ? this.toAssignable(left) : left;
            refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly
            this.checkLVal(left);
            this.next();
            node.right = this.parseMaybeAssign(noIn);
            return this.finishNode(node, "AssignmentExpression");
          } else {
            if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
          }
          return left;
        };

        // Parse a ternary conditional (`?:`) operator.

        pp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {
          var startPos = this.start,
              startLoc = this.startLoc;
          var expr = this.parseExprOps(noIn, refDestructuringErrors);
          if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
          if (this.eat(tt.question)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssign();
            this.expect(tt.colon);
            node.alternate = this.parseMaybeAssign(noIn);
            return this.finishNode(node, "ConditionalExpression");
          }
          return expr;
        };

        // Start the precedence parser.

        pp$3.parseExprOps = function (noIn, refDestructuringErrors) {
          var startPos = this.start,
              startLoc = this.startLoc;
          var expr = this.parseMaybeUnary(refDestructuringErrors, false);
          if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
          return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
        };

        // Parse binary operators with the operator precedence parsing
        // algorithm. `left` is the left-hand side of the operator.
        // `minPrec` provides context that allows the function to stop and
        // defer further parser to one of its callers when it encounters an
        // operator that has a lower precedence than the set it is parsing.

        pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
          var prec = this.type.binop;
          if (prec != null && (!noIn || this.type !== tt._in)) {
            if (prec > minPrec) {
              var logical = this.type === tt.logicalOR || this.type === tt.logicalAND;
              var op = this.value;
              this.next();
              var startPos = this.start,
                  startLoc = this.startLoc;
              var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
              var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
              return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
            }
          }
          return left;
        };

        pp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {
          var node = this.startNodeAt(startPos, startLoc);
          node.left = left;
          node.operator = op;
          node.right = right;
          return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
        };

        // Parse unary operators, both prefix and postfix.

        pp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
          var this$1 = this;

          var startPos = this.start,
              startLoc = this.startLoc,
              expr;
          if (this.type.prefix) {
            var node = this.startNode(),
                update = this.type === tt.incDec;
            node.operator = this.value;
            node.prefix = true;
            this.next();
            node.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(refDestructuringErrors, true);
            if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raiseRecoverable(node.start, "Deleting local variable in strict mode");else sawUnary = true;
            expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
          } else {
            expr = this.parseExprSubscripts(refDestructuringErrors);
            if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
            while (this.type.postfix && !this.canInsertSemicolon()) {
              var node$1 = this$1.startNodeAt(startPos, startLoc);
              node$1.operator = this$1.value;
              node$1.prefix = false;
              node$1.argument = expr;
              this$1.checkLVal(expr);
              this$1.next();
              expr = this$1.finishNode(node$1, "UpdateExpression");
            }
          }

          if (!sawUnary && this.eat(tt.starstar)) return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);else return expr;
        };

        // Parse call, dot, and `[]`-subscript expressions.

        pp$3.parseExprSubscripts = function (refDestructuringErrors) {
          var startPos = this.start,
              startLoc = this.startLoc;
          var expr = this.parseExprAtom(refDestructuringErrors);
          var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
          if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
          return this.parseSubscripts(expr, startPos, startLoc);
        };

        pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {
          var this$1 = this;

          for (;;) {
            if (this$1.eat(tt.dot)) {
              var node = this$1.startNodeAt(startPos, startLoc);
              node.object = base;
              node.property = this$1.parseIdent(true);
              node.computed = false;
              base = this$1.finishNode(node, "MemberExpression");
            } else if (this$1.eat(tt.bracketL)) {
              var node$1 = this$1.startNodeAt(startPos, startLoc);
              node$1.object = base;
              node$1.property = this$1.parseExpression();
              node$1.computed = true;
              this$1.expect(tt.bracketR);
              base = this$1.finishNode(node$1, "MemberExpression");
            } else if (!noCalls && this$1.eat(tt.parenL)) {
              var node$2 = this$1.startNodeAt(startPos, startLoc);
              node$2.callee = base;
              node$2.arguments = this$1.parseExprList(tt.parenR, false);
              base = this$1.finishNode(node$2, "CallExpression");
            } else if (this$1.type === tt.backQuote) {
              var node$3 = this$1.startNodeAt(startPos, startLoc);
              node$3.tag = base;
              node$3.quasi = this$1.parseTemplate();
              base = this$1.finishNode(node$3, "TaggedTemplateExpression");
            } else {
              return base;
            }
          }
        };

        // Parse an atomic expression — either a single token that is an
        // expression, an expression started by a keyword like `function` or
        // `new`, or an expression wrapped in punctuation like `()`, `[]`,
        // or `{}`.

        pp$3.parseExprAtom = function (refDestructuringErrors) {
          var node,
              canBeArrow = this.potentialArrowAt == this.start;
          switch (this.type) {
            case tt._super:
              if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");

            case tt._this:
              var type = this.type === tt._this ? "ThisExpression" : "Super";
              node = this.startNode();
              this.next();
              return this.finishNode(node, type);

            case tt.name:
              var startPos = this.start,
                  startLoc = this.startLoc;
              var id = this.parseIdent(this.type !== tt.name);
              if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
              return id;

            case tt.regexp:
              var value = this.value;
              node = this.parseLiteral(value.value);
              node.regex = { pattern: value.pattern, flags: value.flags };
              return node;

            case tt.num:case tt.string:
              return this.parseLiteral(this.value);

            case tt._null:case tt._true:case tt._false:
              node = this.startNode();
              node.value = this.type === tt._null ? null : this.type === tt._true;
              node.raw = this.type.keyword;
              this.next();
              return this.finishNode(node, "Literal");

            case tt.parenL:
              return this.parseParenAndDistinguishExpression(canBeArrow);

            case tt.bracketL:
              node = this.startNode();
              this.next();
              node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors);
              return this.finishNode(node, "ArrayExpression");

            case tt.braceL:
              return this.parseObj(false, refDestructuringErrors);

            case tt._function:
              node = this.startNode();
              this.next();
              return this.parseFunction(node, false);

            case tt._class:
              return this.parseClass(this.startNode(), false);

            case tt._new:
              return this.parseNew();

            case tt.backQuote:
              return this.parseTemplate();

            default:
              this.unexpected();
          }
        };

        pp$3.parseLiteral = function (value) {
          var node = this.startNode();
          node.value = value;
          node.raw = this.input.slice(this.start, this.end);
          this.next();
          return this.finishNode(node, "Literal");
        };

        pp$3.parseParenExpression = function () {
          this.expect(tt.parenL);
          var val = this.parseExpression();
          this.expect(tt.parenR);
          return val;
        };

        pp$3.parseParenAndDistinguishExpression = function (canBeArrow) {
          var this$1 = this;

          var startPos = this.start,
              startLoc = this.startLoc,
              val;
          if (this.options.ecmaVersion >= 6) {
            this.next();

            var innerStartPos = this.start,
                innerStartLoc = this.startLoc;
            var exprList = [],
                first = true;
            var refDestructuringErrors = new DestructuringErrors(),
                spreadStart,
                innerParenStart;
            while (this.type !== tt.parenR) {
              first ? first = false : this$1.expect(tt.comma);
              if (this$1.type === tt.ellipsis) {
                spreadStart = this$1.start;
                exprList.push(this$1.parseParenItem(this$1.parseRest()));
                break;
              } else {
                if (this$1.type === tt.parenL && !innerParenStart) {
                  innerParenStart = this$1.start;
                }
                exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
              }
            }
            var innerEndPos = this.start,
                innerEndLoc = this.startLoc;
            this.expect(tt.parenR);

            if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {
              this.checkPatternErrors(refDestructuringErrors, true);
              if (innerParenStart) this.unexpected(innerParenStart);
              return this.parseParenArrowList(startPos, startLoc, exprList);
            }

            if (!exprList.length) this.unexpected(this.lastTokStart);
            if (spreadStart) this.unexpected(spreadStart);
            this.checkExpressionErrors(refDestructuringErrors, true);

            if (exprList.length > 1) {
              val = this.startNodeAt(innerStartPos, innerStartLoc);
              val.expressions = exprList;
              this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
            } else {
              val = exprList[0];
            }
          } else {
            val = this.parseParenExpression();
          }

          if (this.options.preserveParens) {
            var par = this.startNodeAt(startPos, startLoc);
            par.expression = val;
            return this.finishNode(par, "ParenthesizedExpression");
          } else {
            return val;
          }
        };

        pp$3.parseParenItem = function (item) {
          return item;
        };

        pp$3.parseParenArrowList = function (startPos, startLoc, exprList) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
        };

        // New's precedence is slightly tricky. It must allow its argument to
        // be a `[]` or dot subscript expression, but not a call — at least,
        // not without wrapping it in parentheses. Thus, it uses the noCalls
        // argument to parseSubscripts to prevent it from consuming the
        // argument list.

        var empty$1 = [];

        pp$3.parseNew = function () {
          var node = this.startNode();
          var meta = this.parseIdent(true);
          if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
            node.meta = meta;
            node.property = this.parseIdent(true);
            if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
            if (!this.inFunction) this.raiseRecoverable(node.start, "new.target can only be used in functions");
            return this.finishNode(node, "MetaProperty");
          }
          var startPos = this.start,
              startLoc = this.startLoc;
          node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
          if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false);else node.arguments = empty$1;
          return this.finishNode(node, "NewExpression");
        };

        // Parse template expression.

        pp$3.parseTemplateElement = function () {
          var elem = this.startNode();
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'),
            cooked: this.value
          };
          this.next();
          elem.tail = this.type === tt.backQuote;
          return this.finishNode(elem, "TemplateElement");
        };

        pp$3.parseTemplate = function () {
          var this$1 = this;

          var node = this.startNode();
          this.next();
          node.expressions = [];
          var curElt = this.parseTemplateElement();
          node.quasis = [curElt];
          while (!curElt.tail) {
            this$1.expect(tt.dollarBraceL);
            node.expressions.push(this$1.parseExpression());
            this$1.expect(tt.braceR);
            node.quasis.push(curElt = this$1.parseTemplateElement());
          }
          this.next();
          return this.finishNode(node, "TemplateLiteral");
        };

        // Parse an object literal or binding pattern.

        pp$3.parseObj = function (isPattern, refDestructuringErrors) {
          var this$1 = this;

          var node = this.startNode(),
              first = true,
              propHash = {};
          node.properties = [];
          this.next();
          while (!this.eat(tt.braceR)) {
            if (!first) {
              this$1.expect(tt.comma);
              if (this$1.afterTrailingComma(tt.braceR)) break;
            } else first = false;

            var prop = this$1.startNode(),
                isGenerator,
                startPos,
                startLoc;
            if (this$1.options.ecmaVersion >= 6) {
              prop.method = false;
              prop.shorthand = false;
              if (isPattern || refDestructuringErrors) {
                startPos = this$1.start;
                startLoc = this$1.startLoc;
              }
              if (!isPattern) isGenerator = this$1.eat(tt.star);
            }
            this$1.parsePropertyName(prop);
            this$1.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
            this$1.checkPropClash(prop, propHash);
            node.properties.push(this$1.finishNode(prop, "Property"));
          }
          return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
        };

        pp$3.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
          if (this.eat(tt.colon)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
            prop.kind = "init";
          } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {
            if (isPattern) this.unexpected();
            prop.kind = "init";
            prop.method = true;
            prop.value = this.parseMethod(isGenerator);
          } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type != tt.comma && this.type != tt.braceR) {
            if (isGenerator || isPattern) this.unexpected();
            prop.kind = prop.key.name;
            this.parsePropertyName(prop);
            prop.value = this.parseMethod(false);
            var paramCount = prop.kind === "get" ? 0 : 1;
            if (prop.value.params.length !== paramCount) {
              var start = prop.value.start;
              if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
            }
            if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
            if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) || this.inGenerator && prop.key.name == "yield") this.raiseRecoverable(prop.key.start, "'" + prop.key.name + "' can not be used as shorthand property");
            prop.kind = "init";
            if (isPattern) {
              prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
            } else if (this.type === tt.eq && refDestructuringErrors) {
              if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;
              prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
            } else {
              prop.value = prop.key;
            }
            prop.shorthand = true;
          } else this.unexpected();
        };

        pp$3.parsePropertyName = function (prop) {
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(tt.bracketL)) {
              prop.computed = true;
              prop.key = this.parseMaybeAssign();
              this.expect(tt.bracketR);
              return prop.key;
            } else {
              prop.computed = false;
            }
          }
          return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true);
        };

        // Initialize empty function node.

        pp$3.initFunction = function (node) {
          node.id = null;
          if (this.options.ecmaVersion >= 6) {
            node.generator = false;
            node.expression = false;
          }
        };

        // Parse object or class method.

        pp$3.parseMethod = function (isGenerator) {
          var node = this.startNode(),
              oldInGen = this.inGenerator;
          this.inGenerator = isGenerator;
          this.initFunction(node);
          this.expect(tt.parenL);
          node.params = this.parseBindingList(tt.parenR, false, false);
          if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
          this.parseFunctionBody(node, false);
          this.inGenerator = oldInGen;
          return this.finishNode(node, "FunctionExpression");
        };

        // Parse arrow function expression with given parameters.

        pp$3.parseArrowExpression = function (node, params) {
          var oldInGen = this.inGenerator;
          this.inGenerator = false;
          this.initFunction(node);
          node.params = this.toAssignableList(params, true);
          this.parseFunctionBody(node, true);
          this.inGenerator = oldInGen;
          return this.finishNode(node, "ArrowFunctionExpression");
        };

        // Parse function body and check parameters.

        pp$3.parseFunctionBody = function (node, isArrowFunction) {
          var isExpression = isArrowFunction && this.type !== tt.braceL;

          if (isExpression) {
            node.body = this.parseMaybeAssign();
            node.expression = true;
          } else {
            // Start a new scope with regard to labels and the `inFunction`
            // flag (restore them to their old value afterwards).
            var oldInFunc = this.inFunction,
                oldLabels = this.labels;
            this.inFunction = true;this.labels = [];
            node.body = this.parseBlock(true);
            node.expression = false;
            this.inFunction = oldInFunc;this.labels = oldLabels;
          }

          // If this is a strict mode function, verify that argument names
          // are not repeated, and it does not try to bind the words `eval`
          // or `arguments`.
          var useStrict = !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0]) ? node.body.body[0] : null;
          if (this.strict || useStrict) {
            var oldStrict = this.strict;
            this.strict = true;
            if (node.id) this.checkLVal(node.id, true);
            this.checkParams(node, useStrict);
            this.strict = oldStrict;
          } else if (isArrowFunction) {
            this.checkParams(node, useStrict);
          }
        };

        // Checks function params for various disallowed patterns such as using "eval"
        // or "arguments" and duplicate parameters.

        pp$3.checkParams = function (node, useStrict) {
          var this$1 = this;

          var nameHash = {};
          for (var i = 0; i < node.params.length; i++) {
            if (useStrict && this$1.options.ecmaVersion >= 7 && node.params[i].type !== "Identifier") this$1.raiseRecoverable(useStrict.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            this$1.checkLVal(node.params[i], true, nameHash);
          }
        };

        // Parses a comma-separated list of expressions, and returns them as
        // an array. `close` is the token type that ends the list, and
        // `allowEmpty` can be turned on to allow subsequent commas with
        // nothing in between them to be parsed as `null` (which is needed
        // for array literals).

        pp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
          var this$1 = this;

          var elts = [],
              first = true;
          while (!this.eat(close)) {
            if (!first) {
              this$1.expect(tt.comma);
              if (allowTrailingComma && this$1.afterTrailingComma(close)) break;
            } else first = false;

            var elt;
            if (allowEmpty && this$1.type === tt.comma) elt = null;else if (this$1.type === tt.ellipsis) {
              elt = this$1.parseSpread(refDestructuringErrors);
              if (this$1.type === tt.comma && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
                refDestructuringErrors.trailingComma = this$1.lastTokStart;
              }
            } else elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
            elts.push(elt);
          }
          return elts;
        };

        // Parse the next token as an identifier. If `liberal` is true (used
        // when parsing properties), it will also convert keywords into
        // identifiers.

        pp$3.parseIdent = function (liberal) {
          var node = this.startNode();
          if (liberal && this.options.allowReserved == "never") liberal = false;
          if (this.type === tt.name) {
            if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved");
            if (!liberal && this.inGenerator && this.value === "yield") this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator");
            node.name = this.value;
          } else if (liberal && this.type.keyword) {
            node.name = this.type.keyword;
          } else {
            this.unexpected();
          }
          this.next();
          return this.finishNode(node, "Identifier");
        };

        // Parses yield expression inside generator.

        pp$3.parseYield = function () {
          var node = this.startNode();
          this.next();
          if (this.type == tt.semi || this.canInsertSemicolon() || this.type != tt.star && !this.type.startsExpr) {
            node.delegate = false;
            node.argument = null;
          } else {
            node.delegate = this.eat(tt.star);
            node.argument = this.parseMaybeAssign();
          }
          return this.finishNode(node, "YieldExpression");
        };

        var pp$4 = Parser.prototype;

        // This function is used to raise exceptions on parse errors. It
        // takes an offset integer (into the current `input`) to indicate
        // the location of the error, attaches the position to the end
        // of the error message, and then raises a `SyntaxError` with that
        // message.

        pp$4.raise = function (pos, message) {
          var loc = getLineInfo(this.input, pos);
          message += " (" + loc.line + ":" + loc.column + ")";
          var err = new SyntaxError(message);
          err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
          throw err;
        };

        pp$4.raiseRecoverable = pp$4.raise;

        pp$4.curPosition = function () {
          if (this.options.locations) {
            return new Position(this.curLine, this.pos - this.lineStart);
          }
        };

        var Node = function Node(parser, pos, loc) {
          this.type = "";
          this.start = pos;
          this.end = 0;
          if (parser.options.locations) this.loc = new SourceLocation(parser, loc);
          if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
          if (parser.options.ranges) this.range = [pos, 0];
        };

        // Start an AST node, attaching a start offset.

        var pp$5 = Parser.prototype;

        pp$5.startNode = function () {
          return new Node(this, this.start, this.startLoc);
        };

        pp$5.startNodeAt = function (pos, loc) {
          return new Node(this, pos, loc);
        };

        // Finish an AST node, adding `type` and `end` properties.

        function finishNodeAt(node, type, pos, loc) {
          node.type = type;
          node.end = pos;
          if (this.options.locations) node.loc.end = loc;
          if (this.options.ranges) node.range[1] = pos;
          return node;
        }

        pp$5.finishNode = function (node, type) {
          return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
        };

        // Finish node at given position

        pp$5.finishNodeAt = function (node, type, pos, loc) {
          return finishNodeAt.call(this, node, type, pos, loc);
        };

        var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
          this.token = token;
          this.isExpr = !!isExpr;
          this.preserveSpace = !!preserveSpace;
          this.override = override;
        };

        var types = {
          b_stat: new TokContext("{", false),
          b_expr: new TokContext("{", true),
          b_tmpl: new TokContext("${", true),
          p_stat: new TokContext("(", false),
          p_expr: new TokContext("(", true),
          q_tmpl: new TokContext("`", true, true, function (p) {
            return p.readTmplToken();
          }),
          f_expr: new TokContext("function", true)
        };

        var pp$6 = Parser.prototype;

        pp$6.initialContext = function () {
          return [types.b_stat];
        };

        pp$6.braceIsBlock = function (prevType) {
          if (prevType === tt.colon) {
            var parent = this.curContext();
            if (parent === types.b_stat || parent === types.b_expr) return !parent.isExpr;
          }
          if (prevType === tt._return) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
          if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR) return true;
          if (prevType == tt.braceL) return this.curContext() === types.b_stat;
          return !this.exprAllowed;
        };

        pp$6.updateContext = function (prevType) {
          var update,
              type = this.type;
          if (type.keyword && prevType == tt.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
        };

        // Token-specific context update code

        tt.parenR.updateContext = tt.braceR.updateContext = function () {
          if (this.context.length == 1) {
            this.exprAllowed = true;
            return;
          }
          var out = this.context.pop();
          if (out === types.b_stat && this.curContext() === types.f_expr) {
            this.context.pop();
            this.exprAllowed = false;
          } else if (out === types.b_tmpl) {
            this.exprAllowed = true;
          } else {
            this.exprAllowed = !out.isExpr;
          }
        };

        tt.braceL.updateContext = function (prevType) {
          this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
          this.exprAllowed = true;
        };

        tt.dollarBraceL.updateContext = function () {
          this.context.push(types.b_tmpl);
          this.exprAllowed = true;
        };

        tt.parenL.updateContext = function (prevType) {
          var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while;
          this.context.push(statementParens ? types.p_stat : types.p_expr);
          this.exprAllowed = true;
        };

        tt.incDec.updateContext = function () {
          // tokExprAllowed stays unchanged
        };

        tt._function.updateContext = function (prevType) {
          if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else && !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat)) this.context.push(types.f_expr);
          this.exprAllowed = false;
        };

        tt.backQuote.updateContext = function () {
          if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
          this.exprAllowed = false;
        };

        // Object type used to represent tokens. Note that normally, tokens
        // simply exist as properties on the parser object. This is only
        // used for the onToken callback and the external tokenizer.

        var Token = function Token(p) {
          this.type = p.type;
          this.value = p.value;
          this.start = p.start;
          this.end = p.end;
          if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
          if (p.options.ranges) this.range = [p.start, p.end];
        };

        // ## Tokenizer

        var pp$7 = Parser.prototype;

        // Are we running under Rhino?
        var isRhino = (typeof Packages === 'undefined' ? 'undefined' : _typeof(Packages)) == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";

        // Move to the next token

        pp$7.next = function () {
          if (this.options.onToken) this.options.onToken(new Token(this));

          this.lastTokEnd = this.end;
          this.lastTokStart = this.start;
          this.lastTokEndLoc = this.endLoc;
          this.lastTokStartLoc = this.startLoc;
          this.nextToken();
        };

        pp$7.getToken = function () {
          this.next();
          return new Token(this);
        };

        // If we're in an ES6 environment, make parsers iterable
        if (typeof Symbol !== "undefined") pp$7[Symbol.iterator] = function () {
          var self = this;
          return { next: function next() {
              var token = self.getToken();
              return {
                done: token.type === tt.eof,
                value: token
              };
            } };
        };

        // Toggle strict mode. Re-reads the next number or string to please
        // pedantic tests (`"use strict"; 010;` should fail).

        pp$7.setStrict = function (strict) {
          var this$1 = this;

          this.strict = strict;
          if (this.type !== tt.num && this.type !== tt.string) return;
          this.pos = this.start;
          if (this.options.locations) {
            while (this.pos < this.lineStart) {
              this$1.lineStart = this$1.input.lastIndexOf("\n", this$1.lineStart - 2) + 1;
              --this$1.curLine;
            }
          }
          this.nextToken();
        };

        pp$7.curContext = function () {
          return this.context[this.context.length - 1];
        };

        // Read a single token, updating the parser object's token-related
        // properties.

        pp$7.nextToken = function () {
          var curContext = this.curContext();
          if (!curContext || !curContext.preserveSpace) this.skipSpace();

          this.start = this.pos;
          if (this.options.locations) this.startLoc = this.curPosition();
          if (this.pos >= this.input.length) return this.finishToken(tt.eof);

          if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
        };

        pp$7.readToken = function (code) {
          // Identifier or keyword. '\uXXXX' sequences are allowed in
          // identifiers, so '\' also dispatches to that.
          if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

          return this.getTokenFromCode(code);
        };

        pp$7.fullCharCodeAtPos = function () {
          var code = this.input.charCodeAt(this.pos);
          if (code <= 0xd7ff || code >= 0xe000) return code;
          var next = this.input.charCodeAt(this.pos + 1);
          return (code << 10) + next - 0x35fdc00;
        };

        pp$7.skipBlockComment = function () {
          var this$1 = this;

          var startLoc = this.options.onComment && this.curPosition();
          var start = this.pos,
              end = this.input.indexOf("*/", this.pos += 2);
          if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
          this.pos = end + 2;
          if (this.options.locations) {
            lineBreakG.lastIndex = start;
            var match;
            while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
              ++this$1.curLine;
              this$1.lineStart = match.index + match[0].length;
            }
          }
          if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
        };

        pp$7.skipLineComment = function (startSkip) {
          var this$1 = this;

          var start = this.pos;
          var startLoc = this.options.onComment && this.curPosition();
          var ch = this.input.charCodeAt(this.pos += startSkip);
          while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
            ++this$1.pos;
            ch = this$1.input.charCodeAt(this$1.pos);
          }
          if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
        };

        // Called at the start of the parse and after every token. Skips
        // whitespace and comments, and.

        pp$7.skipSpace = function () {
          var this$1 = this;

          loop: while (this.pos < this.input.length) {
            var ch = this$1.input.charCodeAt(this$1.pos);
            switch (ch) {
              case 32:case 160:
                // ' '
                ++this$1.pos;
                break;
              case 13:
                if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
                  ++this$1.pos;
                }
              case 10:case 8232:case 8233:
                ++this$1.pos;
                if (this$1.options.locations) {
                  ++this$1.curLine;
                  this$1.lineStart = this$1.pos;
                }
                break;
              case 47:
                // '/'
                switch (this$1.input.charCodeAt(this$1.pos + 1)) {
                  case 42:
                    // '*'
                    this$1.skipBlockComment();
                    break;
                  case 47:
                    this$1.skipLineComment(2);
                    break;
                  default:
                    break loop;
                }
                break;
              default:
                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                  ++this$1.pos;
                } else {
                  break loop;
                }
            }
          }
        };

        // Called at the end of every token. Sets `end`, `val`, and
        // maintains `context` and `exprAllowed`, and skips the space after
        // the token, so that the next one's `start` will point at the
        // right position.

        pp$7.finishToken = function (type, val) {
          this.end = this.pos;
          if (this.options.locations) this.endLoc = this.curPosition();
          var prevType = this.type;
          this.type = type;
          this.value = val;

          this.updateContext(prevType);
        };

        // ### Token reading

        // This is the function that is called to fetch the next token. It
        // is somewhat obscure, because it works in character codes rather
        // than characters, and because operator parsing has been inlined
        // into it.
        //
        // All in the name of speed.
        //
        pp$7.readToken_dot = function () {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next >= 48 && next <= 57) return this.readNumber(true);
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
            // 46 = dot '.'
            this.pos += 3;
            return this.finishToken(tt.ellipsis);
          } else {
            ++this.pos;
            return this.finishToken(tt.dot);
          }
        };

        pp$7.readToken_slash = function () {
          // '/'
          var next = this.input.charCodeAt(this.pos + 1);
          if (this.exprAllowed) {
            ++this.pos;return this.readRegexp();
          }
          if (next === 61) return this.finishOp(tt.assign, 2);
          return this.finishOp(tt.slash, 1);
        };

        pp$7.readToken_mult_modulo_exp = function (code) {
          // '%*'
          var next = this.input.charCodeAt(this.pos + 1);
          var size = 1;
          var tokentype = code === 42 ? tt.star : tt.modulo;

          // exponentiation operator ** and **=
          if (this.options.ecmaVersion >= 7 && next === 42) {
            ++size;
            tokentype = tt.starstar;
            next = this.input.charCodeAt(this.pos + 2);
          }

          if (next === 61) return this.finishOp(tt.assign, size + 1);
          return this.finishOp(tokentype, size);
        };

        pp$7.readToken_pipe_amp = function (code) {
          // '|&'
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2);
          if (next === 61) return this.finishOp(tt.assign, 2);
          return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1);
        };

        pp$7.readToken_caret = function () {
          // '^'
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 61) return this.finishOp(tt.assign, 2);
          return this.finishOp(tt.bitwiseXOR, 1);
        };

        pp$7.readToken_plus_min = function (code) {
          // '+-'
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === code) {
            if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
              // A `-->` line comment
              this.skipLineComment(3);
              this.skipSpace();
              return this.nextToken();
            }
            return this.finishOp(tt.incDec, 2);
          }
          if (next === 61) return this.finishOp(tt.assign, 2);
          return this.finishOp(tt.plusMin, 1);
        };

        pp$7.readToken_lt_gt = function (code) {
          // '<>'
          var next = this.input.charCodeAt(this.pos + 1);
          var size = 1;
          if (next === code) {
            size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1);
            return this.finishOp(tt.bitShift, size);
          }
          if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
            if (this.inModule) this.unexpected();
            // `<!--`, an XML-style comment that should be interpreted as a line comment
            this.skipLineComment(4);
            this.skipSpace();
            return this.nextToken();
          }
          if (next === 61) size = 2;
          return this.finishOp(tt.relational, size);
        };

        pp$7.readToken_eq_excl = function (code) {
          // '=!'
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
          if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
            // '=>'
            this.pos += 2;
            return this.finishToken(tt.arrow);
          }
          return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1);
        };

        pp$7.getTokenFromCode = function (code) {
          switch (code) {
            // The interpretation of a dot depends on whether it is followed
            // by a digit or another two dots.
            case 46:
              // '.'
              return this.readToken_dot();

            // Punctuation tokens.
            case 40:
              ++this.pos;return this.finishToken(tt.parenL);
            case 41:
              ++this.pos;return this.finishToken(tt.parenR);
            case 59:
              ++this.pos;return this.finishToken(tt.semi);
            case 44:
              ++this.pos;return this.finishToken(tt.comma);
            case 91:
              ++this.pos;return this.finishToken(tt.bracketL);
            case 93:
              ++this.pos;return this.finishToken(tt.bracketR);
            case 123:
              ++this.pos;return this.finishToken(tt.braceL);
            case 125:
              ++this.pos;return this.finishToken(tt.braceR);
            case 58:
              ++this.pos;return this.finishToken(tt.colon);
            case 63:
              ++this.pos;return this.finishToken(tt.question);

            case 96:
              // '`'
              if (this.options.ecmaVersion < 6) break;
              ++this.pos;
              return this.finishToken(tt.backQuote);

            case 48:
              // '0'
              var next = this.input.charCodeAt(this.pos + 1);
              if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
              if (this.options.ecmaVersion >= 6) {
                if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
                if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
              }
            // Anything else beginning with a digit is an integer, octal
            // number, or float.
            case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
              // 1-9
              return this.readNumber(false);

            // Quotes produce strings.
            case 34:case 39:
              // '"', "'"
              return this.readString(code);

            // Operators are parsed inline in tiny state machines. '=' (61) is
            // often referred to. `finishOp` simply skips the amount of
            // characters it is given as second argument, and returns a token
            // of the type given by its first argument.

            case 47:
              // '/'
              return this.readToken_slash();

            case 37:case 42:
              // '%*'
              return this.readToken_mult_modulo_exp(code);

            case 124:case 38:
              // '|&'
              return this.readToken_pipe_amp(code);

            case 94:
              // '^'
              return this.readToken_caret();

            case 43:case 45:
              // '+-'
              return this.readToken_plus_min(code);

            case 60:case 62:
              // '<>'
              return this.readToken_lt_gt(code);

            case 61:case 33:
              // '=!'
              return this.readToken_eq_excl(code);

            case 126:
              // '~'
              return this.finishOp(tt.prefix, 1);
          }

          this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
        };

        pp$7.finishOp = function (type, size) {
          var str = this.input.slice(this.pos, this.pos + size);
          this.pos += size;
          return this.finishToken(type, str);
        };

        // Parse a regular expression. Some context-awareness is necessary,
        // since a '/' inside a '[]' set does not end the expression.

        function tryCreateRegexp(src, flags, throwErrorAt, parser) {
          try {
            return new RegExp(src, flags);
          } catch (e) {
            if (throwErrorAt !== undefined) {
              if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
              throw e;
            }
          }
        }

        var regexpUnicodeSupport = !!tryCreateRegexp('\uFFFF', "u");

        pp$7.readRegexp = function () {
          var this$1 = this;

          var escaped,
              inClass,
              start = this.pos;
          for (;;) {
            if (this$1.pos >= this$1.input.length) this$1.raise(start, "Unterminated regular expression");
            var ch = this$1.input.charAt(this$1.pos);
            if (lineBreak.test(ch)) this$1.raise(start, "Unterminated regular expression");
            if (!escaped) {
              if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
              escaped = ch === "\\";
            } else escaped = false;
            ++this$1.pos;
          }
          var content = this.input.slice(start, this.pos);
          ++this.pos;
          // Need to use `readWord1` because '\uXXXX' sequences are allowed
          // here (don't ask).
          var mods = this.readWord1();
          var tmp = content,
              tmpFlags = "";
          if (mods) {
            var validFlags = /^[gim]*$/;
            if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;
            if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
            if (mods.indexOf("u") >= 0) {
              if (regexpUnicodeSupport) {
                tmpFlags = "u";
              } else {
                // Replace each astral symbol and every Unicode escape sequence that
                // possibly represents an astral symbol or a paired surrogate with a
                // single ASCII symbol to avoid throwing on regular expressions that
                // are only valid in combination with the `/u` flag.
                // Note: replacing with the ASCII symbol `x` might cause false
                // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
                // perfectly valid pattern that is equivalent to `[a-b]`, but it would
                // be replaced by `[x-b]` which throws an error.
                tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
                  code = Number("0x" + code);
                  if (code > 0x10FFFF) this$1.raise(start + offset + 3, "Code point out of bounds");
                  return "x";
                });
                tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
                tmpFlags = tmpFlags.replace("u", "");
              }
            }
          }
          // Detect invalid regular expressions.
          var value = null;
          // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
          // so don't do detection if we are running under Rhino
          if (!isRhino) {
            tryCreateRegexp(tmp, tmpFlags, start, this);
            // Get a regular expression object for this pattern-flag pair, or `null` in
            // case the current environment doesn't support the flags it uses.
            value = tryCreateRegexp(content, mods);
          }
          return this.finishToken(tt.regexp, { pattern: content, flags: mods, value: value });
        };

        // Read an integer in the given radix. Return null if zero digits
        // were read, the integer value otherwise. When `len` is given, this
        // will return `null` unless the integer has exactly `len` digits.

        pp$7.readInt = function (radix, len) {
          var this$1 = this;

          var start = this.pos,
              total = 0;
          for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
            var code = this$1.input.charCodeAt(this$1.pos),
                val;
            if (code >= 97) val = code - 97 + 10; // a
            else if (code >= 65) val = code - 65 + 10; // A
              else if (code >= 48 && code <= 57) val = code - 48; // 0-9
                else val = Infinity;
            if (val >= radix) break;
            ++this$1.pos;
            total = total * radix + val;
          }
          if (this.pos === start || len != null && this.pos - start !== len) return null;

          return total;
        };

        pp$7.readRadixNumber = function (radix) {
          this.pos += 2; // 0x
          var val = this.readInt(radix);
          if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
          if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
          return this.finishToken(tt.num, val);
        };

        // Read an integer, octal integer, or floating-point number.

        pp$7.readNumber = function (startsWithDot) {
          var start = this.pos,
              isFloat = false,
              octal = this.input.charCodeAt(this.pos) === 48;
          if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
          var next = this.input.charCodeAt(this.pos);
          if (next === 46) {
            // '.'
            ++this.pos;
            this.readInt(10);
            isFloat = true;
            next = this.input.charCodeAt(this.pos);
          }
          if (next === 69 || next === 101) {
            // 'eE'
            next = this.input.charCodeAt(++this.pos);
            if (next === 43 || next === 45) ++this.pos; // '+-'
            if (this.readInt(10) === null) this.raise(start, "Invalid number");
            isFloat = true;
          }
          if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

          var str = this.input.slice(start, this.pos),
              val;
          if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
          return this.finishToken(tt.num, val);
        };

        // Read a string value, interpreting backslash-escapes.

        pp$7.readCodePoint = function () {
          var ch = this.input.charCodeAt(this.pos),
              code;

          if (ch === 123) {
            if (this.options.ecmaVersion < 6) this.unexpected();
            var codePos = ++this.pos;
            code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos);
            ++this.pos;
            if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
          } else {
            code = this.readHexChar(4);
          }
          return code;
        };

        function codePointToString(code) {
          // UTF-16 Decoding
          if (code <= 0xFFFF) return String.fromCharCode(code);
          code -= 0x10000;
          return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
        }

        pp$7.readString = function (quote) {
          var this$1 = this;

          var out = "",
              chunkStart = ++this.pos;
          for (;;) {
            if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, "Unterminated string constant");
            var ch = this$1.input.charCodeAt(this$1.pos);
            if (ch === quote) break;
            if (ch === 92) {
              // '\'
              out += this$1.input.slice(chunkStart, this$1.pos);
              out += this$1.readEscapedChar(false);
              chunkStart = this$1.pos;
            } else {
              if (isNewLine(ch)) this$1.raise(this$1.start, "Unterminated string constant");
              ++this$1.pos;
            }
          }
          out += this.input.slice(chunkStart, this.pos++);
          return this.finishToken(tt.string, out);
        };

        // Reads template string tokens.

        pp$7.readTmplToken = function () {
          var this$1 = this;

          var out = "",
              chunkStart = this.pos;
          for (;;) {
            if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, "Unterminated template");
            var ch = this$1.input.charCodeAt(this$1.pos);
            if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) {
              // '`', '${'
              if (this$1.pos === this$1.start && this$1.type === tt.template) {
                if (ch === 36) {
                  this$1.pos += 2;
                  return this$1.finishToken(tt.dollarBraceL);
                } else {
                  ++this$1.pos;
                  return this$1.finishToken(tt.backQuote);
                }
              }
              out += this$1.input.slice(chunkStart, this$1.pos);
              return this$1.finishToken(tt.template, out);
            }
            if (ch === 92) {
              // '\'
              out += this$1.input.slice(chunkStart, this$1.pos);
              out += this$1.readEscapedChar(true);
              chunkStart = this$1.pos;
            } else if (isNewLine(ch)) {
              out += this$1.input.slice(chunkStart, this$1.pos);
              ++this$1.pos;
              switch (ch) {
                case 13:
                  if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos;
                case 10:
                  out += "\n";
                  break;
                default:
                  out += String.fromCharCode(ch);
                  break;
              }
              if (this$1.options.locations) {
                ++this$1.curLine;
                this$1.lineStart = this$1.pos;
              }
              chunkStart = this$1.pos;
            } else {
              ++this$1.pos;
            }
          }
        };

        // Used to read escaped characters

        pp$7.readEscapedChar = function (inTemplate) {
          var ch = this.input.charCodeAt(++this.pos);
          ++this.pos;
          switch (ch) {
            case 110:
              return "\n"; // 'n' -> '\n'
            case 114:
              return "\r"; // 'r' -> '\r'
            case 120:
              return String.fromCharCode(this.readHexChar(2)); // 'x'
            case 117:
              return codePointToString(this.readCodePoint()); // 'u'
            case 116:
              return "\t"; // 't' -> '\t'
            case 98:
              return "\b"; // 'b' -> '\b'
            case 118:
              return '\x0B'; // 'v' -> '\u000b'
            case 102:
              return "\f"; // 'f' -> '\f'
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
            case 10:
              // ' \n'
              if (this.options.locations) {
                this.lineStart = this.pos;++this.curLine;
              }
              return "";
            default:
              if (ch >= 48 && ch <= 55) {
                var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
                var octal = parseInt(octalStr, 8);
                if (octal > 255) {
                  octalStr = octalStr.slice(0, -1);
                  octal = parseInt(octalStr, 8);
                }
                if (octalStr !== "0" && (this.strict || inTemplate)) {
                  this.raise(this.pos - 2, "Octal literal in strict mode");
                }
                this.pos += octalStr.length - 1;
                return String.fromCharCode(octal);
              }
              return String.fromCharCode(ch);
          }
        };

        // Used to read character escape sequences ('\x', '\u', '\U').

        pp$7.readHexChar = function (len) {
          var codePos = this.pos;
          var n = this.readInt(16, len);
          if (n === null) this.raise(codePos, "Bad character escape sequence");
          return n;
        };

        // Read an identifier, and return it as a string. Sets `this.containsEsc`
        // to whether the word contained a '\u' escape.
        //
        // Incrementally adds only escaped chars, adding other chunks as-is
        // as a micro-optimization.

        pp$7.readWord1 = function () {
          var this$1 = this;

          this.containsEsc = false;
          var word = "",
              first = true,
              chunkStart = this.pos;
          var astral = this.options.ecmaVersion >= 6;
          while (this.pos < this.input.length) {
            var ch = this$1.fullCharCodeAtPos();
            if (isIdentifierChar(ch, astral)) {
              this$1.pos += ch <= 0xffff ? 1 : 2;
            } else if (ch === 92) {
              // "\"
              this$1.containsEsc = true;
              word += this$1.input.slice(chunkStart, this$1.pos);
              var escStart = this$1.pos;
              if (this$1.input.charCodeAt(++this$1.pos) != 117) // "u"
                this$1.raise(this$1.pos, 'Expecting Unicode escape sequence \\uXXXX');
              ++this$1.pos;
              var esc = this$1.readCodePoint();
              if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this$1.raise(escStart, "Invalid Unicode escape");
              word += codePointToString(esc);
              chunkStart = this$1.pos;
            } else {
              break;
            }
            first = false;
          }
          return word + this.input.slice(chunkStart, this.pos);
        };

        // Read an identifier or keyword token. Will check for reserved
        // words when necessary.

        pp$7.readWord = function () {
          var word = this.readWord1();
          var type = tt.name;
          if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = keywordTypes[word];
          return this.finishToken(type, word);
        };

        var version = "3.3.0";

        // The main exported interface (under `self.acorn` when in the
        // browser) is a `parse` function that takes a code string and
        // returns an abstract syntax tree as specified by [Mozilla parser
        // API][api].
        //
        // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

        function parse(input, options) {
          return new Parser(options, input).parse();
        }

        // This function tries to parse a single expression at a given
        // offset in a string. Useful for parsing mixed-language formats
        // that embed JavaScript expressions.

        function parseExpressionAt(input, pos, options) {
          var p = new Parser(options, input, pos);
          p.nextToken();
          return p.parseExpression();
        }

        // Acorn is organized as a tokenizer and a recursive-descent parser.
        // The `tokenizer` export provides an interface to the tokenizer.

        function tokenizer(input, options) {
          return new Parser(options, input);
        }

        exports.version = version;
        exports.parse = parse;
        exports.parseExpressionAt = parseExpressionAt;
        exports.tokenizer = tokenizer;
        exports.Parser = Parser;
        exports.plugins = plugins;
        exports.defaultOptions = defaultOptions;
        exports.Position = Position;
        exports.SourceLocation = SourceLocation;
        exports.getLineInfo = getLineInfo;
        exports.Node = Node;
        exports.TokenType = TokenType;
        exports.tokTypes = tt;
        exports.TokContext = TokContext;
        exports.tokContexts = types;
        exports.isIdentifierChar = isIdentifierChar;
        exports.isIdentifierStart = isIdentifierStart;
        exports.Token = Token;
        exports.isNewLine = isNewLine;
        exports.lineBreak = lineBreak;
        exports.lineBreakG = lineBreakG;

        Object.defineProperty(exports, '__esModule', { value: true });
      });
    });

    var acorn$1 = acorn && (typeof acorn === 'undefined' ? 'undefined' : _typeof(acorn)) === 'object' && 'default' in acorn ? acorn['default'] : acorn;

    var xhtml = __commonjs(function (module) {
      module.exports = {
        quot: '"',
        amp: '&',
        apos: '\'',
        lt: '<',
        gt: '>',
        nbsp: '\xA0',
        iexcl: '\xA1',
        cent: '\xA2',
        pound: '\xA3',
        curren: '\xA4',
        yen: '\xA5',
        brvbar: '\xA6',
        sect: '\xA7',
        uml: '\xA8',
        copy: '\xA9',
        ordf: '\xAA',
        laquo: '\xAB',
        not: '\xAC',
        shy: '\xAD',
        reg: '\xAE',
        macr: '\xAF',
        deg: '\xB0',
        plusmn: '\xB1',
        sup2: '\xB2',
        sup3: '\xB3',
        acute: '\xB4',
        micro: '\xB5',
        para: '\xB6',
        middot: '\xB7',
        cedil: '\xB8',
        sup1: '\xB9',
        ordm: '\xBA',
        raquo: '\xBB',
        frac14: '\xBC',
        frac12: '\xBD',
        frac34: '\xBE',
        iquest: '\xBF',
        Agrave: '\xC0',
        Aacute: '\xC1',
        Acirc: '\xC2',
        Atilde: '\xC3',
        Auml: '\xC4',
        Aring: '\xC5',
        AElig: '\xC6',
        Ccedil: '\xC7',
        Egrave: '\xC8',
        Eacute: '\xC9',
        Ecirc: '\xCA',
        Euml: '\xCB',
        Igrave: '\xCC',
        Iacute: '\xCD',
        Icirc: '\xCE',
        Iuml: '\xCF',
        ETH: '\xD0',
        Ntilde: '\xD1',
        Ograve: '\xD2',
        Oacute: '\xD3',
        Ocirc: '\xD4',
        Otilde: '\xD5',
        Ouml: '\xD6',
        times: '\xD7',
        Oslash: '\xD8',
        Ugrave: '\xD9',
        Uacute: '\xDA',
        Ucirc: '\xDB',
        Uuml: '\xDC',
        Yacute: '\xDD',
        THORN: '\xDE',
        szlig: '\xDF',
        agrave: '\xE0',
        aacute: '\xE1',
        acirc: '\xE2',
        atilde: '\xE3',
        auml: '\xE4',
        aring: '\xE5',
        aelig: '\xE6',
        ccedil: '\xE7',
        egrave: '\xE8',
        eacute: '\xE9',
        ecirc: '\xEA',
        euml: '\xEB',
        igrave: '\xEC',
        iacute: '\xED',
        icirc: '\xEE',
        iuml: '\xEF',
        eth: '\xF0',
        ntilde: '\xF1',
        ograve: '\xF2',
        oacute: '\xF3',
        ocirc: '\xF4',
        otilde: '\xF5',
        ouml: '\xF6',
        divide: '\xF7',
        oslash: '\xF8',
        ugrave: '\xF9',
        uacute: '\xFA',
        ucirc: '\xFB',
        uuml: '\xFC',
        yacute: '\xFD',
        thorn: '\xFE',
        yuml: '\xFF',
        OElig: '\u0152',
        oelig: '\u0153',
        Scaron: '\u0160',
        scaron: '\u0161',
        Yuml: '\u0178',
        fnof: '\u0192',
        circ: '\u02C6',
        tilde: '\u02DC',
        Alpha: '\u0391',
        Beta: '\u0392',
        Gamma: '\u0393',
        Delta: '\u0394',
        Epsilon: '\u0395',
        Zeta: '\u0396',
        Eta: '\u0397',
        Theta: '\u0398',
        Iota: '\u0399',
        Kappa: '\u039A',
        Lambda: '\u039B',
        Mu: '\u039C',
        Nu: '\u039D',
        Xi: '\u039E',
        Omicron: '\u039F',
        Pi: '\u03A0',
        Rho: '\u03A1',
        Sigma: '\u03A3',
        Tau: '\u03A4',
        Upsilon: '\u03A5',
        Phi: '\u03A6',
        Chi: '\u03A7',
        Psi: '\u03A8',
        Omega: '\u03A9',
        alpha: '\u03B1',
        beta: '\u03B2',
        gamma: '\u03B3',
        delta: '\u03B4',
        epsilon: '\u03B5',
        zeta: '\u03B6',
        eta: '\u03B7',
        theta: '\u03B8',
        iota: '\u03B9',
        kappa: '\u03BA',
        lambda: '\u03BB',
        mu: '\u03BC',
        nu: '\u03BD',
        xi: '\u03BE',
        omicron: '\u03BF',
        pi: '\u03C0',
        rho: '\u03C1',
        sigmaf: '\u03C2',
        sigma: '\u03C3',
        tau: '\u03C4',
        upsilon: '\u03C5',
        phi: '\u03C6',
        chi: '\u03C7',
        psi: '\u03C8',
        omega: '\u03C9',
        thetasym: '\u03D1',
        upsih: '\u03D2',
        piv: '\u03D6',
        ensp: '\u2002',
        emsp: '\u2003',
        thinsp: '\u2009',
        zwnj: '\u200C',
        zwj: '\u200D',
        lrm: '\u200E',
        rlm: '\u200F',
        ndash: '\u2013',
        mdash: '\u2014',
        lsquo: '\u2018',
        rsquo: '\u2019',
        sbquo: '\u201A',
        ldquo: '\u201C',
        rdquo: '\u201D',
        bdquo: '\u201E',
        dagger: '\u2020',
        Dagger: '\u2021',
        bull: '\u2022',
        hellip: '\u2026',
        permil: '\u2030',
        prime: '\u2032',
        Prime: '\u2033',
        lsaquo: '\u2039',
        rsaquo: '\u203A',
        oline: '\u203E',
        frasl: '\u2044',
        euro: '\u20AC',
        image: '\u2111',
        weierp: '\u2118',
        real: '\u211C',
        trade: '\u2122',
        alefsym: '\u2135',
        larr: '\u2190',
        uarr: '\u2191',
        rarr: '\u2192',
        darr: '\u2193',
        harr: '\u2194',
        crarr: '\u21B5',
        lArr: '\u21D0',
        uArr: '\u21D1',
        rArr: '\u21D2',
        dArr: '\u21D3',
        hArr: '\u21D4',
        forall: '\u2200',
        part: '\u2202',
        exist: '\u2203',
        empty: '\u2205',
        nabla: '\u2207',
        isin: '\u2208',
        notin: '\u2209',
        ni: '\u220B',
        prod: '\u220F',
        sum: '\u2211',
        minus: '\u2212',
        lowast: '\u2217',
        radic: '\u221A',
        prop: '\u221D',
        infin: '\u221E',
        ang: '\u2220',
        and: '\u2227',
        or: '\u2228',
        cap: '\u2229',
        cup: '\u222A',
        'int': '\u222B',
        there4: '\u2234',
        sim: '\u223C',
        cong: '\u2245',
        asymp: '\u2248',
        ne: '\u2260',
        equiv: '\u2261',
        le: '\u2264',
        ge: '\u2265',
        sub: '\u2282',
        sup: '\u2283',
        nsub: '\u2284',
        sube: '\u2286',
        supe: '\u2287',
        oplus: '\u2295',
        otimes: '\u2297',
        perp: '\u22A5',
        sdot: '\u22C5',
        lceil: '\u2308',
        rceil: '\u2309',
        lfloor: '\u230A',
        rfloor: '\u230B',
        lang: '\u2329',
        rang: '\u232A',
        loz: '\u25CA',
        spades: '\u2660',
        clubs: '\u2663',
        hearts: '\u2665',
        diams: '\u2666'
      };
    });

    var require$$0 = xhtml && (typeof xhtml === 'undefined' ? 'undefined' : _typeof(xhtml)) === 'object' && 'default' in xhtml ? xhtml['default'] : xhtml;

    var inject = __commonjs(function (module) {
      'use strict';

      var XHTMLEntities = require$$0;

      var hexNumber = /^[\da-fA-F]+$/;
      var decimalNumber = /^\d+$/;

      module.exports = function (acorn) {
        var tt = acorn.tokTypes;
        var tc = acorn.tokContexts;

        tc.j_oTag = new acorn.TokContext('<tag', false);
        tc.j_cTag = new acorn.TokContext('</tag', false);
        tc.j_expr = new acorn.TokContext('<tag>...</tag>', true, true);

        tt.jsxName = new acorn.TokenType('jsxName');
        tt.jsxText = new acorn.TokenType('jsxText', { beforeExpr: true });
        tt.jsxTagStart = new acorn.TokenType('jsxTagStart');
        tt.jsxTagEnd = new acorn.TokenType('jsxTagEnd');

        tt.jsxTagStart.updateContext = function () {
          this.context.push(tc.j_expr); // treat as beginning of JSX expression
          this.context.push(tc.j_oTag); // start opening tag context
          this.exprAllowed = false;
        };
        tt.jsxTagEnd.updateContext = function (prevType) {
          var out = this.context.pop();
          if (out === tc.j_oTag && prevType === tt.slash || out === tc.j_cTag) {
            this.context.pop();
            this.exprAllowed = this.curContext() === tc.j_expr;
          } else {
            this.exprAllowed = true;
          }
        };

        var pp = acorn.Parser.prototype;

        // Reads inline JSX contents token.

        pp.jsx_readToken = function () {
          var out = '',
              chunkStart = this.pos;
          for (;;) {
            if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated JSX contents');
            var ch = this.input.charCodeAt(this.pos);

            switch (ch) {
              case 60: // '<'
              case 123:
                // '{'
                if (this.pos === this.start) {
                  if (ch === 60 && this.exprAllowed) {
                    ++this.pos;
                    return this.finishToken(tt.jsxTagStart);
                  }
                  return this.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(tt.jsxText, out);

              case 38:
                // '&'
                out += this.input.slice(chunkStart, this.pos);
                out += this.jsx_readEntity();
                chunkStart = this.pos;
                break;

              default:
                if (acorn.isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.pos);
                  out += this.jsx_readNewLine(true);
                  chunkStart = this.pos;
                } else {
                  ++this.pos;
                }
            }
          }
        };

        pp.jsx_readNewLine = function (normalizeCRLF) {
          var ch = this.input.charCodeAt(this.pos);
          var out;
          ++this.pos;
          if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
            out = normalizeCRLF ? '\n' : '\r\n';
          } else {
            out = String.fromCharCode(ch);
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }

          return out;
        };

        pp.jsx_readString = function (quote) {
          var out = '',
              chunkStart = ++this.pos;
          for (;;) {
            if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated string constant');
            var ch = this.input.charCodeAt(this.pos);
            if (ch === quote) break;
            if (ch === 38) {
              // '&'
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readEntity();
              chunkStart = this.pos;
            } else if (acorn.isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(false);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
          }
          out += this.input.slice(chunkStart, this.pos++);
          return this.finishToken(tt.string, out);
        };

        pp.jsx_readEntity = function () {
          var str = '',
              count = 0,
              entity;
          var ch = this.input[this.pos];
          if (ch !== '&') this.raise(this.pos, 'Entity must start with an ampersand');
          var startPos = ++this.pos;
          while (this.pos < this.input.length && count++ < 10) {
            ch = this.input[this.pos++];
            if (ch === ';') {
              if (str[0] === '#') {
                if (str[1] === 'x') {
                  str = str.substr(2);
                  if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));
                } else {
                  str = str.substr(1);
                  if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));
                }
              } else {
                entity = XHTMLEntities[str];
              }
              break;
            }
            str += ch;
          }
          if (!entity) {
            this.pos = startPos;
            return '&';
          }
          return entity;
        };

        // Read a JSX identifier (valid tag or attribute name).
        //
        // Optimized version since JSX identifiers can't contain
        // escape characters and so can be read as single slice.
        // Also assumes that first character was already checked
        // by isIdentifierStart in readToken.

        pp.jsx_readWord = function () {
          var ch,
              start = this.pos;
          do {
            ch = this.input.charCodeAt(++this.pos);
          } while (acorn.isIdentifierChar(ch) || ch === 45); // '-'
          return this.finishToken(tt.jsxName, this.input.slice(start, this.pos));
        };

        // Transforms JSX element name to string.

        function getQualifiedJSXName(object) {
          if (object.type === 'JSXIdentifier') return object.name;

          if (object.type === 'JSXNamespacedName') return object.namespace.name + ':' + object.name.name;

          if (object.type === 'JSXMemberExpression') return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);
        }

        // Parse next token as JSX identifier

        pp.jsx_parseIdentifier = function () {
          var node = this.startNode();
          if (this.type === tt.jsxName) node.name = this.value;else if (this.type.keyword) node.name = this.type.keyword;else this.unexpected();
          this.next();
          return this.finishNode(node, 'JSXIdentifier');
        };

        // Parse namespaced identifier.

        pp.jsx_parseNamespacedName = function () {
          var startPos = this.start,
              startLoc = this.startLoc;
          var name = this.jsx_parseIdentifier();
          if (!this.options.plugins.jsx.allowNamespaces || !this.eat(tt.colon)) return name;
          var node = this.startNodeAt(startPos, startLoc);
          node.namespace = name;
          node.name = this.jsx_parseIdentifier();
          return this.finishNode(node, 'JSXNamespacedName');
        };

        // Parses element name in any form - namespaced, member
        // or single identifier.

        pp.jsx_parseElementName = function () {
          var startPos = this.start,
              startLoc = this.startLoc;
          var node = this.jsx_parseNamespacedName();
          if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !this.options.plugins.jsx.allowNamespacedObjects) {
            this.unexpected();
          }
          while (this.eat(tt.dot)) {
            var newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node;
            newNode.property = this.jsx_parseIdentifier();
            node = this.finishNode(newNode, 'JSXMemberExpression');
          }
          return node;
        };

        // Parses any type of JSX attribute value.

        pp.jsx_parseAttributeValue = function () {
          switch (this.type) {
            case tt.braceL:
              var node = this.jsx_parseExpressionContainer();
              if (node.expression.type === 'JSXEmptyExpression') this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');
              return node;

            case tt.jsxTagStart:
            case tt.string:
              return this.parseExprAtom();

            default:
              this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');
          }
        };

        // JSXEmptyExpression is unique type since it doesn't actually parse anything,
        // and so it should start at the end of last read token (left brace) and finish
        // at the beginning of the next one (right brace).

        pp.jsx_parseEmptyExpression = function () {
          var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);
        };

        // Parses JSX expression enclosed into curly brackets.


        pp.jsx_parseExpressionContainer = function () {
          var node = this.startNode();
          this.next();
          node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
          this.expect(tt.braceR);
          return this.finishNode(node, 'JSXExpressionContainer');
        };

        // Parses following JSX attribute name-value pair.

        pp.jsx_parseAttribute = function () {
          var node = this.startNode();
          if (this.eat(tt.braceL)) {
            this.expect(tt.ellipsis);
            node.argument = this.parseMaybeAssign();
            this.expect(tt.braceR);
            return this.finishNode(node, 'JSXSpreadAttribute');
          }
          node.name = this.jsx_parseNamespacedName();
          node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
          return this.finishNode(node, 'JSXAttribute');
        };

        // Parses JSX opening tag starting after '<'.

        pp.jsx_parseOpeningElementAt = function (startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);
          node.attributes = [];
          node.name = this.jsx_parseElementName();
          while (this.type !== tt.slash && this.type !== tt.jsxTagEnd) {
            node.attributes.push(this.jsx_parseAttribute());
          }node.selfClosing = this.eat(tt.slash);
          this.expect(tt.jsxTagEnd);
          return this.finishNode(node, 'JSXOpeningElement');
        };

        // Parses JSX closing tag starting after '</'.

        pp.jsx_parseClosingElementAt = function (startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);
          node.name = this.jsx_parseElementName();
          this.expect(tt.jsxTagEnd);
          return this.finishNode(node, 'JSXClosingElement');
        };

        // Parses entire JSX element, including it's opening tag
        // (starting after '<'), attributes, contents and closing tag.

        pp.jsx_parseElementAt = function (startPos, startLoc) {
          var node = this.startNodeAt(startPos, startLoc);
          var children = [];
          var openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
          var closingElement = null;

          if (!openingElement.selfClosing) {
            contents: for (;;) {
              switch (this.type) {
                case tt.jsxTagStart:
                  startPos = this.start;startLoc = this.startLoc;
                  this.next();
                  if (this.eat(tt.slash)) {
                    closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                    break contents;
                  }
                  children.push(this.jsx_parseElementAt(startPos, startLoc));
                  break;

                case tt.jsxText:
                  children.push(this.parseExprAtom());
                  break;

                case tt.braceL:
                  children.push(this.jsx_parseExpressionContainer());
                  break;

                default:
                  this.unexpected();
              }
            }
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(closingElement.start, 'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');
            }
          }

          node.openingElement = openingElement;
          node.closingElement = closingElement;
          node.children = children;
          if (this.type === tt.relational && this.value === "<") {
            this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
          }
          return this.finishNode(node, 'JSXElement');
        };

        // Parses entire JSX element from current position.

        pp.jsx_parseElement = function () {
          var startPos = this.start,
              startLoc = this.startLoc;
          this.next();
          return this.jsx_parseElementAt(startPos, startLoc);
        };

        acorn.plugins.jsx = function (instance, opts) {
          if (!opts) {
            return;
          }

          if ((typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
            opts = {};
          }

          instance.options.plugins.jsx = {
            allowNamespaces: opts.allowNamespaces !== false,
            allowNamespacedObjects: !!opts.allowNamespacedObjects
          };

          instance.extend('parseExprAtom', function (inner) {
            return function (refShortHandDefaultPos) {
              if (this.type === tt.jsxText) return this.parseLiteral(this.value);else if (this.type === tt.jsxTagStart) return this.jsx_parseElement();else return inner.call(this, refShortHandDefaultPos);
            };
          });

          instance.extend('readToken', function (inner) {
            return function (code) {
              var context = this.curContext();

              if (context === tc.j_expr) return this.jsx_readToken();

              if (context === tc.j_oTag || context === tc.j_cTag) {
                if (acorn.isIdentifierStart(code)) return this.jsx_readWord();

                if (code == 62) {
                  ++this.pos;
                  return this.finishToken(tt.jsxTagEnd);
                }

                if ((code === 34 || code === 39) && context == tc.j_oTag) return this.jsx_readString(code);
              }

              if (code === 60 && this.exprAllowed) {
                ++this.pos;
                return this.finishToken(tt.jsxTagStart);
              }
              return inner.call(this, code);
            };
          });

          instance.extend('updateContext', function (inner) {
            return function (prevType) {
              if (this.type == tt.braceL) {
                var curContext = this.curContext();
                if (curContext == tc.j_oTag) this.context.push(tc.b_expr);else if (curContext == tc.j_expr) this.context.push(tc.b_tmpl);else inner.call(this, prevType);
                this.exprAllowed = true;
              } else if (this.type === tt.slash && prevType === tt.jsxTagStart) {
                this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
                this.context.push(tc.j_cTag); // reconsider as closing tag context
                this.exprAllowed = false;
              } else {
                return inner.call(this, prevType);
              }
            };
          });
        };

        return acorn;
      };
    });

    var acornJsx = inject && (typeof inject === 'undefined' ? 'undefined' : _typeof(inject)) === 'object' && 'default' in inject ? inject['default'] : inject;

    var inject$1 = __commonjs(function (module) {
      'use strict';

      module.exports = function (acorn) {
        var tt = acorn.tokTypes;
        var pp = acorn.Parser.prototype;

        // this is the same parseObj that acorn has with...
        function parseObj(isPattern, refDestructuringErrors) {
          var this$1 = this;

          var node = this.startNode(),
              first = true,
              propHash = {};
          node.properties = [];
          this.next();
          while (!this$1.eat(tt.braceR)) {
            if (!first) {
              this$1.expect(tt.comma);
              if (this$1.afterTrailingComma(tt.braceR)) break;
            } else first = false;

            var prop = this$1.startNode(),
                isGenerator,
                startPos,
                startLoc;
            if (this$1.options.ecmaVersion >= 6) {
              // ...the spread logic borrowed from babylon :)
              if (this$1.type === tt.ellipsis) {
                prop = this$1.parseSpread();
                prop.type = isPattern ? "RestProperty" : "SpreadProperty";
                node.properties.push(prop);
                continue;
              }

              prop.method = false;
              prop.shorthand = false;
              if (isPattern || refDestructuringErrors) {
                startPos = this$1.start;
                startLoc = this$1.startLoc;
              }
              if (!isPattern) isGenerator = this$1.eat(tt.star);
            }
            this$1.parsePropertyName(prop);
            this$1.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
            this$1.checkPropClash(prop, propHash);
            node.properties.push(this$1.finishNode(prop, "Property"));
          }
          return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
        }

        acorn.plugins.objectSpread = function objectSpreadPlugin(instance) {
          pp.parseObj = parseObj;
        };

        return acorn;
      };
    });

    var acornObjectSpread = inject$1 && (typeof inject$1 === 'undefined' ? 'undefined' : _typeof(inject$1)) === 'object' && 'default' in inject$1 ? inject$1['default'] : inject$1;

    var charToInteger = {};
    var integerToChar = {};

    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('').forEach(function (char, i) {
      charToInteger[char] = i;
      integerToChar[i] = char;
    });

    function encode(value) {
      var result, i;

      if (typeof value === 'number') {
        result = encodeInteger(value);
      } else {
        result = '';
        for (i = 0; i < value.length; i += 1) {
          result += encodeInteger(value[i]);
        }
      }

      return result;
    }

    function encodeInteger(num) {
      var result = '',
          clamped;

      if (num < 0) {
        num = -num << 1 | 1;
      } else {
        num <<= 1;
      }

      do {
        clamped = num & 31;
        num >>= 5;

        if (num > 0) {
          clamped |= 32;
        }

        result += integerToChar[clamped];
      } while (num > 0);

      return result;
    }

    function Chunk(start, end, content) {
      this.start = start;
      this.end = end;
      this.original = content;

      this.intro = '';
      this.outro = '';

      this.content = content;
      this.storeName = false;
      this.edited = false;

      // we make these non-enumerable, for sanity while debugging
      Object.defineProperties(this, {
        previous: { writable: true, value: null },
        next: { writable: true, value: null }
      });
    }

    Chunk.prototype = {
      append: function append(content) {
        this.outro += content;
      },

      clone: function clone() {
        var chunk = new Chunk(this.start, this.end, this.original);

        chunk.intro = this.intro;
        chunk.outro = this.outro;
        chunk.content = this.content;
        chunk.storeName = this.storeName;
        chunk.edited = this.edited;

        return chunk;
      },

      contains: function contains(index) {
        return this.start < index && index < this.end;
      },

      eachNext: function eachNext(fn) {
        var chunk = this;
        while (chunk) {
          fn(chunk);
          chunk = chunk.next;
        }
      },

      eachPrevious: function eachPrevious(fn) {
        var chunk = this;
        while (chunk) {
          fn(chunk);
          chunk = chunk.previous;
        }
      },

      edit: function edit(content, storeName) {
        this.content = content;
        this.storeName = storeName;

        this.edited = true;

        return this;
      },

      prepend: function prepend(content) {
        this.intro = content + this.intro;
      },

      split: function split(index) {
        var sliceIndex = index - this.start;

        var originalBefore = this.original.slice(0, sliceIndex);
        var originalAfter = this.original.slice(sliceIndex);

        this.original = originalBefore;

        var newChunk = new Chunk(index, this.end, originalAfter);
        newChunk.outro = this.outro;
        this.outro = '';

        this.end = index;

        if (this.edited) {
          // TODO is this block necessary?...
          newChunk.edit('', false);
          this.content = '';
        } else {
          this.content = originalBefore;
        }

        newChunk.next = this.next;
        if (newChunk.next) newChunk.next.previous = newChunk;
        newChunk.previous = this;
        this.next = newChunk;

        return newChunk;
      },

      toString: function toString() {
        return this.intro + this.content + this.outro;
      },

      trimEnd: function trimEnd(rx) {
        this.outro = this.outro.replace(rx, '');
        if (this.outro.length) return true;

        var trimmed = this.content.replace(rx, '');

        if (trimmed.length) {
          if (trimmed !== this.content) {
            this.split(this.start + trimmed.length).edit('', false);
          }

          return true;
        } else {
          this.edit('', false);

          this.intro = this.intro.replace(rx, '');
          if (this.intro.length) return true;
        }
      },

      trimStart: function trimStart(rx) {
        this.intro = this.intro.replace(rx, '');
        if (this.intro.length) return true;

        var trimmed = this.content.replace(rx, '');

        if (trimmed.length) {
          if (trimmed !== this.content) {
            this.split(this.end - trimmed.length);
            this.edit('', false);
          }

          return true;
        } else {
          this.edit('', false);

          this.outro = this.outro.replace(rx, '');
          if (this.outro.length) return true;
        }
      }
    };

    var _btoa;

    if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
      _btoa = window.btoa;
    } else if (typeof Buffer === 'function') {
      _btoa = function _btoa(str) {
        return new Buffer(str).toString('base64');
      };
    } else {
      _btoa = function _btoa() {
        throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
      };
    }

    var btoa = _btoa;

    function SourceMap(properties) {
      this.version = 3;

      this.file = properties.file;
      this.sources = properties.sources;
      this.sourcesContent = properties.sourcesContent;
      this.names = properties.names;
      this.mappings = properties.mappings;
    }

    SourceMap.prototype = {
      toString: function toString() {
        return JSON.stringify(this);
      },

      toUrl: function toUrl() {
        return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
      }
    };

    function guessIndent(code) {
      var lines = code.split('\n');

      var tabbed = lines.filter(function (line) {
        return (/^\t+/.test(line)
        );
      });
      var spaced = lines.filter(function (line) {
        return (/^ {2,}/.test(line)
        );
      });

      if (tabbed.length === 0 && spaced.length === 0) {
        return null;
      }

      // More lines tabbed than spaced? Assume tabs, and
      // default to tabs in the case of a tie (or nothing
      // to go on)
      if (tabbed.length >= spaced.length) {
        return '\t';
      }

      // Otherwise, we need to guess the multiple
      var min = spaced.reduce(function (previous, current) {
        var numSpaces = /^ +/.exec(current)[0].length;
        return Math.min(numSpaces, previous);
      }, Infinity);

      return new Array(min + 1).join(' ');
    }

    function getLocator(source) {
      var originalLines = source.split('\n');

      var start = 0;
      var lineRanges = originalLines.map(function (line, i) {
        var end = start + line.length + 1;
        var range = { start: start, end: end, line: i };

        start = end;
        return range;
      });

      var i = 0;

      function rangeContains(range, index) {
        return range.start <= index && index < range.end;
      }

      function getLocation(range, index) {
        return { line: range.line, column: index - range.start };
      }

      return function locate(index) {
        var range = lineRanges[i];

        var d = index >= range.end ? 1 : -1;

        while (range) {
          if (rangeContains(range, index)) return getLocation(range, index);

          i += d;
          range = lineRanges[i];
        }
      };
    }

    function encodeMappings(original, intro, chunk, hires, sourcemapLocations, sourceIndex, offsets, names) {
      var rawLines = [];

      var generatedCodeLine = intro.split('\n').length - 1;
      var rawSegments = rawLines[generatedCodeLine] = [];

      var generatedCodeColumn = 0;

      var locate = getLocator(original);

      function addEdit(content, original, loc, nameIndex, i) {
        if (i || content.length) {
          rawSegments.push({
            generatedCodeLine: generatedCodeLine,
            generatedCodeColumn: generatedCodeColumn,
            sourceCodeLine: loc.line,
            sourceCodeColumn: loc.column,
            sourceCodeName: nameIndex,
            sourceIndex: sourceIndex
          });
        }

        var lines = content.split('\n');
        var lastLine = lines.pop();

        if (lines.length) {
          generatedCodeLine += lines.length;
          rawLines[generatedCodeLine] = rawSegments = [];
          generatedCodeColumn = lastLine.length;
        } else {
          generatedCodeColumn += lastLine.length;
        }

        lines = original.split('\n');
        lastLine = lines.pop();

        if (lines.length) {
          loc.line += lines.length;
          loc.column = lastLine.length;
        } else {
          loc.column += lastLine.length;
        }
      }

      function addUneditedChunk(chunk, loc) {
        var originalCharIndex = chunk.start;
        var first = true;

        while (originalCharIndex < chunk.end) {
          if (hires || first || sourcemapLocations[originalCharIndex]) {
            rawSegments.push({
              generatedCodeLine: generatedCodeLine,
              generatedCodeColumn: generatedCodeColumn,
              sourceCodeLine: loc.line,
              sourceCodeColumn: loc.column,
              sourceCodeName: -1,
              sourceIndex: sourceIndex
            });
          }

          if (original[originalCharIndex] === '\n') {
            loc.line += 1;
            loc.column = 0;
            generatedCodeLine += 1;
            rawLines[generatedCodeLine] = rawSegments = [];
            generatedCodeColumn = 0;
          } else {
            loc.column += 1;
            generatedCodeColumn += 1;
          }

          originalCharIndex += 1;
          first = false;
        }
      }

      while (chunk) {
        var loc = locate(chunk.start);

        if (chunk.intro.length) {
          addEdit(chunk.intro, '', loc, -1, !!chunk.previous);
        }

        if (chunk.edited) {
          addEdit(chunk.content, chunk.original, loc, chunk.storeName ? names.indexOf(chunk.original) : -1, !!chunk.previous);
        } else {
          addUneditedChunk(chunk, loc);
        }

        if (chunk.outro.length) {
          addEdit(chunk.outro, '', loc, -1, !!chunk.previous);
        }

        var nextChunk = chunk.next;
        chunk = nextChunk;
      }

      offsets.sourceIndex = offsets.sourceIndex || 0;
      offsets.sourceCodeLine = offsets.sourceCodeLine || 0;
      offsets.sourceCodeColumn = offsets.sourceCodeColumn || 0;
      offsets.sourceCodeName = offsets.sourceCodeName || 0;

      var encoded = rawLines.map(function (segments) {
        var generatedCodeColumn = 0;

        return segments.map(function (segment) {
          var arr = [segment.generatedCodeColumn - generatedCodeColumn, segment.sourceIndex - offsets.sourceIndex, segment.sourceCodeLine - offsets.sourceCodeLine, segment.sourceCodeColumn - offsets.sourceCodeColumn];

          generatedCodeColumn = segment.generatedCodeColumn;
          offsets.sourceIndex = segment.sourceIndex;
          offsets.sourceCodeLine = segment.sourceCodeLine;
          offsets.sourceCodeColumn = segment.sourceCodeColumn;

          if (~segment.sourceCodeName) {
            arr.push(segment.sourceCodeName - offsets.sourceCodeName);
            offsets.sourceCodeName = segment.sourceCodeName;
          }

          return encode(arr);
        }).join(',');
      }).join(';');

      return encoded;
    }

    function getRelativePath(from, to) {
      var fromParts = from.split(/[\/\\]/);
      var toParts = to.split(/[\/\\]/);

      fromParts.pop(); // get dirname

      while (fromParts[0] === toParts[0]) {
        fromParts.shift();
        toParts.shift();
      }

      if (fromParts.length) {
        var i = fromParts.length;
        while (i--) {
          fromParts[i] = '..';
        }
      }

      return fromParts.concat(toParts).join('/');
    }

    var toString = Object.prototype.toString;

    function isObject(thing) {
      return toString.call(thing) === '[object Object]';
    }

    function MagicString(string, options) {
      if (options === void 0) options = {};

      var chunk = new Chunk(0, string.length, string);

      Object.defineProperties(this, {
        original: { writable: true, value: string },
        outro: { writable: true, value: '' },
        intro: { writable: true, value: '' },
        firstChunk: { writable: true, value: chunk },
        lastChunk: { writable: true, value: chunk },
        lastSearchedChunk: { writable: true, value: chunk },
        byStart: { writable: true, value: {} },
        byEnd: { writable: true, value: {} },
        filename: { writable: true, value: options.filename },
        indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
        sourcemapLocations: { writable: true, value: {} },
        storedNames: { writable: true, value: {} },
        indentStr: { writable: true, value: guessIndent(string) }
      });

      this.byStart[0] = chunk;
      this.byEnd[string.length] = chunk;
    }

    MagicString.prototype = {
      addSourcemapLocation: function addSourcemapLocation(char) {
        this.sourcemapLocations[char] = true;
      },

      append: function append(content) {
        if (typeof content !== 'string') throw new TypeError('outro content must be a string');

        this.outro += content;
        return this;
      },

      clone: function clone() {
        var cloned = new MagicString(this.original, { filename: this.filename });

        var originalChunk = this.firstChunk;
        var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();

        while (originalChunk) {
          cloned.byStart[clonedChunk.start] = clonedChunk;
          cloned.byEnd[clonedChunk.end] = clonedChunk;

          var nextOriginalChunk = originalChunk.next;
          var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

          if (nextClonedChunk) {
            clonedChunk.next = nextClonedChunk;
            nextClonedChunk.previous = clonedChunk;

            clonedChunk = nextClonedChunk;
          }

          originalChunk = nextOriginalChunk;
        }

        cloned.lastChunk = clonedChunk;

        if (this.indentExclusionRanges) {
          cloned.indentExclusionRanges = typeof this.indentExclusionRanges[0] === 'number' ? [this.indentExclusionRanges[0], this.indentExclusionRanges[1]] : this.indentExclusionRanges.map(function (range) {
            return [range.start, range.end];
          });
        }

        Object.keys(this.sourcemapLocations).forEach(function (loc) {
          cloned.sourcemapLocations[loc] = true;
        });

        return cloned;
      },

      generateMap: function generateMap(options) {
        options = options || {};

        var names = Object.keys(this.storedNames);

        var map = new SourceMap({
          file: options.file ? options.file.split(/[\/\\]/).pop() : null,
          sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
          sourcesContent: options.includeContent ? [this.original] : [null],
          names: names,
          mappings: this.getMappings(options.hires, 0, {}, names)
        });
        return map;
      },

      getIndentString: function getIndentString() {
        return this.indentStr === null ? '\t' : this.indentStr;
      },

      getMappings: function getMappings(hires, sourceIndex, offsets, names) {
        return encodeMappings(this.original, this.intro, this.firstChunk, hires, this.sourcemapLocations, sourceIndex, offsets, names);
      },

      indent: function indent(indentStr, options) {
        var this$1 = this;

        var pattern = /^[^\r\n]/gm;

        if (isObject(indentStr)) {
          options = indentStr;
          indentStr = undefined;
        }

        indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';

        if (indentStr === '') return this; // noop

        options = options || {};

        // Process exclusion ranges
        var isExcluded = {};

        if (options.exclude) {
          var exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
          exclusions.forEach(function (exclusion) {
            for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
              isExcluded[i] = true;
            }
          });
        }

        var shouldIndentNextCharacter = options.indentStart !== false;
        var replacer = function replacer(match) {
          if (shouldIndentNextCharacter) return "" + indentStr + match;
          shouldIndentNextCharacter = true;
          return match;
        };

        this.intro = this.intro.replace(pattern, replacer);

        var charIndex = 0;

        var chunk = this.firstChunk;

        while (chunk) {
          var end = chunk.end;

          if (chunk.edited) {
            if (!isExcluded[charIndex]) {
              chunk.content = chunk.content.replace(pattern, replacer);

              if (chunk.content.length) {
                shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
              }
            }
          } else {
            charIndex = chunk.start;

            while (charIndex < end) {
              if (!isExcluded[charIndex]) {
                var char = this$1.original[charIndex];

                if (char === '\n') {
                  shouldIndentNextCharacter = true;
                } else if (char !== '\r' && shouldIndentNextCharacter) {
                  shouldIndentNextCharacter = false;

                  if (charIndex === chunk.start) {
                    chunk.prepend(indentStr);
                  } else {
                    var rhs = chunk.split(charIndex);
                    rhs.prepend(indentStr);

                    this$1.byStart[charIndex] = rhs;
                    this$1.byEnd[charIndex] = chunk;

                    chunk = rhs;
                  }
                }
              }

              charIndex += 1;
            }
          }

          charIndex = chunk.end;
          chunk = chunk.next;
        }

        this.outro = this.outro.replace(pattern, replacer);

        return this;
      },

      insert: function insert() {
        throw new Error('magicString.insert(...) is deprecated. Use insertRight(...) or insertLeft(...)');
      },

      insertLeft: function insertLeft(index, content) {
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

        this._split(index);

        var chunk = this.byEnd[index];

        if (chunk) {
          chunk.append(content);
        } else {
          this.intro += content;
        }

        return this;
      },

      insertRight: function insertRight(index, content) {
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

        this._split(index);

        var chunk = this.byStart[index];

        if (chunk) {
          chunk.prepend(content);
        } else {
          this.outro += content;
        }

        return this;
      },

      move: function move(start, end, index) {
        if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');

        this._split(start);
        this._split(end);
        this._split(index);

        var first = this.byStart[start];
        var last = this.byEnd[end];

        var oldLeft = first.previous;
        var oldRight = last.next;

        var newRight = this.byStart[index];
        if (!newRight && last === this.lastChunk) return this;
        var newLeft = newRight ? newRight.previous : this.lastChunk;

        if (oldLeft) oldLeft.next = oldRight;
        if (oldRight) oldRight.previous = oldLeft;

        if (newLeft) newLeft.next = first;
        if (newRight) newRight.previous = last;

        if (!first.previous) this.firstChunk = last.next;
        if (!last.next) {
          this.lastChunk = first.previous;
          this.lastChunk.next = null;
        }

        first.previous = newLeft;
        last.next = newRight;

        if (!newLeft) this.firstChunk = first;
        if (!newRight) this.lastChunk = last;

        return this;
      },

      overwrite: function overwrite(start, end, content, storeName) {
        var this$1 = this;

        if (typeof content !== 'string') throw new TypeError('replacement content must be a string');

        while (start < 0) {
          start += this$1.original.length;
        }while (end < 0) {
          end += this$1.original.length;
        }if (end > this.original.length) throw new Error('end is out of bounds');
        if (start === end) throw new Error('Cannot overwrite a zero-length range – use insertLeft or insertRight instead');

        this._split(start);
        this._split(end);

        if (storeName) {
          var original = this.original.slice(start, end);
          this.storedNames[original] = true;
        }

        var first = this.byStart[start];
        var last = this.byEnd[end];

        if (first) {
          first.edit(content, storeName);

          if (first !== last) {
            first.outro = '';

            var chunk = first.next;
            while (chunk !== last) {
              chunk.edit('', false);
              chunk.intro = chunk.outro = '';
              chunk = chunk.next;
            }

            chunk.edit('', false);
            chunk.intro = '';
          }
        } else {
          // must be inserting at the end
          var newChunk = new Chunk(start, end, '').edit(content, storeName);

          // TODO last chunk in the array may not be the last chunk, if it's moved...
          last.next = newChunk;
          newChunk.previous = last;
        }

        return this;
      },

      prepend: function prepend(content) {
        if (typeof content !== 'string') throw new TypeError('outro content must be a string');

        this.intro = content + this.intro;
        return this;
      },

      remove: function remove(start, end) {
        var this$1 = this;

        while (start < 0) {
          start += this$1.original.length;
        }while (end < 0) {
          end += this$1.original.length;
        }if (start === end) return this;

        if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
        if (start > end) throw new Error('end must be greater than start');

        return this.overwrite(start, end, '', false);
      },

      slice: function slice(start, end) {
        var this$1 = this;
        if (start === void 0) start = 0;
        if (end === void 0) end = this.original.length;

        while (start < 0) {
          start += this$1.original.length;
        }while (end < 0) {
          end += this$1.original.length;
        }var result = '';

        // find start chunk
        var chunk = this.firstChunk;
        while (chunk && (chunk.start > start || chunk.end <= start)) {

          // found end chunk before start
          if (chunk.start < end && chunk.end >= end) {
            return result;
          }

          chunk = chunk.next;
        }

        if (chunk && chunk.edited && chunk.start !== start) throw new Error("Cannot use replaced character " + start + " as slice start anchor.");

        var startChunk = chunk;
        while (chunk) {
          if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
            result += chunk.intro;
          }

          var containsEnd = chunk.start < end && chunk.end >= end;
          if (containsEnd && chunk.edited && chunk.end !== end) throw new Error("Cannot use replaced character " + end + " as slice end anchor.");

          var sliceStart = startChunk === chunk ? start - chunk.start : 0;
          var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

          result += chunk.content.slice(sliceStart, sliceEnd);

          if (chunk.outro && (!containsEnd || chunk.end === end)) {
            result += chunk.outro;
          }

          if (containsEnd) {
            break;
          }

          chunk = chunk.next;
        }

        return result;
      },

      // TODO deprecate this? not really very useful
      snip: function snip(start, end) {
        var clone = this.clone();
        clone.remove(0, start);
        clone.remove(end, clone.original.length);

        return clone;
      },

      _split: function _split(index) {
        var this$1 = this;

        if (this.byStart[index] || this.byEnd[index]) return;

        var chunk = this.lastSearchedChunk;
        var searchForward = index > chunk.end;

        while (true) {
          if (chunk.contains(index)) return this$1._splitChunk(chunk, index);

          chunk = searchForward ? this$1.byStart[chunk.end] : this$1.byEnd[chunk.start];
        }
      },

      _splitChunk: function _splitChunk(chunk, index) {
        if (chunk.edited && chunk.content.length) {
          // zero-length edited chunks are a special case (overlapping replacements)
          var loc = getLocator(this.original)(index);
          throw new Error("Cannot split a chunk that has already been edited (" + loc.line + ":" + loc.column + " – \"" + chunk.original + "\")");
        }

        var newChunk = chunk.split(index);

        this.byEnd[index] = chunk;
        this.byStart[index] = newChunk;
        this.byEnd[newChunk.end] = newChunk;

        if (chunk === this.lastChunk) this.lastChunk = newChunk;

        this.lastSearchedChunk = chunk;
        return true;
      },

      toString: function toString() {
        var str = this.intro;

        var chunk = this.firstChunk;
        while (chunk) {
          str += chunk.toString();
          chunk = chunk.next;
        }

        return str + this.outro;
      },

      trimLines: function trimLines() {
        return this.trim('[\\r\\n]');
      },

      trim: function trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
      },

      trimEnd: function trimEnd(charType) {
        var this$1 = this;

        var rx = new RegExp((charType || '\\s') + '+$');

        this.outro = this.outro.replace(rx, '');
        if (this.outro.length) return this;

        var chunk = this.lastChunk;

        do {
          var end = chunk.end;
          var aborted = chunk.trimEnd(rx);

          // if chunk was trimmed, we have a new lastChunk
          if (chunk.end !== end) {
            this$1.lastChunk = chunk.next;

            this$1.byEnd[chunk.end] = chunk;
            this$1.byStart[chunk.next.start] = chunk.next;
          }

          if (aborted) return this$1;
          chunk = chunk.previous;
        } while (chunk);

        return this;
      },

      trimStart: function trimStart(charType) {
        var this$1 = this;

        var rx = new RegExp('^' + (charType || '\\s') + '+');

        this.intro = this.intro.replace(rx, '');
        if (this.intro.length) return this;

        var chunk = this.firstChunk;

        do {
          var end = chunk.end;
          var aborted = chunk.trimStart(rx);

          if (chunk.end !== end) {
            // special case...
            if (chunk === this$1.lastChunk) this$1.lastChunk = chunk.next;

            this$1.byEnd[chunk.end] = chunk;
            this$1.byStart[chunk.next.start] = chunk.next;
          }

          if (aborted) return this$1;
          chunk = chunk.next;
        } while (chunk);

        return this;
      }
    };

    var hasOwnProp = Object.prototype.hasOwnProperty;

    function Bundle(options) {
      if (options === void 0) options = {};

      this.intro = options.intro || '';
      this.separator = options.separator !== undefined ? options.separator : '\n';

      this.sources = [];

      this.uniqueSources = [];
      this.uniqueSourceIndexByFilename = {};
    }

    Bundle.prototype = {
      addSource: function addSource(source) {
        if (source instanceof MagicString) {
          return this.addSource({
            content: source,
            filename: source.filename,
            separator: this.separator
          });
        }

        if (!isObject(source) || !source.content) {
          throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');
        }

        ['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {
          if (!hasOwnProp.call(source, option)) source[option] = source.content[option];
        });

        if (source.separator === undefined) {
          // TODO there's a bunch of this sort of thing, needs cleaning up
          source.separator = this.separator;
        }

        if (source.filename) {
          if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
            this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
            this.uniqueSources.push({ filename: source.filename, content: source.content.original });
          } else {
            var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
            if (source.content.original !== uniqueSource.content) {
              throw new Error("Illegal source: same filename (" + source.filename + "), different contents");
            }
          }
        }

        this.sources.push(source);
        return this;
      },

      append: function append(str, options) {
        this.addSource({
          content: new MagicString(str),
          separator: options && options.separator || ''
        });

        return this;
      },

      clone: function clone() {
        var bundle = new Bundle({
          intro: this.intro,
          separator: this.separator
        });

        this.sources.forEach(function (source) {
          bundle.addSource({
            filename: source.filename,
            content: source.content.clone(),
            separator: source.separator
          });
        });

        return bundle;
      },

      generateMap: function generateMap(options) {
        var this$1 = this;

        var offsets = {};

        var names = [];
        this.sources.forEach(function (source) {
          Object.keys(source.content.storedNames).forEach(function (name) {
            if (!~names.indexOf(name)) names.push(name);
          });
        });

        var encoded = getSemis(this.intro) + this.sources.map(function (source, i) {
          var prefix = i > 0 ? getSemis(source.separator) || ',' : '';
          var mappings;

          // we don't bother encoding sources without a filename
          if (!source.filename) {
            mappings = getSemis(source.content.toString());
          } else {
            var sourceIndex = this$1.uniqueSourceIndexByFilename[source.filename];
            mappings = source.content.getMappings(options.hires, sourceIndex, offsets, names);
          }

          return prefix + mappings;
        }).join('');

        return new SourceMap({
          file: options.file ? options.file.split(/[\/\\]/).pop() : null,
          sources: this.uniqueSources.map(function (source) {
            return options.file ? getRelativePath(options.file, source.filename) : source.filename;
          }),
          sourcesContent: this.uniqueSources.map(function (source) {
            return options.includeContent ? source.content : null;
          }),
          names: names,
          mappings: encoded
        });
      },

      getIndentString: function getIndentString() {
        var indentStringCounts = {};

        this.sources.forEach(function (source) {
          var indentStr = source.content.indentStr;

          if (indentStr === null) return;

          if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;
          indentStringCounts[indentStr] += 1;
        });

        return Object.keys(indentStringCounts).sort(function (a, b) {
          return indentStringCounts[a] - indentStringCounts[b];
        })[0] || '\t';
      },

      indent: function indent(indentStr) {
        var this$1 = this;

        if (!arguments.length) {
          indentStr = this.getIndentString();
        }

        if (indentStr === '') return this; // noop

        var trailingNewline = !this.intro || this.intro.slice(-1) === '\n';

        this.sources.forEach(function (source, i) {
          var separator = source.separator !== undefined ? source.separator : this$1.separator;
          var indentStart = trailingNewline || i > 0 && /\r?\n$/.test(separator);

          source.content.indent(indentStr, {
            exclude: source.indentExclusionRanges,
            indentStart: indentStart //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
          });

          // TODO this is a very slow way to determine this
          trailingNewline = source.content.toString().slice(0, -1) === '\n';
        });

        if (this.intro) {
          this.intro = indentStr + this.intro.replace(/^[^\n]/gm, function (match, index) {
            return index > 0 ? indentStr + match : match;
          });
        }

        return this;
      },

      prepend: function prepend(str) {
        this.intro = str + this.intro;
        return this;
      },

      toString: function toString() {
        var this$1 = this;

        var body = this.sources.map(function (source, i) {
          var separator = source.separator !== undefined ? source.separator : this$1.separator;
          var str = (i > 0 ? separator : '') + source.content.toString();

          return str;
        }).join('');

        return this.intro + body;
      },

      trimLines: function trimLines() {
        return this.trim('[\\r\\n]');
      },

      trim: function trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
      },

      trimStart: function trimStart(charType) {
        var this$1 = this;

        var rx = new RegExp('^' + (charType || '\\s') + '+');
        this.intro = this.intro.replace(rx, '');

        if (!this.intro) {
          var source;
          var i = 0;

          do {
            source = this$1.sources[i];

            if (!source) {
              break;
            }

            source.content.trimStart(charType);
            i += 1;
          } while (source.content.toString() === ''); // TODO faster way to determine non-empty source?
        }

        return this;
      },

      trimEnd: function trimEnd(charType) {
        var this$1 = this;

        var rx = new RegExp((charType || '\\s') + '+$');

        var source;
        var i = this.sources.length - 1;

        do {
          source = this$1.sources[i];

          if (!source) {
            this$1.intro = this$1.intro.replace(rx, '');
            break;
          }

          source.content.trimEnd(charType);
          i -= 1;
        } while (source.content.toString() === ''); // TODO faster way to determine non-empty source?

        return this;
      }
    };

    function getSemis(str) {
      return new Array(str.split('\n').length).join(';');
    }

    MagicString.Bundle = Bundle;

    var keys = {
      Program: ['body'],
      Literal: []
    };

    // used for debugging, without the noise created by
    // circular references
    function toJSON(node) {
      var obj = {};

      Object.keys(node).forEach(function (key) {
        if (key === 'parent' || key === 'program' || key === 'keys' || key === '__wrapped') return;

        if (Array.isArray(node[key])) {
          obj[key] = node[key].map(toJSON);
        } else if (node[key] && node[key].toJSON) {
          obj[key] = node[key].toJSON();
        } else {
          obj[key] = node[key];
        }
      });

      return obj;
    }

    var Node = function Node(raw, parent) {
      raw.parent = parent;
      raw.program = parent.program || parent;
      raw.depth = parent.depth + 1;
      raw.keys = keys[raw.type];
      raw.indentation = undefined;

      for (var i = 0, list = keys[raw.type]; i < list.length; i += 1) {
        var key = list[i];

        wrap(raw[key], raw);
      }

      raw.program.magicString.addSourcemapLocation(raw.start);
      raw.program.magicString.addSourcemapLocation(raw.end);
    };

    Node.prototype.ancestor = function ancestor(level) {
      var node = this;
      while (level--) {
        node = node.parent;
        if (!node) return null;
      }

      return node;
    };

    Node.prototype.contains = function contains(node) {
      var this$1 = this;

      while (node) {
        if (node === this$1) return true;
        node = node.parent;
      }

      return false;
    };

    Node.prototype.findLexicalBoundary = function findLexicalBoundary() {
      return this.parent.findLexicalBoundary();
    };

    Node.prototype.findNearest = function findNearest(type) {
      if (typeof type === 'string') type = new RegExp("^" + type + "$");
      if (type.test(this.type)) return this;
      return this.parent.findNearest(type);
    };

    Node.prototype.unparenthesizedParent = function unparenthesizedParent() {
      var node = this.parent;
      while (node && node.type === 'ParenthesizedExpression') {
        node = node.parent;
      }
      return node;
    };

    Node.prototype.unparenthesize = function unparenthesize() {
      var node = this;
      while (node.type === 'ParenthesizedExpression') {
        node = node.expression;
      }
      return node;
    };

    Node.prototype.findScope = function findScope(functionScope) {
      return this.parent.findScope(functionScope);
    };

    Node.prototype.getIndentation = function getIndentation() {
      return this.parent.getIndentation();
    };

    Node.prototype.initialise = function initialise(transforms) {
      for (var i = 0, list = this.keys; i < list.length; i += 1) {
        var key = list[i];

        var value = this[key];

        if (Array.isArray(value)) {
          value.forEach(function (node) {
            return node && node.initialise(transforms);
          });
        } else if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
          value.initialise(transforms);
        }
      }
    };

    Node.prototype.toJSON = function toJSON$1() {
      return toJSON(this);
    };

    Node.prototype.toString = function toString() {
      return this.program.magicString.original.slice(this.start, this.end);
    };

    Node.prototype.transpile = function transpile(code, transforms) {
      for (var i = 0, list = this.keys; i < list.length; i += 1) {
        var key = list[i];

        var value = this[key];

        if (Array.isArray(value)) {
          value.forEach(function (node) {
            return node && node.transpile(code, transforms);
          });
        } else if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
          value.transpile(code, transforms);
        }
      }
    };

    function isArguments(node) {
      return node.type === 'Identifier' && node.name === 'arguments';
    }

    function spread(code, elements, start, argumentsArrayAlias, isNew) {
      var i = elements.length;
      var firstSpreadIndex = -1;

      while (i--) {
        var element$1 = elements[i];
        if (element$1 && element$1.type === 'SpreadElement') {
          if (isArguments(element$1.argument)) {
            code.overwrite(element$1.argument.start, element$1.argument.end, argumentsArrayAlias);
          }

          firstSpreadIndex = i;
        }
      }

      if (firstSpreadIndex === -1) return false; // false indicates no spread elements

      if (isNew) {
        for (i = 0; i < elements.length; i += 1) {
          var element$2 = elements[i];
          if (element$2.type === 'SpreadElement') {
            code.remove(element$2.start, element$2.argument.start);
          } else {
            code.insertRight(element$2.start, '[');
            code.insertRight(element$2.end, ']');
          }
        }

        return true; // true indicates some spread elements
      }

      var element = elements[firstSpreadIndex];
      var previousElement = elements[firstSpreadIndex - 1];

      if (!previousElement) {
        code.remove(start, element.start);
        code.overwrite(element.end, elements[1].start, '.concat( ');
      } else {
        code.overwrite(previousElement.end, element.start, ' ].concat( ');
      }

      for (i = firstSpreadIndex; i < elements.length; i += 1) {
        element = elements[i];

        if (element) {
          if (element.type === 'SpreadElement') {
            code.remove(element.start, element.argument.start);
          } else {
            code.insertLeft(element.start, '[');
            code.insertLeft(element.end, ']');
          }
        }
      }

      return true; // true indicates some spread elements
    }

    var ArrayExpression = function (Node) {
      function ArrayExpression() {
        Node.apply(this, arguments);
      }

      if (Node) ArrayExpression.__proto__ = Node;
      ArrayExpression.prototype = Object.create(Node && Node.prototype);
      ArrayExpression.prototype.constructor = ArrayExpression;

      ArrayExpression.prototype.initialise = function initialise(transforms) {
        var this$1 = this;

        if (transforms.spreadRest && this.elements.length) {
          var lexicalBoundary = this.findLexicalBoundary();

          var i = this.elements.length;
          while (i--) {
            var element = this$1.elements[i];
            if (element && element.type === 'SpreadElement' && isArguments(element.argument)) {
              this$1.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();
            }
          }
        }

        Node.prototype.initialise.call(this, transforms);
      };

      ArrayExpression.prototype.transpile = function transpile(code, transforms) {
        if (transforms.spreadRest) {
          // erase trailing comma after last array element if not an array hole
          if (this.elements.length) {
            var lastElement = this.elements[this.elements.length - 1];
            if (lastElement && /\s*,/.test(code.original.slice(lastElement.end, this.end))) {
              code.overwrite(lastElement.end, this.end - 1, ' ');
            }
          }

          if (this.elements.length === 1) {
            var element = this.elements[0];

            if (element && element.type === 'SpreadElement') {
              // special case – [ ...arguments ]
              if (isArguments(element.argument)) {
                code.overwrite(this.start, this.end, "[].concat( " + this.argumentsArrayAlias + " )"); // TODO if this is the only use of argsArray, don't bother concating
              } else {
                code.overwrite(this.start, element.argument.start, '[].concat( ');
                code.overwrite(element.end, this.end, ' )');
              }
            }
          } else {
            var hasSpreadElements = spread(code, this.elements, this.start, this.argumentsArrayAlias);

            if (hasSpreadElements) {
              code.overwrite(this.end - 1, this.end, ')');
            }
          }
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      return ArrayExpression;
    }(Node);

    var ArrowFunctionExpression = function (Node) {
      function ArrowFunctionExpression() {
        Node.apply(this, arguments);
      }

      if (Node) ArrowFunctionExpression.__proto__ = Node;
      ArrowFunctionExpression.prototype = Object.create(Node && Node.prototype);
      ArrowFunctionExpression.prototype.constructor = ArrowFunctionExpression;

      ArrowFunctionExpression.prototype.initialise = function initialise(transforms) {
        this.body.createScope();
        Node.prototype.initialise.call(this, transforms);
      };

      ArrowFunctionExpression.prototype.transpile = function transpile(code, transforms) {
        if (transforms.arrow) {
          // remove arrow
          var charIndex = this.body.start;
          while (code.original[charIndex] !== '=') {
            charIndex -= 1;
          }
          code.remove(charIndex, this.body.start);

          // wrap naked parameter
          if (this.params.length === 1 && this.start === this.params[0].start) {
            code.insertRight(this.params[0].start, '(');
            code.insertLeft(this.params[0].end, ')');
          }

          // add function
          if (this.parent && this.parent.type === 'ExpressionStatement') {
            // standalone expression statement
            code.insertRight(this.start, '(function');
            code.insertRight(this.end, ')');
          } else {
            code.insertRight(this.start, 'function ');
          }
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      return ArrowFunctionExpression;
    }(Node);

    function locate(source, index) {
      var lines = source.split('\n');
      var len = lines.length;

      var lineStart = 0;
      var i;

      for (i = 0; i < len; i += 1) {
        var line = lines[i];
        var lineEnd = lineStart + line.length + 1; // +1 for newline

        if (lineEnd > index) {
          return { line: i + 1, column: index - lineStart, char: i };
        }

        lineStart = lineEnd;
      }

      throw new Error('Could not determine location of character');
    }

    function pad(num, len) {
      var result = String(num);
      return result + repeat(' ', len - result.length);
    }

    function repeat(str, times) {
      var result = '';
      while (times--) {
        result += str;
      }return result;
    }

    function getSnippet(source, loc, length) {
      if (length === void 0) length = 1;

      var first = Math.max(loc.line - 5, 0);
      var last = loc.line;

      var numDigits = String(last).length;

      var lines = source.split('\n').slice(first, last);

      var lastLine = lines[lines.length - 1];
      var offset = lastLine.slice(0, loc.column).replace(/\t/g, '  ').length;

      var snippet = lines.map(function (line, i) {
        return pad(i + first + 1, numDigits) + " : " + line.replace(/\t/g, '  ');
      }).join('\n');

      snippet += '\n' + repeat(' ', numDigits + 3 + offset) + repeat('^', length);

      return snippet;
    }

    var CompileError = function (Error) {
      function CompileError(node, message) {
        Error.call(this);

        var source = node.program.magicString.original;
        var loc = locate(source, node.start);

        this.name = 'CompileError';
        this.message = message + " (" + loc.line + ":" + loc.column + ")";

        this.stack = new Error().stack.replace(new RegExp(".+new " + this.name + ".+\\n", 'm'), '');

        this.loc = loc;
        this.snippet = getSnippet(source, loc, node.end - node.start);
      }

      if (Error) CompileError.__proto__ = Error;
      CompileError.prototype = Object.create(Error && Error.prototype);
      CompileError.prototype.constructor = CompileError;

      CompileError.prototype.toString = function toString() {
        return this.name + ": " + this.message + "\n" + this.snippet;
      };

      return CompileError;
    }(Error);

    var AssignmentExpression = function (Node) {
      function AssignmentExpression() {
        Node.apply(this, arguments);
      }

      if (Node) AssignmentExpression.__proto__ = Node;
      AssignmentExpression.prototype = Object.create(Node && Node.prototype);
      AssignmentExpression.prototype.constructor = AssignmentExpression;

      AssignmentExpression.prototype.initialise = function initialise(transforms) {
        if (this.left.type === 'Identifier') {
          var declaration = this.findScope(false).findDeclaration(this.left.name);
          if (declaration && declaration.kind === 'const') {
            throw new CompileError(this.left, this.left.name + " is read-only");
          }

          // special case – https://gitlab.com/Rich-Harris/buble/issues/11
          var statement = declaration && declaration.node.ancestor(3);
          if (statement && statement.type === 'ForStatement' && statement.body.contains(this)) {
            statement.reassigned[this.left.name] = true;
          }
        }

        Node.prototype.initialise.call(this, transforms);
      };

      AssignmentExpression.prototype.transpile = function transpile(code, transforms) {
        if (this.operator === '**=' && transforms.exponentiation) {
          this.transpileExponentiation(code, transforms);
        } else if (/Pattern/.test(this.left.type) && transforms.destructuring) {
          this.transpileDestructuring(code, transforms);
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      AssignmentExpression.prototype.transpileDestructuring = function transpileDestructuring(code) {
        var scope = this.findScope(true);
        var assign = scope.createIdentifier('assign');
        var temporaries = [assign];

        var start = this.start;

        // We need to pick out some elements from the original code,
        // interleaved with generated code. These helpers are used to
        // easily do that while keeping the order of the output
        // predictable.
        var text = '';
        function use(node) {
          code.insertRight(node.start, text);
          code.move(node.start, node.end, start);
          text = '';
        }
        function write(string) {
          text += string;
        }

        write("(" + assign + " = ");
        use(this.right);

        // Walk `pattern`, generating code that assigns the value in
        // `ref` to it. When `mayDuplicate` is false, the function
        // must take care to only output `ref` once.
        function destructure(pattern, ref, mayDuplicate) {
          if (pattern.type === 'Identifier' || pattern.type === 'MemberExpression') {
            write(', ');
            use(pattern);
            write(" = " + ref);
          } else if (pattern.type === 'AssignmentPattern') {
            if (pattern.left.type === 'Identifier') {
              var target = pattern.left.name;
              var source = ref;
              if (!mayDuplicate) {
                write(", " + target + " = " + ref);
                source = target;
              }
              write(", " + target + " = " + source + " === void 0 ? ");
              use(pattern.right);
              write(" : " + source);
            } else {
              var target$1 = scope.createIdentifier('temp');
              var source$1 = ref;
              temporaries.push(target$1);
              if (!mayDuplicate) {
                write(", " + target$1 + " = " + ref);
                source$1 = target$1;
              }
              write(", " + target$1 + " = " + source$1 + " === void 0 ? ");
              use(pattern.right);
              write(" : " + source$1);
              destructure(pattern.left, target$1, true);
            }
          } else if (pattern.type === 'ArrayPattern') {
            var elements = pattern.elements;
            if (elements.length === 1) {
              destructure(elements[0], ref + "[0]", false);
            } else {
              if (!mayDuplicate) {
                var temp = scope.createIdentifier('array');
                temporaries.push(temp);
                write(", " + temp + " = " + ref);
                ref = temp;
              }
              elements.forEach(function (element, i) {
                if (element) {
                  if (element.type === 'RestElement') {
                    destructure(element.argument, ref + ".slice(" + i + ")", false);
                  } else {
                    destructure(element, ref + "[" + i + "]", false);
                  }
                }
              });
            }
          } else if (pattern.type === 'ObjectPattern') {
            var props = pattern.properties;
            if (props.length == 1) {
              var prop = props[0];
              var value = prop.computed || prop.key.type !== 'Identifier' ? ref + "[" + code.slice(prop.key.start, prop.key.end) + "]" : ref + "." + prop.key.name;
              destructure(prop.value, value, false);
            } else {
              if (!mayDuplicate) {
                var temp$1 = scope.createIdentifier('obj');
                temporaries.push(temp$1);
                write(", " + temp$1 + " = " + ref);
                ref = temp$1;
              }
              props.forEach(function (prop) {
                var value = prop.computed || prop.key.type !== 'Identifier' ? ref + "[" + code.slice(prop.key.start, prop.key.end) + "]" : ref + "." + prop.key.name;
                destructure(prop.value, value, false);
              });
            }
          } else {
            throw new Error("Unexpected node type in destructuring assignment (" + pattern.type + ")");
          }
        }
        destructure(this.left, assign, true);

        if (this.unparenthesizedParent().type === 'ExpressionStatement') {
          // no rvalue needed for expression statement
          code.insertRight(start, text + ")");
        } else {
          // destructuring is part of an expression - need an rvalue
          code.insertRight(start, text + ", " + assign + ")");
        }

        code.remove(start, this.right.start);

        var statement = this.findNearest(/(?:Statement|Declaration)$/);
        code.insertLeft(statement.start, "var " + temporaries.join(', ') + ";\n" + statement.getIndentation());
      };

      AssignmentExpression.prototype.transpileExponentiation = function transpileExponentiation(code) {
        var scope = this.findScope(false);
        var getAlias = function getAlias(name) {
          var declaration = scope.findDeclaration(name);
          return declaration ? declaration.name : name;
        };

        // first, the easy part – `**=` -> `=`
        var charIndex = this.left.end;
        while (code.original[charIndex] !== '*') {
          charIndex += 1;
        }code.remove(charIndex, charIndex + 2);

        // how we do the next part depends on a number of factors – whether
        // this is a top-level statement, and whether we're updating a
        // simple or complex reference
        var base;

        var left = this.left.unparenthesize();

        if (left.type === 'Identifier') {
          base = getAlias(left.name);
        } else if (left.type === 'MemberExpression') {
          var object;
          var needsObjectVar = false;
          var property;
          var needsPropertyVar = false;

          var statement = this.findNearest(/(?:Statement|Declaration)$/);
          var i0 = statement.getIndentation();

          if (left.property.type === 'Identifier') {
            property = left.computed ? getAlias(left.property.name) : left.property.name;
          } else {
            property = scope.createIdentifier('property');
            needsPropertyVar = true;
          }

          if (left.object.type === 'Identifier') {
            object = getAlias(left.object.name);
          } else {
            object = scope.createIdentifier('object');
            needsObjectVar = true;
          }

          if (left.start === statement.start) {
            if (needsObjectVar && needsPropertyVar) {
              code.insertRight(statement.start, "var " + object + " = ");
              code.overwrite(left.object.end, left.property.start, ";\n" + i0 + "var " + property + " = ");
              code.overwrite(left.property.end, left.end, ";\n" + i0 + object + "[" + property + "]");
            } else if (needsObjectVar) {
              code.insertRight(statement.start, "var " + object + " = ");
              code.insertLeft(left.object.end, ";\n" + i0);
              code.insertLeft(left.object.end, object);
            } else if (needsPropertyVar) {
              code.insertRight(left.property.start, "var " + property + " = ");
              code.insertLeft(left.property.end, ";\n" + i0);
              code.move(left.property.start, left.property.end, this.start);

              code.insertLeft(left.object.end, "[" + property + "]");
              code.remove(left.object.end, left.property.start);
              code.remove(left.property.end, left.end);
            }
          } else {
            var declarators = [];
            if (needsObjectVar) declarators.push(object);
            if (needsPropertyVar) declarators.push(property);

            if (declarators.length) {
              code.insertRight(statement.start, "var " + declarators.join(', ') + ";\n" + i0);
            }

            if (needsObjectVar && needsPropertyVar) {
              code.insertRight(left.start, "( " + object + " = ");
              code.overwrite(left.object.end, left.property.start, ", " + property + " = ");
              code.overwrite(left.property.end, left.end, ", " + object + "[" + property + "]");
            } else if (needsObjectVar) {
              code.insertRight(left.start, "( " + object + " = ");
              code.insertLeft(left.object.end, ", " + object);
            } else if (needsPropertyVar) {
              code.insertRight(left.property.start, "( " + property + " = ");
              code.insertLeft(left.property.end, ", ");
              code.move(left.property.start, left.property.end, left.start);

              code.overwrite(left.object.end, left.property.start, "[" + property + "]");
              code.remove(left.property.end, left.end);
            }

            if (needsPropertyVar) {
              code.insertLeft(this.end, " )");
            }
          }

          base = object + (left.computed || needsPropertyVar ? "[" + property + "]" : "." + property);
        }

        code.insertRight(this.right.start, "Math.pow( " + base + ", ");
        code.insertLeft(this.right.end, " )");
      };

      return AssignmentExpression;
    }(Node);

    var BinaryExpression = function (Node) {
      function BinaryExpression() {
        Node.apply(this, arguments);
      }

      if (Node) BinaryExpression.__proto__ = Node;
      BinaryExpression.prototype = Object.create(Node && Node.prototype);
      BinaryExpression.prototype.constructor = BinaryExpression;

      BinaryExpression.prototype.transpile = function transpile(code, transforms) {
        if (this.operator === '**' && transforms.exponentiation) {
          code.insertRight(this.start, "Math.pow( ");
          code.overwrite(this.left.end, this.right.start, ", ");
          code.insertLeft(this.end, " )");
        }
        Node.prototype.transpile.call(this, code, transforms);
      };

      return BinaryExpression;
    }(Node);

    var loopStatement = /(?:For(?:In|Of)?|While)Statement/;

    var BreakStatement = function (Node) {
      function BreakStatement() {
        Node.apply(this, arguments);
      }

      if (Node) BreakStatement.__proto__ = Node;
      BreakStatement.prototype = Object.create(Node && Node.prototype);
      BreakStatement.prototype.constructor = BreakStatement;

      BreakStatement.prototype.initialise = function initialise() {
        var loop = this.findNearest(loopStatement);
        var switchCase = this.findNearest('SwitchCase');

        if (loop && (!switchCase || loop.depth > switchCase.depth)) {
          loop.canBreak = true;
          this.loop = loop;
        }
      };

      BreakStatement.prototype.transpile = function transpile(code) {
        if (this.loop && this.loop.shouldRewriteAsFunction) {
          if (this.label) throw new CompileError(this, 'Labels are not currently supported in a loop with locally-scoped variables');
          code.overwrite(this.start, this.start + 5, "return 'break'");
        }
      };

      return BreakStatement;
    }(Node);

    var CallExpression = function (Node) {
      function CallExpression() {
        Node.apply(this, arguments);
      }

      if (Node) CallExpression.__proto__ = Node;
      CallExpression.prototype = Object.create(Node && Node.prototype);
      CallExpression.prototype.constructor = CallExpression;

      CallExpression.prototype.initialise = function initialise(transforms) {
        var this$1 = this;

        if (transforms.spreadRest && this.arguments.length > 1) {
          var lexicalBoundary = this.findLexicalBoundary();

          var i = this.arguments.length;
          while (i--) {
            var arg = this$1.arguments[i];
            if (arg.type === 'SpreadElement' && isArguments(arg.argument)) {
              this$1.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();
            }
          }
        }

        Node.prototype.initialise.call(this, transforms);
      };

      CallExpression.prototype.transpile = function transpile(code, transforms) {
        if (transforms.spreadRest && this.arguments.length) {
          var hasSpreadElements = false;
          var context;

          var firstArgument = this.arguments[0];

          if (this.arguments.length === 1) {
            if (firstArgument.type === 'SpreadElement') {
              code.remove(firstArgument.start, firstArgument.argument.start);
              hasSpreadElements = true;
            }
          } else {
            hasSpreadElements = spread(code, this.arguments, firstArgument.start, this.argumentsArrayAlias);
          }

          if (hasSpreadElements) {

            // we need to handle super() and super.method() differently
            // due to its instance
            var _super = null;
            if (this.callee.type === 'Super') {
              _super = this.callee;
            } else if (this.callee.type === 'MemberExpression' && this.callee.object.type === 'Super') {
              _super = this.callee.object;
            }

            if (!_super && this.callee.type === 'MemberExpression') {
              if (this.callee.object.type === 'Identifier') {
                context = this.callee.object.name;
              } else {
                context = this.findScope(true).createIdentifier('ref');
                var callExpression = this.callee.object;
                var enclosure = callExpression.findNearest(/Function/);
                var block = enclosure ? enclosure.body.body : callExpression.findNearest(/^Program$/).body;
                var lastStatementInBlock = block[block.length - 1];
                var i0 = lastStatementInBlock.getIndentation();
                code.insertRight(callExpression.start, "(" + context + " = ");
                code.insertLeft(callExpression.end, ")");
                code.insertLeft(lastStatementInBlock.end, "\n" + i0 + "var " + context + ";");
              }
            } else {
              context = 'void 0';
            }

            code.insertLeft(this.callee.end, '.apply');

            if (_super) {
              _super.noCall = true; // bit hacky...

              if (this.arguments.length > 1) {
                if (firstArgument.type !== 'SpreadElement') {
                  code.insertRight(firstArgument.start, "[ ");
                }

                code.insertLeft(this.arguments[this.arguments.length - 1].end, ' )');
              }
            } else if (this.arguments.length === 1) {
              code.insertRight(firstArgument.start, context + ", ");
            } else {
              if (firstArgument.type === 'SpreadElement') {
                code.insertLeft(firstArgument.start, context + ", ");
              } else {
                code.insertLeft(firstArgument.start, context + ", [ ");
              }

              code.insertLeft(this.arguments[this.arguments.length - 1].end, ' )');
            }
          }
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      return CallExpression;
    }(Node);

    function findIndex(array, fn) {
      for (var i = 0; i < array.length; i += 1) {
        if (fn(array[i], i)) return i;
      }

      return -1;
    }

    var reserved = Object.create(null);
    'do if in for let new try var case else enum eval null this true void with await break catch class const false super throw while yield delete export import public return static switch typeof default extends finally package private continue debugger function arguments interface protected implements instanceof'.split(' ').forEach(function (word) {
      return reserved[word] = true;
    });

    // TODO this code is pretty wild, tidy it up
    var ClassBody = function (Node) {
      function ClassBody() {
        Node.apply(this, arguments);
      }

      if (Node) ClassBody.__proto__ = Node;
      ClassBody.prototype = Object.create(Node && Node.prototype);
      ClassBody.prototype.constructor = ClassBody;

      ClassBody.prototype.transpile = function transpile(code, transforms, inFunctionExpression, superName) {
        var this$1 = this;

        if (transforms.classes) {
          var name = this.parent.name;

          var indentStr = code.getIndentString();
          var i0 = this.getIndentation() + (inFunctionExpression ? indentStr : '');
          var i1 = i0 + indentStr;

          var constructorIndex = findIndex(this.body, function (node) {
            return node.kind === 'constructor';
          });
          var constructor = this.body[constructorIndex];

          var introBlock = '';
          var outroBlock = '';

          if (this.body.length) {
            code.remove(this.start, this.body[0].start);
            code.remove(this.body[this.body.length - 1].end, this.end);
          } else {
            code.remove(this.start, this.end);
          }

          if (constructor) {
            constructor.value.body.isConstructorBody = true;

            var previousMethod = this.body[constructorIndex - 1];
            var nextMethod = this.body[constructorIndex + 1];

            // ensure constructor is first
            if (constructorIndex > 0) {
              code.remove(previousMethod.end, constructor.start);
              code.move(constructor.start, nextMethod ? nextMethod.start : this.end - 1, this.body[0].start);
            }

            if (!inFunctionExpression) code.insertLeft(constructor.end, ';');
          }

          var namedFunctions = this.program.options.namedFunctionExpressions !== false;
          var namedConstructor = namedFunctions || this.parent.superClass || this.parent.type !== 'ClassDeclaration';
          if (this.parent.superClass) {
            var inheritanceBlock = "if ( " + superName + " ) " + name + ".__proto__ = " + superName + ";\n" + i0 + name + ".prototype = Object.create( " + superName + " && " + superName + ".prototype );\n" + i0 + name + ".prototype.constructor = " + name + ";";

            if (constructor) {
              introBlock += "\n\n" + i0 + inheritanceBlock;
            } else {
              var fn = "function " + name + " () {" + (superName ? "\n" + i1 + superName + ".apply(this, arguments);\n" + i0 + "}" : "}") + (inFunctionExpression ? '' : ';') + (this.body.length ? "\n\n" + i0 : '');

              inheritanceBlock = fn + inheritanceBlock;
              introBlock += inheritanceBlock + "\n\n" + i0;
            }
          } else if (!constructor) {
            var fn$1 = 'function ' + (namedConstructor ? name + ' ' : '') + '() {}';
            if (this.parent.type === 'ClassDeclaration') fn$1 += ';';
            if (this.body.length) fn$1 += "\n\n" + i0;

            introBlock += fn$1;
          }

          var scope = this.findScope(false);

          var prototypeGettersAndSetters = [];
          var staticGettersAndSetters = [];
          var prototypeAccessors;
          var staticAccessors;

          this.body.forEach(function (method, i) {
            if (method.kind === 'constructor') {
              var constructorName = namedConstructor ? ' ' + name : '';
              code.overwrite(method.key.start, method.key.end, "function" + constructorName);
              return;
            }

            if (method.static) {
              var len = code.original[method.start + 6] == ' ' ? 7 : 6;
              code.remove(method.start, method.start + len);
            }

            var isAccessor = method.kind !== 'method';
            var lhs;

            var methodName = method.key.name;
            if (reserved[methodName] || method.value.body.scope.references[methodName]) {
              methodName = scope.createIdentifier(methodName);
            }

            // when method name is a string or a number let's pretend it's a computed method

            var fake_computed = false;
            if (!method.computed && method.key.type === 'Literal') {
              fake_computed = true;
              method.computed = true;
            }

            if (isAccessor) {
              if (method.computed) {
                throw new Error('Computed accessor properties are not currently supported');
              }

              code.remove(method.start, method.key.start);

              if (method.static) {
                if (!~staticGettersAndSetters.indexOf(method.key.name)) staticGettersAndSetters.push(method.key.name);
                if (!staticAccessors) staticAccessors = scope.createIdentifier('staticAccessors');

                lhs = "" + staticAccessors;
              } else {
                if (!~prototypeGettersAndSetters.indexOf(method.key.name)) prototypeGettersAndSetters.push(method.key.name);
                if (!prototypeAccessors) prototypeAccessors = scope.createIdentifier('prototypeAccessors');

                lhs = "" + prototypeAccessors;
              }
            } else {
              lhs = method.static ? "" + name : name + ".prototype";
            }

            if (!method.computed) lhs += '.';

            var insertNewlines = constructorIndex > 0 && i === constructorIndex + 1 || i === 0 && constructorIndex === this$1.body.length - 1;

            if (insertNewlines) lhs = "\n\n" + i0 + lhs;

            var c = method.key.end;
            if (method.computed) {
              if (fake_computed) {
                code.insertRight(method.key.start, '[');
                code.insertLeft(method.key.end, ']');
              } else {
                while (code.original[c] !== ']') {
                  c += 1;
                }c += 1;
              }
            }

            code.insertRight(method.start, lhs);

            var funcName = method.computed || isAccessor || !namedFunctions ? '' : methodName + " ";
            var rhs = (isAccessor ? "." + method.kind : '') + " = function" + (method.value.generator ? '* ' : ' ') + funcName;
            code.remove(c, method.value.start);
            code.insertRight(method.value.start, rhs);
            code.insertLeft(method.end, ';');

            if (method.value.generator) code.remove(method.start, method.key.start);
          });

          if (prototypeGettersAndSetters.length || staticGettersAndSetters.length) {
            var intro = [];
            var outro = [];

            if (prototypeGettersAndSetters.length) {
              intro.push("var " + prototypeAccessors + " = { " + prototypeGettersAndSetters.map(function (name) {
                return name + ": {}";
              }).join(',') + " };");
              outro.push("Object.defineProperties( " + name + ".prototype, " + prototypeAccessors + " );");
            }

            if (staticGettersAndSetters.length) {
              intro.push("var " + staticAccessors + " = { " + staticGettersAndSetters.map(function (name) {
                return name + ": {}";
              }).join(',') + " };");
              outro.push("Object.defineProperties( " + name + ", " + staticAccessors + " );");
            }

            if (constructor) introBlock += "\n\n" + i0;
            introBlock += intro.join("\n" + i0);
            if (!constructor) introBlock += "\n\n" + i0;

            outroBlock += "\n\n" + i0 + outro.join("\n" + i0);
          }

          if (constructor) {
            code.insertLeft(constructor.end, introBlock);
          } else {
            code.insertRight(this.start, introBlock);
          }

          code.insertLeft(this.end, outroBlock);
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      return ClassBody;
    }(Node);

    // TODO this function is slightly flawed – it works on the original string,
    // not its current edited state.
    // That's not a problem for the way that it's currently used, but it could
    // be in future...
    function deindent(node, code) {
      var start = node.start;
      var end = node.end;

      var indentStr = code.getIndentString();
      var indentStrLen = indentStr.length;
      var indentStart = start - indentStrLen;

      if (!node.program.indentExclusions[indentStart] && code.original.slice(indentStart, start) === indentStr) {
        code.remove(indentStart, start);
      }

      var pattern = new RegExp(indentStr + '\\S', 'g');
      var slice = code.original.slice(start, end);
      var match;

      while (match = pattern.exec(slice)) {
        var removeStart = start + match.index;
        if (!node.program.indentExclusions[removeStart]) {
          code.remove(removeStart, removeStart + indentStrLen);
        }
      }
    }

    var ClassDeclaration = function (Node) {
      function ClassDeclaration() {
        Node.apply(this, arguments);
      }

      if (Node) ClassDeclaration.__proto__ = Node;
      ClassDeclaration.prototype = Object.create(Node && Node.prototype);
      ClassDeclaration.prototype.constructor = ClassDeclaration;

      ClassDeclaration.prototype.initialise = function initialise(transforms) {
        this.name = this.id.name;
        this.findScope(true).addDeclaration(this.id, 'class');

        Node.prototype.initialise.call(this, transforms);
      };

      ClassDeclaration.prototype.transpile = function transpile(code, transforms) {
        if (transforms.classes) {
          if (!this.superClass) deindent(this.body, code);

          var superName = this.superClass && (this.superClass.name || 'superclass');

          var i0 = this.getIndentation();
          var i1 = i0 + code.getIndentString();

          // if this is an export default statement, we have to move the export to
          // after the declaration, because `export default var Foo = ...` is illegal
          var syntheticDefaultExport = this.parent.type === 'ExportDefaultDeclaration' ? "\n\n" + i0 + "export default " + this.id.name + ";" : '';

          if (syntheticDefaultExport) code.remove(this.parent.start, this.start);

          code.overwrite(this.start, this.id.start, 'var ');

          if (this.superClass) {
            if (this.superClass.end === this.body.start) {
              code.remove(this.id.end, this.superClass.start);
              code.insertLeft(this.id.end, " = (function (" + superName + ") {\n" + i1);
            } else {
              code.overwrite(this.id.end, this.superClass.start, ' = ');
              code.overwrite(this.superClass.end, this.body.start, "(function (" + superName + ") {\n" + i1);
            }
          } else {
            if (this.id.end === this.body.start) {
              code.insertLeft(this.id.end, ' = ');
            } else {
              code.overwrite(this.id.end, this.body.start, ' = ');
            }
          }

          this.body.transpile(code, transforms, !!this.superClass, superName);

          if (this.superClass) {
            code.insertLeft(this.end, "\n\n" + i1 + "return " + this.name + ";\n" + i0 + "}(");
            code.move(this.superClass.start, this.superClass.end, this.end);
            code.insertRight(this.end, "));" + syntheticDefaultExport);
          } else if (syntheticDefaultExport) {
            code.insertRight(this.end, syntheticDefaultExport);
          }
        } else {
          this.body.transpile(code, transforms, false, null);
        }
      };

      return ClassDeclaration;
    }(Node);

    var ClassExpression = function (Node) {
      function ClassExpression() {
        Node.apply(this, arguments);
      }

      if (Node) ClassExpression.__proto__ = Node;
      ClassExpression.prototype = Object.create(Node && Node.prototype);
      ClassExpression.prototype.constructor = ClassExpression;

      ClassExpression.prototype.initialise = function initialise(transforms) {
        this.name = this.id ? this.id.name : this.parent.type === 'VariableDeclarator' ? this.parent.id.name : this.parent.type === 'AssignmentExpression' ? this.parent.left.name : this.findScope(true).createIdentifier('anonymous');

        Node.prototype.initialise.call(this, transforms);
      };

      ClassExpression.prototype.transpile = function transpile(code, transforms) {
        if (transforms.classes) {
          var superName = this.superClass && (this.superClass.name || 'superclass');

          var i0 = this.getIndentation();
          var i1 = i0 + code.getIndentString();

          if (this.superClass) {
            code.remove(this.start, this.superClass.start);
            code.remove(this.superClass.end, this.body.start);
            code.insertLeft(this.start, "(function (" + superName + ") {\n" + i1);
          } else {
            code.overwrite(this.start, this.body.start, "(function () {\n" + i1);
          }

          this.body.transpile(code, transforms, true, superName);

          var outro = "\n\n" + i1 + "return " + this.name + ";\n" + i0 + "}(";

          if (this.superClass) {
            code.insertLeft(this.end, outro);
            code.move(this.superClass.start, this.superClass.end, this.end);
            code.insertRight(this.end, '))');
          } else {
            code.insertLeft(this.end, "\n\n" + i1 + "return " + this.name + ";\n" + i0 + "}())");
          }
        } else {
          this.body.transpile(code, transforms, false);
        }
      };

      return ClassExpression;
    }(Node);

    var ContinueStatement = function (Node) {
      function ContinueStatement() {
        Node.apply(this, arguments);
      }

      if (Node) ContinueStatement.__proto__ = Node;
      ContinueStatement.prototype = Object.create(Node && Node.prototype);
      ContinueStatement.prototype.constructor = ContinueStatement;

      ContinueStatement.prototype.transpile = function transpile(code) {
        var loop = this.findNearest(loopStatement);
        if (loop.shouldRewriteAsFunction) {
          if (this.label) throw new CompileError(this, 'Labels are not currently supported in a loop with locally-scoped variables');
          code.overwrite(this.start, this.start + 8, 'return');
        }
      };

      return ContinueStatement;
    }(Node);

    var ExportDefaultDeclaration = function (Node) {
      function ExportDefaultDeclaration() {
        Node.apply(this, arguments);
      }

      if (Node) ExportDefaultDeclaration.__proto__ = Node;
      ExportDefaultDeclaration.prototype = Object.create(Node && Node.prototype);
      ExportDefaultDeclaration.prototype.constructor = ExportDefaultDeclaration;

      ExportDefaultDeclaration.prototype.initialise = function initialise(transforms) {
        if (transforms.moduleExport) throw new CompileError(this, 'export is not supported');
        Node.prototype.initialise.call(this, transforms);
      };

      return ExportDefaultDeclaration;
    }(Node);

    var ExportNamedDeclaration = function (Node) {
      function ExportNamedDeclaration() {
        Node.apply(this, arguments);
      }

      if (Node) ExportNamedDeclaration.__proto__ = Node;
      ExportNamedDeclaration.prototype = Object.create(Node && Node.prototype);
      ExportNamedDeclaration.prototype.constructor = ExportNamedDeclaration;

      ExportNamedDeclaration.prototype.initialise = function initialise(transforms) {
        if (transforms.moduleExport) throw new CompileError(this, 'export is not supported');
        Node.prototype.initialise.call(this, transforms);
      };

      return ExportNamedDeclaration;
    }(Node);

    var LoopStatement = function (Node) {
      function LoopStatement() {
        Node.apply(this, arguments);
      }

      if (Node) LoopStatement.__proto__ = Node;
      LoopStatement.prototype = Object.create(Node && Node.prototype);
      LoopStatement.prototype.constructor = LoopStatement;

      LoopStatement.prototype.findScope = function findScope(functionScope) {
        return functionScope || !this.createdScope ? this.parent.findScope(functionScope) : this.body.scope;
      };

      LoopStatement.prototype.initialise = function initialise(transforms) {
        var this$1 = this;

        this.body.createScope();
        this.createdScope = true;

        // this is populated as and when reassignments occur
        this.reassigned = Object.create(null);
        this.aliases = Object.create(null);

        Node.prototype.initialise.call(this, transforms);

        if (transforms.letConst) {
          // see if any block-scoped declarations are referenced
          // inside function expressions
          var names = Object.keys(this.body.scope.declarations);

          var i = names.length;
          while (i--) {
            var name = names[i];
            var declaration = this$1.body.scope.declarations[name];

            var j = declaration.instances.length;
            while (j--) {
              var instance = declaration.instances[j];
              var nearestFunctionExpression = instance.findNearest(/Function/);

              if (nearestFunctionExpression && nearestFunctionExpression.depth > this$1.depth) {
                this$1.shouldRewriteAsFunction = true;
                break;
              }
            }

            if (this$1.shouldRewriteAsFunction) break;
          }
        }
      };

      LoopStatement.prototype.transpile = function transpile(code, transforms) {
        var needsBlock = this.type != 'ForOfStatement' && (this.body.type !== 'BlockStatement' || this.body.type === 'BlockStatement' && this.body.synthetic);

        if (this.shouldRewriteAsFunction) {
          var i0 = this.getIndentation();
          var i1 = i0 + code.getIndentString();

          var argString = this.args ? " " + this.args.join(', ') + " " : '';
          var paramString = this.params ? " " + this.params.join(', ') + " " : '';

          var functionScope = this.findScope(true);
          var loop = functionScope.createIdentifier('loop');

          var before = "var " + loop + " = function (" + paramString + ") " + (this.body.synthetic ? "{\n" + i0 + code.getIndentString() : '');
          var after = (this.body.synthetic ? "\n" + i0 + "}" : '') + ";\n\n" + i0;

          code.insertRight(this.body.start, before);
          code.insertLeft(this.body.end, after);
          code.move(this.start, this.body.start, this.body.end);

          if (this.canBreak || this.canReturn) {
            var returned = functionScope.createIdentifier('returned');

            var insert = "{\n" + i1 + "var " + returned + " = " + loop + "(" + argString + ");\n";
            if (this.canBreak) insert += "\n" + i1 + "if ( " + returned + " === 'break' ) break;";
            if (this.canReturn) insert += "\n" + i1 + "if ( " + returned + " ) return " + returned + ".v;";
            insert += "\n" + i0 + "}";

            code.insertRight(this.body.end, insert);
          } else {
            var callExpression = loop + "(" + argString + ");";

            if (this.type === 'DoWhileStatement') {
              code.overwrite(this.start, this.body.start, "do {\n" + i1 + callExpression + "\n" + i0 + "}");
            } else {
              code.insertRight(this.body.end, callExpression);
            }
          }
        } else if (needsBlock) {
          code.insertLeft(this.body.start, '{ ');
          code.insertRight(this.body.end, ' }');
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      return LoopStatement;
    }(Node);

    function extractNames(node) {
      var names = [];
      extractors[node.type](names, node);
      return names;
    }

    var extractors = {
      Identifier: function Identifier(names, node) {
        names.push(node);
      },

      ObjectPattern: function ObjectPattern(names, node) {
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];

          extractors[prop.value.type](names, prop.value);
        }
      },

      ArrayPattern: function ArrayPattern(names, node) {
        for (var i = 0, list = node.elements; i < list.length; i += 1) {
          var element = list[i];

          if (element) extractors[element.type](names, element);
        }
      },

      RestElement: function RestElement(names, node) {
        extractors[node.argument.type](names, node.argument);
      },

      AssignmentPattern: function AssignmentPattern(names, node) {
        extractors[node.left.type](names, node.left);
      }
    };

    var ForStatement = function (LoopStatement) {
      function ForStatement() {
        LoopStatement.apply(this, arguments);
      }

      if (LoopStatement) ForStatement.__proto__ = LoopStatement;
      ForStatement.prototype = Object.create(LoopStatement && LoopStatement.prototype);
      ForStatement.prototype.constructor = ForStatement;

      ForStatement.prototype.findScope = function findScope(functionScope) {
        return functionScope || !this.createdScope ? this.parent.findScope(functionScope) : this.body.scope;
      };

      ForStatement.prototype.transpile = function transpile(code, transforms) {
        var this$1 = this;

        var i1 = this.getIndentation() + code.getIndentString();

        if (this.shouldRewriteAsFunction) {
          // which variables are declared in the init statement?
          var names = this.init.type === 'VariableDeclaration' ? [].concat.apply([], this.init.declarations.map(function (declarator) {
            return extractNames(declarator.id);
          })) : [];

          var aliases = this.aliases;

          this.args = names.map(function (name) {
            return name in this$1.aliases ? this$1.aliases[name].outer : name;
          });
          this.params = names.map(function (name) {
            return name in this$1.aliases ? this$1.aliases[name].inner : name;
          });

          var updates = Object.keys(this.reassigned).map(function (name) {
            return aliases[name].outer + " = " + aliases[name].inner + ";";
          });

          if (updates.length) {
            if (this.body.synthetic) {
              code.insertLeft(this.body.body[0].end, "; " + updates.join(" "));
            } else {
              var lastStatement = this.body.body[this.body.body.length - 1];
              code.insertLeft(lastStatement.end, "\n\n" + i1 + updates.join("\n" + i1));
            }
          }
        }

        LoopStatement.prototype.transpile.call(this, code, transforms);
      };

      return ForStatement;
    }(LoopStatement);

    var ForInStatement = function (LoopStatement) {
      function ForInStatement() {
        LoopStatement.apply(this, arguments);
      }

      if (LoopStatement) ForInStatement.__proto__ = LoopStatement;
      ForInStatement.prototype = Object.create(LoopStatement && LoopStatement.prototype);
      ForInStatement.prototype.constructor = ForInStatement;

      ForInStatement.prototype.findScope = function findScope(functionScope) {
        return functionScope || !this.createdScope ? this.parent.findScope(functionScope) : this.body.scope;
      };

      ForInStatement.prototype.transpile = function transpile(code, transforms) {
        var this$1 = this;

        if (this.shouldRewriteAsFunction) {
          // which variables are declared in the init statement?
          var names = this.left.type === 'VariableDeclaration' ? [].concat.apply([], this.left.declarations.map(function (declarator) {
            return extractNames(declarator.id);
          })) : [];

          this.args = names.map(function (name) {
            return name in this$1.aliases ? this$1.aliases[name].outer : name;
          });
          this.params = names.map(function (name) {
            return name in this$1.aliases ? this$1.aliases[name].inner : name;
          });
        }

        LoopStatement.prototype.transpile.call(this, code, transforms);
      };

      return ForInStatement;
    }(LoopStatement);

    var handlers = {
      Identifier: destructureIdentifier,
      AssignmentPattern: destructureAssignmentPattern,
      ArrayPattern: destructureArrayPattern,
      ObjectPattern: destructureObjectPattern
    };

    function destructure(code, scope, node, ref, inline, statementGenerators) {
      handlers[node.type](code, scope, node, ref, inline, statementGenerators);
    }

    function destructureIdentifier(code, scope, node, ref, inline, statementGenerators) {
      statementGenerators.push(function (start, prefix, suffix) {
        code.insertRight(node.start, inline ? prefix : prefix + "var ");
        code.insertLeft(node.end, " = " + ref + suffix);
        code.move(node.start, node.end, start);
      });
    }

    function destructureAssignmentPattern(code, scope, node, ref, inline, statementGenerators) {
      var isIdentifier = node.left.type === 'Identifier';
      var name = isIdentifier ? node.left.name : ref;

      if (!inline) {
        statementGenerators.push(function (start, prefix, suffix) {
          code.insertRight(node.left.end, prefix + "if ( " + name + " === void 0 ) " + name);
          code.move(node.left.end, node.right.end, start);
          code.insertLeft(node.right.end, suffix);
        });
      }

      if (!isIdentifier) {
        destructure(code, scope, node.left, ref, inline, statementGenerators);
      }
    }

    function destructureArrayPattern(code, scope, node, ref, inline, statementGenerators) {
      var c = node.start;

      node.elements.forEach(function (element, i) {
        if (!element) return;

        if (element.type === 'RestElement') {
          handleProperty(code, scope, c, element.argument, ref + ".slice(" + i + ")", inline, statementGenerators);
        } else {
          handleProperty(code, scope, c, element, ref + "[" + i + "]", inline, statementGenerators);
        }
        c = element.end;
      });

      code.remove(c, node.end);
    }

    function destructureObjectPattern(code, scope, node, ref, inline, statementGenerators) {
      var c = node.start;

      node.properties.forEach(function (prop) {
        var value = prop.computed || prop.key.type !== 'Identifier' ? ref + "[" + code.slice(prop.key.start, prop.key.end) + "]" : ref + "." + prop.key.name;
        handleProperty(code, scope, c, prop.value, value, inline, statementGenerators);
        c = prop.end;
      });

      code.remove(c, node.end);
    }

    function handleProperty(code, scope, c, node, value, inline, statementGenerators) {
      switch (node.type) {
        case 'Identifier':
          {
            code.remove(c, node.start);
            destructureIdentifier(code, scope, node, value, inline, statementGenerators);
            break;
          }

        case 'AssignmentPattern':
          {
            var name;

            var isIdentifier = node.left.type === 'Identifier';

            if (isIdentifier) {
              name = node.left.name;
              var declaration = scope.findDeclaration(name);
              if (declaration) name = declaration.name;
            } else {
              name = scope.createIdentifier(value);
            }

            statementGenerators.push(function (start, prefix, suffix) {
              if (inline) {
                code.insertRight(node.right.start, name + " = " + value + " === undefined ? ");
                code.insertLeft(node.right.end, " : " + value);
              } else {
                code.insertRight(node.right.start, prefix + "var " + name + " = " + value + "; if ( " + name + " === void 0 ) " + name + " = ");
                code.insertLeft(node.right.end, suffix);
              }

              code.move(node.right.start, node.right.end, start);
            });

            if (isIdentifier) {
              code.remove(c, node.right.start);
            } else {
              code.remove(c, node.left.start);
              code.remove(node.left.end, node.right.start);
              handleProperty(code, scope, c, node.left, name, inline, statementGenerators);
            }

            break;
          }

        case 'ObjectPattern':
          {
            code.remove(c, c = node.start);

            if (node.properties.length > 1) {
              var ref = scope.createIdentifier(value);

              statementGenerators.push(function (start, prefix, suffix) {
                // this feels a tiny bit hacky, but we can't do a
                // straightforward insertLeft and keep correct order...
                code.insertRight(node.start, prefix + "var " + ref + " = ");
                code.overwrite(node.start, c = node.start + 1, value);
                code.insertLeft(c, suffix);

                code.move(node.start, c, start);
              });

              node.properties.forEach(function (prop) {
                var value = prop.computed || prop.key.type !== 'Identifier' ? ref + "[" + code.slice(prop.key.start, prop.key.end) + "]" : ref + "." + prop.key.name;
                handleProperty(code, scope, c, prop.value, value, inline, statementGenerators);
                c = prop.end;
              });
            } else {
              var prop = node.properties[0];
              var value_suffix = prop.computed || prop.key.type !== 'Identifier' ? "[" + code.slice(prop.key.start, prop.key.end) + "]" : "." + prop.key.name;
              handleProperty(code, scope, c, prop.value, "" + value + value_suffix, inline, statementGenerators);
              c = prop.end;
            }

            code.remove(c, node.end);
            break;
          }

        case 'ArrayPattern':
          {
            code.remove(c, c = node.start);

            if (node.elements.filter(Boolean).length > 1) {
              var ref$1 = scope.createIdentifier(value);

              statementGenerators.push(function (start, prefix, suffix) {
                code.insertRight(node.start, prefix + "var " + ref$1 + " = ");
                code.overwrite(node.start, c = node.start + 1, value);
                code.insertLeft(c, suffix);

                code.move(node.start, c, start);
              });

              node.elements.forEach(function (element, i) {
                if (!element) return;

                if (element.type === 'RestElement') {
                  handleProperty(code, scope, c, element.argument, ref$1 + ".slice(" + i + ")", inline, statementGenerators);
                } else {
                  handleProperty(code, scope, c, element, ref$1 + "[" + i + "]", inline, statementGenerators);
                }
                c = element.end;
              });
            } else {
              var index = findIndex(node.elements, Boolean);
              var element = node.elements[index];
              if (element.type === 'RestElement') {
                handleProperty(code, scope, c, element.argument, value + ".slice(" + index + ")", inline, statementGenerators);
              } else {
                handleProperty(code, scope, c, element, value + "[" + index + "]", inline, statementGenerators);
              }
              c = element.end;
            }

            code.remove(c, node.end);
            break;
          }

        default:
          {
            throw new Error("Unexpected node type in destructuring (" + node.type + ")");
          }
      }
    }

    var ForOfStatement = function (LoopStatement) {
      function ForOfStatement() {
        LoopStatement.apply(this, arguments);
      }

      if (LoopStatement) ForOfStatement.__proto__ = LoopStatement;
      ForOfStatement.prototype = Object.create(LoopStatement && LoopStatement.prototype);
      ForOfStatement.prototype.constructor = ForOfStatement;

      ForOfStatement.prototype.initialise = function initialise(transforms) {
        if (transforms.forOf && !transforms.dangerousForOf) throw new CompileError(this, 'for...of statements are not supported. Use `transforms: { forOf: false }` to skip transformation and disable this error, or `transforms: { dangerousForOf: true }` if you know what you\'re doing');
        LoopStatement.prototype.initialise.call(this, transforms);
      };

      ForOfStatement.prototype.transpile = function transpile(code, transforms) {
        if (!transforms.dangerousForOf) {
          LoopStatement.prototype.transpile.call(this, code, transforms);
          return;
        }

        // edge case (#80)
        if (!this.body.body[0]) {
          if (this.left.type === 'VariableDeclaration' && this.left.kind === 'var') {
            code.remove(this.start, this.left.start);
            code.insertLeft(this.left.end, ';');
            code.remove(this.left.end, this.end);
          } else {
            code.remove(this.start, this.end);
          }

          return;
        }

        var scope = this.findScope(true);
        var i0 = this.getIndentation();
        var i1 = i0 + code.getIndentString();

        var key = scope.createIdentifier('i');
        var list = scope.createIdentifier('list');

        if (this.body.synthetic) {
          code.insertRight(this.left.start, "{\n" + i1);
          code.insertLeft(this.body.body[0].end, "\n" + i0 + "}");
        }

        var bodyStart = this.body.body[0].start;

        code.remove(this.left.end, this.right.start);
        code.move(this.left.start, this.left.end, bodyStart);

        code.insertRight(this.right.start, "var " + key + " = 0, " + list + " = ");
        code.insertLeft(this.right.end, "; " + key + " < " + list + ".length; " + key + " += 1");

        // destructuring. TODO non declaration destructuring
        var declarator = this.left.type === 'VariableDeclaration' && this.left.declarations[0];
        if (declarator && declarator.id.type !== 'Identifier') {
          var statementGenerators = [];
          var ref = scope.createIdentifier('ref');
          destructure(code, scope, declarator.id, ref, false, statementGenerators);

          var suffix = ";\n" + i1;
          statementGenerators.forEach(function (fn, i) {
            if (i === statementGenerators.length - 1) {
              suffix = ";\n\n" + i1;
            }

            fn(bodyStart, '', suffix);
          });

          code.insertLeft(this.left.start + this.left.kind.length + 1, ref);
          code.insertLeft(this.left.end, " = " + list + "[" + key + "];\n" + i1);
        } else {
          code.insertLeft(this.left.end, " = " + list + "[" + key + "];\n\n" + i1);
        }

        LoopStatement.prototype.transpile.call(this, code, transforms);
      };

      return ForOfStatement;
    }(LoopStatement);

    var FunctionDeclaration = function (Node) {
      function FunctionDeclaration() {
        Node.apply(this, arguments);
      }

      if (Node) FunctionDeclaration.__proto__ = Node;
      FunctionDeclaration.prototype = Object.create(Node && Node.prototype);
      FunctionDeclaration.prototype.constructor = FunctionDeclaration;

      FunctionDeclaration.prototype.initialise = function initialise(transforms) {
        if (this.generator && transforms.generator) {
          throw new CompileError(this, 'Generators are not supported');
        }

        this.body.createScope();

        this.findScope(true).addDeclaration(this.id, 'function');
        Node.prototype.initialise.call(this, transforms);
      };

      return FunctionDeclaration;
    }(Node);

    var FunctionExpression = function (Node) {
      function FunctionExpression() {
        Node.apply(this, arguments);
      }

      if (Node) FunctionExpression.__proto__ = Node;
      FunctionExpression.prototype = Object.create(Node && Node.prototype);
      FunctionExpression.prototype.constructor = FunctionExpression;

      FunctionExpression.prototype.initialise = function initialise(transforms) {
        if (this.generator && transforms.generator) {
          throw new CompileError(this, 'Generators are not supported');
        }

        this.body.createScope();

        if (this.id) {
          // function expression IDs belong to the child scope...
          this.body.scope.addDeclaration(this.id, 'function');
        }

        Node.prototype.initialise.call(this, transforms);

        var parent = this.parent;
        var methodName;

        if (transforms.conciseMethodProperty && parent.type === 'Property' && parent.kind === 'init' && parent.method && parent.key.type === 'Identifier') {
          // object literal concise method
          methodName = parent.key.name;
        } else if (transforms.classes && parent.type === 'MethodDefinition' && parent.kind === 'method' && parent.key.type === 'Identifier') {
          // method definition in a class
          methodName = parent.key.name;
        } else if (this.id && this.id.type === 'Identifier') {
          // naked function expression
          methodName = this.id.alias || this.id.name;
        }

        if (methodName) {
          for (var i = 0, list = this.params; i < list.length; i += 1) {
            var param = list[i];

            if (param.type === 'Identifier' && methodName === param.name) {
              // workaround for Safari 9/WebKit bug:
              // https://gitlab.com/Rich-Harris/buble/issues/154
              // change parameter name when same as method name

              var scope = this.body.scope;
              var declaration = scope.declarations[methodName];

              var alias = scope.createIdentifier(methodName);
              param.alias = alias;

              for (var i$1 = 0, list$1 = declaration.instances; i$1 < list$1.length; i$1 += 1) {
                var identifier = list$1[i$1];

                identifier.alias = alias;
              }

              break;
            }
          }
        }
      };

      return FunctionExpression;
    }(Node);

    function isReference(node, parent) {
      if (node.type === 'MemberExpression') {
        return !node.computed && isReference(node.object, node);
      }

      if (node.type === 'Identifier') {
        // the only time we could have an identifier node without a parent is
        // if it's the entire body of a function without a block statement –
        // i.e. an arrow function expression like `a => a`
        if (!parent) return true;

        if (/(Function|Class)Expression/.test(parent.type)) return false;

        if (parent.type === 'VariableDeclarator') return node === parent.init;

        // TODO is this right?
        if (parent.type === 'MemberExpression' || parent.type === 'MethodDefinition') {
          return parent.computed || node === parent.object;
        }

        if (parent.type === 'ArrayPattern') return false;

        // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
        if (parent.type === 'Property') {
          if (parent.parent.type === 'ObjectPattern') return false;
          return parent.computed || node === parent.value;
        }

        // disregard the `bar` in `class Foo { bar () {...} }`
        if (parent.type === 'MethodDefinition') return false;

        // disregard the `bar` in `export { foo as bar }`
        if (parent.type === 'ExportSpecifier' && node !== parent.local) return false;

        return true;
      }
    }

    var Identifier = function (Node) {
      function Identifier() {
        Node.apply(this, arguments);
      }

      if (Node) Identifier.__proto__ = Node;
      Identifier.prototype = Object.create(Node && Node.prototype);
      Identifier.prototype.constructor = Identifier;

      Identifier.prototype.findScope = function findScope(functionScope) {
        if (this.parent.params && ~this.parent.params.indexOf(this)) {
          return this.parent.body.scope;
        }

        if (this.parent.type === 'FunctionExpression' && this === this.parent.id) {
          return this.parent.body.scope;
        }

        return this.parent.findScope(functionScope);
      };

      Identifier.prototype.initialise = function initialise(transforms) {
        if (transforms.arrow && isReference(this, this.parent)) {
          if (this.name === 'arguments' && !this.findScope(false).contains(this.name)) {
            var lexicalBoundary = this.findLexicalBoundary();
            var arrowFunction = this.findNearest('ArrowFunctionExpression');
            var loop = this.findNearest(loopStatement);

            if (arrowFunction && arrowFunction.depth > lexicalBoundary.depth) {
              this.alias = lexicalBoundary.getArgumentsAlias();
            }

            if (loop && loop.body.contains(this) && loop.depth > lexicalBoundary.depth) {
              this.alias = lexicalBoundary.getArgumentsAlias();
            }
          }

          this.findScope(false).addReference(this);
        }
      };

      Identifier.prototype.transpile = function transpile(code) {
        if (this.alias) {
          code.overwrite(this.start, this.end, this.alias, true);
        }
      };

      return Identifier;
    }(Node);

    var IfStatement = function (Node) {
      function IfStatement() {
        Node.apply(this, arguments);
      }

      if (Node) IfStatement.__proto__ = Node;
      IfStatement.prototype = Object.create(Node && Node.prototype);
      IfStatement.prototype.constructor = IfStatement;

      IfStatement.prototype.initialise = function initialise(transforms) {
        Node.prototype.initialise.call(this, transforms);
      };

      IfStatement.prototype.transpile = function transpile(code, transforms) {
        if (this.consequent.type !== 'BlockStatement' || this.consequent.type === 'BlockStatement' && this.consequent.synthetic) {
          code.insertLeft(this.consequent.start, '{ ');
          code.insertRight(this.consequent.end, ' }');
        }

        if (this.alternate && this.alternate.type !== 'IfStatement' && (this.alternate.type !== 'BlockStatement' || this.alternate.type === 'BlockStatement' && this.alternate.synthetic)) {
          code.insertLeft(this.alternate.start, '{ ');
          code.insertRight(this.alternate.end, ' }');
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      return IfStatement;
    }(Node);

    var ImportDeclaration = function (Node) {
      function ImportDeclaration() {
        Node.apply(this, arguments);
      }

      if (Node) ImportDeclaration.__proto__ = Node;
      ImportDeclaration.prototype = Object.create(Node && Node.prototype);
      ImportDeclaration.prototype.constructor = ImportDeclaration;

      ImportDeclaration.prototype.initialise = function initialise(transforms) {
        if (transforms.moduleImport) throw new CompileError(this, 'import is not supported');
        Node.prototype.initialise.call(this, transforms);
      };

      return ImportDeclaration;
    }(Node);

    var ImportDefaultSpecifier = function (Node) {
      function ImportDefaultSpecifier() {
        Node.apply(this, arguments);
      }

      if (Node) ImportDefaultSpecifier.__proto__ = Node;
      ImportDefaultSpecifier.prototype = Object.create(Node && Node.prototype);
      ImportDefaultSpecifier.prototype.constructor = ImportDefaultSpecifier;

      ImportDefaultSpecifier.prototype.initialise = function initialise(transforms) {
        this.findScope(true).addDeclaration(this.local, 'import');
        Node.prototype.initialise.call(this, transforms);
      };

      return ImportDefaultSpecifier;
    }(Node);

    var ImportSpecifier = function (Node) {
      function ImportSpecifier() {
        Node.apply(this, arguments);
      }

      if (Node) ImportSpecifier.__proto__ = Node;
      ImportSpecifier.prototype = Object.create(Node && Node.prototype);
      ImportSpecifier.prototype.constructor = ImportSpecifier;

      ImportSpecifier.prototype.initialise = function initialise(transforms) {
        this.findScope(true).addDeclaration(this.local, 'import');
        Node.prototype.initialise.call(this, transforms);
      };

      return ImportSpecifier;
    }(Node);

    var IS_DATA_ATTRIBUTE = /-/;

    var JSXAttribute = function (Node) {
      function JSXAttribute() {
        Node.apply(this, arguments);
      }

      if (Node) JSXAttribute.__proto__ = Node;
      JSXAttribute.prototype = Object.create(Node && Node.prototype);
      JSXAttribute.prototype.constructor = JSXAttribute;

      JSXAttribute.prototype.transpile = function transpile(code, transforms) {
        if (this.value) {
          code.overwrite(this.name.end, this.value.start, ': ');
        } else {
          // tag without value
          code.overwrite(this.name.start, this.name.end, this.name.name + ": true");
        }

        if (IS_DATA_ATTRIBUTE.test(this.name.name)) {
          code.overwrite(this.name.start, this.name.end, "'" + this.name.name + "'");
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      return JSXAttribute;
    }(Node);

    function containsNewLine(node) {
      return node.type === 'Literal' && !/\S/.test(node.value) && /\n/.test(node.value);
    }

    var JSXClosingElement = function (Node) {
      function JSXClosingElement() {
        Node.apply(this, arguments);
      }

      if (Node) JSXClosingElement.__proto__ = Node;
      JSXClosingElement.prototype = Object.create(Node && Node.prototype);
      JSXClosingElement.prototype.constructor = JSXClosingElement;

      JSXClosingElement.prototype.transpile = function transpile(code) {
        var spaceBeforeParen = true;

        var lastChild = this.parent.children[this.parent.children.length - 1];

        // omit space before closing paren if
        //   a) this is on a separate line, or
        //   b) there are no children but there are attributes
        if (lastChild && containsNewLine(lastChild) || this.parent.openingElement.attributes.length) {
          spaceBeforeParen = false;
        }

        code.overwrite(this.start, this.end, spaceBeforeParen ? ' )' : ')');
      };

      return JSXClosingElement;
    }(Node);

    function normalise(str, removeTrailingWhitespace) {
      if (removeTrailingWhitespace && /\n/.test(str)) {
        str = str.replace(/\s+$/, '');
      }

      str = str.replace(/^\n\r?\s+/, '') // remove leading newline + space
      .replace(/\s*\n\r?\s*/gm, ' '); // replace newlines with spaces

      // TODO prefer single quotes?
      return JSON.stringify(str);
    }

    var JSXElement = function (Node) {
      function JSXElement() {
        Node.apply(this, arguments);
      }

      if (Node) JSXElement.__proto__ = Node;
      JSXElement.prototype = Object.create(Node && Node.prototype);
      JSXElement.prototype.constructor = JSXElement;

      JSXElement.prototype.transpile = function transpile(code, transforms) {
        Node.prototype.transpile.call(this, code, transforms);

        var children = this.children.filter(function (child) {
          if (child.type !== 'Literal') return true;

          // remove whitespace-only literals, unless on a single line
          return (/\S/.test(child.value) || !/\n/.test(child.value)
          );
        });

        if (children.length) {
          var c = this.openingElement.end;

          var i;
          for (i = 0; i < children.length; i += 1) {
            var child = children[i];

            if (child.type === 'JSXExpressionContainer' && child.expression.type === 'JSXEmptyExpression') {
              // empty block is a no op
            } else {
              var tail = code.original[c] === '\n' && child.type !== 'Literal' ? '' : ' ';
              code.insertLeft(c, "," + tail);
            }

            if (child.type === 'Literal') {
              var str = normalise(child.value, i === children.length - 1);
              code.overwrite(child.start, child.end, str);
            }

            c = child.end;
          }
        }
      };

      return JSXElement;
    }(Node);

    var JSXExpressionContainer = function (Node) {
      function JSXExpressionContainer() {
        Node.apply(this, arguments);
      }

      if (Node) JSXExpressionContainer.__proto__ = Node;
      JSXExpressionContainer.prototype = Object.create(Node && Node.prototype);
      JSXExpressionContainer.prototype.constructor = JSXExpressionContainer;

      JSXExpressionContainer.prototype.transpile = function transpile(code, transforms) {
        code.remove(this.start, this.expression.start);
        code.remove(this.expression.end, this.end);

        Node.prototype.transpile.call(this, code, transforms);
      };

      return JSXExpressionContainer;
    }(Node);

    var JSXOpeningElement = function (Node) {
      function JSXOpeningElement() {
        Node.apply(this, arguments);
      }

      if (Node) JSXOpeningElement.__proto__ = Node;
      JSXOpeningElement.prototype = Object.create(Node && Node.prototype);
      JSXOpeningElement.prototype.constructor = JSXOpeningElement;

      JSXOpeningElement.prototype.transpile = function transpile(code, transforms) {
        var this$1 = this;

        code.overwrite(this.start, this.name.start, this.program.jsx + "( ");

        var html = this.name.type === 'JSXIdentifier' && this.name.name[0] === this.name.name[0].toLowerCase();
        if (html) code.insertRight(this.name.start, "'");

        var len = this.attributes.length;
        var c = this.name.end;

        if (len) {
          var i;

          var hasSpread = false;
          for (i = 0; i < len; i += 1) {
            if (this$1.attributes[i].type === 'JSXSpreadAttribute') {
              hasSpread = true;
              break;
            }
          }

          c = this.attributes[0].end;

          for (i = 0; i < len; i += 1) {
            var attr = this$1.attributes[i];

            if (i > 0) {
              code.overwrite(c, attr.start, ', ');
            }

            if (hasSpread && attr.type !== 'JSXSpreadAttribute') {
              var lastAttr = this$1.attributes[i - 1];
              var nextAttr = this$1.attributes[i + 1];

              if (!lastAttr || lastAttr.type === 'JSXSpreadAttribute') {
                code.insertRight(attr.start, '{ ');
              }

              if (!nextAttr || nextAttr.type === 'JSXSpreadAttribute') {
                code.insertLeft(attr.end, ' }');
              }
            }

            c = attr.end;
          }

          var after;
          var before;
          if (hasSpread) {
            if (len === 1) {
              before = html ? "'," : ',';
            } else {
              if (!this.program.options.objectAssign) {
                throw new CompileError(this, 'Mixed JSX attributes ending in spread requires specified objectAssign option with \'Object.assign\' or polyfill helper.');
              }
              before = html ? "', " + this.program.options.objectAssign + "({}," : ", " + this.program.options.objectAssign + "({},";
              after = ')';
            }
          } else {
            before = html ? "', {" : ', {';
            after = ' }';
          }

          code.insertRight(this.name.end, before);

          if (after) {
            code.insertLeft(this.attributes[len - 1].end, after);
          }
        } else {
          code.insertLeft(this.name.end, html ? "', null" : ", null");
          c = this.name.end;
        }

        Node.prototype.transpile.call(this, code, transforms);

        if (this.selfClosing) {
          code.overwrite(c, this.end, this.attributes.length ? ")" : " )");
        } else {
          code.remove(c, this.end);
        }
      };

      return JSXOpeningElement;
    }(Node);

    var JSXSpreadAttribute = function (Node) {
      function JSXSpreadAttribute() {
        Node.apply(this, arguments);
      }

      if (Node) JSXSpreadAttribute.__proto__ = Node;
      JSXSpreadAttribute.prototype = Object.create(Node && Node.prototype);
      JSXSpreadAttribute.prototype.constructor = JSXSpreadAttribute;

      JSXSpreadAttribute.prototype.transpile = function transpile(code, transforms) {
        code.remove(this.start, this.argument.start);
        code.remove(this.argument.end, this.end);

        Node.prototype.transpile.call(this, code, transforms);
      };

      return JSXSpreadAttribute;
    }(Node);

    var regenerate = __commonjs(function (module, exports, global) {
      /*! https://mths.be/regenerate v1.3.1 by @mathias | MIT license */
      (function (root) {

        // Detect free variables `exports`.
        var freeExports = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object' && exports;

        // Detect free variable `module`.
        var freeModule = (typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module && module.exports == freeExports && module;

        // Detect free variable `global`, from Node.js/io.js or Browserified code,
        // and use it as `root`.
        var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
          root = freeGlobal;
        }

        /*--------------------------------------------------------------------------*/

        var ERRORS = {
          'rangeOrder': 'A range\u2019s `stop` value must be greater than or equal ' + 'to the `start` value.',
          'codePointRange': 'Invalid code point value. Code points range from ' + 'U+000000 to U+10FFFF.'
        };

        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-pairs
        var HIGH_SURROGATE_MIN = 0xD800;
        var HIGH_SURROGATE_MAX = 0xDBFF;
        var LOW_SURROGATE_MIN = 0xDC00;
        var LOW_SURROGATE_MAX = 0xDFFF;

        // In Regenerate output, `\0` is never preceded by `\` because we sort by
        // code point value, so let’s keep this regular expression simple.
        var regexNull = /\\x00([^0123456789]|$)/g;

        var object = {};
        var hasOwnProperty = object.hasOwnProperty;
        var extend = function extend(destination, source) {
          var key;
          for (key in source) {
            if (hasOwnProperty.call(source, key)) {
              destination[key] = source[key];
            }
          }
          return destination;
        };

        var forEach = function forEach(array, callback) {
          var index = -1;
          var length = array.length;
          while (++index < length) {
            callback(array[index], index);
          }
        };

        var toString = object.toString;
        var isArray = function isArray(value) {
          return toString.call(value) == '[object Array]';
        };
        var isNumber = function isNumber(value) {
          return typeof value == 'number' || toString.call(value) == '[object Number]';
        };

        // This assumes that `number` is a positive integer that `toString()`s nicely
        // (which is the case for all code point values).
        var zeroes = '0000';
        var pad = function pad(number, totalCharacters) {
          var string = String(number);
          return string.length < totalCharacters ? (zeroes + string).slice(-totalCharacters) : string;
        };

        var hex = function hex(number) {
          return Number(number).toString(16).toUpperCase();
        };

        var slice = [].slice;

        /*--------------------------------------------------------------------------*/

        var dataFromCodePoints = function dataFromCodePoints(codePoints) {
          var index = -1;
          var length = codePoints.length;
          var max = length - 1;
          var result = [];
          var isStart = true;
          var tmp;
          var previous = 0;
          while (++index < length) {
            tmp = codePoints[index];
            if (isStart) {
              result.push(tmp);
              previous = tmp;
              isStart = false;
            } else {
              if (tmp == previous + 1) {
                if (index != max) {
                  previous = tmp;
                  continue;
                } else {
                  isStart = true;
                  result.push(tmp + 1);
                }
              } else {
                // End the previous range and start a new one.
                result.push(previous + 1, tmp);
                previous = tmp;
              }
            }
          }
          if (!isStart) {
            result.push(tmp + 1);
          }
          return result;
        };

        var dataRemove = function dataRemove(data, codePoint) {
          // Iterate over the data per `(start, end)` pair.
          var index = 0;
          var start;
          var end;
          var length = data.length;
          while (index < length) {
            start = data[index];
            end = data[index + 1];
            if (codePoint >= start && codePoint < end) {
              // Modify this pair.
              if (codePoint == start) {
                if (end == start + 1) {
                  // Just remove `start` and `end`.
                  data.splice(index, 2);
                  return data;
                } else {
                  // Just replace `start` with a new value.
                  data[index] = codePoint + 1;
                  return data;
                }
              } else if (codePoint == end - 1) {
                // Just replace `end` with a new value.
                data[index + 1] = codePoint;
                return data;
              } else {
                // Replace `[start, end]` with `[startA, endA, startB, endB]`.
                data.splice(index, 2, start, codePoint, codePoint + 1, end);
                return data;
              }
            }
            index += 2;
          }
          return data;
        };

        var dataRemoveRange = function dataRemoveRange(data, rangeStart, rangeEnd) {
          if (rangeEnd < rangeStart) {
            throw Error(ERRORS.rangeOrder);
          }
          // Iterate over the data per `(start, end)` pair.
          var index = 0;
          var start;
          var end;
          while (index < data.length) {
            start = data[index];
            end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.

            // Exit as soon as no more matching pairs can be found.
            if (start > rangeEnd) {
              return data;
            }

            // Check if this range pair is equal to, or forms a subset of, the range
            // to be removed.
            // E.g. we have `[0, 11, 40, 51]` and want to remove 0-10 → `[40, 51]`.
            // E.g. we have `[40, 51]` and want to remove 0-100 → `[]`.
            if (rangeStart <= start && rangeEnd >= end) {
              // Remove this pair.
              data.splice(index, 2);
              continue;
            }

            // Check if both `rangeStart` and `rangeEnd` are within the bounds of
            // this pair.
            // E.g. we have `[0, 11]` and want to remove 4-6 → `[0, 4, 7, 11]`.
            if (rangeStart >= start && rangeEnd < end) {
              if (rangeStart == start) {
                // Replace `[start, end]` with `[startB, endB]`.
                data[index] = rangeEnd + 1;
                data[index + 1] = end + 1;
                return data;
              }
              // Replace `[start, end]` with `[startA, endA, startB, endB]`.
              data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);
              return data;
            }

            // Check if only `rangeStart` is within the bounds of this pair.
            // E.g. we have `[0, 11]` and want to remove 4-20 → `[0, 4]`.
            if (rangeStart >= start && rangeStart <= end) {
              // Replace `end` with `rangeStart`.
              data[index + 1] = rangeStart;
              // Note: we cannot `return` just yet, in case any following pairs still
              // contain matching code points.
              // E.g. we have `[0, 11, 14, 31]` and want to remove 4-20
              // → `[0, 4, 21, 31]`.
            }

            // Check if only `rangeEnd` is within the bounds of this pair.
            // E.g. we have `[14, 31]` and want to remove 4-20 → `[21, 31]`.
            else if (rangeEnd >= start && rangeEnd <= end) {
                // Just replace `start`.
                data[index] = rangeEnd + 1;
                return data;
              }

            index += 2;
          }
          return data;
        };

        var dataAdd = function dataAdd(data, codePoint) {
          // Iterate over the data per `(start, end)` pair.
          var index = 0;
          var start;
          var end;
          var lastIndex = null;
          var length = data.length;
          if (codePoint < 0x0 || codePoint > 0x10FFFF) {
            throw RangeError(ERRORS.codePointRange);
          }
          while (index < length) {
            start = data[index];
            end = data[index + 1];

            // Check if the code point is already in the set.
            if (codePoint >= start && codePoint < end) {
              return data;
            }

            if (codePoint == start - 1) {
              // Just replace `start` with a new value.
              data[index] = codePoint;
              return data;
            }

            // At this point, if `start` is `greater` than `codePoint`, insert a new
            // `[start, end]` pair before the current pair, or after the current pair
            // if there is a known `lastIndex`.
            if (start > codePoint) {
              data.splice(lastIndex != null ? lastIndex + 2 : 0, 0, codePoint, codePoint + 1);
              return data;
            }

            if (codePoint == end) {
              // Check if adding this code point causes two separate ranges to become
              // a single range, e.g. `dataAdd([0, 4, 5, 10], 4)` → `[0, 10]`.
              if (codePoint + 1 == data[index + 2]) {
                data.splice(index, 4, start, data[index + 3]);
                return data;
              }
              // Else, just replace `end` with a new value.
              data[index + 1] = codePoint + 1;
              return data;
            }
            lastIndex = index;
            index += 2;
          }
          // The loop has finished; add the new pair to the end of the data set.
          data.push(codePoint, codePoint + 1);
          return data;
        };

        var dataAddData = function dataAddData(dataA, dataB) {
          // Iterate over the data per `(start, end)` pair.
          var index = 0;
          var start;
          var end;
          var data = dataA.slice();
          var length = dataB.length;
          while (index < length) {
            start = dataB[index];
            end = dataB[index + 1] - 1;
            if (start == end) {
              data = dataAdd(data, start);
            } else {
              data = dataAddRange(data, start, end);
            }
            index += 2;
          }
          return data;
        };

        var dataRemoveData = function dataRemoveData(dataA, dataB) {
          // Iterate over the data per `(start, end)` pair.
          var index = 0;
          var start;
          var end;
          var data = dataA.slice();
          var length = dataB.length;
          while (index < length) {
            start = dataB[index];
            end = dataB[index + 1] - 1;
            if (start == end) {
              data = dataRemove(data, start);
            } else {
              data = dataRemoveRange(data, start, end);
            }
            index += 2;
          }
          return data;
        };

        var dataAddRange = function dataAddRange(data, rangeStart, rangeEnd) {
          if (rangeEnd < rangeStart) {
            throw Error(ERRORS.rangeOrder);
          }
          if (rangeStart < 0x0 || rangeStart > 0x10FFFF || rangeEnd < 0x0 || rangeEnd > 0x10FFFF) {
            throw RangeError(ERRORS.codePointRange);
          }
          // Iterate over the data per `(start, end)` pair.
          var index = 0;
          var start;
          var end;
          var added = false;
          var length = data.length;
          while (index < length) {
            start = data[index];
            end = data[index + 1];

            if (added) {
              // The range has already been added to the set; at this point, we just
              // need to get rid of the following ranges in case they overlap.

              // Check if this range can be combined with the previous range.
              if (start == rangeEnd + 1) {
                data.splice(index - 1, 2);
                return data;
              }

              // Exit as soon as no more possibly overlapping pairs can be found.
              if (start > rangeEnd) {
                return data;
              }

              // E.g. `[0, 11, 12, 16]` and we’ve added 5-15, so we now have
              // `[0, 16, 12, 16]`. Remove the `12,16` part, as it lies within the
              // `0,16` range that was previously added.
              if (start >= rangeStart && start <= rangeEnd) {
                // `start` lies within the range that was previously added.

                if (end > rangeStart && end - 1 <= rangeEnd) {
                  // `end` lies within the range that was previously added as well,
                  // so remove this pair.
                  data.splice(index, 2);
                  index -= 2;
                  // Note: we cannot `return` just yet, as there may still be other
                  // overlapping pairs.
                } else {
                  // `start` lies within the range that was previously added, but
                  // `end` doesn’t. E.g. `[0, 11, 12, 31]` and we’ve added 5-15, so
                  // now we have `[0, 16, 12, 31]`. This must be written as `[0, 31]`.
                  // Remove the previously added `end` and the current `start`.
                  data.splice(index - 1, 2);
                  index -= 2;
                }

                // Note: we cannot return yet.
              }
            } else if (start == rangeEnd + 1) {
              data[index] = rangeStart;
              return data;
            }

            // Check if a new pair must be inserted *before* the current one.
            else if (start > rangeEnd) {
                data.splice(index, 0, rangeStart, rangeEnd + 1);
                return data;
              } else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {
                // The new range lies entirely within an existing range pair. No action
                // needed.
                return data;
              } else if (
              // E.g. `[0, 11]` and you add 5-15 → `[0, 16]`.
              rangeStart >= start && rangeStart < end ||
              // E.g. `[0, 3]` and you add 3-6 → `[0, 7]`.
              end == rangeStart) {
                // Replace `end` with the new value.
                data[index + 1] = rangeEnd + 1;
                // Make sure the next range pair doesn’t overlap, e.g. `[0, 11, 12, 14]`
                // and you add 5-15 → `[0, 16]`, i.e. remove the `12,14` part.
                added = true;
                // Note: we cannot `return` just yet.
              } else if (rangeStart <= start && rangeEnd + 1 >= end) {
                // The new range is a superset of the old range.
                data[index] = rangeStart;
                data[index + 1] = rangeEnd + 1;
                added = true;
              }

            index += 2;
          }
          // The loop has finished without doing anything; add the new pair to the end
          // of the data set.
          if (!added) {
            data.push(rangeStart, rangeEnd + 1);
          }
          return data;
        };

        var dataContains = function dataContains(data, codePoint) {
          var index = 0;
          var length = data.length;
          // Exit early if `codePoint` is not within `data`’s overall range.
          var start = data[index];
          var end = data[length - 1];
          if (length >= 2) {
            if (codePoint < start || codePoint > end) {
              return false;
            }
          }
          // Iterate over the data per `(start, end)` pair.
          while (index < length) {
            start = data[index];
            end = data[index + 1];
            if (codePoint >= start && codePoint < end) {
              return true;
            }
            index += 2;
          }
          return false;
        };

        var dataIntersection = function dataIntersection(data, codePoints) {
          var index = 0;
          var length = codePoints.length;
          var codePoint;
          var result = [];
          while (index < length) {
            codePoint = codePoints[index];
            if (dataContains(data, codePoint)) {
              result.push(codePoint);
            }
            ++index;
          }
          return dataFromCodePoints(result);
        };

        var dataIsEmpty = function dataIsEmpty(data) {
          return !data.length;
        };

        var dataIsSingleton = function dataIsSingleton(data) {
          // Check if the set only represents a single code point.
          return data.length == 2 && data[0] + 1 == data[1];
        };

        var dataToArray = function dataToArray(data) {
          // Iterate over the data per `(start, end)` pair.
          var index = 0;
          var start;
          var end;
          var result = [];
          var length = data.length;
          while (index < length) {
            start = data[index];
            end = data[index + 1];
            while (start < end) {
              result.push(start);
              ++start;
            }
            index += 2;
          }
          return result;
        };

        /*--------------------------------------------------------------------------*/

        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        var floor = Math.floor;
        var highSurrogate = function highSurrogate(codePoint) {
          return parseInt(floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN, 10);
        };

        var lowSurrogate = function lowSurrogate(codePoint) {
          return parseInt((codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN, 10);
        };

        var stringFromCharCode = String.fromCharCode;
        var codePointToString = function codePointToString(codePoint) {
          var string;
          // https://mathiasbynens.be/notes/javascript-escapes#single
          // Note: the `\b` escape sequence for U+0008 BACKSPACE in strings has a
          // different meaning in regular expressions (word boundary), so it cannot
          // be used here.
          if (codePoint == 0x09) {
            string = '\\t';
          }
          // Note: IE < 9 treats `'\v'` as `'v'`, so avoid using it.
          // else if (codePoint == 0x0B) {
          // 	string = '\\v';
          // }
          else if (codePoint == 0x0A) {
              string = '\\n';
            } else if (codePoint == 0x0C) {
              string = '\\f';
            } else if (codePoint == 0x0D) {
              string = '\\r';
            } else if (codePoint == 0x5C) {
              string = '\\\\';
            } else if (codePoint == 0x24 || codePoint >= 0x28 && codePoint <= 0x2B || codePoint == 0x2D || codePoint == 0x2E || codePoint == 0x3F || codePoint >= 0x5B && codePoint <= 0x5E || codePoint >= 0x7B && codePoint <= 0x7D) {
              // The code point maps to an unsafe printable ASCII character;
              // backslash-escape it. Here’s the list of those symbols:
              //
              //     $()*+-.?[\]^{|}
              //
              // See #7 for more info.
              string = '\\' + stringFromCharCode(codePoint);
            } else if (codePoint >= 0x20 && codePoint <= 0x7E) {
              // The code point maps to one of these printable ASCII symbols
              // (including the space character):
              //
              //      !"#%&',/0123456789:;<=>@ABCDEFGHIJKLMNO
              //     PQRSTUVWXYZ_`abcdefghijklmnopqrstuvwxyz~
              //
              // These can safely be used directly.
              string = stringFromCharCode(codePoint);
            } else if (codePoint <= 0xFF) {
              // https://mathiasbynens.be/notes/javascript-escapes#hexadecimal
              string = '\\x' + pad(hex(codePoint), 2);
            } else {
              // `codePoint <= 0xFFFF` holds true.
              // https://mathiasbynens.be/notes/javascript-escapes#unicode
              string = '\\u' + pad(hex(codePoint), 4);
            }

          // There’s no need to account for astral symbols / surrogate pairs here,
          // since `codePointToString` is private and only used for BMP code points.
          // But if that’s what you need, just add an `else` block with this code:
          //
          //     string = '\\u' + pad(hex(highSurrogate(codePoint)), 4)
          //     	+ '\\u' + pad(hex(lowSurrogate(codePoint)), 4);

          return string;
        };

        var codePointToStringUnicode = function codePointToStringUnicode(codePoint) {
          if (codePoint <= 0xFFFF) {
            return codePointToString(codePoint);
          }
          return '\\u{' + codePoint.toString(16).toUpperCase() + '}';
        };

        var symbolToCodePoint = function symbolToCodePoint(symbol) {
          var length = symbol.length;
          var first = symbol.charCodeAt(0);
          var second;
          if (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > 1 // There is a next code unit.
          ) {
              // `first` is a high surrogate, and there is a next character. Assume
              // it’s a low surrogate (else it’s invalid usage of Regenerate anyway).
              second = symbol.charCodeAt(1);
              // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
              return (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;
            }
          return first;
        };

        var createBMPCharacterClasses = function createBMPCharacterClasses(data) {
          // Iterate over the data per `(start, end)` pair.
          var result = '';
          var index = 0;
          var start;
          var end;
          var length = data.length;
          if (dataIsSingleton(data)) {
            return codePointToString(data[0]);
          }
          while (index < length) {
            start = data[index];
            end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.
            if (start == end) {
              result += codePointToString(start);
            } else if (start + 1 == end) {
              result += codePointToString(start) + codePointToString(end);
            } else {
              result += codePointToString(start) + '-' + codePointToString(end);
            }
            index += 2;
          }
          return '[' + result + ']';
        };

        var createUnicodeCharacterClasses = function createUnicodeCharacterClasses(data) {
          // Iterate over the data per `(start, end)` pair.
          var result = '';
          var index = 0;
          var start;
          var end;
          var length = data.length;
          if (dataIsSingleton(data)) {
            return codePointToStringUnicode(data[0]);
          }
          while (index < length) {
            start = data[index];
            end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.
            if (start == end) {
              result += codePointToStringUnicode(start);
            } else if (start + 1 == end) {
              result += codePointToStringUnicode(start) + codePointToStringUnicode(end);
            } else {
              result += codePointToStringUnicode(start) + '-' + codePointToStringUnicode(end);
            }
            index += 2;
          }
          return '[' + result + ']';
        };

        var splitAtBMP = function splitAtBMP(data) {
          // Iterate over the data per `(start, end)` pair.
          var loneHighSurrogates = [];
          var loneLowSurrogates = [];
          var bmp = [];
          var astral = [];
          var index = 0;
          var start;
          var end;
          var length = data.length;
          while (index < length) {
            start = data[index];
            end = data[index + 1] - 1; // Note: the `- 1` makes `end` inclusive.

            if (start < HIGH_SURROGATE_MIN) {

              // The range starts and ends before the high surrogate range.
              // E.g. (0, 0x10).
              if (end < HIGH_SURROGATE_MIN) {
                bmp.push(start, end + 1);
              }

              // The range starts before the high surrogate range and ends within it.
              // E.g. (0, 0xD855).
              if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
                bmp.push(start, HIGH_SURROGATE_MIN);
                loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);
              }

              // The range starts before the high surrogate range and ends in the low
              // surrogate range. E.g. (0, 0xDCFF).
              if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
                bmp.push(start, HIGH_SURROGATE_MIN);
                loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
                loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
              }

              // The range starts before the high surrogate range and ends after the
              // low surrogate range. E.g. (0, 0x10FFFF).
              if (end > LOW_SURROGATE_MAX) {
                bmp.push(start, HIGH_SURROGATE_MIN);
                loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
                loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);
                if (end <= 0xFFFF) {
                  bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
                } else {
                  bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
                  astral.push(0xFFFF + 1, end + 1);
                }
              }
            } else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {

              // The range starts and ends in the high surrogate range.
              // E.g. (0xD855, 0xD866).
              if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
                loneHighSurrogates.push(start, end + 1);
              }

              // The range starts in the high surrogate range and ends in the low
              // surrogate range. E.g. (0xD855, 0xDCFF).
              if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
                loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
                loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
              }

              // The range starts in the high surrogate range and ends after the low
              // surrogate range. E.g. (0xD855, 0x10FFFF).
              if (end > LOW_SURROGATE_MAX) {
                loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
                loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);
                if (end <= 0xFFFF) {
                  bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
                } else {
                  bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
                  astral.push(0xFFFF + 1, end + 1);
                }
              }
            } else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {

              // The range starts and ends in the low surrogate range.
              // E.g. (0xDCFF, 0xDDFF).
              if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
                loneLowSurrogates.push(start, end + 1);
              }

              // The range starts in the low surrogate range and ends after the low
              // surrogate range. E.g. (0xDCFF, 0x10FFFF).
              if (end > LOW_SURROGATE_MAX) {
                loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);
                if (end <= 0xFFFF) {
                  bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
                } else {
                  bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
                  astral.push(0xFFFF + 1, end + 1);
                }
              }
            } else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {

              // The range starts and ends after the low surrogate range.
              // E.g. (0xFFAA, 0x10FFFF).
              if (end <= 0xFFFF) {
                bmp.push(start, end + 1);
              } else {
                bmp.push(start, 0xFFFF + 1);
                astral.push(0xFFFF + 1, end + 1);
              }
            } else {

              // The range starts and ends in the astral range.
              astral.push(start, end + 1);
            }

            index += 2;
          }
          return {
            'loneHighSurrogates': loneHighSurrogates,
            'loneLowSurrogates': loneLowSurrogates,
            'bmp': bmp,
            'astral': astral
          };
        };

        var optimizeSurrogateMappings = function optimizeSurrogateMappings(surrogateMappings) {
          var result = [];
          var tmpLow = [];
          var addLow = false;
          var mapping;
          var nextMapping;
          var highSurrogates;
          var lowSurrogates;
          var nextHighSurrogates;
          var nextLowSurrogates;
          var index = -1;
          var length = surrogateMappings.length;
          while (++index < length) {
            mapping = surrogateMappings[index];
            nextMapping = surrogateMappings[index + 1];
            if (!nextMapping) {
              result.push(mapping);
              continue;
            }
            highSurrogates = mapping[0];
            lowSurrogates = mapping[1];
            nextHighSurrogates = nextMapping[0];
            nextLowSurrogates = nextMapping[1];

            // Check for identical high surrogate ranges.
            tmpLow = lowSurrogates;
            while (nextHighSurrogates && highSurrogates[0] == nextHighSurrogates[0] && highSurrogates[1] == nextHighSurrogates[1]) {
              // Merge with the next item.
              if (dataIsSingleton(nextLowSurrogates)) {
                tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);
              } else {
                tmpLow = dataAddRange(tmpLow, nextLowSurrogates[0], nextLowSurrogates[1] - 1);
              }
              ++index;
              mapping = surrogateMappings[index];
              highSurrogates = mapping[0];
              lowSurrogates = mapping[1];
              nextMapping = surrogateMappings[index + 1];
              nextHighSurrogates = nextMapping && nextMapping[0];
              nextLowSurrogates = nextMapping && nextMapping[1];
              addLow = true;
            }
            result.push([highSurrogates, addLow ? tmpLow : lowSurrogates]);
            addLow = false;
          }
          return optimizeByLowSurrogates(result);
        };

        var optimizeByLowSurrogates = function optimizeByLowSurrogates(surrogateMappings) {
          if (surrogateMappings.length == 1) {
            return surrogateMappings;
          }
          var index = -1;
          var innerIndex = -1;
          while (++index < surrogateMappings.length) {
            var mapping = surrogateMappings[index];
            var lowSurrogates = mapping[1];
            var lowSurrogateStart = lowSurrogates[0];
            var lowSurrogateEnd = lowSurrogates[1];
            innerIndex = index; // Note: the loop starts at the next index.
            while (++innerIndex < surrogateMappings.length) {
              var otherMapping = surrogateMappings[innerIndex];
              var otherLowSurrogates = otherMapping[1];
              var otherLowSurrogateStart = otherLowSurrogates[0];
              var otherLowSurrogateEnd = otherLowSurrogates[1];
              if (lowSurrogateStart == otherLowSurrogateStart && lowSurrogateEnd == otherLowSurrogateEnd) {
                // Add the code points in the other item to this one.
                if (dataIsSingleton(otherMapping[0])) {
                  mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);
                } else {
                  mapping[0] = dataAddRange(mapping[0], otherMapping[0][0], otherMapping[0][1] - 1);
                }
                // Remove the other, now redundant, item.
                surrogateMappings.splice(innerIndex, 1);
                --innerIndex;
              }
            }
          }
          return surrogateMappings;
        };

        var surrogateSet = function surrogateSet(data) {
          // Exit early if `data` is an empty set.
          if (!data.length) {
            return [];
          }

          // Iterate over the data per `(start, end)` pair.
          var index = 0;
          var start;
          var end;
          var startHigh;
          var startLow;
          var prevStartHigh = 0;
          var prevEndHigh = 0;
          var tmpLow = [];
          var endHigh;
          var endLow;
          var surrogateMappings = [];
          var length = data.length;
          var dataHigh = [];
          while (index < length) {
            start = data[index];
            end = data[index + 1] - 1;

            startHigh = highSurrogate(start);
            startLow = lowSurrogate(start);
            endHigh = highSurrogate(end);
            endLow = lowSurrogate(end);

            var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;
            var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;
            var complete = false;

            // Append the previous high-surrogate-to-low-surrogate mappings.
            // Step 1: `(startHigh, startLow)` to `(startHigh, LOW_SURROGATE_MAX)`.
            if (startHigh == endHigh || startsWithLowestLowSurrogate && endsWithHighestLowSurrogate) {
              surrogateMappings.push([[startHigh, endHigh + 1], [startLow, endLow + 1]]);
              complete = true;
            } else {
              surrogateMappings.push([[startHigh, startHigh + 1], [startLow, LOW_SURROGATE_MAX + 1]]);
            }

            // Step 2: `(startHigh + 1, LOW_SURROGATE_MIN)` to
            // `(endHigh - 1, LOW_SURROGATE_MAX)`.
            if (!complete && startHigh + 1 < endHigh) {
              if (endsWithHighestLowSurrogate) {
                // Combine step 2 and step 3.
                surrogateMappings.push([[startHigh + 1, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
                complete = true;
              } else {
                surrogateMappings.push([[startHigh + 1, endHigh], [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]]);
              }
            }

            // Step 3. `(endHigh, LOW_SURROGATE_MIN)` to `(endHigh, endLow)`.
            if (!complete) {
              surrogateMappings.push([[endHigh, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
            }

            prevStartHigh = startHigh;
            prevEndHigh = endHigh;

            index += 2;
          }

          // The format of `surrogateMappings` is as follows:
          //
          //     [ surrogateMapping1, surrogateMapping2 ]
          //
          // i.e.:
          //
          //     [
          //       [ highSurrogates1, lowSurrogates1 ],
          //       [ highSurrogates2, lowSurrogates2 ]
          //     ]
          return optimizeSurrogateMappings(surrogateMappings);
        };

        var createSurrogateCharacterClasses = function createSurrogateCharacterClasses(surrogateMappings) {
          var result = [];
          forEach(surrogateMappings, function (surrogateMapping) {
            var highSurrogates = surrogateMapping[0];
            var lowSurrogates = surrogateMapping[1];
            result.push(createBMPCharacterClasses(highSurrogates) + createBMPCharacterClasses(lowSurrogates));
          });
          return result.join('|');
        };

        var createCharacterClassesFromData = function createCharacterClassesFromData(data, bmpOnly, hasUnicodeFlag) {
          if (hasUnicodeFlag) {
            return createUnicodeCharacterClasses(data);
          }
          var result = [];

          var parts = splitAtBMP(data);
          var loneHighSurrogates = parts.loneHighSurrogates;
          var loneLowSurrogates = parts.loneLowSurrogates;
          var bmp = parts.bmp;
          var astral = parts.astral;
          var hasAstral = !dataIsEmpty(parts.astral);
          var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);
          var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);

          var surrogateMappings = surrogateSet(astral);

          if (bmpOnly) {
            bmp = dataAddData(bmp, loneHighSurrogates);
            hasLoneHighSurrogates = false;
            bmp = dataAddData(bmp, loneLowSurrogates);
            hasLoneLowSurrogates = false;
          }

          if (!dataIsEmpty(bmp)) {
            // The data set contains BMP code points that are not high surrogates
            // needed for astral code points in the set.
            result.push(createBMPCharacterClasses(bmp));
          }
          if (surrogateMappings.length) {
            // The data set contains astral code points; append character classes
            // based on their surrogate pairs.
            result.push(createSurrogateCharacterClasses(surrogateMappings));
          }
          // https://gist.github.com/mathiasbynens/bbe7f870208abcfec860
          if (hasLoneHighSurrogates) {
            result.push(createBMPCharacterClasses(loneHighSurrogates) +
            // Make sure the high surrogates aren’t part of a surrogate pair.
            '(?![\\uDC00-\\uDFFF])');
          }
          if (hasLoneLowSurrogates) {
            result.push(
            // It is not possible to accurately assert the low surrogates aren’t
            // part of a surrogate pair, since JavaScript regular expressions do
            // not support lookbehind.
            '(?:[^\\uD800-\\uDBFF]|^)' + createBMPCharacterClasses(loneLowSurrogates));
          }
          return result.join('|');
        };

        /*--------------------------------------------------------------------------*/

        // `regenerate` can be used as a constructor (and new methods can be added to
        // its prototype) but also as a regular function, the latter of which is the
        // documented and most common usage. For that reason, it’s not capitalized.
        var regenerate = function regenerate(value) {
          if (arguments.length > 1) {
            value = slice.call(arguments);
          }
          if (this instanceof regenerate) {
            this.data = [];
            return value ? this.add(value) : this;
          }
          return new regenerate().add(value);
        };

        regenerate.version = '1.3.1';

        var proto = regenerate.prototype;
        extend(proto, {
          'add': function add(value) {
            var $this = this;
            if (value == null) {
              return $this;
            }
            if (value instanceof regenerate) {
              // Allow passing other Regenerate instances.
              $this.data = dataAddData($this.data, value.data);
              return $this;
            }
            if (arguments.length > 1) {
              value = slice.call(arguments);
            }
            if (isArray(value)) {
              forEach(value, function (item) {
                $this.add(item);
              });
              return $this;
            }
            $this.data = dataAdd($this.data, isNumber(value) ? value : symbolToCodePoint(value));
            return $this;
          },
          'remove': function remove(value) {
            var $this = this;
            if (value == null) {
              return $this;
            }
            if (value instanceof regenerate) {
              // Allow passing other Regenerate instances.
              $this.data = dataRemoveData($this.data, value.data);
              return $this;
            }
            if (arguments.length > 1) {
              value = slice.call(arguments);
            }
            if (isArray(value)) {
              forEach(value, function (item) {
                $this.remove(item);
              });
              return $this;
            }
            $this.data = dataRemove($this.data, isNumber(value) ? value : symbolToCodePoint(value));
            return $this;
          },
          'addRange': function addRange(start, end) {
            var $this = this;
            $this.data = dataAddRange($this.data, isNumber(start) ? start : symbolToCodePoint(start), isNumber(end) ? end : symbolToCodePoint(end));
            return $this;
          },
          'removeRange': function removeRange(start, end) {
            var $this = this;
            var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);
            var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);
            $this.data = dataRemoveRange($this.data, startCodePoint, endCodePoint);
            return $this;
          },
          'intersection': function intersection(argument) {
            var $this = this;
            // Allow passing other Regenerate instances.
            // TODO: Optimize this by writing and using `dataIntersectionData()`.
            var array = argument instanceof regenerate ? dataToArray(argument.data) : argument;
            $this.data = dataIntersection($this.data, array);
            return $this;
          },
          'contains': function contains(codePoint) {
            return dataContains(this.data, isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint));
          },
          'clone': function clone() {
            var set$$1 = new regenerate();
            set$$1.data = this.data.slice(0);
            return set$$1;
          },
          'toString': function toString(options) {
            var result = createCharacterClassesFromData(this.data, options ? options.bmpOnly : false, options ? options.hasUnicodeFlag : false);
            if (!result) {
              // For an empty set, return something that can be inserted `/here/` to
              // form a valid regular expression. Avoid `(?:)` since that matches the
              // empty string.
              return '[]';
            }
            // Use `\0` instead of `\x00` where possible.
            return result.replace(regexNull, '\\0$1');
          },
          'toRegExp': function toRegExp(flags) {
            var pattern = this.toString(flags && flags.indexOf('u') != -1 ? { 'hasUnicodeFlag': true } : null);
            return RegExp(pattern, flags || '');
          },
          'valueOf': function valueOf() {
            // Note: `valueOf` is aliased as `toArray`.
            return dataToArray(this.data);
          }
        });

        proto.toArray = proto.valueOf;

        // Some AMD build optimizers, like r.js, check for specific condition patterns
        // like the following:
        if (false) {
          undefined(function () {
            return regenerate;
          });
        } else if (freeExports && !freeExports.nodeType) {
          if (freeModule) {
            // in Node.js, io.js, or RingoJS v0.8.0+
            freeModule.exports = regenerate;
          } else {
            // in Narwhal or RingoJS v0.7.0-
            freeExports.regenerate = regenerate;
          }
        } else {
          // in Rhino or a web browser
          root.regenerate = regenerate;
        }
      })(__commonjs_global);
    });

    var require$$0$2 = regenerate && (typeof regenerate === 'undefined' ? 'undefined' : _typeof(regenerate)) === 'object' && 'default' in regenerate ? regenerate['default'] : regenerate;

    var characterClassEscapeSets = __commonjs(function (module, exports) {
      // Generated by `/scripts/character-class-escape-sets.js`. Do not edit.
      var regenerate = require$$0$2;

      exports.REGULAR = {
        'd': regenerate().addRange(0x30, 0x39),
        'D': regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0xFFFF),
        's': regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029),
        'S': regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0xFFFF),
        'w': regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A),
        'W': regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0xFFFF)
      };

      exports.UNICODE = {
        'd': regenerate().addRange(0x30, 0x39),
        'D': regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF),
        's': regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029),
        'S': regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF),
        'w': regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A),
        'W': regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)
      };

      exports.UNICODE_IGNORE_CASE = {
        'd': regenerate().addRange(0x30, 0x39),
        'D': regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF),
        's': regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029),
        'S': regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF),
        'w': regenerate(0x5F, 0x17F, 0x212A).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A),
        'W': regenerate(0x4B, 0x53, 0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)
      };
    });

    var require$$0$1 = characterClassEscapeSets && (typeof characterClassEscapeSets === 'undefined' ? 'undefined' : _typeof(characterClassEscapeSets)) === 'object' && 'default' in characterClassEscapeSets ? characterClassEscapeSets['default'] : characterClassEscapeSets;

    var require$$1 = {
      "75": 8490,
      "83": 383,
      "107": 8490,
      "115": 383,
      "181": 924,
      "197": 8491,
      "383": 83,
      "452": 453,
      "453": 452,
      "455": 456,
      "456": 455,
      "458": 459,
      "459": 458,
      "497": 498,
      "498": 497,
      "837": 8126,
      "914": 976,
      "917": 1013,
      "920": 1012,
      "921": 8126,
      "922": 1008,
      "924": 181,
      "928": 982,
      "929": 1009,
      "931": 962,
      "934": 981,
      "937": 8486,
      "962": 931,
      "976": 914,
      "977": 1012,
      "981": 934,
      "982": 928,
      "1008": 922,
      "1009": 929,
      "1012": [920, 977],
      "1013": 917,
      "7776": 7835,
      "7835": 7776,
      "8126": [837, 921],
      "8486": 937,
      "8490": 75,
      "8491": 197,
      "66560": 66600,
      "66561": 66601,
      "66562": 66602,
      "66563": 66603,
      "66564": 66604,
      "66565": 66605,
      "66566": 66606,
      "66567": 66607,
      "66568": 66608,
      "66569": 66609,
      "66570": 66610,
      "66571": 66611,
      "66572": 66612,
      "66573": 66613,
      "66574": 66614,
      "66575": 66615,
      "66576": 66616,
      "66577": 66617,
      "66578": 66618,
      "66579": 66619,
      "66580": 66620,
      "66581": 66621,
      "66582": 66622,
      "66583": 66623,
      "66584": 66624,
      "66585": 66625,
      "66586": 66626,
      "66587": 66627,
      "66588": 66628,
      "66589": 66629,
      "66590": 66630,
      "66591": 66631,
      "66592": 66632,
      "66593": 66633,
      "66594": 66634,
      "66595": 66635,
      "66596": 66636,
      "66597": 66637,
      "66598": 66638,
      "66599": 66639,
      "66600": 66560,
      "66601": 66561,
      "66602": 66562,
      "66603": 66563,
      "66604": 66564,
      "66605": 66565,
      "66606": 66566,
      "66607": 66567,
      "66608": 66568,
      "66609": 66569,
      "66610": 66570,
      "66611": 66571,
      "66612": 66572,
      "66613": 66573,
      "66614": 66574,
      "66615": 66575,
      "66616": 66576,
      "66617": 66577,
      "66618": 66578,
      "66619": 66579,
      "66620": 66580,
      "66621": 66581,
      "66622": 66582,
      "66623": 66583,
      "66624": 66584,
      "66625": 66585,
      "66626": 66586,
      "66627": 66587,
      "66628": 66588,
      "66629": 66589,
      "66630": 66590,
      "66631": 66591,
      "66632": 66592,
      "66633": 66593,
      "66634": 66594,
      "66635": 66595,
      "66636": 66596,
      "66637": 66597,
      "66638": 66598,
      "66639": 66599,
      "68736": 68800,
      "68737": 68801,
      "68738": 68802,
      "68739": 68803,
      "68740": 68804,
      "68741": 68805,
      "68742": 68806,
      "68743": 68807,
      "68744": 68808,
      "68745": 68809,
      "68746": 68810,
      "68747": 68811,
      "68748": 68812,
      "68749": 68813,
      "68750": 68814,
      "68751": 68815,
      "68752": 68816,
      "68753": 68817,
      "68754": 68818,
      "68755": 68819,
      "68756": 68820,
      "68757": 68821,
      "68758": 68822,
      "68759": 68823,
      "68760": 68824,
      "68761": 68825,
      "68762": 68826,
      "68763": 68827,
      "68764": 68828,
      "68765": 68829,
      "68766": 68830,
      "68767": 68831,
      "68768": 68832,
      "68769": 68833,
      "68770": 68834,
      "68771": 68835,
      "68772": 68836,
      "68773": 68837,
      "68774": 68838,
      "68775": 68839,
      "68776": 68840,
      "68777": 68841,
      "68778": 68842,
      "68779": 68843,
      "68780": 68844,
      "68781": 68845,
      "68782": 68846,
      "68783": 68847,
      "68784": 68848,
      "68785": 68849,
      "68786": 68850,
      "68800": 68736,
      "68801": 68737,
      "68802": 68738,
      "68803": 68739,
      "68804": 68740,
      "68805": 68741,
      "68806": 68742,
      "68807": 68743,
      "68808": 68744,
      "68809": 68745,
      "68810": 68746,
      "68811": 68747,
      "68812": 68748,
      "68813": 68749,
      "68814": 68750,
      "68815": 68751,
      "68816": 68752,
      "68817": 68753,
      "68818": 68754,
      "68819": 68755,
      "68820": 68756,
      "68821": 68757,
      "68822": 68758,
      "68823": 68759,
      "68824": 68760,
      "68825": 68761,
      "68826": 68762,
      "68827": 68763,
      "68828": 68764,
      "68829": 68765,
      "68830": 68766,
      "68831": 68767,
      "68832": 68768,
      "68833": 68769,
      "68834": 68770,
      "68835": 68771,
      "68836": 68772,
      "68837": 68773,
      "68838": 68774,
      "68839": 68775,
      "68840": 68776,
      "68841": 68777,
      "68842": 68778,
      "68843": 68779,
      "68844": 68780,
      "68845": 68781,
      "68846": 68782,
      "68847": 68783,
      "68848": 68784,
      "68849": 68785,
      "68850": 68786,
      "71840": 71872,
      "71841": 71873,
      "71842": 71874,
      "71843": 71875,
      "71844": 71876,
      "71845": 71877,
      "71846": 71878,
      "71847": 71879,
      "71848": 71880,
      "71849": 71881,
      "71850": 71882,
      "71851": 71883,
      "71852": 71884,
      "71853": 71885,
      "71854": 71886,
      "71855": 71887,
      "71856": 71888,
      "71857": 71889,
      "71858": 71890,
      "71859": 71891,
      "71860": 71892,
      "71861": 71893,
      "71862": 71894,
      "71863": 71895,
      "71864": 71896,
      "71865": 71897,
      "71866": 71898,
      "71867": 71899,
      "71868": 71900,
      "71869": 71901,
      "71870": 71902,
      "71871": 71903,
      "71872": 71840,
      "71873": 71841,
      "71874": 71842,
      "71875": 71843,
      "71876": 71844,
      "71877": 71845,
      "71878": 71846,
      "71879": 71847,
      "71880": 71848,
      "71881": 71849,
      "71882": 71850,
      "71883": 71851,
      "71884": 71852,
      "71885": 71853,
      "71886": 71854,
      "71887": 71855,
      "71888": 71856,
      "71889": 71857,
      "71890": 71858,
      "71891": 71859,
      "71892": 71860,
      "71893": 71861,
      "71894": 71862,
      "71895": 71863,
      "71896": 71864,
      "71897": 71865,
      "71898": 71866,
      "71899": 71867,
      "71900": 71868,
      "71901": 71869,
      "71902": 71870,
      "71903": 71871
    };

    var parser = __commonjs(function (module) {
      // regjsparser
      //
      // ==================================================================
      //
      // See ECMA-262 Standard: 15.10.1
      //
      // NOTE: The ECMA-262 standard uses the term "Assertion" for /^/. Here the
      //   term "Anchor" is used.
      //
      // Pattern ::
      //      Disjunction
      //
      // Disjunction ::
      //      Alternative
      //      Alternative | Disjunction
      //
      // Alternative ::
      //      [empty]
      //      Alternative Term
      //
      // Term ::
      //      Anchor
      //      Atom
      //      Atom Quantifier
      //
      // Anchor ::
      //      ^
      //      $
      //      \ b
      //      \ B
      //      ( ? = Disjunction )
      //      ( ? ! Disjunction )
      //
      // Quantifier ::
      //      QuantifierPrefix
      //      QuantifierPrefix ?
      //
      // QuantifierPrefix ::
      //      *
      //      +
      //      ?
      //      { DecimalDigits }
      //      { DecimalDigits , }
      //      { DecimalDigits , DecimalDigits }
      //
      // Atom ::
      //      PatternCharacter
      //      .
      //      \ AtomEscape
      //      CharacterClass
      //      ( Disjunction )
      //      ( ? : Disjunction )
      //
      // PatternCharacter ::
      //      SourceCharacter but not any of: ^ $ \ . * + ? ( ) [ ] { } |
      //
      // AtomEscape ::
      //      DecimalEscape
      //      CharacterEscape
      //      CharacterClassEscape
      //
      // CharacterEscape[U] ::
      //      ControlEscape
      //      c ControlLetter
      //      HexEscapeSequence
      //      RegExpUnicodeEscapeSequence[?U] (ES6)
      //      IdentityEscape[?U]
      //
      // ControlEscape ::
      //      one of f n r t v
      // ControlLetter ::
      //      one of
      //          a b c d e f g h i j k l m n o p q r s t u v w x y z
      //          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
      //
      // IdentityEscape ::
      //      SourceCharacter but not IdentifierPart
      //      <ZWJ>
      //      <ZWNJ>
      //
      // DecimalEscape ::
      //      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]
      //
      // CharacterClassEscape ::
      //      one of d D s S w W
      //
      // CharacterClass ::
      //      [ [lookahead ∉ {^}] ClassRanges ]
      //      [ ^ ClassRanges ]
      //
      // ClassRanges ::
      //      [empty]
      //      NonemptyClassRanges
      //
      // NonemptyClassRanges ::
      //      ClassAtom
      //      ClassAtom NonemptyClassRangesNoDash
      //      ClassAtom - ClassAtom ClassRanges
      //
      // NonemptyClassRangesNoDash ::
      //      ClassAtom
      //      ClassAtomNoDash NonemptyClassRangesNoDash
      //      ClassAtomNoDash - ClassAtom ClassRanges
      //
      // ClassAtom ::
      //      -
      //      ClassAtomNoDash
      //
      // ClassAtomNoDash ::
      //      SourceCharacter but not one of \ or ] or -
      //      \ ClassEscape
      //
      // ClassEscape ::
      //      DecimalEscape
      //      b
      //      CharacterEscape
      //      CharacterClassEscape

      (function () {

        function parse(str, flags) {
          function addRaw(node) {
            node.raw = str.substring(node.range[0], node.range[1]);
            return node;
          }

          function updateRawStart(node, start) {
            node.range[0] = start;
            return addRaw(node);
          }

          function createAnchor(kind, rawLength) {
            return addRaw({
              type: 'anchor',
              kind: kind,
              range: [pos - rawLength, pos]
            });
          }

          function createValue(kind, codePoint, from, to) {
            return addRaw({
              type: 'value',
              kind: kind,
              codePoint: codePoint,
              range: [from, to]
            });
          }

          function createEscaped(kind, codePoint, value, fromOffset) {
            fromOffset = fromOffset || 0;
            return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
          }

          function createCharacter(matches) {
            var _char = matches[0];
            var first = _char.charCodeAt(0);
            if (hasUnicodeFlag) {
              var second;
              if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
                second = lookahead().charCodeAt(0);
                if (second >= 0xDC00 && second <= 0xDFFF) {
                  // Unicode surrogate pair
                  pos++;
                  return createValue('symbol', (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000, pos - 2, pos);
                }
              }
            }
            return createValue('symbol', first, pos - 1, pos);
          }

          function createDisjunction(alternatives, from, to) {
            return addRaw({
              type: 'disjunction',
              body: alternatives,
              range: [from, to]
            });
          }

          function createDot() {
            return addRaw({
              type: 'dot',
              range: [pos - 1, pos]
            });
          }

          function createCharacterClassEscape(value) {
            return addRaw({
              type: 'characterClassEscape',
              value: value,
              range: [pos - 2, pos]
            });
          }

          function createReference(matchIndex) {
            return addRaw({
              type: 'reference',
              matchIndex: parseInt(matchIndex, 10),
              range: [pos - 1 - matchIndex.length, pos]
            });
          }

          function createGroup(behavior, disjunction, from, to) {
            return addRaw({
              type: 'group',
              behavior: behavior,
              body: disjunction,
              range: [from, to]
            });
          }

          function createQuantifier(min, max, from, to) {
            if (to == null) {
              from = pos - 1;
              to = pos;
            }

            return addRaw({
              type: 'quantifier',
              min: min,
              max: max,
              greedy: true,
              body: null, // set later on
              range: [from, to]
            });
          }

          function createAlternative(terms, from, to) {
            return addRaw({
              type: 'alternative',
              body: terms,
              range: [from, to]
            });
          }

          function createCharacterClass(classRanges, negative, from, to) {
            return addRaw({
              type: 'characterClass',
              body: classRanges,
              negative: negative,
              range: [from, to]
            });
          }

          function createClassRange(min, max, from, to) {
            // See 15.10.2.15:
            if (min.codePoint > max.codePoint) {
              bail('invalid range in character class', min.raw + '-' + max.raw, from, to);
            }

            return addRaw({
              type: 'characterClassRange',
              min: min,
              max: max,
              range: [from, to]
            });
          }

          function flattenBody(body) {
            if (body.type === 'alternative') {
              return body.body;
            } else {
              return [body];
            }
          }

          function incr(amount) {
            amount = amount || 1;
            var res = str.substring(pos, pos + amount);
            pos += amount || 1;
            return res;
          }

          function skip(value) {
            if (!match(value)) {
              bail('character', value);
            }
          }

          function match(value) {
            if (str.indexOf(value, pos) === pos) {
              return incr(value.length);
            }
          }

          function lookahead() {
            return str[pos];
          }

          function current(value) {
            return str.indexOf(value, pos) === pos;
          }

          function next(value) {
            return str[pos + 1] === value;
          }

          function matchReg(regExp) {
            var subStr = str.substring(pos);
            var res = subStr.match(regExp);
            if (res) {
              res.range = [];
              res.range[0] = pos;
              incr(res[0].length);
              res.range[1] = pos;
            }
            return res;
          }

          function parseDisjunction() {
            // Disjunction ::
            //      Alternative
            //      Alternative | Disjunction
            var res = [],
                from = pos;
            res.push(parseAlternative());

            while (match('|')) {
              res.push(parseAlternative());
            }

            if (res.length === 1) {
              return res[0];
            }

            return createDisjunction(res, from, pos);
          }

          function parseAlternative() {
            var res = [],
                from = pos;
            var term;

            // Alternative ::
            //      [empty]
            //      Alternative Term
            while (term = parseTerm()) {
              res.push(term);
            }

            if (res.length === 1) {
              return res[0];
            }

            return createAlternative(res, from, pos);
          }

          function parseTerm() {
            // Term ::
            //      Anchor
            //      Atom
            //      Atom Quantifier

            if (pos >= str.length || current('|') || current(')')) {
              return null; /* Means: The term is empty */
            }

            var anchor = parseAnchor();

            if (anchor) {
              return anchor;
            }

            var atom = parseAtom();
            if (!atom) {
              bail('Expected atom');
            }
            var quantifier = parseQuantifier() || false;
            if (quantifier) {
              quantifier.body = flattenBody(atom);
              // The quantifier contains the atom. Therefore, the beginning of the
              // quantifier range is given by the beginning of the atom.
              updateRawStart(quantifier, atom.range[0]);
              return quantifier;
            }
            return atom;
          }

          function parseGroup(matchA, typeA, matchB, typeB) {
            var type = null,
                from = pos;

            if (match(matchA)) {
              type = typeA;
            } else if (match(matchB)) {
              type = typeB;
            } else {
              return false;
            }

            var body = parseDisjunction();
            if (!body) {
              bail('Expected disjunction');
            }
            skip(')');
            var group = createGroup(type, flattenBody(body), from, pos);

            if (type == 'normal') {
              // Keep track of the number of closed groups. This is required for
              // parseDecimalEscape(). In case the string is parsed a second time the
              // value already holds the total count and no incrementation is required.
              if (firstIteration) {
                closedCaptureCounter++;
              }
            }
            return group;
          }

          function parseAnchor() {
            // Anchor ::
            //      ^
            //      $
            //      \ b
            //      \ B
            //      ( ? = Disjunction )
            //      ( ? ! Disjunction )
            var res,
                from = pos;

            if (match('^')) {
              return createAnchor('start', 1 /* rawLength */);
            } else if (match('$')) {
              return createAnchor('end', 1 /* rawLength */);
            } else if (match('\\b')) {
              return createAnchor('boundary', 2 /* rawLength */);
            } else if (match('\\B')) {
              return createAnchor('not-boundary', 2 /* rawLength */);
            } else {
              return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
            }
          }

          function parseQuantifier() {
            // Quantifier ::
            //      QuantifierPrefix
            //      QuantifierPrefix ?
            //
            // QuantifierPrefix ::
            //      *
            //      +
            //      ?
            //      { DecimalDigits }
            //      { DecimalDigits , }
            //      { DecimalDigits , DecimalDigits }

            var res,
                from = pos;
            var quantifier;
            var min, max;

            if (match('*')) {
              quantifier = createQuantifier(0);
            } else if (match('+')) {
              quantifier = createQuantifier(1);
            } else if (match('?')) {
              quantifier = createQuantifier(0, 1);
            } else if (res = matchReg(/^\{([0-9]+)\}/)) {
              min = parseInt(res[1], 10);
              quantifier = createQuantifier(min, min, res.range[0], res.range[1]);
            } else if (res = matchReg(/^\{([0-9]+),\}/)) {
              min = parseInt(res[1], 10);
              quantifier = createQuantifier(min, undefined, res.range[0], res.range[1]);
            } else if (res = matchReg(/^\{([0-9]+),([0-9]+)\}/)) {
              min = parseInt(res[1], 10);
              max = parseInt(res[2], 10);
              if (min > max) {
                bail('numbers out of order in {} quantifier', '', from, pos);
              }
              quantifier = createQuantifier(min, max, res.range[0], res.range[1]);
            }

            if (quantifier) {
              if (match('?')) {
                quantifier.greedy = false;
                quantifier.range[1] += 1;
              }
            }

            return quantifier;
          }

          function parseAtom() {
            // Atom ::
            //      PatternCharacter
            //      .
            //      \ AtomEscape
            //      CharacterClass
            //      ( Disjunction )
            //      ( ? : Disjunction )

            var res;

            // jviereck: allow ']', '}' here as well to be compatible with browser's
            //   implementations: ']'.match(/]/);
            // if (res = matchReg(/^[^^$\\.*+?()[\]{}|]/)) {
            if (res = matchReg(/^[^^$\\.*+?(){[|]/)) {
              //      PatternCharacter
              return createCharacter(res);
            } else if (match('.')) {
              //      .
              return createDot();
            } else if (match('\\')) {
              //      \ AtomEscape
              res = parseAtomEscape();
              if (!res) {
                bail('atomEscape');
              }
              return res;
            } else if (res = parseCharacterClass()) {
              return res;
            } else {
              //      ( Disjunction )
              //      ( ? : Disjunction )
              return parseGroup('(?:', 'ignore', '(', 'normal');
            }
          }

          function parseUnicodeSurrogatePairEscape(firstEscape) {
            if (hasUnicodeFlag) {
              var first, second;
              if (firstEscape.kind == 'unicodeEscape' && (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF && current('\\') && next('u')) {
                var prevPos = pos;
                pos++;
                var secondEscape = parseClassEscape();
                if (secondEscape.kind == 'unicodeEscape' && (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
                  // Unicode surrogate pair
                  firstEscape.range[1] = secondEscape.range[1];
                  firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                  firstEscape.type = 'value';
                  firstEscape.kind = 'unicodeCodePointEscape';
                  addRaw(firstEscape);
                } else {
                  pos = prevPos;
                }
              }
            }
            return firstEscape;
          }

          function parseClassEscape() {
            return parseAtomEscape(true);
          }

          function parseAtomEscape(insideCharacterClass) {
            // AtomEscape ::
            //      DecimalEscape
            //      CharacterEscape
            //      CharacterClassEscape

            var res,
                from = pos;

            res = parseDecimalEscape();
            if (res) {
              return res;
            }

            // For ClassEscape
            if (insideCharacterClass) {
              if (match('b')) {
                // 15.10.2.19
                // The production ClassEscape :: b evaluates by returning the
                // CharSet containing the one character <BS> (Unicode value 0008).
                return createEscaped('singleEscape', 0x0008, '\\b');
              } else if (match('B')) {
                bail('\\B not possible inside of CharacterClass', '', from);
              }
            }

            res = parseCharacterEscape();

            return res;
          }

          function parseDecimalEscape() {
            // DecimalEscape ::
            //      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]
            //      CharacterClassEscape :: one of d D s S w W

            var res, match;

            if (res = matchReg(/^(?!0)\d+/)) {
              match = res[0];
              var refIdx = parseInt(res[0], 10);
              if (refIdx <= closedCaptureCounter) {
                // If the number is smaller than the normal-groups found so
                // far, then it is a reference...
                return createReference(res[0]);
              } else {
                // ... otherwise it needs to be interpreted as a octal (if the
                // number is in an octal format). If it is NOT octal format,
                // then the slash is ignored and the number is matched later
                // as normal characters.

                // Recall the negative decision to decide if the input must be parsed
                // a second time with the total normal-groups.
                backrefDenied.push(refIdx);

                // Reset the position again, as maybe only parts of the previous
                // matched numbers are actual octal numbers. E.g. in '019' only
                // the '01' should be matched.
                incr(-res[0].length);
                if (res = matchReg(/^[0-7]{1,3}/)) {
                  return createEscaped('octal', parseInt(res[0], 8), res[0], 1);
                } else {
                  // If we end up here, we have a case like /\91/. Then the
                  // first slash is to be ignored and the 9 & 1 to be treated
                  // like ordinary characters. Create a character for the
                  // first number only here - other number-characters
                  // (if available) will be matched later.
                  res = createCharacter(matchReg(/^[89]/));
                  return updateRawStart(res, res.range[0] - 1);
                }
              }
            }
            // Only allow octal numbers in the following. All matched numbers start
            // with a zero (if the do not, the previous if-branch is executed).
            // If the number is not octal format and starts with zero (e.g. `091`)
            // then only the zeros `0` is treated here and the `91` are ordinary
            // characters.
            // Example:
            //   /\091/.exec('\091')[0].length === 3
            else if (res = matchReg(/^[0-7]{1,3}/)) {
                match = res[0];
                if (/^0{1,3}$/.test(match)) {
                  // If they are all zeros, then only take the first one.
                  return createEscaped('null', 0x0000, '0', match.length + 1);
                } else {
                  return createEscaped('octal', parseInt(match, 8), match, 1);
                }
              } else if (res = matchReg(/^[dDsSwW]/)) {
                return createCharacterClassEscape(res[0]);
              }
            return false;
          }

          function parseCharacterEscape() {
            // CharacterEscape ::
            //      ControlEscape
            //      c ControlLetter
            //      HexEscapeSequence
            //      UnicodeEscapeSequence
            //      IdentityEscape

            var res;
            if (res = matchReg(/^[fnrtv]/)) {
              // ControlEscape
              var codePoint = 0;
              switch (res[0]) {
                case 't':
                  codePoint = 0x009;break;
                case 'n':
                  codePoint = 0x00A;break;
                case 'v':
                  codePoint = 0x00B;break;
                case 'f':
                  codePoint = 0x00C;break;
                case 'r':
                  codePoint = 0x00D;break;
              }
              return createEscaped('singleEscape', codePoint, '\\' + res[0]);
            } else if (res = matchReg(/^c([a-zA-Z])/)) {
              // c ControlLetter
              return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);
            } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
              // HexEscapeSequence
              return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);
            } else if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
              // UnicodeEscapeSequence
              return parseUnicodeSurrogatePairEscape(createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2));
            } else if (hasUnicodeFlag && (res = matchReg(/^u\{([0-9a-fA-F]+)\}/))) {
              // RegExpUnicodeEscapeSequence (ES6 Unicode code point escape)
              return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);
            } else {
              // IdentityEscape
              return parseIdentityEscape();
            }
          }

          // Taken from the Esprima parser.
          function isIdentifierPart(ch) {
            // Generated by `tools/generate-identifier-regex.js`.
            var NonAsciiIdentifierPart = new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]');

            return ch === 36 || ch === 95 || // $ (dollar) and _ (underscore)
            ch >= 65 && ch <= 90 || // A..Z
            ch >= 97 && ch <= 122 || // a..z
            ch >= 48 && ch <= 57 || // 0..9
            ch === 92 || // \ (backslash)
            ch >= 0x80 && NonAsciiIdentifierPart.test(String.fromCharCode(ch));
          }

          function parseIdentityEscape() {
            // IdentityEscape ::
            //      SourceCharacter but not IdentifierPart
            //      <ZWJ>
            //      <ZWNJ>

            var ZWJ = '\u200C';
            var ZWNJ = '\u200D';

            var tmp;

            if (!isIdentifierPart(lookahead())) {
              tmp = incr();
              return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);
            }

            if (match(ZWJ)) {
              // <ZWJ>
              return createEscaped('identifier', 0x200C, ZWJ);
            } else if (match(ZWNJ)) {
              // <ZWNJ>
              return createEscaped('identifier', 0x200D, ZWNJ);
            }

            return null;
          }

          function parseCharacterClass() {
            // CharacterClass ::
            //      [ [lookahead ∉ {^}] ClassRanges ]
            //      [ ^ ClassRanges ]

            var res,
                from = pos;
            if (res = matchReg(/^\[\^/)) {
              res = parseClassRanges();
              skip(']');
              return createCharacterClass(res, true, from, pos);
            } else if (match('[')) {
              res = parseClassRanges();
              skip(']');
              return createCharacterClass(res, false, from, pos);
            }

            return null;
          }

          function parseClassRanges() {
            // ClassRanges ::
            //      [empty]
            //      NonemptyClassRanges

            var res;
            if (current(']')) {
              // Empty array means nothing insinde of the ClassRange.
              return [];
            } else {
              res = parseNonemptyClassRanges();
              if (!res) {
                bail('nonEmptyClassRanges');
              }
              return res;
            }
          }

          function parseHelperClassRanges(atom) {
            var from, to, res;
            if (current('-') && !next(']')) {
              // ClassAtom - ClassAtom ClassRanges
              skip('-');

              res = parseClassAtom();
              if (!res) {
                bail('classAtom');
              }
              to = pos;
              var classRanges = parseClassRanges();
              if (!classRanges) {
                bail('classRanges');
              }
              from = atom.range[0];
              if (classRanges.type === 'empty') {
                return [createClassRange(atom, res, from, to)];
              }
              return [createClassRange(atom, res, from, to)].concat(classRanges);
            }

            res = parseNonemptyClassRangesNoDash();
            if (!res) {
              bail('nonEmptyClassRangesNoDash');
            }

            return [atom].concat(res);
          }

          function parseNonemptyClassRanges() {
            // NonemptyClassRanges ::
            //      ClassAtom
            //      ClassAtom NonemptyClassRangesNoDash
            //      ClassAtom - ClassAtom ClassRanges

            var atom = parseClassAtom();
            if (!atom) {
              bail('classAtom');
            }

            if (current(']')) {
              // ClassAtom
              return [atom];
            }

            // ClassAtom NonemptyClassRangesNoDash
            // ClassAtom - ClassAtom ClassRanges
            return parseHelperClassRanges(atom);
          }

          function parseNonemptyClassRangesNoDash() {
            // NonemptyClassRangesNoDash ::
            //      ClassAtom
            //      ClassAtomNoDash NonemptyClassRangesNoDash
            //      ClassAtomNoDash - ClassAtom ClassRanges

            var res = parseClassAtom();
            if (!res) {
              bail('classAtom');
            }
            if (current(']')) {
              //      ClassAtom
              return res;
            }

            // ClassAtomNoDash NonemptyClassRangesNoDash
            // ClassAtomNoDash - ClassAtom ClassRanges
            return parseHelperClassRanges(res);
          }

          function parseClassAtom() {
            // ClassAtom ::
            //      -
            //      ClassAtomNoDash
            if (match('-')) {
              return createCharacter('-');
            } else {
              return parseClassAtomNoDash();
            }
          }

          function parseClassAtomNoDash() {
            // ClassAtomNoDash ::
            //      SourceCharacter but not one of \ or ] or -
            //      \ ClassEscape

            var res;
            if (res = matchReg(/^[^\\\]-]/)) {
              return createCharacter(res[0]);
            } else if (match('\\')) {
              res = parseClassEscape();
              if (!res) {
                bail('classEscape');
              }

              return parseUnicodeSurrogatePairEscape(res);
            }
          }

          function bail(message, details, from, to) {
            from = from == null ? pos : from;
            to = to == null ? from : to;

            var contextStart = Math.max(0, from - 10);
            var contextEnd = Math.min(to + 10, str.length);

            // Output a bit of context and a line pointing to where our error is.
            //
            // We are assuming that there are no actual newlines in the content as this is a regular expression.
            var context = '    ' + str.substring(contextStart, contextEnd);
            var pointer = '    ' + new Array(from - contextStart + 1).join(' ') + '^';

            throw SyntaxError(message + ' at position ' + from + (details ? ': ' + details : '') + '\n' + context + '\n' + pointer);
          }

          var backrefDenied = [];
          var closedCaptureCounter = 0;
          var firstIteration = true;
          var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
          var pos = 0;

          // Convert the input to a string and treat the empty string special.
          str = String(str);
          if (str === '') {
            str = '(?:)';
          }

          var result = parseDisjunction();

          if (result.range[1] !== str.length) {
            bail('Could not parse entire input - got stuck', '', result.range[1]);
          }

          // The spec requires to interpret the `\2` in `/\2()()/` as backreference.
          // As the parser collects the number of capture groups as the string is
          // parsed it is impossible to make these decisions at the point when the
          // `\2` is handled. In case the local decision turns out to be wrong after
          // the parsing has finished, the input string is parsed a second time with
          // the total number of capture groups set.
          //
          // SEE: https://github.com/jviereck/regjsparser/issues/70
          for (var i = 0; i < backrefDenied.length; i++) {
            if (backrefDenied[i] <= closedCaptureCounter) {
              // Parse the input a second time.
              pos = 0;
              firstIteration = false;
              return parseDisjunction();
            }
          }

          return result;
        }

        var regjsparser = {
          parse: parse
        };

        if (typeof module !== 'undefined' && module.exports) {
          module.exports = regjsparser;
        } else {
          window.regjsparser = regjsparser;
        }
      })();
    });

    var require$$3 = parser && (typeof parser === 'undefined' ? 'undefined' : _typeof(parser)) === 'object' && 'default' in parser ? parser['default'] : parser;

    var regjsgen = __commonjs(function (module, exports, global) {
      /*!
       * RegJSGen
       * Copyright 2014 Benjamin Tan <https://d10.github.io/>
       * Available under MIT license <http://d10.mit-license.org/>
       */
      (function () {
        'use strict';

        /** Used to determine if values are of the language type `Object` */

        var objectTypes = {
          'function': true,
          'object': true
        };

        /** Used as a reference to the global object */
        var root = objectTypes[typeof window === 'undefined' ? 'undefined' : _typeof(window)] && window || this;

        /** Backup possible global object */
        var oldRoot = root;

        /** Detect free variable `exports` */
        var freeExports = objectTypes[typeof exports === 'undefined' ? 'undefined' : _typeof(exports)] && exports;

        /** Detect free variable `module` */
        var freeModule = objectTypes[typeof module === 'undefined' ? 'undefined' : _typeof(module)] && module && !module.nodeType && module;

        /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
        var freeGlobal = freeExports && freeModule && (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
        if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
          root = freeGlobal;
        }

        /*--------------------------------------------------------------------------*/

        /*! Based on https://mths.be/fromcodepoint v0.2.0 by @mathias */

        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        function fromCodePoint() {
          var MAX_SIZE = 0x4000;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return '';
          }
          var result = '';
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) != codePoint // not an integer
            ) {
                throw RangeError('Invalid code point: ' + codePoint);
              }
            if (codePoint <= 0xFFFF) {
              // BMP code point
              codeUnits.push(codePoint);
            } else {
              // Astral code point; split in surrogate halves
              // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
              codePoint -= 0x10000;
              highSurrogate = (codePoint >> 10) + 0xD800;
              lowSurrogate = codePoint % 0x400 + 0xDC00;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 == length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        }

        function assertType(type, expected) {
          if (expected.indexOf('|') == -1) {
            if (type == expected) {
              return;
            }

            throw Error('Invalid node type: ' + type);
          }

          expected = assertType.hasOwnProperty(expected) ? assertType[expected] : assertType[expected] = RegExp('^(?:' + expected + ')$');

          if (expected.test(type)) {
            return;
          }

          throw Error('Invalid node type: ' + type);
        }

        /*--------------------------------------------------------------------------*/

        function generate(node) {
          var type = node.type;

          if (generate.hasOwnProperty(type) && typeof generate[type] == 'function') {
            return generate[type](node);
          }

          throw Error('Invalid node type: ' + type);
        }

        /*--------------------------------------------------------------------------*/

        function generateAlternative(node) {
          assertType(node.type, 'alternative');

          var terms = node.body,
              length = terms ? terms.length : 0;

          if (length == 1) {
            return generateTerm(terms[0]);
          } else {
            var i = -1,
                result = '';

            while (++i < length) {
              result += generateTerm(terms[i]);
            }

            return result;
          }
        }

        function generateAnchor(node) {
          assertType(node.type, 'anchor');

          switch (node.kind) {
            case 'start':
              return '^';
            case 'end':
              return '$';
            case 'boundary':
              return '\\b';
            case 'not-boundary':
              return '\\B';
            default:
              throw Error('Invalid assertion');
          }
        }

        function generateAtom(node) {
          assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');

          return generate(node);
        }

        function generateCharacterClass(node) {
          assertType(node.type, 'characterClass');

          var classRanges = node.body,
              length = classRanges ? classRanges.length : 0;

          var i = -1,
              result = '[';

          if (node.negative) {
            result += '^';
          }

          while (++i < length) {
            result += generateClassAtom(classRanges[i]);
          }

          result += ']';

          return result;
        }

        function generateCharacterClassEscape(node) {
          assertType(node.type, 'characterClassEscape');

          return '\\' + node.value;
        }

        function generateCharacterClassRange(node) {
          assertType(node.type, 'characterClassRange');

          var min = node.min,
              max = node.max;

          if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {
            throw Error('Invalid character class range');
          }

          return generateClassAtom(min) + '-' + generateClassAtom(max);
        }

        function generateClassAtom(node) {
          assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');

          return generate(node);
        }

        function generateDisjunction(node) {
          assertType(node.type, 'disjunction');

          var body = node.body,
              length = body ? body.length : 0;

          if (length == 0) {
            throw Error('No body');
          } else if (length == 1) {
            return generate(body[0]);
          } else {
            var i = -1,
                result = '';

            while (++i < length) {
              if (i != 0) {
                result += '|';
              }
              result += generate(body[i]);
            }

            return result;
          }
        }

        function generateDot(node) {
          assertType(node.type, 'dot');

          return '.';
        }

        function generateGroup(node) {
          assertType(node.type, 'group');

          var result = '(';

          switch (node.behavior) {
            case 'normal':
              break;
            case 'ignore':
              result += '?:';
              break;
            case 'lookahead':
              result += '?=';
              break;
            case 'negativeLookahead':
              result += '?!';
              break;
            default:
              throw Error('Invalid behaviour: ' + node.behaviour);
          }

          var body = node.body,
              length = body ? body.length : 0;

          if (length == 1) {
            result += generate(body[0]);
          } else {
            var i = -1;

            while (++i < length) {
              result += generate(body[i]);
            }
          }

          result += ')';

          return result;
        }

        function generateQuantifier(node) {
          assertType(node.type, 'quantifier');

          var quantifier = '',
              min = node.min,
              max = node.max;

          switch (max) {
            case undefined:
            case null:
              switch (min) {
                case 0:
                  quantifier = '*';
                  break;
                case 1:
                  quantifier = '+';
                  break;
                default:
                  quantifier = '{' + min + ',}';
                  break;
              }
              break;
            default:
              if (min == max) {
                quantifier = '{' + min + '}';
              } else if (min == 0 && max == 1) {
                quantifier = '?';
              } else {
                quantifier = '{' + min + ',' + max + '}';
              }
              break;
          }

          if (!node.greedy) {
            quantifier += '?';
          }

          return generateAtom(node.body[0]) + quantifier;
        }

        function generateReference(node) {
          assertType(node.type, 'reference');

          return '\\' + node.matchIndex;
        }

        function generateTerm(node) {
          assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|value');

          return generate(node);
        }

        function generateValue(node) {
          assertType(node.type, 'value');

          var kind = node.kind,
              codePoint = node.codePoint;

          switch (kind) {
            case 'controlLetter':
              return '\\c' + fromCodePoint(codePoint + 64);
            case 'hexadecimalEscape':
              return '\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);
            case 'identifier':
              return '\\' + fromCodePoint(codePoint);
            case 'null':
              return '\\' + codePoint;
            case 'octal':
              return '\\' + codePoint.toString(8);
            case 'singleEscape':
              switch (codePoint) {
                case 0x0008:
                  return '\\b';
                case 0x009:
                  return '\\t';
                case 0x00A:
                  return '\\n';
                case 0x00B:
                  return '\\v';
                case 0x00C:
                  return '\\f';
                case 0x00D:
                  return '\\r';
                default:
                  throw Error('Invalid codepoint: ' + codePoint);
              }
            case 'symbol':
              return fromCodePoint(codePoint);
            case 'unicodeEscape':
              return '\\u' + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);
            case 'unicodeCodePointEscape':
              return '\\u{' + codePoint.toString(16).toUpperCase() + '}';
            default:
              throw Error('Unsupported node kind: ' + kind);
          }
        }

        /*--------------------------------------------------------------------------*/

        generate.alternative = generateAlternative;
        generate.anchor = generateAnchor;
        generate.characterClass = generateCharacterClass;
        generate.characterClassEscape = generateCharacterClassEscape;
        generate.characterClassRange = generateCharacterClassRange;
        generate.disjunction = generateDisjunction;
        generate.dot = generateDot;
        generate.group = generateGroup;
        generate.quantifier = generateQuantifier;
        generate.reference = generateReference;
        generate.value = generateValue;

        /*--------------------------------------------------------------------------*/

        // export regjsgen
        // some AMD build optimizers, like r.js, check for condition patterns like the following:
        if (false) {
          // define as an anonymous module so, through path mapping, it can be aliased
          undefined(function () {
            return {
              'generate': generate
            };
          });
        }
        // check for `exports` after `define` in case a build optimizer adds an `exports` object
        else if (freeExports && freeModule) {
            // in Narwhal, Node.js, Rhino -require, or RingoJS
            freeExports.generate = generate;
          }
          // in a browser or Rhino
          else {
              root.regjsgen = {
                'generate': generate
              };
            }
      }).call(__commonjs_global);
    });

    var require$$4 = regjsgen && (typeof regjsgen === 'undefined' ? 'undefined' : _typeof(regjsgen)) === 'object' && 'default' in regjsgen ? regjsgen['default'] : regjsgen;

    var rewritePattern = __commonjs(function (module) {
      var generate = require$$4.generate;
      var parse = require$$3.parse;
      var regenerate = require$$0$2;
      var iuMappings = require$$1;
      var ESCAPE_SETS = require$$0$1;

      function getCharacterClassEscapeSet(character) {
        if (unicode) {
          if (ignoreCase) {
            return ESCAPE_SETS.UNICODE_IGNORE_CASE[character];
          }
          return ESCAPE_SETS.UNICODE[character];
        }
        return ESCAPE_SETS.REGULAR[character];
      }

      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      function has(object, property) {
        return hasOwnProperty.call(object, property);
      }

      // Prepare a Regenerate set containing all code points, used for negative
      // character classes (if any).
      var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);
      // Without the `u` flag, the range stops at 0xFFFF.
      // https://mths.be/es6#sec-pattern-semantics
      var BMP_SET = regenerate().addRange(0x0, 0xFFFF);

      // Prepare a Regenerate set containing all code points that are supposed to be
      // matched by `/./u`. https://mths.be/es6#sec-atom
      var DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points
      .remove(
      // minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):
      0x000A, // Line Feed <LF>
      0x000D, // Carriage Return <CR>
      0x2028, // Line Separator <LS>
      0x2029 // Paragraph Separator <PS>
      );
      // Prepare a Regenerate set containing all code points that are supposed to be
      // matched by `/./` (only BMP code points).
      var DOT_SET = DOT_SET_UNICODE.clone().intersection(BMP_SET);

      // Add a range of code points + any case-folded code points in that range to a
      // set.
      regenerate.prototype.iuAddRange = function (min, max) {
        var $this = this;
        do {
          var folded = caseFold(min);
          if (folded) {
            $this.add(folded);
          }
        } while (++min <= max);
        return $this;
      };

      function assign(target, source) {
        for (var key in source) {
          // Note: `hasOwnProperty` is not needed here.
          target[key] = source[key];
        }
      }

      function update(item, pattern) {
        // TODO: Test if memoizing `pattern` here is worth the effort.
        if (!pattern) {
          return;
        }
        var tree = parse(pattern, '');
        switch (tree.type) {
          case 'characterClass':
          case 'group':
          case 'value':
            // No wrapping needed.
            break;
          default:
            // Wrap the pattern in a non-capturing group.
            tree = wrap(tree, pattern);
        }
        assign(item, tree);
      }

      function wrap(tree, pattern) {
        // Wrap the pattern in a non-capturing group.
        return {
          'type': 'group',
          'behavior': 'ignore',
          'body': [tree],
          'raw': '(?:' + pattern + ')'
        };
      }

      function caseFold(codePoint) {
        return has(iuMappings, codePoint) ? iuMappings[codePoint] : false;
      }

      var ignoreCase = false;
      var unicode = false;
      function processCharacterClass(characterClassItem) {
        var set$$1 = regenerate();
        var body = characterClassItem.body.forEach(function (item) {
          switch (item.type) {
            case 'value':
              set$$1.add(item.codePoint);
              if (ignoreCase && unicode) {
                var folded = caseFold(item.codePoint);
                if (folded) {
                  set$$1.add(folded);
                }
              }
              break;
            case 'characterClassRange':
              var min = item.min.codePoint;
              var max = item.max.codePoint;
              set$$1.addRange(min, max);
              if (ignoreCase && unicode) {
                set$$1.iuAddRange(min, max);
              }
              break;
            case 'characterClassEscape':
              set$$1.add(getCharacterClassEscapeSet(item.value));
              break;
            // The `default` clause is only here as a safeguard; it should never be
            // reached. Code coverage tools should ignore it.
            /* istanbul ignore next */
            default:
              throw Error('Unknown term type: ' + item.type);
          }
        });
        if (characterClassItem.negative) {
          set$$1 = (unicode ? UNICODE_SET : BMP_SET).clone().remove(set$$1);
        }
        update(characterClassItem, set$$1.toString());
        return characterClassItem;
      }

      function processTerm(item) {
        switch (item.type) {
          case 'dot':
            update(item, (unicode ? DOT_SET_UNICODE : DOT_SET).toString());
            break;
          case 'characterClass':
            item = processCharacterClass(item);
            break;
          case 'characterClassEscape':
            update(item, getCharacterClassEscapeSet(item.value).toString());
            break;
          case 'alternative':
          case 'disjunction':
          case 'group':
          case 'quantifier':
            item.body = item.body.map(processTerm);
            break;
          case 'value':
            var codePoint = item.codePoint;
            var set$$1 = regenerate(codePoint);
            if (ignoreCase && unicode) {
              var folded = caseFold(codePoint);
              if (folded) {
                set$$1.add(folded);
              }
            }
            update(item, set$$1.toString());
            break;
          case 'anchor':
          case 'empty':
          case 'group':
          case 'reference':
            // Nothing to do here.
            break;
          // The `default` clause is only here as a safeguard; it should never be
          // reached. Code coverage tools should ignore it.
          /* istanbul ignore next */
          default:
            throw Error('Unknown term type: ' + item.type);
        }
        return item;
      }

      module.exports = function (pattern, flags) {
        var tree = parse(pattern, flags);
        ignoreCase = flags ? flags.indexOf('i') > -1 : false;
        unicode = flags ? flags.indexOf('u') > -1 : false;
        assign(tree, processTerm(tree));
        return generate(tree);
      };
    });

    var rewritePattern$1 = rewritePattern && (typeof rewritePattern === 'undefined' ? 'undefined' : _typeof(rewritePattern)) === 'object' && 'default' in rewritePattern ? rewritePattern['default'] : rewritePattern;

    var Literal = function (Node) {
      function Literal() {
        Node.apply(this, arguments);
      }

      if (Node) Literal.__proto__ = Node;
      Literal.prototype = Object.create(Node && Node.prototype);
      Literal.prototype.constructor = Literal;

      Literal.prototype.initialise = function initialise() {
        if (typeof this.value === 'string') {
          this.program.indentExclusionElements.push(this);
        }
      };

      Literal.prototype.transpile = function transpile(code, transforms) {
        if (transforms.numericLiteral) {
          var leading = this.raw.slice(0, 2);
          if (leading === '0b' || leading === '0o') {
            code.overwrite(this.start, this.end, String(this.value), true);
          }
        }

        if (this.regex) {
          var ref = this.regex;
          var pattern = ref.pattern;
          var flags = ref.flags;

          if (transforms.stickyRegExp && /y/.test(flags)) throw new CompileError(this, 'Regular expression sticky flag is not supported');
          if (transforms.unicodeRegExp && /u/.test(flags)) {
            code.overwrite(this.start, this.end, "/" + rewritePattern$1(pattern, flags) + "/" + flags.replace('u', ''));
          }
        }
      };

      return Literal;
    }(Node);

    var MemberExpression = function (Node) {
      function MemberExpression() {
        Node.apply(this, arguments);
      }

      if (Node) MemberExpression.__proto__ = Node;
      MemberExpression.prototype = Object.create(Node && Node.prototype);
      MemberExpression.prototype.constructor = MemberExpression;

      MemberExpression.prototype.transpile = function transpile(code, transforms) {
        if (transforms.reservedProperties && reserved[this.property.name]) {
          code.overwrite(this.object.end, this.property.start, "['");
          code.insertLeft(this.property.end, "']");
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      return MemberExpression;
    }(Node);

    var NewExpression = function (Node) {
      function NewExpression() {
        Node.apply(this, arguments);
      }

      if (Node) NewExpression.__proto__ = Node;
      NewExpression.prototype = Object.create(Node && Node.prototype);
      NewExpression.prototype.constructor = NewExpression;

      NewExpression.prototype.initialise = function initialise(transforms) {
        var this$1 = this;

        if (transforms.spreadRest && this.arguments.length) {
          var lexicalBoundary = this.findLexicalBoundary();

          var i = this.arguments.length;
          while (i--) {
            var arg = this$1.arguments[i];
            if (arg.type === 'SpreadElement' && isArguments(arg.argument)) {
              this$1.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();
              break;
            }
          }
        }

        Node.prototype.initialise.call(this, transforms);
      };

      NewExpression.prototype.transpile = function transpile(code, transforms) {
        if (transforms.spreadRest && this.arguments.length) {
          var firstArgument = this.arguments[0];
          var isNew = true;
          var hasSpreadElements = spread(code, this.arguments, firstArgument.start, this.argumentsArrayAlias, isNew);

          if (hasSpreadElements) {
            code.insertRight(this.start + 'new'.length, ' (Function.prototype.bind.apply(');
            code.overwrite(this.callee.end, firstArgument.start, ', [ null ].concat( ');
            code.insertLeft(this.end, ' ))');
          }
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      return NewExpression;
    }(Node);

    var ObjectExpression = function (Node) {
      function ObjectExpression() {
        Node.apply(this, arguments);
      }

      if (Node) ObjectExpression.__proto__ = Node;
      ObjectExpression.prototype = Object.create(Node && Node.prototype);
      ObjectExpression.prototype.constructor = ObjectExpression;

      ObjectExpression.prototype.transpile = function transpile(code, transforms) {
        var this$1 = this;

        Node.prototype.transpile.call(this, code, transforms);

        var firstPropertyStart = this.start + 1;
        var regularPropertyCount = 0;
        var spreadPropertyCount = 0;
        var computedPropertyCount = 0;

        for (var i$2 = 0, list = this.properties; i$2 < list.length; i$2 += 1) {
          var prop = list[i$2];

          if (prop.type === 'SpreadProperty') {
            spreadPropertyCount += 1;
          } else if (prop.computed) {
            computedPropertyCount += 1;
          } else if (prop.type === 'Property') {
            regularPropertyCount += 1;
          }
        }

        if (spreadPropertyCount) {
          if (!this.program.options.objectAssign) {
            throw new CompileError(this, 'Object spread operator requires specified objectAssign option with \'Object.assign\' or polyfill helper.');
          }
          // enclose run of non-spread properties in curlies
          var i = this.properties.length;
          if (regularPropertyCount) {
            while (i--) {
              var prop$1 = this$1.properties[i];

              if (prop$1.type === 'Property' && !prop$1.computed) {
                var lastProp = this$1.properties[i - 1];
                var nextProp = this$1.properties[i + 1];

                if (!lastProp || lastProp.type !== 'Property' || lastProp.computed) {
                  code.insertRight(prop$1.start, '{');
                }

                if (!nextProp || nextProp.type !== 'Property' || nextProp.computed) {
                  code.insertLeft(prop$1.end, '}');
                }
              }
            }
          }

          // wrap the whole thing in Object.assign
          firstPropertyStart = this.properties[0].start;
          code.overwrite(this.start, firstPropertyStart, this.program.options.objectAssign + "({}, ");
          code.overwrite(this.properties[this.properties.length - 1].end, this.end, ')');
        }

        if (computedPropertyCount && transforms.computedProperty) {
          var i0 = this.getIndentation();

          var isSimpleAssignment;
          var name;

          if (this.parent.type === 'VariableDeclarator' && this.parent.parent.declarations.length === 1) {
            isSimpleAssignment = true;
            name = this.parent.id.alias || this.parent.id.name; // TODO is this right?
          } else if (this.parent.type === 'AssignmentExpression' && this.parent.parent.type === 'ExpressionStatement' && this.parent.left.type === 'Identifier') {
            isSimpleAssignment = true;
            name = this.parent.left.alias || this.parent.left.name; // TODO is this right?
          } else if (this.parent.type === 'AssignmentPattern' && this.parent.left.type === 'Identifier') {
            isSimpleAssignment = true;
            name = this.parent.left.alias || this.parent.left.name; // TODO is this right?
          }

          // handle block scoping
          var declaration = this.findScope(false).findDeclaration(name);
          if (declaration) name = declaration.name;

          var start = firstPropertyStart;
          var end = this.end;

          if (isSimpleAssignment) {
            // ???
          } else {
            name = this.findScope(true).createIdentifier('obj');

            var statement = this.findNearest(/(?:Statement|Declaration)$/);
            code.insertLeft(statement.end, "\n" + i0 + "var " + name + ";");

            code.insertRight(this.start, "( " + name + " = ");
          }

          var len = this.properties.length;
          var lastComputedProp;
          var sawNonComputedProperty = false;

          for (var i$1 = 0; i$1 < len; i$1 += 1) {
            var prop$2 = this$1.properties[i$1];

            if (prop$2.computed) {
              lastComputedProp = prop$2;
              var moveStart = i$1 > 0 ? this$1.properties[i$1 - 1].end : start;

              var propId = isSimpleAssignment ? ";\n" + i0 + name : ", " + name;

              if (moveStart < prop$2.start) {
                code.overwrite(moveStart, prop$2.start, propId);
              } else {
                code.insertRight(prop$2.start, propId);
              }

              var c = prop$2.key.end;
              while (code.original[c] !== ']') {
                c += 1;
              }c += 1;

              if (prop$2.value.start > c) code.remove(c, prop$2.value.start);
              code.insertLeft(c, ' = ');
              code.move(moveStart, prop$2.end, end);

              if (i$1 < len - 1 && !sawNonComputedProperty) {
                // remove trailing comma
                c = prop$2.end;
                while (code.original[c] !== ',') {
                  c += 1;
                }code.remove(prop$2.end, c + 1);
              }

              if (prop$2.method && transforms.conciseMethodProperty) {
                code.insertRight(prop$2.value.start, 'function ');
              }
            } else {
              sawNonComputedProperty = true;
            }
          }

          // special case
          if (computedPropertyCount === len) {
            code.remove(this.properties[len - 1].end, this.end - 1);
          }

          if (!isSimpleAssignment) {
            code.insertLeft(lastComputedProp.end, ", " + name + " )");
          }
        }
      };

      return ObjectExpression;
    }(Node);

    var Property = function (Node) {
      function Property() {
        Node.apply(this, arguments);
      }

      if (Node) Property.__proto__ = Node;
      Property.prototype = Object.create(Node && Node.prototype);
      Property.prototype.constructor = Property;

      Property.prototype.transpile = function transpile(code, transforms) {
        if (transforms.conciseMethodProperty && !this.computed && this.parent.type !== 'ObjectPattern') {
          if (this.shorthand) {
            code.insertRight(this.start, this.key.name + ": ");
          } else if (this.method) {
            var name = '';
            if (this.program.options.namedFunctionExpressions !== false) {
              if (this.key.type === 'Literal' && typeof this.key.value === 'number') {
                name = "";
              } else if (this.key.type === 'Identifier') {
                if (reserved[this.key.name] || !/^[a-z_$][a-z0-9_$]*$/i.test(this.key.name) || this.value.body.scope.references[this.key.name]) {
                  name = this.findScope(true).createIdentifier(this.key.name);
                } else {
                  name = this.key.name;
                }
              } else {
                name = this.findScope(true).createIdentifier(this.key.value);
              }
              name = ' ' + name;
            }

            if (this.value.generator) code.remove(this.start, this.key.start);
            code.insertLeft(this.key.end, ": function" + (this.value.generator ? '*' : '') + name);
          }
        }

        if (transforms.reservedProperties && reserved[this.key.name]) {
          code.insertRight(this.key.start, "'");
          code.insertLeft(this.key.end, "'");
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      return Property;
    }(Node);

    var ReturnStatement = function (Node) {
      function ReturnStatement() {
        Node.apply(this, arguments);
      }

      if (Node) ReturnStatement.__proto__ = Node;
      ReturnStatement.prototype = Object.create(Node && Node.prototype);
      ReturnStatement.prototype.constructor = ReturnStatement;

      ReturnStatement.prototype.initialise = function initialise(transforms) {
        this.loop = this.findNearest(loopStatement);
        this.nearestFunction = this.findNearest(/Function/);

        if (this.loop && (!this.nearestFunction || this.loop.depth > this.nearestFunction.depth)) {
          this.loop.canReturn = true;
          this.shouldWrap = true;
        }

        if (this.argument) this.argument.initialise(transforms);
      };

      ReturnStatement.prototype.transpile = function transpile(code, transforms) {
        var shouldWrap = this.shouldWrap && this.loop && this.loop.shouldRewriteAsFunction;

        if (this.argument) {
          if (shouldWrap) code.insertRight(this.argument.start, "{ v: ");
          this.argument.transpile(code, transforms);
          if (shouldWrap) code.insertLeft(this.argument.end, " }");
        } else if (shouldWrap) {
          code.insertLeft(this.start + 6, ' {}');
        }
      };

      return ReturnStatement;
    }(Node);

    var SpreadProperty = function (Node) {
      function SpreadProperty() {
        Node.apply(this, arguments);
      }

      if (Node) SpreadProperty.__proto__ = Node;
      SpreadProperty.prototype = Object.create(Node && Node.prototype);
      SpreadProperty.prototype.constructor = SpreadProperty;

      SpreadProperty.prototype.transpile = function transpile(code, transforms) {
        code.remove(this.start, this.argument.start);
        code.remove(this.argument.end, this.end);

        Node.prototype.transpile.call(this, code, transforms);
      };

      return SpreadProperty;
    }(Node);

    var Super = function (Node) {
      function Super() {
        Node.apply(this, arguments);
      }

      if (Node) Super.__proto__ = Node;
      Super.prototype = Object.create(Node && Node.prototype);
      Super.prototype.constructor = Super;

      Super.prototype.initialise = function initialise(transforms) {
        if (transforms.classes) {
          this.method = this.findNearest('MethodDefinition');
          if (!this.method) throw new CompileError(this, 'use of super outside class method');

          var parentClass = this.findNearest('ClassBody').parent;
          this.superClassName = parentClass.superClass && (parentClass.superClass.name || 'superclass');

          if (!this.superClassName) throw new CompileError(this, 'super used in base class');

          this.isCalled = this.parent.type === 'CallExpression' && this === this.parent.callee;

          if (this.method.kind !== 'constructor' && this.isCalled) {
            throw new CompileError(this, 'super() not allowed outside class constructor');
          }

          this.isMember = this.parent.type === 'MemberExpression';

          if (!this.isCalled && !this.isMember) {
            throw new CompileError(this, 'Unexpected use of `super` (expected `super(...)` or `super.*`)');
          }
        }

        if (transforms.arrow) {
          var lexicalBoundary = this.findLexicalBoundary();
          var arrowFunction = this.findNearest('ArrowFunctionExpression');
          var loop = this.findNearest(loopStatement);

          if (arrowFunction && arrowFunction.depth > lexicalBoundary.depth) {
            this.thisAlias = lexicalBoundary.getThisAlias();
          }

          if (loop && loop.body.contains(this) && loop.depth > lexicalBoundary.depth) {
            this.thisAlias = lexicalBoundary.getThisAlias();
          }
        }
      };

      Super.prototype.transpile = function transpile(code, transforms) {
        if (transforms.classes) {
          var expression = this.isCalled || this.method.static ? this.superClassName : this.superClassName + ".prototype";

          code.overwrite(this.start, this.end, expression, true);

          var callExpression = this.isCalled ? this.parent : this.parent.parent;

          if (callExpression && callExpression.type === 'CallExpression') {
            if (!this.noCall) {
              // special case – `super( ...args )`
              code.insertLeft(callExpression.callee.end, '.call');
            }

            var thisAlias = this.thisAlias || 'this';

            if (callExpression.arguments.length) {
              code.insertLeft(callExpression.arguments[0].start, thisAlias + ", ");
            } else {
              code.insertLeft(callExpression.end - 1, "" + thisAlias);
            }
          }
        }
      };

      return Super;
    }(Node);

    var TaggedTemplateExpression = function (Node) {
      function TaggedTemplateExpression() {
        Node.apply(this, arguments);
      }

      if (Node) TaggedTemplateExpression.__proto__ = Node;
      TaggedTemplateExpression.prototype = Object.create(Node && Node.prototype);
      TaggedTemplateExpression.prototype.constructor = TaggedTemplateExpression;

      TaggedTemplateExpression.prototype.initialise = function initialise(transforms) {
        if (transforms.templateString && !transforms.dangerousTaggedTemplateString) {
          throw new CompileError(this, 'Tagged template strings are not supported. Use `transforms: { templateString: false }` to skip transformation and disable this error, or `transforms: { dangerousTaggedTemplateString: true }` if you know what you\'re doing');
        }

        Node.prototype.initialise.call(this, transforms);
      };

      TaggedTemplateExpression.prototype.transpile = function transpile(code, transforms) {
        if (transforms.templateString && transforms.dangerousTaggedTemplateString) {
          var ordered = this.quasi.expressions.concat(this.quasi.quasis).sort(function (a, b) {
            return a.start - b.start;
          });

          // insert strings at start
          var templateStrings = this.quasi.quasis.map(function (quasi) {
            return JSON.stringify(quasi.value.cooked);
          });
          code.overwrite(this.tag.end, ordered[0].start, "([" + templateStrings.join(', ') + "]");

          var lastIndex = ordered[0].start;
          ordered.forEach(function (node) {
            if (node.type === 'TemplateElement') {
              code.remove(lastIndex, node.end);
            } else {
              code.overwrite(lastIndex, node.start, ', ');
            }

            lastIndex = node.end;
          });

          code.overwrite(lastIndex, this.end, ')');
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      return TaggedTemplateExpression;
    }(Node);

    var TemplateElement = function (Node) {
      function TemplateElement() {
        Node.apply(this, arguments);
      }

      if (Node) TemplateElement.__proto__ = Node;
      TemplateElement.prototype = Object.create(Node && Node.prototype);
      TemplateElement.prototype.constructor = TemplateElement;

      TemplateElement.prototype.initialise = function initialise() {
        this.program.indentExclusionElements.push(this);
      };

      return TemplateElement;
    }(Node);

    var TemplateLiteral = function (Node) {
      function TemplateLiteral() {
        Node.apply(this, arguments);
      }

      if (Node) TemplateLiteral.__proto__ = Node;
      TemplateLiteral.prototype = Object.create(Node && Node.prototype);
      TemplateLiteral.prototype.constructor = TemplateLiteral;

      TemplateLiteral.prototype.transpile = function transpile(code, transforms) {
        if (transforms.templateString && this.parent.type !== 'TaggedTemplateExpression') {
          var ordered = this.expressions.concat(this.quasis).sort(function (a, b) {
            return a.start - b.start || a.end - b.end;
          }).filter(function (node, i) {
            // include all expressions
            if (node.type !== 'TemplateElement') return true;

            // include all non-empty strings
            if (node.value.raw) return true;

            // exclude all empty strings not at the head
            return !i;
          });

          // special case – we may be able to skip the first element,
          // if it's the empty string, but only if the second and
          // third elements aren't both expressions (since they maybe
          // be numeric, and `1 + 2 + '3' === '33'`)
          if (ordered.length >= 3) {
            var first = ordered[0];
            var third = ordered[2];
            if (first.type === 'TemplateElement' && first.value.raw === '' && third.type === 'TemplateElement') {
              ordered.shift();
            }
          }

          var parenthesise = (this.quasis.length !== 1 || this.expressions.length !== 0) && this.parent.type !== 'AssignmentExpression' && this.parent.type !== 'AssignmentPattern' && this.parent.type !== 'VariableDeclarator' && (this.parent.type !== 'BinaryExpression' || this.parent.operator !== '+');

          if (parenthesise) code.insertRight(this.start, '(');

          var lastIndex = this.start;

          ordered.forEach(function (node, i) {
            if (node.type === 'TemplateElement') {
              var replacement = '';
              if (i) replacement += ' + ';
              replacement += JSON.stringify(node.value.cooked);

              code.overwrite(lastIndex, node.end, replacement);
            } else {
              var parenthesise = node.type !== 'Identifier'; // TODO other cases where it's safe

              var replacement$1 = '';
              if (i) replacement$1 += ' + ';
              if (parenthesise) replacement$1 += '(';

              code.overwrite(lastIndex, node.start, replacement$1);

              if (parenthesise) code.insertLeft(node.end, ')');
            }

            lastIndex = node.end;
          });

          var close = '';
          if (parenthesise) close += ')';

          code.overwrite(lastIndex, this.end, close);
        }

        Node.prototype.transpile.call(this, code, transforms);
      };

      return TemplateLiteral;
    }(Node);

    var ThisExpression = function (Node) {
      function ThisExpression() {
        Node.apply(this, arguments);
      }

      if (Node) ThisExpression.__proto__ = Node;
      ThisExpression.prototype = Object.create(Node && Node.prototype);
      ThisExpression.prototype.constructor = ThisExpression;

      ThisExpression.prototype.initialise = function initialise(transforms) {
        if (transforms.arrow) {
          var lexicalBoundary = this.findLexicalBoundary();
          var arrowFunction = this.findNearest('ArrowFunctionExpression');
          var loop = this.findNearest(loopStatement);

          if (arrowFunction && arrowFunction.depth > lexicalBoundary.depth || loop && loop.body.contains(this) && loop.depth > lexicalBoundary.depth || loop && loop.right && loop.right.contains(this)) {
            this.alias = lexicalBoundary.getThisAlias();
          }
        }
      };

      ThisExpression.prototype.transpile = function transpile(code) {
        if (this.alias) {
          code.overwrite(this.start, this.end, this.alias, true);
        }
      };

      return ThisExpression;
    }(Node);

    var UpdateExpression = function (Node) {
      function UpdateExpression() {
        Node.apply(this, arguments);
      }

      if (Node) UpdateExpression.__proto__ = Node;
      UpdateExpression.prototype = Object.create(Node && Node.prototype);
      UpdateExpression.prototype.constructor = UpdateExpression;

      UpdateExpression.prototype.initialise = function initialise(transforms) {
        if (this.argument.type === 'Identifier') {
          var declaration = this.findScope(false).findDeclaration(this.argument.name);
          if (declaration && declaration.kind === 'const') {
            throw new CompileError(this, this.argument.name + " is read-only");
          }

          // special case – https://gitlab.com/Rich-Harris/buble/issues/150
          var statement = declaration && declaration.node.ancestor(3);
          if (statement && statement.type === 'ForStatement' && statement.body.contains(this)) {
            statement.reassigned[this.argument.name] = true;
          }
        }

        Node.prototype.initialise.call(this, transforms);
      };

      return UpdateExpression;
    }(Node);

    var VariableDeclaration = function (Node) {
      function VariableDeclaration() {
        Node.apply(this, arguments);
      }

      if (Node) VariableDeclaration.__proto__ = Node;
      VariableDeclaration.prototype = Object.create(Node && Node.prototype);
      VariableDeclaration.prototype.constructor = VariableDeclaration;

      VariableDeclaration.prototype.initialise = function initialise(transforms) {
        this.scope = this.findScope(this.kind === 'var');
        this.declarations.forEach(function (declarator) {
          return declarator.initialise(transforms);
        });
      };

      VariableDeclaration.prototype.transpile = function transpile(code, transforms) {
        var this$1 = this;

        var i0 = this.getIndentation();
        var kind = this.kind;

        if (transforms.letConst && kind !== 'var') {
          kind = 'var';
          code.overwrite(this.start, this.start + this.kind.length, kind, true);
        }

        if (transforms.destructuring && this.parent.type !== 'ForOfStatement') {
          var c = this.start;
          var lastDeclaratorIsPattern;

          this.declarations.forEach(function (declarator, i) {
            if (declarator.id.type === 'Identifier') {
              if (i > 0 && this$1.declarations[i - 1].id.type !== 'Identifier') {
                code.overwrite(c, declarator.id.start, "var ");
              }
            } else {
              var inline = loopStatement.test(this$1.parent.type);

              if (i === 0) {
                code.remove(c, declarator.id.start);
              } else {
                code.overwrite(c, declarator.id.start, ";\n" + i0);
              }

              var simple = declarator.init.type === 'Identifier' && !declarator.init.rewritten;

              var name = simple ? declarator.init.name : declarator.findScope(true).createIdentifier('ref');

              var c$1 = declarator.start;

              var statementGenerators = [];

              if (simple) {
                code.remove(declarator.id.end, declarator.end);
              } else {
                statementGenerators.push(function (start, prefix, suffix) {
                  code.insertRight(declarator.id.end, "var " + name);
                  code.insertLeft(declarator.init.end, "" + suffix);
                  code.move(declarator.id.end, declarator.end, start);
                });
              }

              destructure(code, declarator.findScope(false), declarator.id, name, inline, statementGenerators);

              var prefix = inline ? 'var ' : '';
              var suffix = inline ? ", " : ";\n" + i0;
              statementGenerators.forEach(function (fn, j) {
                if (i === this$1.declarations.length - 1 && j === statementGenerators.length - 1) {
                  suffix = inline ? '' : ';';
                }

                fn(declarator.start, j === 0 ? prefix : '', suffix);
              });
            }

            declarator.transpile(code, transforms);

            c = declarator.end;
            lastDeclaratorIsPattern = declarator.id.type !== 'Identifier';
          });

          if (lastDeclaratorIsPattern) {
            code.remove(c, this.end);
          }
        } else {
          this.declarations.forEach(function (declarator) {
            declarator.transpile(code, transforms);
          });
        }
      };

      return VariableDeclaration;
    }(Node);

    var VariableDeclarator = function (Node) {
      function VariableDeclarator() {
        Node.apply(this, arguments);
      }

      if (Node) VariableDeclarator.__proto__ = Node;
      VariableDeclarator.prototype = Object.create(Node && Node.prototype);
      VariableDeclarator.prototype.constructor = VariableDeclarator;

      VariableDeclarator.prototype.initialise = function initialise(transforms) {
        var kind = this.parent.kind;
        if (kind === 'let' && this.parent.parent.type === 'ForStatement') {
          kind = 'for.let'; // special case...
        }

        this.parent.scope.addDeclaration(this.id, kind);
        Node.prototype.initialise.call(this, transforms);
      };

      VariableDeclarator.prototype.transpile = function transpile(code, transforms) {
        if (!this.init && transforms.letConst && this.parent.kind !== 'var') {
          var inLoop = this.findNearest(/Function|^For(In|Of)?Statement|^(?:Do)?WhileStatement/);
          if (inLoop && !/Function/.test(inLoop.type) && !this.isLeftDeclaratorOfLoop()) {
            code.insertLeft(this.id.end, ' = (void 0)');
          }
        }

        if (this.id) this.id.transpile(code, transforms);
        if (this.init) this.init.transpile(code, transforms);
      };

      VariableDeclarator.prototype.isLeftDeclaratorOfLoop = function isLeftDeclaratorOfLoop() {
        return this.parent && this.parent.type === 'VariableDeclaration' && this.parent.parent && (this.parent.parent.type === 'ForInStatement' || this.parent.parent.type === 'ForOfStatement') && this.parent.parent.left && this.parent.parent.left.declarations[0] === this;
      };

      return VariableDeclarator;
    }(Node);

    var types = {
      ArrayExpression: ArrayExpression,
      ArrowFunctionExpression: ArrowFunctionExpression,
      AssignmentExpression: AssignmentExpression,
      BinaryExpression: BinaryExpression,
      BreakStatement: BreakStatement,
      CallExpression: CallExpression,
      ClassBody: ClassBody,
      ClassDeclaration: ClassDeclaration,
      ClassExpression: ClassExpression,
      ContinueStatement: ContinueStatement,
      DoWhileStatement: LoopStatement,
      ExportNamedDeclaration: ExportNamedDeclaration,
      ExportDefaultDeclaration: ExportDefaultDeclaration,
      ForStatement: ForStatement,
      ForInStatement: ForInStatement,
      ForOfStatement: ForOfStatement,
      FunctionDeclaration: FunctionDeclaration,
      FunctionExpression: FunctionExpression,
      Identifier: Identifier,
      IfStatement: IfStatement,
      ImportDeclaration: ImportDeclaration,
      ImportDefaultSpecifier: ImportDefaultSpecifier,
      ImportSpecifier: ImportSpecifier,
      JSXAttribute: JSXAttribute,
      JSXClosingElement: JSXClosingElement,
      JSXElement: JSXElement,
      JSXExpressionContainer: JSXExpressionContainer,
      JSXOpeningElement: JSXOpeningElement,
      JSXSpreadAttribute: JSXSpreadAttribute,
      Literal: Literal,
      MemberExpression: MemberExpression,
      NewExpression: NewExpression,
      ObjectExpression: ObjectExpression,
      Property: Property,
      ReturnStatement: ReturnStatement,
      SpreadProperty: SpreadProperty,
      Super: Super,
      TaggedTemplateExpression: TaggedTemplateExpression,
      TemplateElement: TemplateElement,
      TemplateLiteral: TemplateLiteral,
      ThisExpression: ThisExpression,
      UpdateExpression: UpdateExpression,
      VariableDeclaration: VariableDeclaration,
      VariableDeclarator: VariableDeclarator,
      WhileStatement: LoopStatement
    };

    var statementsWithBlocks = {
      IfStatement: 'consequent',
      ForStatement: 'body',
      ForInStatement: 'body',
      ForOfStatement: 'body',
      WhileStatement: 'body',
      DoWhileStatement: 'body',
      ArrowFunctionExpression: 'body'
    };

    function wrap(raw, parent) {
      if (!raw) return;

      if ('length' in raw) {
        var i = raw.length;
        while (i--) {
          wrap(raw[i], parent);
        }return;
      }

      // with e.g. shorthand properties, key and value are
      // the same node. We don't want to wrap an object twice
      if (raw.__wrapped) return;
      raw.__wrapped = true;

      if (!keys[raw.type]) {
        keys[raw.type] = Object.keys(raw).filter(function (key) {
          return _typeof(raw[key]) === 'object';
        });
      }

      // special case – body-less if/for/while statements. TODO others?
      var bodyType = statementsWithBlocks[raw.type];
      if (bodyType && raw[bodyType].type !== 'BlockStatement') {
        var expression = raw[bodyType];

        // create a synthetic block statement, otherwise all hell
        // breaks loose when it comes to block scoping
        raw[bodyType] = {
          start: expression.start,
          end: expression.end,
          type: 'BlockStatement',
          body: [expression],
          synthetic: true
        };
      }

      new Node(raw, parent);

      var type = (raw.type === 'BlockStatement' ? BlockStatement : types[raw.type]) || Node;
      raw.__proto__ = type.prototype;
    }

    var letConst = /^(?:let|const)$/;

    function Scope(options) {
      options = options || {};

      this.parent = options.parent;
      this.isBlockScope = !!options.block;

      var scope = this;
      while (scope.isBlockScope) {
        scope = scope.parent;
      }this.functionScope = scope;

      this.identifiers = [];
      this.declarations = Object.create(null);
      this.references = Object.create(null);
      this.blockScopedDeclarations = this.isBlockScope ? null : Object.create(null);
      this.aliases = this.isBlockScope ? null : Object.create(null);
    }

    Scope.prototype = {
      addDeclaration: function addDeclaration(node, kind) {
        for (var i = 0, list = extractNames(node); i < list.length; i += 1) {
          var identifier = list[i];

          var name = identifier.name;
          var existingDeclaration = this.declarations[name];
          if (existingDeclaration && (letConst.test(kind) || letConst.test(existingDeclaration.kind))) {
            // TODO warn about double var declarations?
            throw new CompileError(identifier, name + " is already declared");
          }

          var declaration = { name: name, node: identifier, kind: kind, instances: [] };
          this.declarations[name] = declaration;

          if (this.isBlockScope) {
            if (!this.functionScope.blockScopedDeclarations[name]) this.functionScope.blockScopedDeclarations[name] = [];
            this.functionScope.blockScopedDeclarations[name].push(declaration);
          }
        }
      },

      addReference: function addReference(identifier) {
        if (this.consolidated) {
          this.consolidateReference(identifier);
        } else {
          this.identifiers.push(identifier);
        }
      },

      consolidate: function consolidate() {
        var this$1 = this;

        for (var i = 0; i < this$1.identifiers.length; i += 1) {
          // we might push to the array during consolidation, so don't cache length
          var identifier = this$1.identifiers[i];
          this$1.consolidateReference(identifier);
        }

        this.consolidated = true; // TODO understand why this is necessary... seems bad
      },

      consolidateReference: function consolidateReference(identifier) {
        var declaration = this.declarations[identifier.name];
        if (declaration) {
          declaration.instances.push(identifier);
        } else {
          this.references[identifier.name] = true;
          if (this.parent) this.parent.addReference(identifier);
        }
      },

      contains: function contains(name) {
        return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
      },

      createIdentifier: function createIdentifier(base) {
        var this$1 = this;

        if (typeof base === 'number') base = base.toString();

        base = base.replace(/\s/g, '').replace(/\[([^\]]+)\]/g, '_$1').replace(/[^a-zA-Z0-9_$]/g, '_').replace(/_{2,}/, '_');

        var name = base;
        var counter = 1;

        while (this$1.declarations[name] || this$1.references[name] || this$1.aliases[name] || name in reserved) {
          name = base + "$" + counter++;
        }

        this.aliases[name] = true;
        return name;
      },

      findDeclaration: function findDeclaration(name) {
        return this.declarations[name] || this.parent && this.parent.findDeclaration(name);
      }
    };

    function isUseStrict(node) {
      if (!node) return false;
      if (node.type !== 'ExpressionStatement') return false;
      if (node.expression.type !== 'Literal') return false;
      return node.expression.value === 'use strict';
    }

    var BlockStatement = function (Node) {
      function BlockStatement() {
        Node.apply(this, arguments);
      }

      if (Node) BlockStatement.__proto__ = Node;
      BlockStatement.prototype = Object.create(Node && Node.prototype);
      BlockStatement.prototype.constructor = BlockStatement;

      BlockStatement.prototype.createScope = function createScope() {
        var this$1 = this;

        this.parentIsFunction = /Function/.test(this.parent.type);
        this.isFunctionBlock = this.parentIsFunction || this.parent.type === 'Root';
        this.scope = new Scope({
          block: !this.isFunctionBlock,
          parent: this.parent.findScope(false)
        });

        if (this.parentIsFunction) {
          this.parent.params.forEach(function (node) {
            this$1.scope.addDeclaration(node, 'param');
          });
        }
      };

      BlockStatement.prototype.initialise = function initialise(transforms) {
        this.thisAlias = null;
        this.argumentsAlias = null;
        this.defaultParameters = [];

        // normally the scope gets created here, during initialisation,
        // but in some cases (e.g. `for` statements), we need to create
        // the scope early, as it pertains to both the init block and
        // the body of the statement
        if (!this.scope) this.createScope();

        this.body.forEach(function (node) {
          return node.initialise(transforms);
        });

        this.scope.consolidate();
      };

      BlockStatement.prototype.findLexicalBoundary = function findLexicalBoundary() {
        if (this.type === 'Program') return this;
        if (/^Function/.test(this.parent.type)) return this;

        return this.parent.findLexicalBoundary();
      };

      BlockStatement.prototype.findScope = function findScope(functionScope) {
        if (functionScope && !this.isFunctionBlock) return this.parent.findScope(functionScope);
        return this.scope;
      };

      BlockStatement.prototype.getArgumentsAlias = function getArgumentsAlias() {
        if (!this.argumentsAlias) {
          this.argumentsAlias = this.scope.createIdentifier('arguments');
        }

        return this.argumentsAlias;
      };

      BlockStatement.prototype.getArgumentsArrayAlias = function getArgumentsArrayAlias() {
        if (!this.argumentsArrayAlias) {
          this.argumentsArrayAlias = this.scope.createIdentifier('argsArray');
        }

        return this.argumentsArrayAlias;
      };

      BlockStatement.prototype.getThisAlias = function getThisAlias() {
        if (!this.thisAlias) {
          this.thisAlias = this.scope.createIdentifier('this');
        }

        return this.thisAlias;
      };

      BlockStatement.prototype.getIndentation = function getIndentation() {
        var this$1 = this;

        if (this.indentation === undefined) {
          var source = this.program.magicString.original;

          var useOuter = this.synthetic || !this.body.length;
          var c = useOuter ? this.start : this.body[0].start;

          while (c && source[c] !== '\n') {
            c -= 1;
          }this.indentation = '';

          while (true) {
            // eslint-disable-line no-constant-condition
            c += 1;
            var char = source[c];

            if (char !== ' ' && char !== '\t') break;

            this$1.indentation += char;
          }

          var indentString = this.program.magicString.getIndentString();

          // account for dedented class constructors
          var parent = this.parent;
          while (parent) {
            if (parent.kind === 'constructor' && !parent.parent.parent.superClass) {
              this$1.indentation = this$1.indentation.replace(indentString, '');
            }

            parent = parent.parent;
          }

          if (useOuter) this.indentation += indentString;
        }

        return this.indentation;
      };

      BlockStatement.prototype.transpile = function transpile(code, transforms) {
        var this$1 = this;

        var indentation = this.getIndentation();

        var introStatementGenerators = [];

        if (this.argumentsAlias) {
          introStatementGenerators.push(function (start, prefix, suffix) {
            var assignment = prefix + "var " + this$1.argumentsAlias + " = arguments" + suffix;
            code.insertLeft(start, assignment);
          });
        }

        if (this.thisAlias) {
          introStatementGenerators.push(function (start, prefix, suffix) {
            var assignment = prefix + "var " + this$1.thisAlias + " = this" + suffix;
            code.insertLeft(start, assignment);
          });
        }

        if (this.argumentsArrayAlias) {
          introStatementGenerators.push(function (start, prefix, suffix) {
            var i = this$1.scope.createIdentifier('i');
            var assignment = prefix + "var " + i + " = arguments.length, " + this$1.argumentsArrayAlias + " = Array(" + i + ");\n" + indentation + "while ( " + i + "-- ) " + this$1.argumentsArrayAlias + "[" + i + "] = arguments[" + i + "]" + suffix;
            code.insertLeft(start, assignment);
          });
        }

        if (/Function/.test(this.parent.type)) {
          this.transpileParameters(code, transforms, indentation, introStatementGenerators);
        }

        if (transforms.letConst && this.isFunctionBlock) {
          this.transpileBlockScopedIdentifiers(code);
        }

        Node.prototype.transpile.call(this, code, transforms);

        if (this.synthetic) {
          if (this.parent.type === 'ArrowFunctionExpression') {
            var expr = this.body[0];

            if (introStatementGenerators.length) {
              code.insertLeft(this.start, "{").insertRight(this.end, this.parent.getIndentation() + "}");

              code.insertRight(expr.start, "\n" + indentation + "return ");
              code.insertLeft(expr.end, ";\n");
            } else if (transforms.arrow) {
              code.insertLeft(expr.start, "{ return ");
              code.insertLeft(expr.end, "; }");
            }
          } else if (introStatementGenerators.length) {
            code.insertLeft(this.start, "{").insertRight(this.end, "}");
          }
        }

        var start;
        if (isUseStrict(this.body[0])) {
          start = this.body[0].end;
        } else if (this.synthetic || this.parent.type === 'Root') {
          start = this.start;
        } else {
          start = this.start + 1;
        }

        var prefix = "\n" + indentation;
        var suffix = ';';
        introStatementGenerators.forEach(function (fn, i) {
          if (i === introStatementGenerators.length - 1) suffix = ";\n";
          fn(start, prefix, suffix);
        });
      };

      BlockStatement.prototype.transpileParameters = function transpileParameters(code, transforms, indentation, introStatementGenerators) {
        var this$1 = this;

        var params = this.parent.params;

        params.forEach(function (param) {
          if (param.type === 'AssignmentPattern' && param.left.type === 'Identifier') {
            if (transforms.defaultParameter) {
              introStatementGenerators.push(function (start, prefix, suffix) {
                var lhs = prefix + "if ( " + param.left.name + " === void 0 ) " + param.left.name;

                code.insertRight(param.left.end, lhs).move(param.left.end, param.right.end, start).insertLeft(param.right.end, suffix);
              });
            }
          } else if (param.type === 'RestElement') {
            if (transforms.spreadRest) {
              introStatementGenerators.push(function (start, prefix, suffix) {
                var penultimateParam = params[params.length - 2];

                if (penultimateParam) {
                  code.remove(penultimateParam ? penultimateParam.end : param.start, param.end);
                } else {
                  var start$1 = param.start,
                      end = param.end; // TODO https://gitlab.com/Rich-Harris/buble/issues/8

                  while (/\s/.test(code.original[start$1 - 1])) {
                    start$1 -= 1;
                  }while (/\s/.test(code.original[end])) {
                    end += 1;
                  }code.remove(start$1, end);
                }

                var name = param.argument.name;
                var len = this$1.scope.createIdentifier('len');
                var count = params.length - 1;

                if (count) {
                  code.insertLeft(start, prefix + "var " + name + " = [], " + len + " = arguments.length - " + count + ";\n" + indentation + "while ( " + len + "-- > 0 ) " + name + "[ " + len + " ] = arguments[ " + len + " + " + count + " ]" + suffix);
                } else {
                  code.insertLeft(start, prefix + "var " + name + " = [], " + len + " = arguments.length;\n" + indentation + "while ( " + len + "-- ) " + name + "[ " + len + " ] = arguments[ " + len + " ]" + suffix);
                }
              });
            }
          } else if (param.type !== 'Identifier') {
            if (transforms.parameterDestructuring) {
              var ref = this$1.scope.createIdentifier('ref');
              destructure(code, this$1.scope, param, ref, false, introStatementGenerators);
              code.insertLeft(param.start, ref);
            }
          }
        });
      };

      BlockStatement.prototype.transpileBlockScopedIdentifiers = function transpileBlockScopedIdentifiers(code) {
        var this$1 = this;

        Object.keys(this.scope.blockScopedDeclarations).forEach(function (name) {
          var declarations = this$1.scope.blockScopedDeclarations[name];

          for (var i = 0, list = declarations; i < list.length; i += 1) {
            var declaration = list[i];

            var cont = false; // TODO implement proper continue...

            if (declaration.kind === 'for.let') {
              // special case
              var forStatement = declaration.node.findNearest('ForStatement');

              if (forStatement.shouldRewriteAsFunction) {
                var outerAlias = this$1.scope.createIdentifier(name);
                var innerAlias = forStatement.reassigned[name] ? this$1.scope.createIdentifier(name) : name;

                declaration.name = outerAlias;
                code.overwrite(declaration.node.start, declaration.node.end, outerAlias, true);

                forStatement.aliases[name] = {
                  outer: outerAlias,
                  inner: innerAlias
                };

                for (var i$1 = 0, list$1 = declaration.instances; i$1 < list$1.length; i$1 += 1) {
                  var identifier = list$1[i$1];

                  var alias = forStatement.body.contains(identifier) ? innerAlias : outerAlias;

                  if (name !== alias) {
                    code.overwrite(identifier.start, identifier.end, alias, true);
                  }
                }

                cont = true;
              }
            }

            if (!cont) {
              var alias$1 = this$1.scope.createIdentifier(name);

              if (name !== alias$1) {
                declaration.name = alias$1;
                code.overwrite(declaration.node.start, declaration.node.end, alias$1, true);

                for (var i$2 = 0, list$2 = declaration.instances; i$2 < list$2.length; i$2 += 1) {
                  var identifier$1 = list$2[i$2];

                  identifier$1.rewritten = true;
                  code.overwrite(identifier$1.start, identifier$1.end, alias$1, true);
                }
              }
            }
          }
        });
      };

      return BlockStatement;
    }(Node);

    function Program(source, ast, transforms, options) {
      var this$1 = this;

      this.type = 'Root';

      // options
      this.jsx = options.jsx || 'React.createElement';
      this.options = options;

      this.source = source;
      this.magicString = new MagicString(source);

      this.ast = ast;
      this.depth = 0;

      wrap(this.body = ast, this);
      this.body.__proto__ = BlockStatement.prototype;

      this.indentExclusionElements = [];
      this.body.initialise(transforms);

      this.indentExclusions = Object.create(null);
      for (var i$1 = 0, list = this.indentExclusionElements; i$1 < list.length; i$1 += 1) {
        var node = list[i$1];

        for (var i = node.start; i < node.end; i += 1) {
          this$1.indentExclusions[i] = true;
        }
      }

      this.body.transpile(this.magicString, transforms);
    }

    Program.prototype = {
      export: function export$1(options) {
        if (options === void 0) options = {};

        return {
          code: this.magicString.toString(),
          map: this.magicString.generateMap({
            file: options.file,
            source: options.source,
            includeContent: options.includeContent !== false
          })
        };
      },

      findNearest: function findNearest() {
        return null;
      },

      findScope: function findScope() {
        return null;
      }
    };

    var matrix = {
      chrome: {
        48: 1333689725,
        49: 1342078975,
        50: 1610514431,
        51: 1610514431,
        52: 2147385343
      },
      firefox: {
        43: 1207307741,
        44: 1207307741,
        45: 1207307741,
        46: 1476267485,
        47: 1476296671,
        48: 1476296671
      },
      safari: {
        8: 1073741824,
        9: 1328940894
      },
      ie: {
        8: 0,
        9: 1073741824,
        10: 1073741824,
        11: 1073770592
      },
      edge: {
        12: 1591620701,
        13: 1608400479
      },
      node: {
        '0.10': 1075052608,
        '0.12': 1091830852,
        4: 1327398527,
        5: 1327398527,
        6: 1610514431
      }
    };

    var features = ['arrow', 'classes', 'collections', 'computedProperty', 'conciseMethodProperty', 'constLoop', 'constRedef', 'defaultParameter', 'destructuring', 'extendNatives', 'forOf', 'generator', 'letConst', 'letLoop', 'letLoopScope', 'moduleExport', 'moduleImport', 'numericLiteral', 'objectProto', 'objectSuper', 'oldOctalLiteral', 'parameterDestructuring', 'spreadRest', 'stickyRegExp', 'symbol', 'templateString', 'unicodeEscape', 'unicodeIdentifier', 'unicodeRegExp',

    // ES2016
    'exponentiation',

    // additional transforms, not from
    // https://featuretests.io
    'reservedProperties'];

    var version = "0.15.2";

    var ref = [acornObjectSpread, acornJsx].reduce(function (final, plugin) {
      return plugin(final);
    }, acorn$1);
    var parse = ref.parse;

    var dangerousTransforms = ['dangerousTaggedTemplateString', 'dangerousForOf'];

    function target(target) {
      var targets = Object.keys(target);
      var bitmask = targets.length ? 2147483647 : 1073741824;

      Object.keys(target).forEach(function (environment) {
        var versions = matrix[environment];
        if (!versions) throw new Error("Unknown environment '" + environment + "'. Please raise an issue at https://gitlab.com/Rich-Harris/buble/issues");

        var targetVersion = target[environment];
        if (!(targetVersion in versions)) throw new Error("Support data exists for the following versions of " + environment + ": " + Object.keys(versions).join(', ') + ". Please raise an issue at https://gitlab.com/Rich-Harris/buble/issues");
        var support = versions[targetVersion];

        bitmask &= support;
      });

      var transforms = Object.create(null);
      features.forEach(function (name, i) {
        transforms[name] = !(bitmask & 1 << i);
      });

      dangerousTransforms.forEach(function (name) {
        transforms[name] = false;
      });

      return transforms;
    }

    function transform(source, options) {
      if (options === void 0) options = {};

      var ast;

      try {
        ast = parse(source, {
          ecmaVersion: 7,
          preserveParens: true,
          sourceType: 'module',
          plugins: {
            jsx: true,
            objectSpread: true
          }
        });
      } catch (err) {
        err.snippet = getSnippet(source, err.loc);
        err.toString = function () {
          return err.name + ": " + err.message + "\n" + err.snippet;
        };
        throw err;
      }

      var transforms = target(options.target || {});
      Object.keys(options.transforms || {}).forEach(function (name) {
        if (name === 'modules') {
          if (!('moduleImport' in options.transforms)) transforms.moduleImport = options.transforms.modules;
          if (!('moduleExport' in options.transforms)) transforms.moduleExport = options.transforms.modules;
          return;
        }

        if (!(name in transforms)) throw new Error("Unknown transform '" + name + "'");
        transforms[name] = options.transforms[name];
      });

      return new Program(source, ast, transforms, options).export(options);
    }

    exports.target = target;
    exports.transform = transform;
    exports.VERSION = version;

    Object.defineProperty(exports, '__esModule', { value: true });
  });
  
});

var buble_deps_1 = buble_deps.transform;

var _global = createCommonjsModule(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.4.0' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});

var _isObject = function _isObject(it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function _anObject(it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function _fails(exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

var document$1 = _global.document;
var is = _isObject(document$1) && _isObject(document$1.createElement);
var _domCreate = function _domCreate(it) {
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])

// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function _toPrimitive(it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP = Object.defineProperty;

var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);
  P = _toPrimitive(P, true);
  _anObject(Attributes);
  if (_ie8DomDefine) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _objectDp = {
  f: f
};

var _propertyDesc = function _propertyDesc(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var _hide = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;
var _has = function _has(it, key) {
  return hasOwnProperty.call(it, key);
};

var id = 0;
var px = Math.random();
var _uid = function _uid(key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var _redefine = createCommonjsModule(function (module) {
  var SRC = _uid('src'),
      TO_STRING = 'toString',
      $toString = Function[TO_STRING],
      TPL = ('' + $toString).split(TO_STRING);

  _core.inspectSource = function (it) {
    return $toString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if (O === _global) {
      O[key] = val;
    } else {
      if (!safe) {
        delete O[key];
        _hide(O, key, val);
      } else {
        if (O[key]) O[key] = val;else _hide(O, key, val);
      }
    }
    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
});

var _aFunction = function _aFunction(it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding

var _ctx = function _ctx(fn, that, length) {
  _aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F,
      IS_GLOBAL = type & $export.G,
      IS_STATIC = type & $export.S,
      IS_PROTO = type & $export.P,
      IS_BIND = type & $export.B,
      target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE],
      exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {}),
      expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
      key,
      own,
      out,
      exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
    // extend global
    if (target) _redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) _hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
_global.core = _core;
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library` 
var _export = $export;

var toString = {}.toString;

var _cof = function _cof(it) {
  return toString.call(it).slice(8, -1);
};

// fallback for non-array-like ES3 and non-enumerable old V8 strings

var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return _cof(it) == 'String' ? it.split('') : Object(it);
};

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function _defined(it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

// to indexed object, toObject with fallback for non-array-like ES3 strings

var _toIobject = function _toIobject(it) {
  return _iobject(_defined(it));
};

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
var _toInteger = function _toInteger(it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

// 7.1.15 ToLength
var min = Math.min;
var _toLength = function _toLength(it) {
  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min;
var _toIndex = function _toIndex(index, length) {
  index = _toInteger(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
};

// false -> Array#indexOf
// true  -> Array#includes

var _arrayIncludes = function _arrayIncludes(IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = _toIobject($this),
        length = _toLength(O.length),
        index = _toIndex(fromIndex, length),
        value;
    // Array#includes uses SameValueZero equality algorithm
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      if (value != value) return true;
      // Array#toIndex ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }return !IS_INCLUDES && -1;
  };
};

var SHARED = '__core-js_shared__';
var store = _global[SHARED] || (_global[SHARED] = {});
var _shared = function _shared(key) {
  return store[key] || (store[key] = {});
};

var shared = _shared('keys');
var _sharedKey = function _sharedKey(key) {
  return shared[key] || (shared[key] = _uid(key));
};

var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO = _sharedKey('IE_PROTO');

var _objectKeysInternal = function _objectKeysInternal(object, names) {
  var O = _toIobject(object),
      i = 0,
      result = [],
      key;
  for (key in O) {
    if (key != IE_PROTO) _has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys
  while (names.length > i) {
    if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

// 19.1.2.14 / 15.2.3.14 Object.keys(O)


var _objectKeys = Object.keys || function keys(O) {
  return _objectKeysInternal(O, _enumBugKeys);
};

var f$1 = Object.getOwnPropertySymbols;

var _objectGops = {
	f: f$1
};

var f$2 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$2
};

// 7.1.13 ToObject(argument)

var _toObject = function _toObject(it) {
  return Object(_defined(it));
};

// 19.1.2.1 Object.assign(target, source, ...)
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
var _objectAssign = !$assign || _fails(function () {
  var A = {},
      B = {},
      S = Symbol(),
      K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = _toObject(target),
      aLen = arguments.length,
      index = 1,
      getSymbols = _objectGops.f,
      isEnum = _objectPie.f;
  while (aLen > index) {
    var S = _iobject(arguments[index++]),
        keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S),
        length = keys.length,
        j = 0,
        key;
    while (length > j) {
      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
  }return T;
} : $assign;

// 19.1.3.1 Object.assign(target, source)


_export(_export.S + _export.F, 'Object', { assign: _objectAssign });

var assign = _core.Object.assign;

var _poly = { assign: assign };

var opts = {
  objectAssign: '_poly.assign',
  transforms: {
    dangerousForOf: true,
    dangerousTaggedTemplateString: true
  }
};

var transform$$1 = (function (code) {
  return buble_deps_1(code, opts).code;
});

var errorBoundary = function errorBoundary(element, errorCallback) {
  var isEvalFunc = typeof element === 'function';

  if (isEvalFunc && __WEBPACK_IMPORTED_MODULE_0_react__["Component"].isPrototypeOf(element)) {
    var originalRender = element.prototype.render;
    element.prototype.render = function render() {
      try {
        return originalRender.apply(this, arguments);
      } catch (err) {
        setTimeout(function () {
          errorCallback(err);
        });

        return null;
      }
    };
  } else if (isEvalFunc) {
    return function wrappedPFC() {
      try {
        return element();
      } catch (err) {
        setTimeout(function () {
          errorCallback(err);
        });

        return null;
      }
    };
  }

  return element;
};

var evalCode = function evalCode(code, scope) {
  var scopeKeys = Object.keys(scope);
  var scopeValues = scopeKeys.map(function (key) {
    return scope[key];
  });
  var res = new (Function.prototype.bind.apply(Function, [null].concat(['_poly', 'React'], scopeKeys, [code])))();
  return res.apply(undefined, [_poly, __WEBPACK_IMPORTED_MODULE_0_react___default.a].concat(scopeValues));
};

var generateElement = function generateElement(_ref, errorCallback) {
  var _ref$code = _ref.code,
      code = _ref$code === undefined ? '' : _ref$code,
      _ref$scope = _ref.scope,
      scope = _ref$scope === undefined ? {} : _ref$scope;

  // NOTE: Workaround for classes, since buble doesn't allow `return` without a function
  var transformed = transform$$1(code).trim().replace(/^var \w+ =/, '').replace(/;$/, '');

  return errorBoundary(evalCode('return (' + transformed + ')', scope), errorCallback);
};

var renderElementAsync = function renderElementAsync(_ref2, resultCallback, errorCallback) {
  var _ref2$code = _ref2.code,
      code = _ref2$code === undefined ? '' : _ref2$code,
      _ref2$scope = _ref2.scope,
      scope = _ref2$scope === undefined ? {} : _ref2$scope;

  var render = function render(element) {
    resultCallback(errorBoundary(element, errorCallback));
  };

  if (!/render\s*\(/.test(code)) {
    return errorCallback(new SyntaxError('No-Inline evaluations must call `render`.'));
  }

  evalCode(transform$$1(code), _extends({}, scope, { render: render }));
};

var css = "\n.prism-code {\n  display: block;\n  white-space: pre;\n\n  background-color: #1D1F21;\n  color: #C5C8C6;\n\n  padding: 0.5rem;\n  margin: 0;\n\n  box-sizing: border-box;\n  vertical-align: baseline;\n  outline: none;\n  text-shadow: none;\n  -webkit-hyphens: none;\n  -ms-hyphens: none;\n  hyphens: none;\n  word-wrap: normal;\n  word-break: normal;\n  text-align: left;\n  word-spacing: normal;\n  -moz-tab-size: 2;\n  -o-tab-size: 2;\n  tab-size: 2;\n}\n\n.token.comment,\n.token.prolog,\n.token.doctype,\n.token.cdata {\n  color: hsl(30, 20%, 50%);\n}\n\n.token.punctuation {\n  opacity: .7;\n}\n\n.namespace {\n  opacity: .7;\n}\n\n.token.property,\n.token.tag,\n.token.boolean,\n.token.number,\n.token.constant,\n.token.symbol {\n  color: hsl(350, 40%, 70%);\n}\n\n.token.selector,\n.token.attr-name,\n.token.string,\n.token.char,\n.token.builtin,\n.token.inserted {\n  color: hsl(75, 70%, 60%);\n}\n\n.token.operator,\n.token.entity,\n.token.url,\n.language-css .token.string,\n.style .token.string,\n.token.variable {\n  color: hsl(40, 90%, 60%);\n}\n\n.token.atrule,\n.token.attr-value,\n.token.keyword {\n  color: hsl(350, 40%, 70%);\n}\n\n.token.regex,\n.token.important {\n  color: #e90;\n}\n\n.token.important,\n.token.bold {\n  font-weight: bold;\n}\n.token.italic {\n  font-style: italic;\n}\n\n.token.entity {\n  cursor: help;\n}\n\n.token.deleted {\n  color: red;\n}\n";

var prismStyling = __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('style', { dangerouslySetInnerHTML: { __html: css } });

var Style = (function () {
  return prismStyling;
});

var LiveContextTypes = {
  live: index$6.shape({
    code: index$6.string,
    error: index$6.string,

    onError: index$6.func,
    onChange: index$6.func,

    element: index$6.oneOfType([index$6.string, index$6.number, index$6.element, index$6.func])
  })
};

var LiveProvider = function (_Component) {
  inherits(LiveProvider, _Component);

  function LiveProvider() {
    var _temp, _this, _ret;

    classCallCheck(this, LiveProvider);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.onChange = function (code) {
      var _this$props = _this.props,
          scope = _this$props.scope,
          transformCode = _this$props.transformCode,
          noInline = _this$props.noInline;

      _this.transpile({ code: code, scope: scope, transformCode: transformCode, noInline: noInline });
    }, _this.onError = function (error) {
      _this.setState({ error: error.toString() });
    }, _this.transpile = function (_ref) {
      var code = _ref.code,
          scope = _ref.scope,
          transformCode = _ref.transformCode,
          _ref$noInline = _ref.noInline,
          noInline = _ref$noInline === undefined ? false : _ref$noInline;

      // Transpilation arguments
      var input = {
        code: transformCode ? transformCode(code) : code,
        scope: scope
      };
      var errorCallback = function errorCallback(err) {
        return _this.setState({ element: undefined, error: err.toString() });
      };
      var renderElement = function renderElement(element) {
        return _this.setState(_extends({}, state, { element: element }));
      };

      // State reset object
      var state = { unsafeWrapperError: undefined, error: undefined };

      try {
        if (noInline) {
          _this.setState(_extends({}, state, { element: null })); // Reset output for async (no inline) evaluation
          renderElementAsync(input, renderElement, errorCallback);
        } else {
          renderElement(generateElement(input, errorCallback));
        }
      } catch (error) {
        _this.setState(_extends({}, state, { error: error.toString() }));
      }
    }, _this.getChildContext = function () {
      return {
        live: _extends({}, _this.state, {
          code: _this.props.code,
          onError: _this.onError,
          onChange: _this.onChange
        })
      };
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  LiveProvider.prototype.componentWillMount = function componentWillMount() {
    var _props = this.props,
        code = _props.code,
        scope = _props.scope,
        transformCode = _props.transformCode,
        noInline = _props.noInline;


    this.transpile({ code: code, scope: scope, transformCode: transformCode, noInline: noInline });
  };

  LiveProvider.prototype.componentWillReceiveProps = function componentWillReceiveProps(_ref2) {
    var code = _ref2.code,
        scope = _ref2.scope,
        noInline = _ref2.noInline,
        transformCode = _ref2.transformCode;

    if (code !== this.props.code || scope !== this.props.scope || noInline !== this.props.noInline || transformCode !== this.props.transformCode) {
      this.transpile({ code: code, scope: scope, transformCode: transformCode, noInline: noInline });
    }
  };

  LiveProvider.prototype.render = function render() {
    var _props2 = this.props,
        children = _props2.children,
        className = _props2.className,
        code = _props2.code,
        mountStylesheet = _props2.mountStylesheet,
        noInline = _props2.noInline,
        transformCode = _props2.transformCode,
        rest = objectWithoutProperties(_props2, ['children', 'className', 'code', 'mountStylesheet', 'noInline', 'transformCode']);


    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      'div',
      _extends({
        className: cn('react-live', className)
      }, rest),
      mountStylesheet && __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Style, null),
      children
    );
  };

  return LiveProvider;
}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

LiveProvider.childContextTypes = LiveContextTypes;
LiveProvider.defaultProps = {
  code: '',
  mountStylesheet: true,
  noInline: false
};
LiveProvider.propTypes = {
  className: index$6.string,
  code: index$6.string,
  scope: index$6.object,
  mountStylesheet: index$6.bool,
  noInline: index$6.bool,
  transformCode: index$6.func
};

var LiveEditor = function LiveEditor(props, _ref) {
  var live = _ref.live;
  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Editor, _extends({}, props, {
    code: live.code,
    onChange: function onChange(code) {
      live.onChange(code);

      if (typeof props.onChange === 'function') {
        props.onChange(code);
      }
    }
  }));
};

LiveEditor.contextTypes = LiveContextTypes;
LiveEditor.propTypes = { onChange: index$6.func };

var LiveError = function LiveError(_ref, _ref2) {
  var live = _ref2.live;
  var className = _ref.className,
      rest = objectWithoutProperties(_ref, ['className']);
  return live.error ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    'div',
    _extends({}, rest, {
      className: cn('react-live-error', className)
    }),
    live.error
  ) : null;
};

LiveError.contextTypes = LiveContextTypes;

var LivePreview = function LivePreview(_ref, _ref2) {
  var element = _ref2.live.element;
  var className = _ref.className,
      rest = objectWithoutProperties(_ref, ['className']);
  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
    'div',
    _extends({}, rest, {
      className: cn('react-live-preview', className)
    }),
    typeof element === 'function' ? Object(__WEBPACK_IMPORTED_MODULE_0_react__["createElement"])(element) : element
  );
};

LivePreview.contextTypes = LiveContextTypes;

var withLive = function withLive(WrappedComponent) {
  var WithLive = function (_Component) {
    inherits(WithLive, _Component);

    function WithLive() {
      classCallCheck(this, WithLive);
      return possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    WithLive.prototype.render = function render() {
      var live = this.context.live;

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(WrappedComponent, { live: live });
    };

    return WithLive;
  }(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

  WithLive.contextTypes = LiveContextTypes;


  return WithLive;
};



/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(180), __webpack_require__(414).Buffer))

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(415)
var ieee754 = __webpack_require__(416)
var isArray = __webpack_require__(417)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(180)))

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 416 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 417 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(419);


/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __webpack_require__(44);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(15);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(16);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(45);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(49);

var _inherits3 = _interopRequireDefault(_inherits2);

var _style = __webpack_require__(391);

var _style2 = _interopRequireDefault(_style);

var _react = __webpack_require__(17);

var _react2 = _interopRequireDefault(_react);

var _main = __webpack_require__(399);

var _main2 = _interopRequireDefault(_main);

var _reactLive = __webpack_require__(413);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _jsxFileName = "/opt/guydev/study/render-props-presentation-next/pages/example1.js?entry";


var Caffeinate = function (_Component) {
  (0, _inherits3.default)(Caffeinate, _Component);

  function Caffeinate() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, Caffeinate);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Caffeinate.__proto__ || (0, _getPrototypeOf2.default)(Caffeinate)).call.apply(_ref, [this].concat(args))), _this), _this.state = { coffee: "Americano" }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(Caffeinate, [{
    key: "render",
    value: function render() {
      return this.props.children(this.state.coffee);
    }
  }]);

  return Caffeinate;
}(_react.Component);

exports.default = function () {
  return _react2.default.createElement(_main2.default, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 13
    }
  }, _react2.default.createElement("div", {
    className: "jsx-880604262" + " " + "cont",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 14
    }
  }, _react2.default.createElement("h2", {
    className: "jsx-880604262",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 15
    }
  }, "Example 1"), _react2.default.createElement("p", {
    className: "jsx-880604262",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 16
    }
  }, "Most simple render props, sending the state from the parent to the child"), _react2.default.createElement(_reactLive.LiveProvider, {
    code: "class Caffeinate extends Component {\n  state = { coffee: \"Americano\" };\n  render() {\n    return this.props.children(this.state.coffee);\n  }\n}",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19
    }
  }, _react2.default.createElement(_reactLive.LiveEditor, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 27
    }
  })), _react2.default.createElement("br", {
    className: "jsx-880604262",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 29
    }
  }), _react2.default.createElement("br", {
    className: "jsx-880604262",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 30
    }
  }), _react2.default.createElement(Caffeinate, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 31
    }
  }, function (beverage) {
    return _react2.default.createElement("div", {
      className: "jsx-880604262",
      __source: {
        fileName: _jsxFileName,
        lineNumber: 31
      }
    }, "Drinking an ", beverage, ".");
  }), _react2.default.createElement("br", {
    className: "jsx-880604262",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 32
    }
  }), _react2.default.createElement("br", {
    className: "jsx-880604262",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 33
    }
  }), _react2.default.createElement(_reactLive.LiveProvider, {
    code: "<Caffeinate>{beverage => <div>Drinking an {beverage}.</div>}</Caffeinate>",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 34
    }
  }, _react2.default.createElement(_reactLive.LiveEditor, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 37
    }
  }))), _react2.default.createElement(_style2.default, {
    styleId: "880604262",
    css: ".cont.jsx-880604262{background:#eee;padding:100px;text-align:center;-webkit-transition:100ms ease-in background;transition:100ms ease-in background;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2V4YW1wbGUxLmpzP2VudHJ5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXdDZ0IsQUFHeUIsZ0JBQ0YsY0FDSSxrQkFDa0IsZ0ZBQ3RDIiwiZmlsZSI6InBhZ2VzL2V4YW1wbGUxLmpzP2VudHJ5Iiwic291cmNlUm9vdCI6Ii9vcHQvZ3V5ZGV2L3N0dWR5L3JlbmRlci1wcm9wcy1wcmVzZW50YXRpb24tbmV4dCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQYWdlIGZyb20gXCIuLi9sYXlvdXRzL21haW5cIjtcbmltcG9ydCB7IExpdmVQcm92aWRlciwgTGl2ZUVkaXRvciwgTGl2ZUVycm9yLCBMaXZlUHJldmlldyB9IGZyb20gXCJyZWFjdC1saXZlXCI7XG5cbmNsYXNzIENhZmZlaW5hdGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0ZSA9IHsgY29mZmVlOiBcIkFtZXJpY2Fub1wiIH07XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnN0YXRlLmNvZmZlZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgKCkgPT4gKFxuICA8UGFnZT5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRcIj5cbiAgICAgIDxoMj5FeGFtcGxlIDE8L2gyPlxuICAgICAgPHA+XG4gICAgICAgIE1vc3Qgc2ltcGxlIHJlbmRlciBwcm9wcywgc2VuZGluZyB0aGUgc3RhdGUgZnJvbSB0aGUgcGFyZW50IHRvIHRoZSBjaGlsZFxuICAgICAgPC9wPlxuICAgICAgPExpdmVQcm92aWRlclxuICAgICAgICBjb2RlPXtgY2xhc3MgQ2FmZmVpbmF0ZSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRlID0geyBjb2ZmZWU6IFwiQW1lcmljYW5vXCIgfTtcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuc3RhdGUuY29mZmVlKTtcbiAgfVxufWB9XG4gICAgICA+XG4gICAgICAgIDxMaXZlRWRpdG9yIC8+XG4gICAgICA8L0xpdmVQcm92aWRlcj5cbiAgICAgIDxiciAvPlxuICAgICAgPGJyIC8+XG4gICAgICA8Q2FmZmVpbmF0ZT57YmV2ZXJhZ2UgPT4gPGRpdj5Ecmlua2luZyBhbiB7YmV2ZXJhZ2V9LjwvZGl2Pn08L0NhZmZlaW5hdGU+XG4gICAgICA8YnIgLz5cbiAgICAgIDxiciAvPlxuICAgICAgPExpdmVQcm92aWRlclxuICAgICAgICBjb2RlPXtgPENhZmZlaW5hdGU+e2JldmVyYWdlID0+IDxkaXY+RHJpbmtpbmcgYW4ge2JldmVyYWdlfS48L2Rpdj59PC9DYWZmZWluYXRlPmB9XG4gICAgICA+XG4gICAgICAgIDxMaXZlRWRpdG9yIC8+XG4gICAgICA8L0xpdmVQcm92aWRlcj5cbiAgICA8L2Rpdj5cblxuICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgIC5jb250IHtcbiAgICAgICAgYmFja2dyb3VuZDogI2VlZTtcbiAgICAgICAgcGFkZGluZzogMTAwcHg7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgdHJhbnNpdGlvbjogMTAwbXMgZWFzZS1pbiBiYWNrZ3JvdW5kO1xuICAgICAgfVxuICAgIGB9PC9zdHlsZT5cbiAgPC9QYWdlPlxuKTtcbiJdfQ== */\n/*@ sourceURL=pages/example1.js?entry */"
  }));
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhZ2VzL2V4YW1wbGUxLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwiQ29tcG9uZW50IiwiUGFnZSIsIkxpdmVQcm92aWRlciIsIkxpdmVFZGl0b3IiLCJMaXZlRXJyb3IiLCJMaXZlUHJldmlldyIsIkNhZmZlaW5hdGUiLCJzdGF0ZSIsImNvZmZlZSIsInByb3BzIiwiY2hpbGRyZW4iLCJiZXZlcmFnZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsQUFBTyxBQUFTOzs7O0FBQ2hCLEFBQU8sQUFBVTs7OztBQUNqQixBQUFTLEFBQWMsQUFBWSxBQUFXOzs7Ozs7O0lBRXhDLEE7Ozs7Ozs7Ozs7Ozs7O29OLEFBQ0osUUFBUSxFQUFFLFFBQUYsQUFBVSxBOzs7Ozs2QkFDVCxBQUNQO2FBQU8sS0FBQSxBQUFLLE1BQUwsQUFBVyxTQUFTLEtBQUEsQUFBSyxNQUFoQyxBQUFPLEFBQStCLEFBQ3ZDOzs7OztBQUpzQixBLEFBT3pCOztrQkFBZSxZQUFBO3lCQUNiLEFBQUM7O2dCQUFEO2tCQUFBLEFBQ0U7QUFERjtBQUFBLEdBQUEsa0JBQ0UsY0FBQTt1Q0FBQSxBQUFlOztnQkFBZjtrQkFBQSxBQUNFO0FBREY7QUFBQSxxQkFDRSxjQUFBO2VBQUE7O2dCQUFBO2tCQUFBO0FBQUE7QUFBQSxLQURGLEFBQ0UsQUFDQSw4QkFBQSxjQUFBO2VBQUE7O2dCQUFBO2tCQUFBO0FBQUE7QUFBQSxLQUZGLEFBRUUsQUFHQSw2RkFBQSxBQUFDO1VBQUQ7O2dCQUFBO2tCQUFBLEFBUUU7QUFSRjtBQUNFLHFCQU9BLEFBQUM7O2dCQUFEO2tCQWJKLEFBS0UsQUFRRSxBQUVGO0FBRkU7QUFBQTtlQUVGOztnQkFBQTtrQkFmRixBQWVFLEFBQ0E7QUFEQTtBQUFBO2VBQ0E7O2dCQUFBO2tCQWhCRixBQWdCRSxBQUNBO0FBREE7QUFBQSxzQkFDQyxjQUFEOztnQkFBQTtrQkFBQSxBQUFhO0FBQWI7QUFBQSx5QkFBYTsyQkFBWSxjQUFBO2lCQUFBOztrQkFBQTtvQkFBQTtBQUFBO0FBQUEsS0FBQSxFQUFrQixnQkFBbEIsVUFBWixBQUFZO0FBakIzQixBQWlCRSxBQUNBO2VBQUE7O2dCQUFBO2tCQWxCRixBQWtCRSxBQUNBO0FBREE7QUFBQTtlQUNBOztnQkFBQTtrQkFuQkYsQUFtQkUsQUFDQTtBQURBO0FBQUEsc0JBQ0EsQUFBQztVQUFEOztnQkFBQTtrQkFBQSxBQUdFO0FBSEY7QUFDRSxxQkFFQSxBQUFDOztnQkFBRDtrQkF4Qk4sQUFDRSxBQW9CRSxBQUdFO0FBQUE7QUFBQTthQXhCTjtTQURhLEFBQ2I7QUFBQTtBQURGIiwiZmlsZSI6ImV4YW1wbGUxLmpzP2VudHJ5Iiwic291cmNlUm9vdCI6Ii9vcHQvZ3V5ZGV2L3N0dWR5L3JlbmRlci1wcm9wcy1wcmVzZW50YXRpb24tbmV4dCJ9

 ;(function register() { /* react-hot-loader/webpack */ if (true) { if (typeof __REACT_HOT_LOADER__ === 'undefined') { return; } /* eslint-disable camelcase, no-undef */ var webpackExports = typeof __webpack_exports__ !== 'undefined' ? __webpack_exports__ : module.exports; /* eslint-enable camelcase, no-undef */ if (typeof webpackExports === 'function') { __REACT_HOT_LOADER__.register(webpackExports, 'module.exports', "/opt/guydev/study/render-props-presentation-next/pages/example1.js"); return; } /* eslint-disable no-restricted-syntax */ for (var key in webpackExports) { /* eslint-enable no-restricted-syntax */ if (!Object.prototype.hasOwnProperty.call(webpackExports, key)) { continue; } var namedExport = void 0; try { namedExport = webpackExports[key]; } catch (err) { continue; } __REACT_HOT_LOADER__.register(namedExport, key, "/opt/guydev/study/render-props-presentation-next/pages/example1.js"); } } })();
    (function (Component, route) {
      if (false) return
      if (false) return

      var qs = __webpack_require__(84)
      var params = qs.parse(__resourceQuery.slice(1))
      if (params.entry == null) return

      module.hot.accept()
      Component.__route = route

      if (module.hot.status() === 'idle') return

      var components = next.router.components
      for (var r in components) {
        if (!components.hasOwnProperty(r)) continue

        if (components[r].Component.__route === route) {
          next.router.update(r, Component)
        }
      }
    })(typeof __webpack_exports__ !== 'undefined' ? __webpack_exports__.default : (module.exports.default || module.exports), "/example1")
  
/* WEBPACK VAR INJECTION */}.call(exports, "?entry"))

/***/ })
],[418]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlcy9wYWdlcy9leGFtcGxlMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcz9jODZiODAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzP2M4NmI4MDIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanM/Yzg2YjgwMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcz9jODZiODAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzP2M4NmI4MDIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanM/Yzg2YjgwMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzP2M4NmI4MDIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanM/Yzg2YjgwMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcz9jODZiODAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcz9jODZiODAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanM/Yzg2YjgwMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcz9jODZiODAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcz9jODZiODAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzP2M4NmI4MDIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanM/Yzg2YjgwMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzP2M4NmI4MDIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcz9jODZiODAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcz9jODZiODAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzP2M4NmI4MDIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzP2M4NmI4MDIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcz9jODZiODAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanM/Yzg2YjgwMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcz9mNDcyNWE1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanM/ZjQ3MjVhNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzP2Y0NzI1YTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi91dGlscy5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldC5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9yb3V0ZXIvaW5kZXguanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcz9lYmQwYTcyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzP2ViZDBhNzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanM/ZWJkMGE3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanM/ZmJmYjE2NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanM/ZmJmYjE2NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanM/ZmJmYjE2NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190YXNrLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wZXJmb3JtLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanM/ZmJmYjE2NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1vZi5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tZnJvbS5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMuanM/ZmJmYjE2NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanM/ZmJmYjE2NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanM/ZmJmYjE2NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanM/ZmJmYjE2NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3NldC5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc2V0LmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0Lm9mLmpzP2ZiZmIxNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcz9mYmZiMTY3Iiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/ZmJmYjE2NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9FdmVudEVtaXR0ZXIuanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9zaGFsbG93LWVxdWFscy5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL3JvdXRlci93aXRoLXJvdXRlci5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL3JvdXRlci9yb3V0ZXIuanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91cmwvdXRpbC5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL3AtcXVldWUuanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9kaXN0L3N0eWxlLmpzPzEwOThjOWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXAuanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL21hcC5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWFwLmpzPzEwOThjOWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcubWFwLm9mLmpzPzEwOThjOWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5tYXAuZnJvbS5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L2Rpc3Qvc3R5bGVzaGVldC1yZWdpc3RyeS5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpbmctaGFzaC9pbmRleC5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L2Rpc3QvbGliL3N0eWxlc2hlZXQuanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9zdHlsZS5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWZpbmUtcHJvcGVydGllcy9pbmRleC5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pbmRleC5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QuYXNzaWduL2ltcGxlbWVudGF0aW9uLmpzPzEwOThjOWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LmFzc2lnbi9wb2x5ZmlsbC5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL2xheW91dHMvbWFpbi5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvaGVhZGVyLmpzPzEwOThjOWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvbGluay5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnkuanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzPzEwOThjOWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMtZXhhY3QvYnVpbGQvaW5kZXguanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LmFzc2lnbi9pbmRleC5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mb3JlYWNoL2luZGV4LmpzPzEwOThjOWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LmFzc2lnbi9zaGltLmpzPzEwOThjOWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy1leGFjdC9idWlsZC9oZWxwZXJzL2lzUGxhaW5PYmplY3QuanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtbGl2ZS9kaXN0L3JlYWN0LWxpdmUuZXMuanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzPzEwOThjOWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcz8xMDk4YzlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzPzEwOThjOWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanM/MTA5OGM5ZCIsIndlYnBhY2s6Ly8vLi9wYWdlcy9leGFtcGxlMS5qcz9mYzZhN2M2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMycgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBrZXkgaW4gZXhwb3J0cykgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIEJSRUFLID0ge307XG52YXIgUkVUVVJOID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1IpIHtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpO1xuICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZiAoaXNBcnJheUl0ZXIoaXRlckZuKSkgZm9yIChsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTspIHtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgRE9NSXRlcmFibGVzID0gKCdDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LCcgK1xuICAnRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCwnICtcbiAgJ01lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsJyArXG4gICdTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCwnICtcbiAgJ1RleHRUcmFja0xpc3QsVG91Y2hMaXN0Jykuc3BsaXQoJywnKTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBET01JdGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBET01JdGVyYWJsZXNbaV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gKCFCVUdHWSAmJiAkbmF0aXZlKSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1pbnN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAoc2FmZSAmJiB0YXJnZXRba2V5XSkgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICBlbHNlIGhpZGUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfSByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuICB2YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ3RoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAlc2AuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0pO1xuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgNiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubG9hZEdldEluaXRpYWxQcm9wcyA9IHVuZGVmaW5lZDtcblxudmFyIF9yZWdlbmVyYXRvciA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3InKTtcblxudmFyIF9yZWdlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWdlbmVyYXRvcik7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvcicpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmNUb0dlbmVyYXRvcjIpO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduJyk7XG5cbnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cbnZhciBsb2FkR2V0SW5pdGlhbFByb3BzID0gZXhwb3J0cy5sb2FkR2V0SW5pdGlhbFByb3BzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjMuZGVmYXVsdCkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IyLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKENvbXBvbmVudCwgY3R4KSB7XG4gICAgdmFyIHByb3BzLCBjb21wTmFtZSwgbWVzc2FnZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yMi5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoQ29tcG9uZW50LmdldEluaXRpYWxQcm9wcykge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIHt9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudC5nZXRJbml0aWFsUHJvcHMoY3R4KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHByb3BzID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgaWYgKCEoIXByb3BzICYmICghY3R4LnJlcyB8fCAhY3R4LnJlcy5maW5pc2hlZCkpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tcE5hbWUgPSBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpO1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdcIicgKyBjb21wTmFtZSArICcuZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIicgKyBwcm9wcyArICdcIiBpbnN0ZWFkLic7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCBwcm9wcyk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gIH0pKTtcblxuICByZXR1cm4gZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wcyhfeDIsIF94Mykge1xuICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMud2FybiA9IHdhcm47XG5leHBvcnRzLmV4ZWNPbmNlID0gZXhlY09uY2U7XG5leHBvcnRzLmRlcHJlY2F0ZWQgPSBkZXByZWNhdGVkO1xuZXhwb3J0cy5wcmludEFuZEV4aXQgPSBwcmludEFuZEV4aXQ7XG5leHBvcnRzLmdldERpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWU7XG5leHBvcnRzLmdldExvY2F0aW9uT3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW47XG5leHBvcnRzLmdldFVSTCA9IGdldFVSTDtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleGVjT25jZShmbikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciB1c2VkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKCF1c2VkKSB7XG4gICAgICB1c2VkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoZm4sIG1lc3NhZ2UpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHJldHVybiBmbjtcblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIHZhciBuZXdGbiA9IGZ1bmN0aW9uIG5ld0ZuKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcblxuICAvLyBjb3B5IGFsbCBwcm9wZXJ0aWVzXG4gICgwLCBfYXNzaWduMi5kZWZhdWx0KShuZXdGbiwgZm4pO1xuXG4gIHJldHVybiBuZXdGbjtcbn1cblxuZnVuY3Rpb24gcHJpbnRBbmRFeGl0KG1lc3NhZ2UpIHtcbiAgdmFyIGNvZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG5cbiAgaWYgKGNvZGUgPT09IDApIHtcbiAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG5cbiAgcHJvY2Vzcy5leGl0KGNvZGUpO1xufVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpIHtcbiAgcmV0dXJuIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bic7XG59XG5cbmZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgIHByb3RvY29sID0gX3dpbmRvdyRsb2NhdGlvbi5wcm90b2NvbCxcbiAgICAgIGhvc3RuYW1lID0gX3dpbmRvdyRsb2NhdGlvbi5ob3N0bmFtZSxcbiAgICAgIHBvcnQgPSBfd2luZG93JGxvY2F0aW9uLnBvcnQ7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgJy8vJyArIGhvc3RuYW1lICsgKHBvcnQgPyAnOicgKyBwb3J0IDogJycpO1xufVxuXG5mdW5jdGlvbiBnZXRVUkwoKSB7XG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbiAgdmFyIG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKCk7XG4gIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDYiLCIndXNlIHN0cmljdCc7XG4vLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxuZnVuY3Rpb24gUHJvbWlzZUNhcGFiaWxpdHkoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA2IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IHR5cGVvZiBjb3JlW0tFWV0gPT0gJ2Z1bmN0aW9uJyA/IGNvcmVbS0VZXSA6IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3NldFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXQuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgNiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiA1IDYiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDYiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9wcm9taXNlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvcHJvbWlzZVwiKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gbmV3IF9wcm9taXNlMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3Byb21pc2UyLmRlZmF1bHQucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBzdGVwKFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RlcChcIm5leHRcIik7XG4gICAgfSk7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDYiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDYiLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCA1IDYiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUm91dGVyID0gZXhwb3J0cy5jcmVhdGVSb3V0ZXIgPSBleHBvcnRzLndpdGhSb3V0ZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheScpO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2xpY2VkVG9BcnJheTIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHknKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbnZhciBfd2l0aFJvdXRlciA9IHJlcXVpcmUoJy4vd2l0aC1yb3V0ZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd3aXRoUm91dGVyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2l0aFJvdXRlcikuZGVmYXVsdDtcbiAgfVxufSk7XG5leHBvcnRzLl9ub3RpZnlCdWlsZElkTWlzbWF0Y2ggPSBfbm90aWZ5QnVpbGRJZE1pc21hdGNoO1xuZXhwb3J0cy5fcmV3cml0ZVVybEZvck5leHRFeHBvcnQgPSBfcmV3cml0ZVVybEZvck5leHRFeHBvcnQ7XG5leHBvcnRzLm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSA9IG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZTtcblxudmFyIF9yb3V0ZXIgPSByZXF1aXJlKCcuL3JvdXRlcicpO1xuXG52YXIgX3JvdXRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgU2luZ2xldG9uUm91dGVyID0ge1xuICByb3V0ZXI6IG51bGwsIC8vIGhvbGRzIHRoZSBhY3R1YWwgcm91dGVyIGluc3RhbmNlXG4gIHJlYWR5Q2FsbGJhY2tzOiBbXSxcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KGNiKSB7XG4gICAgaWYgKHRoaXMucm91dGVyKSByZXR1cm4gY2IoKTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmVhZHlDYWxsYmFja3MucHVzaChjYik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBDcmVhdGUgcHVibGljIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb2YgdGhlIHJvdXRlciBpbiB0aGUgU2luZ2xldG9uUm91dGVyXG4vKiBnbG9iYWwgd2luZG93ICovXG52YXIgcHJvcGVydHlGaWVsZHMgPSBbJ2NvbXBvbmVudHMnLCAncGF0aG5hbWUnLCAncm91dGUnLCAncXVlcnknLCAnYXNQYXRoJ107XG52YXIgY29yZU1ldGhvZEZpZWxkcyA9IFsncHVzaCcsICdyZXBsYWNlJywgJ3JlbG9hZCcsICdiYWNrJywgJ3ByZWZldGNoJ107XG52YXIgcm91dGVyRXZlbnRzID0gWydyb3V0ZUNoYW5nZVN0YXJ0JywgJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCAncm91dGVDaGFuZ2VDb21wbGV0ZScsICdyb3V0ZUNoYW5nZUVycm9yJ107XG5cbnByb3BlcnR5RmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gIC8vIEhlcmUgd2UgbmVlZCB0byB1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGJlY2F1c2UsIHdlIG5lZWQgdG8gcmV0dXJuXG4gIC8vIHRoZSBwcm9wZXJ0eSBhc3NpZ25lZCB0byB0aGUgYWN0dWFsIHJvdXRlclxuICAvLyBUaGUgdmFsdWUgbWlnaHQgZ2V0IGNoYW5nZWQgYXMgd2UgY2hhbmdlIHJvdXRlcyBhbmQgdGhpcyBpcyB0aGVcbiAgLy8gcHJvcGVyIHdheSB0byBhY2Nlc3MgaXRcbiAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoU2luZ2xldG9uUm91dGVyLCBmaWVsZCwge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3dJZk5vUm91dGVyKCk7XG4gICAgICByZXR1cm4gU2luZ2xldG9uUm91dGVyLnJvdXRlcltmaWVsZF07XG4gICAgfVxuICB9KTtcbn0pO1xuXG5jb3JlTWV0aG9kRmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gIFNpbmdsZXRvblJvdXRlcltmaWVsZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9TaW5nbGV0b25Sb3V0ZXIkcm91dDtcblxuICAgIHRocm93SWZOb1JvdXRlcigpO1xuICAgIHJldHVybiAoX1NpbmdsZXRvblJvdXRlciRyb3V0ID0gU2luZ2xldG9uUm91dGVyLnJvdXRlcilbZmllbGRdLmFwcGx5KF9TaW5nbGV0b25Sb3V0ZXIkcm91dCwgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG5yb3V0ZXJFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgU2luZ2xldG9uUm91dGVyLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICBTaW5nbGV0b25Sb3V0ZXIucm91dGVyLmV2ZW50cy5vbihldmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV2ZW50RmllbGQgPSAnb24nICsgZXZlbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAoU2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgU2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdLmFwcGx5KFNpbmdsZXRvblJvdXRlciwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igd2hlbiBydW5uaW5nIHRoZSBSb3V0ZXIgZXZlbnQ6ICcgKyBldmVudEZpZWxkKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVyci5tZXNzYWdlICsgJ1xcbicgKyBlcnIuc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIHRocm93SWZOb1JvdXRlcigpIHtcbiAgaWYgKCFTaW5nbGV0b25Sb3V0ZXIucm91dGVyKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnTm8gcm91dGVyIGluc3RhbmNlIGZvdW5kLlxcbicgKyAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgaW5zaWRlIHRoZSBjbGllbnQgc2lkZSBvZiB5b3VyIGFwcC5cXG4nO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgdGhlIFNpbmdsZXRvblJvdXRlciBhbmQgdGhpcyBpcyB0aGUgcHVibGljIEFQSS5cbmV4cG9ydHMuZGVmYXVsdCA9IFNpbmdsZXRvblJvdXRlcjtcblxuLy8gUmVleHBvcnQgdGhlIHdpdGhSb3V0ZSBIT0NcblxuLy8gSU5URVJOQUwgQVBJU1xuLy8gLS0tLS0tLS0tLS0tLVxuLy8gKGRvIG5vdCB1c2UgZm9sbG93aW5nIGV4cG9ydHMgaW5zaWRlIHRoZSBhcHApXG5cbi8vIENyZWF0ZSBhIHJvdXRlciBhbmQgYXNzaWduIGl0IGFzIHRoZSBzaW5nbGV0b24gaW5zdGFuY2UuXG4vLyBUaGlzIGlzIHVzZWQgaW4gY2xpZW50IHNpZGUgd2hlbiB3ZSBhcmUgaW5pdGlsaXppbmcgdGhlIGFwcC5cbi8vIFRoaXMgc2hvdWxkICoqbm90KiogdXNlIGluc2lkZSB0aGUgc2VydmVyLlxudmFyIGNyZWF0ZVJvdXRlciA9IGV4cG9ydHMuY3JlYXRlUm91dGVyID0gZnVuY3Rpb24gY3JlYXRlUm91dGVyKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBTaW5nbGV0b25Sb3V0ZXIucm91dGVyID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShfcm91dGVyMi5kZWZhdWx0LCBbbnVsbF0uY29uY2F0KGFyZ3MpKSkoKTtcbiAgU2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgcmV0dXJuIGNiKCk7XG4gIH0pO1xuICBTaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MgPSBbXTtcblxuICByZXR1cm4gU2luZ2xldG9uUm91dGVyLnJvdXRlcjtcbn07XG5cbi8vIEV4cG9ydCB0aGUgYWN0dWFsIFJvdXRlciBjbGFzcywgd2hpY2ggaXMgdXN1YWxseSB1c2VkIGluc2lkZSB0aGUgc2VydmVyXG52YXIgUm91dGVyID0gZXhwb3J0cy5Sb3V0ZXIgPSBfcm91dGVyMi5kZWZhdWx0O1xuXG5mdW5jdGlvbiBfbm90aWZ5QnVpbGRJZE1pc21hdGNoKG5leHRSb3V0ZSkge1xuICBpZiAoU2luZ2xldG9uUm91dGVyLm9uQXBwVXBkYXRlZCkge1xuICAgIFNpbmdsZXRvblJvdXRlci5vbkFwcFVwZGF0ZWQobmV4dFJvdXRlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oJ0FuIGFwcCB1cGRhdGUgZGV0ZWN0ZWQuIExvYWRpbmcgdGhlIFNTUiB2ZXJzaW9uIG9mIFwiJyArIG5leHRSb3V0ZSArICdcIicpO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gbmV4dFJvdXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9yZXdyaXRlVXJsRm9yTmV4dEV4cG9ydCh1cmwpIHtcbiAgdmFyIF91cmwkc3BsaXQgPSB1cmwuc3BsaXQoJyMnKSxcbiAgICAgIF91cmwkc3BsaXQyID0gKDAsIF9zbGljZWRUb0FycmF5My5kZWZhdWx0KShfdXJsJHNwbGl0LCAyKSxcbiAgICAgIGhhc2ggPSBfdXJsJHNwbGl0MlsxXTtcblxuICB1cmwgPSB1cmwucmVwbGFjZSgvIy4qLywgJycpO1xuXG4gIHZhciBfdXJsJHNwbGl0MyA9IHVybC5zcGxpdCgnPycpLFxuICAgICAgX3VybCRzcGxpdDQgPSAoMCwgX3NsaWNlZFRvQXJyYXkzLmRlZmF1bHQpKF91cmwkc3BsaXQzLCAyKSxcbiAgICAgIHBhdGggPSBfdXJsJHNwbGl0NFswXSxcbiAgICAgIHFzID0gX3VybCRzcGxpdDRbMV07XG5cbiAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICB2YXIgbmV3UGF0aCA9IHBhdGg7XG4gIC8vIEFwcGVuZCBhIHRyYWlsaW5nIHNsYXNoIGlmIHRoaXMgcGF0aCBkb2VzIG5vdCBoYXZlIGFuIGV4dGVuc2lvblxuICBpZiAoIS9cXC5bXi9dK1xcLz8kLy50ZXN0KHBhdGgpKSB7XG4gICAgbmV3UGF0aCA9IHBhdGggKyAnLyc7XG4gIH1cblxuICBpZiAocXMpIHtcbiAgICBuZXdQYXRoID0gbmV3UGF0aCArICc/JyArIHFzO1xuICB9XG5cbiAgaWYgKGhhc2gpIHtcbiAgICBuZXdQYXRoID0gbmV3UGF0aCArICcjJyArIGhhc2g7XG4gIH1cblxuICByZXR1cm4gbmV3UGF0aDtcbn1cblxuZnVuY3Rpb24gbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcikge1xuICB2YXIgaW5zdGFuY2UgPSB7fTtcblxuICBwcm9wZXJ0eUZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIC8vIEhlcmUgd2UgbmVlZCB0byB1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGJlY2F1c2UsIHdlIG5lZWQgdG8gcmV0dXJuXG4gICAgLy8gdGhlIHByb3BlcnR5IGFzc2lnbmVkIHRvIHRoZSBhY3R1YWwgcm91dGVyXG4gICAgLy8gVGhlIHZhbHVlIG1pZ2h0IGdldCBjaGFuZ2VkIGFzIHdlIGNoYW5nZSByb3V0ZXMgYW5kIHRoaXMgaXMgdGhlXG4gICAgLy8gcHJvcGVyIHdheSB0byBhY2Nlc3MgaXRcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShpbnN0YW5jZSwgZmllbGQsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGluc3RhbmNlW2ZpZWxkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByb3V0ZXJbZmllbGRdLmFwcGx5KHJvdXRlciwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9yb3V0ZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgNSA2IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXNJdGVyYWJsZTIgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9pcy1pdGVyYWJsZVwiKTtcblxudmFyIF9pc0l0ZXJhYmxlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSXRlcmFibGUyKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShhcnIpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXNJdGVyYWJsZTMuZGVmYXVsdCkoT2JqZWN0KGFycikpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiA1IDYiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpIHtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiKTtcblxudmFyIF9hc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX2Fzc2lnbjIuZGVmYXVsdCB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiA1IDYiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXByb3RvLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKSB7XG4gIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMi4wXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi4yLjAnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gQ29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbmZ1bmN0aW9uIEFzeW5jQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgYXN5bmNDb21wb25lbnRQcm90b3R5cGUgPSBBc3luY0NvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXN5bmNDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24oYXN5bmNDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7XG4gICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pO1xuICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuJCR0eXBlb2YgPT09ICd1bmRlZmluZWQnIHx8IHByb3BzLiQkdHlwZW9mICE9PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVmYWN0b3J5XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xuXG57XG4gIC8vIENvbXBvbmVudCB0aGF0IGlzIGJlaW5nIHdvcmtlZCBvblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHJldHVybiBpbXBsKCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG5cbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG52YXIgUE9PTF9TSVpFID0gMTA7XG52YXIgdHJhdmVyc2VDb250ZXh0UG9vbCA9IFtdO1xuZnVuY3Rpb24gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gdHJhdmVyc2VDb250ZXh0UG9vbC5wb3AoKTtcbiAgICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbWFwUmVzdWx0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgICByZXR1cm4gdHJhdmVyc2VDb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IG1hcFJlc3VsdCxcbiAgICAgIGtleVByZWZpeDoga2V5UHJlZml4LFxuICAgICAgZnVuYzogbWFwRnVuY3Rpb24sXG4gICAgICBjb250ZXh0OiBtYXBDb250ZXh0LFxuICAgICAgY291bnQ6IDBcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KSB7XG4gIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCA8IFBPT0xfU0laRSkge1xuICAgIHRyYXZlcnNlQ29udGV4dFBvb2wucHVzaCh0cmF2ZXJzZUNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG51bGwsIG51bGwsIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdCxcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHtcbiAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbntcbiAgdmFyIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcblxuICB2YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcblxuICB2YXIgZ2V0RGlzcGxheU5hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnI2VtcHR5JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnI3RleHQnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHJldHVybiAnUmVhY3QuRnJhZ21lbnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7XG4gICAgaWYgKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KTtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9vd25lcjtcbiAgICAgIHN0YWNrICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgZ2V0Q29tcG9uZW50TmFtZShvd25lcikpO1xuICAgIH1cbiAgICBzdGFjayArPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSB8fCAnJztcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgdmFyIFZBTElEX0ZSQUdNRU5UX1BST1BTID0gbmV3IE1hcChbWydjaGlsZHJlbicsIHRydWVdLCBbJ2tleScsIHRydWVdXSk7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50UHJvcHMuX19zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50UHJvcHMuX19zb3VyY2U7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICdcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyKSArICcuJztcbiAgfVxuXG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAge1xuICAgIHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgdmFyIHByb3BUeXBlcyA9IGNvbXBvbmVudENsYXNzLnByb3BUeXBlcztcbiAgaWYgKHByb3BUeXBlcykge1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSk7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudENsYXNzLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgbmFtZSB8fCAnVW5rbm93bicpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBmcmFnbWVudDtcblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcylbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmICghVkFMSURfRlJBR01FTlRfUFJPUFMuaGFzKGtleSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4lcycsIGtleSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3JbJ3JldHVybiddKSB7XG4gICAgICAgIF9pdGVyYXRvclsncmV0dXJuJ10oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4lcycsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N5bWJvbCcgfHwgdHlwZW9mIHR5cGUgPT09ICdudW1iZXInO1xuICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShwcm9wcyk7XG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICBpbmZvICs9IGdldFN0YWNrQWRkZW5kdW0oKSB8fCAnJztcblxuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnICYmIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbnZhciBSZWFjdCA9IHtcbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IG1hcENoaWxkcmVuLFxuICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogQ29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBQdXJlQ29tcG9uZW50LFxuICB1bnN0YWJsZV9Bc3luY0NvbXBvbmVudDogQXN5bmNDb21wb25lbnQsXG5cbiAgRnJhZ21lbnQ6IFJFQUNUX0ZSQUdNRU5UX1RZUEUsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24sXG4gIGlzVmFsaWRFbGVtZW50OiBpc1ZhbGlkRWxlbWVudCxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gICAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgICBhc3NpZ246IF9hc3NpZ25cbiAgfVxufTtcblxue1xuICBfYXNzaWduKFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELCB7XG4gICAgLy8gVGhlc2Ugc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiBwcm9kdWN0aW9uLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWU6IFJlYWN0RGVidWdDdXJyZW50RnJhbWUsXG4gICAgLy8gU2hpbSBmb3IgUmVhY3QgRE9NIDE2LjAuMCB3aGljaCBzdGlsbCBkZXN0cnVjdHVyZWQgKGJ1dCBub3QgdXNlZCkgdGhpcy5cbiAgICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuMC5cbiAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rOiB7fVxuICB9KTtcbn1cblxuXG5cbnZhciBSZWFjdCQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0XG59KTtcblxudmFyIFJlYWN0JDMgPSAoIFJlYWN0JDIgJiYgUmVhY3QgKSB8fCBSZWFjdCQyO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdCA9IFJlYWN0JDNbJ2RlZmF1bHQnXSA/IFJlYWN0JDNbJ2RlZmF1bHQnXSA6IFJlYWN0JDM7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3Q7XG4gIH0pKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA2IiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDYiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3BlcmZvcm0uanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDYiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgNiIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0laRSA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICB2YXIgZW50cnk7XG4gIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IgKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgIGlmIChlbnRyeS5rID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGZvciAodmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKSwgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wKSBlbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubjtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYgKHRoYXQuX2YgPT0gZW50cnkpIHRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmICh0aGF0Ll9sID09IGVudHJ5KSB0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKSB7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTkFNRSksIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHRoaXMsIE5BTUUpW1NJWkVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICB2YXIgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZiAoIXRoYXQuX2YpIHRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDLCBOQU1FLCBJU19NQVApIHtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICB0aGlzLl90ID0gdmFsaWRhdGUoaXRlcmF0ZWQsIE5BTUUpOyAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7ICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGtpbmQgPSB0aGF0Ll9rO1xuICAgICAgdmFyIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgZWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKSB7XG4gIHZhciBCYXNlID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgQyA9IEJhc2U7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBwcm90byA9IEMgJiYgQy5wcm90b3R5cGU7XG4gIHZhciBPID0ge307XG4gIGlmICghREVTQ1JJUFRPUlMgfHwgdHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSwgJ19jJyk7XG4gICAgICB0YXJnZXQuX2MgPSBuZXcgQmFzZSgpO1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGFyZ2V0W0FEREVSXSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBlYWNoKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04nLnNwbGl0KCcsJyksIGZ1bmN0aW9uIChLRVkpIHtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG4gICAgICBpZiAoS0VZIGluIHByb3RvICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gJ2NsZWFyJykpIGhpZGUoQy5wcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBDLCBLRVkpO1xuICAgICAgICBpZiAoIUlTX0FEREVSICYmIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpKSByZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIElTX1dFQUsgfHwgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYsIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiA1IDYiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXIsIElURVJBVE9SKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgNSA2IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIEEgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIEFbbGVuZ3RoXSA9IGFyZ3VtZW50c1tsZW5ndGhdO1xuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgZnJvbTogZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBGbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBtYXBGbiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWFwcGluZywgQSwgbiwgY2I7XG4gICAgYUZ1bmN0aW9uKHRoaXMpO1xuICAgIG1hcHBpbmcgPSBtYXBGbiAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChtYXBwaW5nKSBhRnVuY3Rpb24obWFwRm4pO1xuICAgIGlmIChzb3VyY2UgPT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IHRoaXMoKTtcbiAgICBBID0gW107XG4gICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgIG4gPSAwO1xuICAgICAgY2IgPSBjdHgobWFwRm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBmdW5jdGlvbiAobmV4dEl0ZW0pIHtcbiAgICAgICAgQS5wdXNoKGNiKG5leHRJdGVtLCBuKyspKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBBLnB1c2gsIEEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLWZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDUgNiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5c1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDUgNiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Qua2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDUgNiIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDUgNiIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiA1IDYiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXQgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDUgNiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9pcy1pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDUgNiIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIgNSA2IiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIgNSA2IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgNiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDYiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuUHJvbWlzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA2IiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIHByb21pc2UuX2ggIT09IDEgJiYgKHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYykubGVuZ3RoID09PSAwO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgNiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDYiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyBTYWZhcmkgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIgJiYgIShnbG9iYWwubmF2aWdhdG9yICYmIGdsb2JhbC5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpIHtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZiAoIWhlYWQpIHtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWljcm90YXNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA2IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHksXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICB9IDogb25GaW5hbGx5XG4gICk7XG59IH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgNiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeS5qc1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgNiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5TZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA2IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0VUID0gJ1NldCc7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgNiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0JywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDUgNiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnU2V0Jyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0Lm9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNSA2IiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0LmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnU2V0Jyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0LmZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA1IDYiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgNSA2IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2V0ID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXRcIik7XG5cbnZhciBfc2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldCk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIik7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIEV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEV2ZW50RW1pdHRlcik7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKEV2ZW50RW1pdHRlciwgW3tcbiAgICBrZXk6IFwib25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnQsIGNiKSB7XG4gICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudF0gPSBuZXcgX3NldDIuZGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnRdLmhhcyhjYikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxpc3RlbmVyIGFscmVhZHkgZXhpc2luZyBpbiBldmVudDogXCIgKyBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50XS5hZGQoY2IpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkYXRhID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBkYXRhW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1tldmVudF0pIHJldHVybjtcbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICByZXR1cm4gY2IuYXBwbHkodW5kZWZpbmVkLCBkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2ZW50LCBjYikge1xuICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRdLmRlbGV0ZShjYik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RW1pdHRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL0V2ZW50RW1pdHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCA1IDYiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNoYWxsb3dFcXVhbHM7XG5mdW5jdGlvbiBzaGFsbG93RXF1YWxzKGEsIGIpIHtcbiAgZm9yICh2YXIgaSBpbiBhKSB7XG4gICAgaWYgKGJbaV0gIT09IGFbaV0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIF9pIGluIGIpIHtcbiAgICBpZiAoYltfaV0gIT09IGFbX2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL3NoYWxsb3ctZXF1YWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDUgNiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzJyk7XG5cbnZhciBfZXh0ZW5kczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmRzMik7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSB3aXRoUm91dGVyO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzID0gcmVxdWlyZSgnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnKTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ob2lzdE5vblJlYWN0U3RhdGljcyk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB3aXRoUm91dGVyKENvbXBvc2VkQ29tcG9uZW50KSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9ICgwLCBfdXRpbHMuZ2V0RGlzcGxheU5hbWUpKENvbXBvc2VkQ29tcG9uZW50KTtcblxuICB2YXIgV2l0aFJvdXRlV3JhcHBlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoV2l0aFJvdXRlV3JhcHBlciwgX0NvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBXaXRoUm91dGVXcmFwcGVyKCkge1xuICAgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgV2l0aFJvdXRlV3JhcHBlcik7XG4gICAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoV2l0aFJvdXRlV3JhcHBlci5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoV2l0aFJvdXRlV3JhcHBlcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFdpdGhSb3V0ZVdyYXBwZXIsIFt7XG4gICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gKDAsIF9leHRlbmRzMy5kZWZhdWx0KSh7XG4gICAgICAgICAgcm91dGVyOiB0aGlzLmNvbnRleHQucm91dGVyXG4gICAgICAgIH0sIHRoaXMucHJvcHMpO1xuXG4gICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb3NlZENvbXBvbmVudCwgcHJvcHMpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gV2l0aFJvdXRlV3JhcHBlcjtcbiAgfShfcmVhY3QuQ29tcG9uZW50KTtcblxuICBXaXRoUm91dGVXcmFwcGVyLmNvbnRleHRUeXBlcyA9IHtcbiAgICByb3V0ZXI6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0XG4gIH07XG4gIFdpdGhSb3V0ZVdyYXBwZXIuZGlzcGxheU5hbWUgPSAnd2l0aFJvdXRlKCcgKyBkaXNwbGF5TmFtZSArICcpJztcblxuXG4gIHJldHVybiAoMCwgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMi5kZWZhdWx0KShXaXRoUm91dGVXcmFwcGVyLCBDb21wb3NlZENvbXBvbmVudCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9yb3V0ZXIvd2l0aC1yb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgNSA2IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZXM6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mICYmIGdldFByb3RvdHlwZU9mKE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuXG4gICAgICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5XSAmJiAhS05PV05fU1RBVElDU1trZXldICYmICghYmxhY2tsaXN0IHx8ICFibGFja2xpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHsgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCA1IDYiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheScpO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2xpY2VkVG9BcnJheTIpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mJyk7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG52YXIgX2V4dGVuZHMyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnKTtcblxudmFyIF9leHRlbmRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZHMyKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3InKTtcblxudmFyIF9yZWdlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWdlbmVyYXRvcik7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvcicpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmNUb0dlbmVyYXRvcjIpO1xuXG52YXIgX3NldCA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXQnKTtcblxudmFyIF9zZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfdXJsMiA9IHJlcXVpcmUoJ3VybCcpO1xuXG52YXIgX0V2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4uL0V2ZW50RW1pdHRlcicpO1xuXG52YXIgX0V2ZW50RW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudEVtaXR0ZXIpO1xuXG52YXIgX3NoYWxsb3dFcXVhbHMgPSByZXF1aXJlKCcuLi9zaGFsbG93LWVxdWFscycpO1xuXG52YXIgX3NoYWxsb3dFcXVhbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhbGxvd0VxdWFscyk7XG5cbnZhciBfcFF1ZXVlID0gcmVxdWlyZSgnLi4vcC1xdWV1ZScpO1xuXG52YXIgX3BRdWV1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wUXVldWUpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIF8gPSByZXF1aXJlKCcuLycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiBnbG9iYWwgX19ORVhUX0RBVEFfXyAqL1xuXG52YXIgUm91dGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSb3V0ZXIocGF0aG5hbWUsIHF1ZXJ5LCBhcykge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fSxcbiAgICAgICAgcGFnZUxvYWRlciA9IF9yZWYucGFnZUxvYWRlcixcbiAgICAgICAgQ29tcG9uZW50ID0gX3JlZi5Db21wb25lbnQsXG4gICAgICAgIEVycm9yQ29tcG9uZW50ID0gX3JlZi5FcnJvckNvbXBvbmVudCxcbiAgICAgICAgZXJyID0gX3JlZi5lcnI7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBSb3V0ZXIpO1xuXG4gICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgdGhpcy5yb3V0ZSA9IHRvUm91dGUocGF0aG5hbWUpO1xuXG4gICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgIGlmIChDb21wb25lbnQgIT09IEVycm9yQ29tcG9uZW50KSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0gPSB7IENvbXBvbmVudDogQ29tcG9uZW50LCBlcnI6IGVyciB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsaW5nIFJvdXRlciBFdmVudHNcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBfRXZlbnRFbWl0dGVyMi5kZWZhdWx0KCk7XG5cbiAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICAgIHRoaXMucHJlZmV0Y2hRdWV1ZSA9IG5ldyBfcFF1ZXVlMi5kZWZhdWx0KHsgY29uY3VycmVuY3k6IDIgfSk7XG4gICAgdGhpcy5FcnJvckNvbXBvbmVudCA9IEVycm9yQ29tcG9uZW50O1xuICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgdGhpcy5hc1BhdGggPSBhcztcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgX3NldDIuZGVmYXVsdCgpO1xuICAgIHRoaXMuY29tcG9uZW50TG9hZENhbmNlbCA9IG51bGw7XG4gICAgdGhpcy5vblBvcFN0YXRlID0gdGhpcy5vblBvcFN0YXRlLmJpbmQodGhpcyk7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsICgwLCBfdXJsMi5mb3JtYXQpKHsgcGF0aG5hbWU6IHBhdGhuYW1lLCBxdWVyeTogcXVlcnkgfSksICgwLCBfdXRpbHMuZ2V0VVJMKSgpKTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5vblBvcFN0YXRlKTtcbiAgICB9XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShSb3V0ZXIsIFt7XG4gICAga2V5OiAnb25Qb3BTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjMuZGVmYXVsdCkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IyLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGUpIHtcbiAgICAgICAgdmFyIHBhdGhuYW1lLCBxdWVyeSwgX2Ukc3RhdGUsIHVybCwgYXMsIG9wdGlvbnM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcjIuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmIChlLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgICAgICAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxuICAgICAgICAgICAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXG4gICAgICAgICAgICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cbiAgICAgICAgICAgICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUsIHF1ZXJ5ID0gdGhpcy5xdWVyeTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsICgwLCBfdXJsMi5mb3JtYXQpKHsgcGF0aG5hbWU6IHBhdGhuYW1lLCBxdWVyeTogcXVlcnkgfSksICgwLCBfdXRpbHMuZ2V0VVJMKSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgX2Ukc3RhdGUgPSBlLnN0YXRlLCB1cmwgPSBfZSRzdGF0ZS51cmwsIGFzID0gX2Ukc3RhdGUuYXMsIG9wdGlvbnMgPSBfZSRzdGF0ZS5vcHRpb25zO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlKHVybCwgYXMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9uUG9wU3RhdGUoX3gyKSB7XG4gICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb25Qb3BTdGF0ZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShyb3V0ZSwgQ29tcG9uZW50KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIHVuYXZhaWxhYmxlIHJvdXRlOiAnICsgcm91dGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RGF0YSA9ICgwLCBfZXh0ZW5kczMuZGVmYXVsdCkoe30sIGRhdGEsIHsgQ29tcG9uZW50OiBDb21wb25lbnQgfSk7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gbmV3RGF0YTtcblxuICAgICAgaWYgKHJvdXRlID09PSB0aGlzLnJvdXRlKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KG5ld0RhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmMyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjMuZGVmYXVsdCkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IyLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihyb3V0ZSkge1xuICAgICAgICB2YXIgcGF0aG5hbWUsIHF1ZXJ5LCB1cmwsIHJvdXRlSW5mbywgZXJyb3I7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IyLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmNsZWFyQ2FjaGUocm91dGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEocm91dGUgIT09IHRoaXMucm91dGUpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgncmV0dXJuJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSwgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuICAgICAgICAgICAgICAgIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuXG5cbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZVN0YXJ0JywgdXJsKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um91dGVJbmZvKHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIHVybCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHJvdXRlSW5mbyA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgIGVycm9yID0gcm91dGVJbmZvLmVycm9yO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoZXJyb3IgJiYgZXJyb3IuY2FuY2VsbGVkKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkocm91dGVJbmZvKTtcblxuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyb3IsIHVybCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcblxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCB1cmwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbG9hZChfeDMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWxvYWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6ICdiYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmFjaygpIHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh1cmwpIHtcbiAgICAgIHZhciBhcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdXJsO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlcGxhY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKHVybCkge1xuICAgICAgdmFyIGFzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB1cmw7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIHJldHVybiB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2hhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWY0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMy5kZWZhdWx0KSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcjIuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKG1ldGhvZCwgX3VybCwgX2FzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cmwsIGFzLCBfcGFyc2UsIHBhdGhuYW1lLCBxdWVyeSwgcm91dGUsIF9vcHRpb25zJHNoYWxsb3csIHNoYWxsb3csIHJvdXRlSW5mbywgX3JvdXRlSW5mbywgZXJyb3IsIGhhc2g7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcjIuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgICAgICAgICAgICAgICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICAgICAgICAgICAgICAgIHVybCA9ICh0eXBlb2YgX3VybCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShfdXJsKSkgPT09ICdvYmplY3QnID8gKDAsIF91cmwyLmZvcm1hdCkoX3VybCkgOiBfdXJsO1xuICAgICAgICAgICAgICAgIGFzID0gKHR5cGVvZiBfYXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoX2FzKSkgPT09ICdvYmplY3QnID8gKDAsIF91cmwyLmZvcm1hdCkoX2FzKSA6IF9hcztcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZW5kaW5nIHNsYXNoIHRvIHRoZSBwYXRocy4gU28sIHdlIGNhbiBzZXJ2ZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBcIjxwYWdlPi9pbmRleC5odG1sXCIgZGlyZWN0bHkgZm9yIHRoZSBTU1IgcGFnZS5cblxuICAgICAgICAgICAgICAgIGlmIChfX05FWFRfREFUQV9fLm5leHRFeHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgIGFzID0gKDAsIF8uX3Jld3JpdGVVcmxGb3JOZXh0RXhwb3J0KShhcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbXBvbmVudExvYWQoYXMpO1xuICAgICAgICAgICAgICAgIF9wYXJzZSA9ICgwLCBfdXJsMi5wYXJzZSkodXJsLCB0cnVlKSwgcGF0aG5hbWUgPSBfcGFyc2UucGF0aG5hbWUsIHF1ZXJ5ID0gX3BhcnNlLnF1ZXJ5O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub25seUFIYXNoQ2hhbmdlKGFzKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGFzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgncmV0dXJuJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuXG4gICAgICAgICAgICAgICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgICAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgICAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy51cmxJc05ldyhwYXRobmFtZSwgcXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb3V0ZSA9IHRvUm91dGUocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIF9vcHRpb25zJHNoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3csIHNoYWxsb3cgPSBfb3B0aW9ucyRzaGFsbG93ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHNoYWxsb3c7XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvID0gbnVsbDtcblxuXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHNoYWxsb3cgPT09IGZhbHNlIGFuZCBvdGhlciBjb25kaXRpb25zIG1ldCwgd2UgcmV1c2UgdGhlXG4gICAgICAgICAgICAgICAgLy8gZXhpc3Rpbmcgcm91dGVJbmZvIGZvciB0aGlzIHJvdXRlLlxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhpcywgZ2V0SW5pdGlhbFByb3BzIHdvdWxkIG5vdCBydW4uXG5cbiAgICAgICAgICAgICAgICBpZiAoIShzaGFsbG93ICYmIHRoaXMuaXNTaGFsbG93Um91dGluZ1Bvc3NpYmxlKHJvdXRlKSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSB0aGlzLmNvbXBvbmVudHNbcm91dGVdO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDIwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJvdXRlSW5mbyhyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgIF9yb3V0ZUluZm8gPSByb3V0ZUluZm8sIGVycm9yID0gX3JvdXRlSW5mby5lcnJvcjtcblxuICAgICAgICAgICAgICAgIGlmICghKGVycm9yICYmIGVycm9yLmNhbmNlbGxlZCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgncmV0dXJuJywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjQ6XG5cbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpO1xuXG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldChyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgKDAsIF9leHRlbmRzMy5kZWZhdWx0KSh7fSwgcm91dGVJbmZvLCB7IGhhc2g6IGhhc2ggfSkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgYXMpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzE6XG5cbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCdyZXR1cm4nLCB0cnVlKTtcblxuICAgICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjaGFuZ2UoX3g4LCBfeDksIF94MTAsIF94MTEpIHtcbiAgICAgICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6ICdjaGFuZ2VTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgICBpZiAobWV0aG9kICE9PSAncHVzaFN0YXRlJyB8fCAoMCwgX3V0aWxzLmdldFVSTCkoKSAhPT0gYXMpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXSh7IHVybDogdXJsLCBhczogYXMsIG9wdGlvbnM6IG9wdGlvbnMgfSwgbnVsbCwgYXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFJvdXRlSW5mbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmNSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjMuZGVmYXVsdCkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IyLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNChyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcykge1xuICAgICAgICB2YXIgcm91dGVJbmZvLCBfcm91dGVJbmZvMiwgQ29tcG9uZW50LCBjdHgsIF9Db21wb25lbnQsIF9jdHg7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcjIuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBudWxsO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMTtcblxuICAgICAgICAgICAgICAgIHJvdXRlSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG5cbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUsIGFzKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgQ29tcG9uZW50OiBfY29udGV4dDQudDBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBfcm91dGVJbmZvMiA9IHJvdXRlSW5mbywgQ29tcG9uZW50ID0gX3JvdXRlSW5mbzIuQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGN0eCA9IHsgcGF0aG5hbWU6IHBhdGhuYW1lLCBxdWVyeTogcXVlcnksIGFzUGF0aDogYXMgfTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIGN0eCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBfY29udGV4dDQuc2VudDtcblxuXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDMyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAxNjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDQudDEgPSBfY29udGV4dDRbJ2NhdGNoJ10oMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIV9jb250ZXh0NC50MS5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdCgncmV0dXJuJywgeyBlcnJvcjogX2NvbnRleHQ0LnQxIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgaWYgKCFfY29udGV4dDQudDEuYnVpbGRJZE1pc21hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBOb3cgd2UgbmVlZCB0byByZWxvYWQgdGhlIHBhZ2Ugb3IgZG8gdGhlIGFjdGlvbiBhc2tlZCBieSB0aGUgdXNlclxuICAgICAgICAgICAgICAgICgwLCBfLl9ub3RpZnlCdWlsZElkTWlzbWF0Y2gpKGFzKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gY2FuY2VsIHRoaXMgY3VycmVudCByb3V0ZSBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gaXQgbGlrZSB0aGlzLlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NC50MS5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nLCB7IGVycm9yOiBfY29udGV4dDQudDEgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNDpcblxuICAgICAgICAgICAgICAgIGlmIChfY29udGV4dDQudDEuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZSBtYWluIGVycm9yIGRpc3BsYXkgbG9naWMgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSByZW5kZXJpbmcgdGhpcyBlcnJvciBhcyBhIHJ1bnRpbWUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDQudDEuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfQ29tcG9uZW50ID0gdGhpcy5FcnJvckNvbXBvbmVudDtcblxuICAgICAgICAgICAgICAgIHJvdXRlSW5mbyA9IHsgQ29tcG9uZW50OiBfQ29tcG9uZW50LCBlcnI6IF9jb250ZXh0NC50MSB9O1xuICAgICAgICAgICAgICAgIF9jdHggPSB7IGVycjogX2NvbnRleHQ0LnQxLCBwYXRobmFtZTogcGF0aG5hbWUsIHF1ZXJ5OiBxdWVyeSB9O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5pdGlhbFByb3BzKF9Db21wb25lbnQsIF9jdHgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gX2NvbnRleHQ0LnNlbnQ7XG5cblxuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5lcnJvciA9IF9jb250ZXh0NC50MTtcblxuICAgICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nLCByb3V0ZUluZm8pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcywgW1sxLCAxNl1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0Um91dGVJbmZvKF94MTMsIF94MTQsIF94MTUsIF94MTYpIHtcbiAgICAgICAgcmV0dXJuIF9yZWY1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRSb3V0ZUluZm87XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6ICdzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQocm91dGUsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIGRhdGEpIHtcbiAgICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgIHRoaXMuYXNQYXRoID0gYXM7XG4gICAgICB0aGlzLm5vdGlmeShkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbmx5QUhhc2hDaGFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmx5QUhhc2hDaGFuZ2UoYXMpIHtcbiAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgdmFyIF9hc1BhdGgkc3BsaXQgPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpLFxuICAgICAgICAgIF9hc1BhdGgkc3BsaXQyID0gKDAsIF9zbGljZWRUb0FycmF5My5kZWZhdWx0KShfYXNQYXRoJHNwbGl0LCAyKSxcbiAgICAgICAgICBvbGRVcmxOb0hhc2ggPSBfYXNQYXRoJHNwbGl0MlswXSxcbiAgICAgICAgICBvbGRIYXNoID0gX2FzUGF0aCRzcGxpdDJbMV07XG5cbiAgICAgIHZhciBfYXMkc3BsaXQgPSBhcy5zcGxpdCgnIycpLFxuICAgICAgICAgIF9hcyRzcGxpdDIgPSAoMCwgX3NsaWNlZFRvQXJyYXkzLmRlZmF1bHQpKF9hcyRzcGxpdCwgMiksXG4gICAgICAgICAgbmV3VXJsTm9IYXNoID0gX2FzJHNwbGl0MlswXSxcbiAgICAgICAgICBuZXdIYXNoID0gX2FzJHNwbGl0MlsxXTtcblxuICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuXG5cbiAgICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzY3JvbGxUb0hhc2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxUb0hhc2goYXMpIHtcbiAgICAgIHZhciBfYXMkc3BsaXQzID0gYXMuc3BsaXQoJyMnKSxcbiAgICAgICAgICBfYXMkc3BsaXQ0ID0gKDAsIF9zbGljZWRUb0FycmF5My5kZWZhdWx0KShfYXMkc3BsaXQzLCAyKSxcbiAgICAgICAgICBoYXNoID0gX2FzJHNwbGl0NFsxXTtcblxuICAgICAgdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCk7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgZWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cmxJc05ldycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVybElzTmV3KHBhdGhuYW1lLCBxdWVyeSkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aG5hbWUgIT09IHBhdGhuYW1lIHx8ICEoMCwgX3NoYWxsb3dFcXVhbHMyLmRlZmF1bHQpKHF1ZXJ5LCB0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc1NoYWxsb3dSb3V0aW5nUG9zc2libGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NoYWxsb3dSb3V0aW5nUG9zc2libGUocm91dGUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIElmIHRoZXJlJ3MgY2FjaGVkIHJvdXRlSW5mbyBmb3IgdGhlIHJvdXRlLlxuICAgICAgICBCb29sZWFuKHRoaXMuY29tcG9uZW50c1tyb3V0ZV0pICYmXG4gICAgICAgIC8vIElmIHRoZSByb3V0ZSBpcyBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBzY3JlZW4uXG4gICAgICAgIHRoaXMucm91dGUgPT09IHJvdXRlXG4gICAgICApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ByZWZldGNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWY2ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMy5kZWZhdWx0KSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcjIuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KHVybCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBfcGFyc2UyLCBwYXRobmFtZSwgcm91dGU7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcjIuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JykpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX3BhcnNlMiA9ICgwLCBfdXJsMi5wYXJzZSkodXJsKSwgcGF0aG5hbWUgPSBfcGFyc2UyLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHJvdXRlID0gdG9Sb3V0ZShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoJ3JldHVybicsIHRoaXMucHJlZmV0Y2hRdWV1ZS5hZGQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZldGNoUm91dGUocm91dGUpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHByZWZldGNoKF94MTcpIHtcbiAgICAgICAgcmV0dXJuIF9yZWY2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVmZXRjaDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogJ2ZldGNoQ29tcG9uZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWY3ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMy5kZWZhdWx0KSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcjIuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KHJvdXRlLCBhcykge1xuICAgICAgICB2YXIgY2FuY2VsbGVkLCBjYW5jZWwsIENvbXBvbmVudCwgZXJyb3I7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IyLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBjYW5jZWwgPSB0aGlzLmNvbXBvbmVudExvYWRDYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDI7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoUm91dGUocm91dGUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBDb21wb25lbnQgPSBfY29udGV4dDYuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0Fib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJyArIHJvdXRlICsgJ1wiJyk7XG5cbiAgICAgICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNvbXBvbmVudExvYWRDYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TG9hZENhbmNlbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoJ3JldHVybicsIENvbXBvbmVudCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDE0O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni50MCA9IF9jb250ZXh0NlsnY2F0Y2gnXSgyKTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3MgYW4gZXJyb3IgaW4gbG9hZGluZyB0aGUgcm91dGUuXG4gICAgICAgICAgICAgICAgLy8gVXN1YWxseSB0aGlzIGhhcHBlbnMgd2hlbiB0aGVyZSdzIGEgZmFpbHVyZSBpbiB0aGUgd2VicGFjayBidWlsZFxuICAgICAgICAgICAgICAgIC8vIFNvIGluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byBsb2FkIHRoZSBwYWdlIHdpdGggZnVsbCBTU1JcbiAgICAgICAgICAgICAgICAvLyBUaGF0J2xsIGNsZWFuIHRoZSBpbnZhbGlkIGV4aXNpbmcgY2xpZW50IHNpZGUgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgLy8gKExpa2UgY2FjaGVkIHJvdXRlcylcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzO1xuICAgICAgICAgICAgICAgIHRocm93IF9jb250ZXh0Ni50MDtcblxuICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMsIFtbMiwgMTRdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGZldGNoQ29tcG9uZW50KF94MTgsIF94MTkpIHtcbiAgICAgICAgcmV0dXJuIF9yZWY3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmZXRjaENvbXBvbmVudDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogJ2dldEluaXRpYWxQcm9wcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmOCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjMuZGVmYXVsdCkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IyLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhDb21wb25lbnQsIGN0eCkge1xuICAgICAgICB2YXIgY2FuY2VsbGVkLCBjYW5jZWwsIHByb3BzLCBlcnI7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IyLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBjYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudExvYWRDYW5jZWwgPSBjYW5jZWw7XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMubG9hZEdldEluaXRpYWxQcm9wcykoQ29tcG9uZW50LCBjdHgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBwcm9wcyA9IF9jb250ZXh0Ny5zZW50O1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNvbXBvbmVudExvYWRDYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TG9hZENhbmNlbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKTtcblxuICAgICAgICAgICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KCdyZXR1cm4nLCBwcm9wcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU3LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFByb3BzKF94MjAsIF94MjEpIHtcbiAgICAgICAgcmV0dXJuIF9yZWY4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRJbml0aWFsUHJvcHM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6ICdmZXRjaFJvdXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWY5ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMy5kZWZhdWx0KSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcjIuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IyLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdCgncmV0dXJuJywgX2NvbnRleHQ4LnNlbnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZmV0Y2hSb3V0ZShfeDIyKSB7XG4gICAgICAgIHJldHVybiBfcmVmOS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmV0Y2hSb3V0ZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogJ2Fib3J0Q29tcG9uZW50TG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0Q29tcG9uZW50TG9hZChhcykge1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50TG9hZENhbmNlbCkge1xuICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgbmV3IEVycm9yKCdSb3V0ZSBDYW5jZWxsZWQnKSwgYXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudExvYWRDYW5jZWwoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRMb2FkQ2FuY2VsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdub3RpZnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3RpZnkoZGF0YSkge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbihkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N1YnNjcmliZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZShmbikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoZm4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5zdWJzY3JpcHRpb25zLmRlbGV0ZShmbik7XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUm91dGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZXI7XG5cblxuZnVuY3Rpb24gdG9Sb3V0ZShwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvcm91dGVyL3JvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCA1IDYiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3VybC91cmwuanNcbi8vIG1vZHVsZSBpZCA9IDIzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgNSA2IiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDUgNiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDUgNiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wcm9taXNlID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UnKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduJyk7XG5cbnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtcXVldWUgKE1JVClcbi8vIG1vZGlmaWVkIGZvciBicm93c2VyIHN1cHBvcnRcblxudmFyIFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBRdWV1ZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBRdWV1ZSk7XG5cbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoUXVldWUsIFt7XG4gICAga2V5OiAnZW5xdWV1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVucXVldWUocnVuKSB7XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKHJ1bik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVxdWV1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlcXVldWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzaXplJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5sZW5ndGg7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBRdWV1ZTtcbn0oKTtcblxudmFyIFBRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUFF1ZXVlKG9wdHMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBQUXVldWUpO1xuXG4gICAgb3B0cyA9ICgwLCBfYXNzaWduMi5kZWZhdWx0KSh7XG4gICAgICBjb25jdXJyZW5jeTogSW5maW5pdHksXG4gICAgICBxdWV1ZUNsYXNzOiBRdWV1ZVxuICAgIH0sIG9wdHMpO1xuXG4gICAgaWYgKG9wdHMuY29uY3VycmVuY3kgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgY29uY3VycmVuY3lgIHRvIGJlIGEgbnVtYmVyIGZyb20gMSBhbmQgdXAnKTtcbiAgICB9XG5cbiAgICB0aGlzLnF1ZXVlID0gbmV3IG9wdHMucXVldWVDbGFzcygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgICB0aGlzLl9wZW5kaW5nQ291bnQgPSAwO1xuICAgIHRoaXMuX2NvbmN1cnJlbmN5ID0gb3B0cy5jb25jdXJyZW5jeTtcbiAgICB0aGlzLl9yZXNvbHZlRW1wdHkgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFBRdWV1ZSwgW3tcbiAgICBrZXk6ICdfbmV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXh0KCkge1xuICAgICAgdGhpcy5fcGVuZGluZ0NvdW50LS07XG5cbiAgICAgIGlmICh0aGlzLnF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgIHRoaXMucXVldWUuZGVxdWV1ZSgpKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXNvbHZlRW1wdHkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZm4sIG9wdHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgX3Byb21pc2UyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICAgICAgICAgIF90aGlzLl9wZW5kaW5nQ291bnQrKztcblxuICAgICAgICAgIGZuKCkudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbCk7XG4gICAgICAgICAgICBfdGhpcy5fbmV4dCgpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgX3RoaXMuX25leHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoX3RoaXMuX3BlbmRpbmdDb3VudCA8IF90aGlzLl9jb25jdXJyZW5jeSkge1xuICAgICAgICAgIHJ1bigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLnF1ZXVlLmVucXVldWUocnVuLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25FbXB0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRW1wdHkoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBfcHJvbWlzZTIuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmdSZXNvbHZlID0gX3RoaXMyLl9yZXNvbHZlRW1wdHk7XG4gICAgICAgIF90aGlzMi5fcmVzb2x2ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGV4aXN0aW5nUmVzb2x2ZSgpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NpemUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucXVldWUuc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwZW5kaW5nJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQUXVldWU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBRdWV1ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL3AtcXVldWUuanNcbi8vIG1vZHVsZSBpZCA9IDIzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgNSA2IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hcCA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXAnKTtcblxudmFyIF9tYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFwKTtcblxudmFyIF9zbGljZWRUb0FycmF5MiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5Jyk7XG5cbnZhciBfc2xpY2VkVG9BcnJheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zbGljZWRUb0FycmF5Mik7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxudmFyIF9pbmhlcml0czIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcblxudmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5leHBvcnRzLmZsdXNoID0gZmx1c2g7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3N0eWxlc2hlZXRSZWdpc3RyeSA9IHJlcXVpcmUoJy4vc3R5bGVzaGVldC1yZWdpc3RyeScpO1xuXG52YXIgX3N0eWxlc2hlZXRSZWdpc3RyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHlsZXNoZWV0UmVnaXN0cnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc3R5bGVTaGVldFJlZ2lzdHJ5ID0gbmV3IF9zdHlsZXNoZWV0UmVnaXN0cnkyLmRlZmF1bHQoKTtcblxudmFyIEpTWFN0eWxlID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoSlNYU3R5bGUsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEpTWFN0eWxlKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEpTWFN0eWxlKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoSlNYU3R5bGUuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEpTWFN0eWxlKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShKU1hTdHlsZSwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICBzdHlsZVNoZWV0UmVnaXN0cnkuYWRkKHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNzcyAhPT0gbmV4dFByb3BzLmNzcztcbiAgICB9XG5cbiAgICAvLyBUbyBhdm9pZCBGT1VDLCB3ZSBwcm9jZXNzIG5ldyBjaGFuZ2VzXG4gICAgLy8gb24gYGNvbXBvbmVudFdpbGxVcGRhdGVgIHJhdGhlciB0aGFuIGBjb21wb25lbnREaWRVcGRhdGVgLlxuXG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgIHN0eWxlU2hlZXRSZWdpc3RyeS51cGRhdGUodGhpcy5wcm9wcywgbmV4dFByb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgc3R5bGVTaGVldFJlZ2lzdHJ5LnJlbW92ZSh0aGlzLnByb3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2R5bmFtaWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkeW5hbWljKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLm1hcChmdW5jdGlvbiAodGFnSW5mbykge1xuICAgICAgICB2YXIgX3RhZ0luZm8gPSAoMCwgX3NsaWNlZFRvQXJyYXkzLmRlZmF1bHQpKHRhZ0luZm8sIDIpLFxuICAgICAgICAgICAgYmFzZUlkID0gX3RhZ0luZm9bMF0sXG4gICAgICAgICAgICBwcm9wcyA9IF90YWdJbmZvWzFdO1xuXG4gICAgICAgIHJldHVybiBzdHlsZVNoZWV0UmVnaXN0cnkuY29tcHV0ZUlkKGJhc2VJZCwgcHJvcHMpO1xuICAgICAgfSkuam9pbignICcpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSlNYU3R5bGU7XG59KF9yZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBKU1hTdHlsZTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICB2YXIgY3NzUnVsZXMgPSBzdHlsZVNoZWV0UmVnaXN0cnkuY3NzUnVsZXMoKTtcbiAgc3R5bGVTaGVldFJlZ2lzdHJ5LmZsdXNoKCk7XG4gIHJldHVybiBuZXcgX21hcDIuZGVmYXVsdChjc3NSdWxlcyk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9kaXN0L3N0eWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzODFcbi8vIG1vZHVsZSBjaHVua3MgPSAyIDUgNiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9tYXBcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzODJcbi8vIG1vZHVsZSBjaHVua3MgPSAyIDUgNiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5tYXAub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5NYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzODNcbi8vIG1vZHVsZSBjaHVua3MgPSAyIDUgNiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIE1BUCA9ICdNYXAnO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShNQVAsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzODRcbi8vIG1vZHVsZSBjaHVua3MgPSAyIDUgNiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMiA1IDYiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ01hcCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm1hcC5vZi5qc1xuLy8gbW9kdWxlIGlkID0gMzg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMiA1IDYiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdNYXAnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5tYXAuZnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMzg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMiA1IDYiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfa2V5cyA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cycpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3N0cmluZ0hhc2ggPSByZXF1aXJlKCdzdHJpbmctaGFzaCcpO1xuXG52YXIgX3N0cmluZ0hhc2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5nSGFzaCk7XG5cbnZhciBfc3R5bGVzaGVldCA9IHJlcXVpcmUoJy4vbGliL3N0eWxlc2hlZXQnKTtcblxudmFyIF9zdHlsZXNoZWV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0eWxlc2hlZXQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgU3R5bGVTaGVldFJlZ2lzdHJ5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVNoZWV0UmVnaXN0cnkoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBfcmVmJHN0eWxlU2hlZXQgPSBfcmVmLnN0eWxlU2hlZXQsXG4gICAgICAgIHN0eWxlU2hlZXQgPSBfcmVmJHN0eWxlU2hlZXQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBfcmVmJHN0eWxlU2hlZXQsXG4gICAgICAgIF9yZWYkb3B0aW1pemVGb3JTcGVlZCA9IF9yZWYub3B0aW1pemVGb3JTcGVlZCxcbiAgICAgICAgb3B0aW1pemVGb3JTcGVlZCA9IF9yZWYkb3B0aW1pemVGb3JTcGVlZCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG9wdGltaXplRm9yU3BlZWQsXG4gICAgICAgIF9yZWYkaXNCcm93c2VyID0gX3JlZi5pc0Jyb3dzZXIsXG4gICAgICAgIGlzQnJvd3NlciA9IF9yZWYkaXNCcm93c2VyID09PSB1bmRlZmluZWQgPyB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA6IF9yZWYkaXNCcm93c2VyO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU3R5bGVTaGVldFJlZ2lzdHJ5KTtcblxuICAgIHRoaXMuX3NoZWV0ID0gc3R5bGVTaGVldCB8fCBuZXcgX3N0eWxlc2hlZXQyLmRlZmF1bHQoe1xuICAgICAgbmFtZTogJ3N0eWxlZC1qc3gnLFxuICAgICAgb3B0aW1pemVGb3JTcGVlZDogb3B0aW1pemVGb3JTcGVlZFxuICAgIH0pO1xuICAgIHRoaXMuX3NoZWV0LmluamVjdCgpO1xuICAgIHRoaXMuX2lzQnJvd3NlciA9IGlzQnJvd3NlcjtcblxuICAgIHRoaXMuX2Zyb21TZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgIHRoaXMuX2luc3RhbmNlc0NvdW50cyA9IHt9O1xuXG4gICAgdGhpcy5jb21wdXRlSWQgPSB0aGlzLmNyZWF0ZUNvbXB1dGVJZCgpO1xuICAgIHRoaXMuY29tcHV0ZVNlbGVjdG9yID0gdGhpcy5jcmVhdGVDb21wdXRlU2VsZWN0b3IoKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFN0eWxlU2hlZXRSZWdpc3RyeSwgW3tcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQocHJvcHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh1bmRlZmluZWQgPT09IHRoaXMuX29wdGltaXplRm9yU3BlZWQpIHtcbiAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IEFycmF5LmlzQXJyYXkocHJvcHMuY3NzKTtcbiAgICAgICAgdGhpcy5fc2hlZXQuc2V0T3B0aW1pemVGb3JTcGVlZCh0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKTtcbiAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IHRoaXMuX3NoZWV0LmlzT3B0aW1pemVGb3JTcGVlZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faXNCcm93c2VyICYmICF0aGlzLl9mcm9tU2VydmVyKSB7XG4gICAgICAgIHRoaXMuX2Zyb21TZXJ2ZXIgPSB0aGlzLnNlbGVjdEZyb21TZXJ2ZXIoKTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VzQ291bnRzID0gKDAsIF9rZXlzMi5kZWZhdWx0KSh0aGlzLl9mcm9tU2VydmVyKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdGFnTmFtZSkge1xuICAgICAgICAgIGFjY1t0YWdOYW1lXSA9IDA7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2dldElkQW5kUnVsZXMgPSB0aGlzLmdldElkQW5kUnVsZXMocHJvcHMpLFxuICAgICAgICAgIHN0eWxlSWQgPSBfZ2V0SWRBbmRSdWxlcy5zdHlsZUlkLFxuICAgICAgICAgIHJ1bGVzID0gX2dldElkQW5kUnVsZXMucnVsZXM7XG5cbiAgICAgIC8vIERlZHVwaW5nOiBqdXN0IGluY3JlYXNlIHRoZSBpbnN0YW5jZXMgY291bnQuXG5cblxuICAgICAgaWYgKHN0eWxlSWQgaW4gdGhpcy5faW5zdGFuY2VzQ291bnRzKSB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSArPSAxO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRpY2VzID0gcnVsZXMubWFwKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5fc2hlZXQuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgIH0pXG4gICAgICAvLyBGaWx0ZXIgb3V0IGludmFsaWQgcnVsZXNcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCAhPT0gLTE7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl9pbmRpY2VzW3N0eWxlSWRdID0gaW5kaWNlcztcbiAgICAgICAgdGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUocHJvcHMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgX2dldElkQW5kUnVsZXMyID0gdGhpcy5nZXRJZEFuZFJ1bGVzKHByb3BzKSxcbiAgICAgICAgICBzdHlsZUlkID0gX2dldElkQW5kUnVsZXMyLnN0eWxlSWQ7XG5cbiAgICAgIGludmFyaWFudChzdHlsZUlkIGluIHRoaXMuX2luc3RhbmNlc0NvdW50cywgJ3N0eWxlSWQ6IGAnICsgc3R5bGVJZCArICdgIG5vdCBmb3VuZCcpO1xuICAgICAgdGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdIC09IDE7XG5cbiAgICAgIGlmICh0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gPCAxKSB7XG4gICAgICAgIHZhciB0YWdGcm9tU2VydmVyID0gdGhpcy5fZnJvbVNlcnZlciAmJiB0aGlzLl9mcm9tU2VydmVyW3N0eWxlSWRdO1xuICAgICAgICBpZiAodGFnRnJvbVNlcnZlcikge1xuICAgICAgICAgIHRhZ0Zyb21TZXJ2ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWdGcm9tU2VydmVyKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fZnJvbVNlcnZlcltzdHlsZUlkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9pbmRpY2VzW3N0eWxlSWRdLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9zaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5faW5kaWNlc1tzdHlsZUlkXTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShwcm9wcywgbmV4dFByb3BzKSB7XG4gICAgICB0aGlzLmFkZChuZXh0UHJvcHMpO1xuICAgICAgdGhpcy5yZW1vdmUocHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZsdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICB0aGlzLl9zaGVldC5mbHVzaCgpO1xuICAgICAgdGhpcy5fc2hlZXQuaW5qZWN0KCk7XG4gICAgICB0aGlzLl9mcm9tU2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgICAgdGhpcy5faW5zdGFuY2VzQ291bnRzID0ge307XG5cbiAgICAgIHRoaXMuY29tcHV0ZUlkID0gdGhpcy5jcmVhdGVDb21wdXRlSWQoKTtcbiAgICAgIHRoaXMuY29tcHV0ZVNlbGVjdG9yID0gdGhpcy5jcmVhdGVDb21wdXRlU2VsZWN0b3IoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjc3NSdWxlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNzc1J1bGVzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBmcm9tU2VydmVyID0gdGhpcy5fZnJvbVNlcnZlciA/ICgwLCBfa2V5czIuZGVmYXVsdCkodGhpcy5fZnJvbVNlcnZlcikubWFwKGZ1bmN0aW9uIChzdHlsZUlkKSB7XG4gICAgICAgIHJldHVybiBbc3R5bGVJZCwgX3RoaXMzLl9mcm9tU2VydmVyW3N0eWxlSWRdXTtcbiAgICAgIH0pIDogW107XG4gICAgICB2YXIgY3NzUnVsZXMgPSB0aGlzLl9zaGVldC5jc3NSdWxlcygpO1xuXG4gICAgICByZXR1cm4gZnJvbVNlcnZlci5jb25jYXQoKDAsIF9rZXlzMi5kZWZhdWx0KSh0aGlzLl9pbmRpY2VzKS5tYXAoZnVuY3Rpb24gKHN0eWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIFtzdHlsZUlkLCBfdGhpczMuX2luZGljZXNbc3R5bGVJZF0ubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgIHJldHVybiBjc3NSdWxlc1tpbmRleF0uY3NzVGV4dDtcbiAgICAgICAgfSkuam9pbignXFxuJyldO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZUNvbXB1dGVJZFxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRvIGNvbXB1dGUgYW5kIG1lbW9pemUgYSBqc3ggaWQgZnJvbSBhIGJhc2VkSWQgYW5kIG9wdGlvbmFsbHkgcHJvcHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZUNvbXB1dGVJZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVJZCgpIHtcbiAgICAgIHZhciBjYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiYXNlSWQsIHByb3BzKSB7XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gJ2pzeC0nICsgYmFzZUlkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wc1RvU3RyaW5nID0gU3RyaW5nKHByb3BzKTtcbiAgICAgICAgdmFyIGtleSA9IGJhc2VJZCArIHByb3BzVG9TdHJpbmc7XG4gICAgICAgIC8vIHJldHVybiBganN4LSR7aGFzaFN0cmluZyhgJHtiYXNlSWR9LSR7cHJvcHNUb1N0cmluZ31gKX1gXG4gICAgICAgIGlmICghY2FjaGVba2V5XSkge1xuICAgICAgICAgIGNhY2hlW2tleV0gPSAnanN4LScgKyAoMCwgX3N0cmluZ0hhc2gyLmRlZmF1bHQpKGJhc2VJZCArICctJyArIHByb3BzVG9TdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGVDb21wdXRlU2VsZWN0b3JcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0byBjb21wdXRlIGFuZCBtZW1vaXplIGR5bmFtaWMgc2VsZWN0b3JzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVDb21wdXRlU2VsZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDb21wdXRlU2VsZWN0b3IoKSB7XG4gICAgICB2YXIgc2VsZWN0b1BsYWNlaG9sZGVyUmVnZXhwID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAvX19qc3gtc3R5bGUtZHluYW1pYy1zZWxlY3Rvci9nO1xuXG4gICAgICB2YXIgY2FjaGUgPSB7fTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIGNzcykge1xuICAgICAgICB2YXIgaWRjc3MgPSBpZCArIGNzcztcbiAgICAgICAgaWYgKCFjYWNoZVtpZGNzc10pIHtcbiAgICAgICAgICBjYWNoZVtpZGNzc10gPSBjc3MucmVwbGFjZShzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVbaWRjc3NdO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRJZEFuZFJ1bGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SWRBbmRSdWxlcyhwcm9wcykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmIChwcm9wcy5keW5hbWljKSB7XG4gICAgICAgIHZhciBzdHlsZUlkID0gdGhpcy5jb21wdXRlSWQocHJvcHMuc3R5bGVJZCwgcHJvcHMuZHluYW1pYyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICBydWxlczogQXJyYXkuaXNBcnJheShwcm9wcy5jc3MpID8gcHJvcHMuY3NzLm1hcChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5jb21wdXRlU2VsZWN0b3Ioc3R5bGVJZCwgcnVsZSk7XG4gICAgICAgICAgfSkgOiBbdGhpcy5jb21wdXRlU2VsZWN0b3Ioc3R5bGVJZCwgcHJvcHMuY3NzKV1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGVJZDogdGhpcy5jb21wdXRlSWQocHJvcHMuc3R5bGVJZCksXG4gICAgICAgIHJ1bGVzOiBBcnJheS5pc0FycmF5KHByb3BzLmNzcykgPyBwcm9wcy5jc3MgOiBbcHJvcHMuY3NzXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3RGcm9tU2VydmVyXG4gICAgICpcbiAgICAgKiBDb2xsZWN0cyBzdHlsZSB0YWdzIGZyb20gdGhlIGRvY3VtZW50IHdpdGggaWQgX19qc3gtWFhYXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdEZyb21TZXJ2ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RGcm9tU2VydmVyKCkge1xuICAgICAgdmFyIGVsZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2lkXj1cIl9fanN4LVwiXScpKTtcblxuICAgICAgcmV0dXJuIGVsZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBpZCA9IGVsZW1lbnQuaWQuc2xpY2UoMik7XG4gICAgICAgIGFjY1tpZF0gPSBlbGVtZW50O1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3R5bGVTaGVldFJlZ2lzdHJ5O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdHlsZVNoZWV0UmVnaXN0cnk7XG5cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignU3R5bGVTaGVldFJlZ2lzdHJ5OiAnICsgbWVzc2FnZSArICcuJyk7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L2Rpc3Qvc3R5bGVzaGVldC1yZWdpc3RyeS5qc1xuLy8gbW9kdWxlIGlkID0gMzg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMiA1IDYiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgdmFyIGhhc2ggPSA1MzgxLFxuICAgICAgaSAgICA9IHN0ci5sZW5ndGg7XG5cbiAgd2hpbGUoaSkge1xuICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gIH1cblxuICAvKiBKYXZhU2NyaXB0IGRvZXMgYml0d2lzZSBvcGVyYXRpb25zIChsaWtlIFhPUiwgYWJvdmUpIG9uIDMyLWJpdCBzaWduZWRcbiAgICogaW50ZWdlcnMuIFNpbmNlIHdlIHdhbnQgdGhlIHJlc3VsdHMgdG8gYmUgYWx3YXlzIHBvc2l0aXZlLCBjb252ZXJ0IHRoZVxuICAgKiBzaWduZWQgaW50IHRvIGFuIHVuc2lnbmVkIGJ5IGRvaW5nIGFuIHVuc2lnbmVkIGJpdHNoaWZ0LiAqL1xuICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3RyaW5nLWhhc2gvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDIgNSA2IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5cbnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLypcbkJhc2VkIG9uIEdsYW1vcidzIHNoZWV0XG5odHRwczovL2dpdGh1Yi5jb20vdGhyZWVwb2ludG9uZS9nbGFtb3IvYmxvYi82NjdiNDgwZDMxYjM3MjFhOTA1MDIxYjI2ZTEyOTBjZTkyY2EyODc5L3NyYy9zaGVldC5qc1xuKi9cblxudmFyIGlzUHJvZCA9IHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudmFyIFN0eWxlU2hlZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0eWxlU2hlZXQoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBfcmVmJG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIG5hbWUgPSBfcmVmJG5hbWUgPT09IHVuZGVmaW5lZCA/ICdzdHlsZXNoZWV0JyA6IF9yZWYkbmFtZSxcbiAgICAgICAgX3JlZiRvcHRpbWl6ZUZvclNwZWVkID0gX3JlZi5vcHRpbWl6ZUZvclNwZWVkLFxuICAgICAgICBvcHRpbWl6ZUZvclNwZWVkID0gX3JlZiRvcHRpbWl6ZUZvclNwZWVkID09PSB1bmRlZmluZWQgPyBpc1Byb2QgOiBfcmVmJG9wdGltaXplRm9yU3BlZWQsXG4gICAgICAgIF9yZWYkaXNCcm93c2VyID0gX3JlZi5pc0Jyb3dzZXIsXG4gICAgICAgIGlzQnJvd3NlciA9IF9yZWYkaXNCcm93c2VyID09PSB1bmRlZmluZWQgPyB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA6IF9yZWYkaXNCcm93c2VyO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU3R5bGVTaGVldCk7XG5cbiAgICBpbnZhcmlhbnQoaXNTdHJpbmcobmFtZSksICdgbmFtZWAgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuX2RlbGV0ZWRSdWxlUGxhY2Vob2xkZXIgPSAnIycgKyBuYW1lICsgJy1kZWxldGVkLXJ1bGVfX19fe30nO1xuXG4gICAgaW52YXJpYW50KHR5cGVvZiBvcHRpbWl6ZUZvclNwZWVkID09PSAnYm9vbGVhbicsICdgb3B0aW1pemVGb3JTcGVlZGAgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gb3B0aW1pemVGb3JTcGVlZDtcbiAgICB0aGlzLl9pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5cbiAgICB0aGlzLl9zZXJ2ZXJTaGVldCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90YWdzID0gW107XG4gICAgdGhpcy5faW5qZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ydWxlc0NvdW50ID0gMDtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFN0eWxlU2hlZXQsIFt7XG4gICAga2V5OiAnc2V0T3B0aW1pemVGb3JTcGVlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGltaXplRm9yU3BlZWQoYm9vbCkge1xuICAgICAgaW52YXJpYW50KHR5cGVvZiBib29sID09PSAnYm9vbGVhbicsICdgc2V0T3B0aW1pemVGb3JTcGVlZGAgYWNjZXB0cyBhIGJvb2xlYW4nKTtcblxuICAgICAgaW52YXJpYW50KHRoaXMuX3J1bGVzQ291bnQgPT09IDAsICdvcHRpbWl6ZUZvclNwZWVkIGNhbm5vdCBiZSB3aGVuIHJ1bGVzIGhhdmUgYWxyZWFkeSBiZWVuIGluc2VydGVkJyk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gYm9vbDtcbiAgICAgIHRoaXMuaW5qZWN0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNPcHRpbWl6ZUZvclNwZWVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNPcHRpbWl6ZUZvclNwZWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29wdGltaXplRm9yU3BlZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5qZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5qZWN0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaW52YXJpYW50KCF0aGlzLl9pbmplY3RlZCwgJ3NoZWV0IGFscmVhZHkgaW5qZWN0ZWQnKTtcbiAgICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLl9pc0Jyb3dzZXIgJiYgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICB0aGlzLl90YWdzWzBdID0gdGhpcy5tYWtlU3R5bGVUYWcodGhpcy5fbmFtZSk7XG4gICAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSAnaW5zZXJ0UnVsZScgaW4gdGhpcy5nZXRTaGVldCgpO1xuICAgICAgICBpZiAoIXRoaXMuX29wdGltaXplRm9yU3BlZWQpIHtcbiAgICAgICAgICBpZiAoIWlzUHJvZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdTdHlsZVNoZWV0OiBvcHRpbWl6ZUZvclNwZWVkIG1vZGUgbm90IHN1cHBvcnRlZCBmYWxsaW5nIGJhY2sgdG8gc3RhbmRhcmQgbW9kZS4nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICB0aGlzLl9pbmplY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXJ2ZXJTaGVldCA9IHtcbiAgICAgICAgY3NzUnVsZXM6IFtdLFxuICAgICAgICBpbnNlcnRSdWxlOiBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlc1tpbmRleF0gPSB7IGNzc1RleHQ6IHJ1bGUgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuX3NlcnZlclNoZWV0LmNzc1J1bGVzLnB1c2goeyBjc3NUZXh0OiBydWxlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZVJ1bGU6IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUoaW5kZXgpIHtcbiAgICAgICAgICBfdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTaGVldEZvclRhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNoZWV0Rm9yVGFnKHRhZykge1xuICAgICAgaWYgKHRhZy5zaGVldCkge1xuICAgICAgICByZXR1cm4gdGFnLnNoZWV0O1xuICAgICAgfVxuXG4gICAgICAvLyB0aGlzIHdlaXJkbmVzcyBicm91Z2h0IHRvIHlvdSBieSBmaXJlZm94XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5zdHlsZVNoZWV0c1tpXS5vd25lck5vZGUgPT09IHRhZykge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudC5zdHlsZVNoZWV0c1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFNoZWV0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2hlZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTaGVldEZvclRhZyh0aGlzLl90YWdzW3RoaXMuX3RhZ3MubGVuZ3RoIC0gMV0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydFJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4KSB7XG4gICAgICBpbnZhcmlhbnQoaXNTdHJpbmcocnVsZSksICdgaW5zZXJ0UnVsZWAgYWNjZXB0cyBvbmx5IHN0cmluZ3MnKTtcblxuICAgICAgaWYgKCF0aGlzLl9pc0Jyb3dzZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBpbmRleCA9IHRoaXMuX3NlcnZlclNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzQ291bnQrKztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQpIHtcbiAgICAgICAgdmFyIHNoZWV0ID0gdGhpcy5nZXRTaGVldCgpO1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGluZGV4ID0gc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgd2VpcmRuZXNzIGZvciBwZXJmLCBhbmQgY2hyb21lJ3Mgd2VpcmQgYnVnXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMDA3OTkyL2Nocm9tZS1zdWRkZW5seS1zdG9wcGVkLWFjY2VwdGluZy1pbnNlcnRydWxlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1N0eWxlU2hlZXQ6IGlsbGVnYWwgcnVsZTogXFxuXFxuJyArIHJ1bGUgKyAnXFxuXFxuU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8yMDAwNzk5MiBmb3IgbW9yZSBpbmZvJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbnNlcnRpb25Qb2ludCA9IHRoaXMuX3RhZ3NbaW5kZXhdO1xuICAgICAgICB0aGlzLl90YWdzLnB1c2godGhpcy5tYWtlU3R5bGVUYWcodGhpcy5fbmFtZSwgcnVsZSwgaW5zZXJ0aW9uUG9pbnQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzQ291bnQrKztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXBsYWNlUnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKGluZGV4LCBydWxlKSB7XG4gICAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCB8fCAhdGhpcy5faXNCcm93c2VyKSB7XG4gICAgICAgIHZhciBzaGVldCA9IHRoaXMuX2lzQnJvd3NlciA/IHRoaXMuZ2V0U2hlZXQoKSA6IHRoaXMuX3NlcnZlclNoZWV0O1xuICAgICAgICBpZiAoIXJ1bGUudHJpbSgpKSB7XG4gICAgICAgICAgcnVsZSA9IHRoaXMuX2RlbGV0ZWRSdWxlUGxhY2Vob2xkZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNoZWV0LmNzc1J1bGVzW2luZGV4XSkge1xuICAgICAgICAgIC8vIEBUQkQgU2hvdWxkIHdlIHRocm93IGFuIGVycm9yP1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1N0eWxlU2hlZXQ6IGlsbGVnYWwgcnVsZTogXFxuXFxuJyArIHJ1bGUgKyAnXFxuXFxuU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8yMDAwNzk5MiBmb3IgbW9yZSBpbmZvJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgaW5kaWNlcyB3ZSBpbnNlcnQgYSBkZWxldGVSdWxlUGxhY2Vob2xkZXJcbiAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHRoaXMuX2RlbGV0ZWRSdWxlUGxhY2Vob2xkZXIsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IHRoaXMuX3RhZ3NbaW5kZXhdO1xuICAgICAgICBpbnZhcmlhbnQodGFnLCAnb2xkIHJ1bGUgYXQgaW5kZXggYCcgKyBpbmRleCArICdgIG5vdCBmb3VuZCcpO1xuICAgICAgICB0YWcudGV4dENvbnRlbnQgPSBydWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVSdWxlKGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX2lzQnJvd3Nlcikge1xuICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICB0aGlzLnJlcGxhY2VSdWxlKGluZGV4LCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFnID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgIGludmFyaWFudCh0YWcsICdydWxlIGF0IGluZGV4IGAnICsgaW5kZXggKyAnYCBub3QgZm91bmQnKTtcbiAgICAgICAgdGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFnKTtcbiAgICAgICAgdGhpcy5fdGFnc1tpbmRleF0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZsdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICB0aGlzLl9pbmplY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcnVsZXNDb3VudCA9IDA7XG4gICAgICBpZiAodGhpcy5faXNCcm93c2VyKSB7XG4gICAgICAgIHRoaXMuX3RhZ3MuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHRhZyAmJiB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdGFncyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2ltcGxlciBvbiBzZXJ2ZXJcbiAgICAgICAgdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXMgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjc3NSdWxlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNzc1J1bGVzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5faXNCcm93c2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90YWdzLnJlZHVjZShmdW5jdGlvbiAocnVsZXMsIHRhZykge1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgcnVsZXMgPSBydWxlcy5jb25jYXQoX3RoaXMyLmdldFNoZWV0Rm9yVGFnKHRhZykuY3NzUnVsZXMubWFwKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVsZS5jc3NUZXh0ID09PSBfdGhpczIuX2RlbGV0ZWRSdWxlUGxhY2Vob2xkZXIgPyBudWxsIDogcnVsZTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnVsZXMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZXM7XG4gICAgICB9LCBbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWFrZVN0eWxlVGFnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZVN0eWxlVGFnKG5hbWUsIGNzc1N0cmluZywgcmVsYXRpdmVUb1RhZykge1xuICAgICAgaWYgKGNzc1N0cmluZykge1xuICAgICAgICBpbnZhcmlhbnQoaXNTdHJpbmcoY3NzU3RyaW5nKSwgJ21ha2VTdHlsZVRhZyBhY2NlcHMgb25seSBzdHJpbmdzIGFzIHNlY29uZCBwYXJhbWV0ZXInKTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgdGFnLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgdGFnLnNldEF0dHJpYnV0ZSgnZGF0YS0nICsgbmFtZSwgJycpO1xuICAgICAgaWYgKGNzc1N0cmluZykge1xuICAgICAgICB0YWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzU3RyaW5nKSk7XG4gICAgICB9XG4gICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgIGlmIChyZWxhdGl2ZVRvVGFnKSB7XG4gICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHRhZywgcmVsYXRpdmVUb1RhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHRhZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xlbmd0aCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVsZXNDb3VudDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN0eWxlU2hlZXQ7XG5cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignU3R5bGVTaGVldDogJyArIG1lc3NhZ2UgKyAnLicpO1xuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGVkLWpzeC9kaXN0L2xpYi9zdHlsZXNoZWV0LmpzXG4vLyBtb2R1bGUgaWQgPSAzOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAyIDUgNiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3N0eWxlJylcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlZC1qc3gvc3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDM5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDUgNiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xudmFyIGZvcmVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgpID09PSAnc3ltYm9sJztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0ci5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgb2JqID0ge307XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ3gnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cbiAgICAgICAgZm9yICh2YXIgXyBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG5cdFx0cmV0dXJuIG9iai54ID09PSBvYmo7XG5cdH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBJRSA4LiAqL1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIGFyZVByb3BlcnR5RGVzY3JpcHRvcnNTdXBwb3J0ZWQoKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgdmFsdWUsIHByZWRpY2F0ZSkge1xuXHRpZiAobmFtZSBpbiBvYmplY3QgJiYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgfHwgIXByZWRpY2F0ZSgpKSkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvYmplY3RbbmFtZV0gPSB2YWx1ZTtcblx0fVxufTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcblx0dmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0cHJvcHMgPSBwcm9wcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtYXApKTtcblx0fVxuXHRmb3JlYWNoKHByb3BzLCBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgbWFwW25hbWVdLCBwcmVkaWNhdGVzW25hbWVdKTtcblx0fSk7XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydGllcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0aWVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzOTJcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDYiLCIndXNlIHN0cmljdCc7XG5cbi8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpO1xudmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcbnZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xudmFyIGRvbnRFbnVtcyA9IFtcblx0J3RvU3RyaW5nJyxcblx0J3RvTG9jYWxlU3RyaW5nJyxcblx0J3ZhbHVlT2YnLFxuXHQnaGFzT3duUHJvcGVydHknLFxuXHQnaXNQcm90b3R5cGVPZicsXG5cdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdCdjb25zdHJ1Y3Rvcidcbl07XG52YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuXHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xufTtcbnZhciBleGNsdWRlZEtleXMgPSB7XG5cdCRjb25zb2xlOiB0cnVlLFxuXHQkZXh0ZXJuYWw6IHRydWUsXG5cdCRmcmFtZTogdHJ1ZSxcblx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0JGZyYW1lczogdHJ1ZSxcblx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0JG91dGVySGVpZ2h0OiB0cnVlLFxuXHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHQkcGFnZVlPZmZzZXQ6IHRydWUsXG5cdCRwYXJlbnQ6IHRydWUsXG5cdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHQkc2Nyb2xsVG9wOiB0cnVlLFxuXHQkc2Nyb2xsWDogdHJ1ZSxcblx0JHNjcm9sbFk6IHRydWUsXG5cdCRzZWxmOiB0cnVlLFxuXHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdCR3aW5kb3c6IHRydWVcbn07XG52YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn0oKSk7XG52YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxudmFyIGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0dmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuXHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdHZhciBpc1N0cmluZyA9IGlzT2JqZWN0ICYmIHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cdHZhciB0aGVLZXlzID0gW107XG5cblx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG5cdH1cblxuXHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdGlmIChpc1N0cmluZyAmJiBvYmplY3QubGVuZ3RoID4gMCAmJiAhaGFzLmNhbGwob2JqZWN0LCAwKSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdC5sZW5ndGg7ICsraikge1xuXHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhuYW1lKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkb250RW51bXMubGVuZ3RoOyArK2spIHtcblx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoZUtleXM7XG59O1xuXG5rZXlzU2hpbS5zaGltID0gZnVuY3Rpb24gc2hpbU9iamVjdEtleXMoKSB7XG5cdGlmIChPYmplY3Qua2V5cykge1xuXHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFNhZmFyaSA1LjAgYnVnXG5cdFx0XHRyZXR1cm4gKE9iamVjdC5rZXlzKGFyZ3VtZW50cykgfHwgJycpLmxlbmd0aCA9PT0gMjtcblx0XHR9KDEsIDIpKTtcblx0XHRpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcblx0XHRcdHZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcblx0XHRcdE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHRcdFx0aWYgKGlzQXJncyhvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDUgNiIsIid1c2Ugc3RyaWN0JztcblxuLy8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM2LXNoaW1cbnZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGNhbkJlT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuXHRyZXR1cm4gdHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqICE9PSBudWxsO1xufTtcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMvc2hhbXMnKSgpO1xudmFyIHRvT2JqZWN0ID0gT2JqZWN0O1xudmFyIHB1c2ggPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLnB1c2gpO1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG52YXIgb3JpZ2luYWxHZXRTeW1ib2xzID0gaGFzU3ltYm9scyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgOiBudWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZTEpIHtcblx0aWYgKCFjYW5CZU9iamVjdCh0YXJnZXQpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpOyB9XG5cdHZhciBvYmpUYXJnZXQgPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgcywgc291cmNlLCBpLCBwcm9wcywgc3ltcywgdmFsdWUsIGtleTtcblx0Zm9yIChzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7ICsrcykge1xuXHRcdHNvdXJjZSA9IHRvT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cdFx0cHJvcHMgPSBrZXlzKHNvdXJjZSk7XG5cdFx0dmFyIGdldFN5bWJvbHMgPSBoYXNTeW1ib2xzICYmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIHx8IG9yaWdpbmFsR2V0U3ltYm9scyk7XG5cdFx0aWYgKGdldFN5bWJvbHMpIHtcblx0XHRcdHN5bXMgPSBnZXRTeW1ib2xzKHNvdXJjZSk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgc3ltcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRrZXkgPSBzeW1zW2ldO1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZShzb3VyY2UsIGtleSkpIHtcblx0XHRcdFx0XHRwdXNoKHByb3BzLCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0a2V5ID0gcHJvcHNbaV07XG5cdFx0XHR2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUoc291cmNlLCBrZXkpKSB7XG5cdFx0XHRcdG9ialRhcmdldFtrZXldID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvYmpUYXJnZXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LmFzc2lnbi9pbXBsZW1lbnRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzk0XG4vLyBtb2R1bGUgY2h1bmtzID0gNSA2IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzOTVcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDYiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxudmFyIGxhY2tzUHJvcGVyRW51bWVyYXRpb25PcmRlciA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdC8vIHY4LCBzcGVjaWZpY2FsbHkgaW4gbm9kZSA0LngsIGhhcyBhIGJ1ZyB3aXRoIGluY29ycmVjdCBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlclxuXHQvLyBub3RlOiB0aGlzIGRvZXMgbm90IGRldGVjdCB0aGUgYnVnIHVubGVzcyB0aGVyZSdzIDIwIGNoYXJhY3RlcnNcblx0dmFyIHN0ciA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG5cdHZhciBsZXR0ZXJzID0gc3RyLnNwbGl0KCcnKTtcblx0dmFyIG1hcCA9IHt9O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyArK2kpIHtcblx0XHRtYXBbbGV0dGVyc1tpXV0gPSBsZXR0ZXJzW2ldO1xuXHR9XG5cdHZhciBvYmogPSBPYmplY3QuYXNzaWduKHt9LCBtYXApO1xuXHR2YXIgYWN0dWFsID0gJyc7XG5cdGZvciAodmFyIGsgaW4gb2JqKSB7XG5cdFx0YWN0dWFsICs9IGs7XG5cdH1cblx0cmV0dXJuIHN0ciAhPT0gYWN0dWFsO1xufTtcblxudmFyIGFzc2lnbkhhc1BlbmRpbmdFeGNlcHRpb25zID0gZnVuY3Rpb24gKCkge1xuXHRpZiAoIU9iamVjdC5hc3NpZ24gfHwgIU9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHQvLyBGaXJlZm94IDM3IHN0aWxsIGhhcyBcInBlbmRpbmcgZXhjZXB0aW9uXCIgbG9naWMgaW4gaXRzIE9iamVjdC5hc3NpZ24gaW1wbGVtZW50YXRpb24sXG5cdC8vIHdoaWNoIGlzIDcyJSBzbG93ZXIgdGhhbiBvdXIgc2hpbSwgYW5kIEZpcmVmb3ggNDAncyBuYXRpdmUgaW1wbGVtZW50YXRpb24uXG5cdHZhciB0aHJvd2VyID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHsgMTogMiB9KTtcblx0dHJ5IHtcblx0XHRPYmplY3QuYXNzaWduKHRocm93ZXIsICd4eScpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIHRocm93ZXJbMV0gPT09ICd5Jztcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRyZXR1cm4gaW1wbGVtZW50YXRpb247XG5cdH1cblx0aWYgKGxhY2tzUHJvcGVyRW51bWVyYXRpb25PcmRlcigpKSB7XG5cdFx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xuXHR9XG5cdGlmIChhc3NpZ25IYXNQZW5kaW5nRXhjZXB0aW9ucygpKSB7XG5cdFx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xuXHR9XG5cdHJldHVybiBPYmplY3QuYXNzaWduO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vcG9seWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDM5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDUgNiIsImltcG9ydCBIZWFkZXIgZnJvbSBcIi4uL2NvbXBvbmVudHMvaGVhZGVyXCI7XG5leHBvcnQgZGVmYXVsdCAoeyBjaGlsZHJlbiB9KSA9PiAoXG4gIDxkaXY+XG4gICAgPEhlYWRlciAvPlxuICAgIHtjaGlsZHJlbn1cbiAgPC9kaXY+XG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGF5b3V0cy9tYWluLmpzIiwiaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xuXG5jb25zdCBJbmRleCA9ICgpID0+IChcbiAgPGRpdj5cbiAgICA8TGluayBocmVmPVwiL2Fib3V0XCI+XG4gICAgICA8YT5BYm91dCBQYWdlPC9hPlxuICAgIDwvTGluaz5cbiAgICA8cD5IZWxsbyBOZXh0LmpzPC9wPlxuICA8L2Rpdj5cbik7XG5cbmZ1bmN0aW9uIEhlYWRlcigpIHtcbiAgbGV0IGV4YW1wbGVOdW1iZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gNjsgaSsrKSB7XG4gICAgZXhhbXBsZU51bWJlcnMucHVzaChpKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udFwiPlxuICAgICAgPGgxIGNsYXNzTmFtZT1cImhlbGxvXCI+UmVuZGVyIHByb3BzIHByZXNlbnRhdGlvbjwvaDE+XG4gICAgICA8TGluayBocmVmPVwiL1wiPlxuICAgICAgICA8YnV0dG9uPkhvbWU8L2J1dHRvbj5cbiAgICAgIDwvTGluaz5cbiAgICAgIDxoNSBjbGFzc05hbWU9XCJoZWxsb1wiPmV4YW1wbGVzOjwvaDU+XG4gICAgICB7ZXhhbXBsZU51bWJlcnMubWFwKG51bWJlciA9PiAoXG4gICAgICAgIDxMaW5rIGhyZWY9e2AvZXhhbXBsZSR7bnVtYmVyfWB9PlxuICAgICAgICAgIDxidXR0b24+RXhhbXBsZSB7bnVtYmVyfTwvYnV0dG9uPlxuICAgICAgICA8L0xpbms+XG4gICAgICApKX1cbiAgICAgIDxzdHlsZSBqc3g+e2BcbiAgICAgICAgLmNvbnQge1xuICAgICAgICAgIGJhY2tncm91bmQ6ICMyMmEwZjI7XG4gICAgICAgICAgcGFkZGluZzogMTAwcHg7XG4gICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgIHRyYW5zaXRpb246IDEwMG1zIGVhc2UtaW4gYmFja2dyb3VuZDtcbiAgICAgICAgfVxuICAgICAgYH08L3N0eWxlPlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBIZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2hlYWRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZicpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxudmFyIF9zdHJpbmdpZnkgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnknKTtcblxudmFyIF9zdHJpbmdpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZ5KTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG52YXIgX2luaGVyaXRzMiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpO1xuXG52YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cbnZhciBfdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbnZhciBfcHJvcFR5cGVzRXhhY3QgPSByZXF1aXJlKCdwcm9wLXR5cGVzLWV4YWN0Jyk7XG5cbnZhciBfcHJvcFR5cGVzRXhhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzRXhhY3QpO1xuXG52YXIgX3JvdXRlciA9IHJlcXVpcmUoJy4vcm91dGVyJyk7XG5cbnZhciBfcm91dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qIGdsb2JhbCBfX05FWFRfREFUQV9fICovXG5cbnZhciBMaW5rID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoTGluaywgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTGluayhwcm9wcykge1xuICAgIHZhciBfcmVmO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgTGluayk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHJlc3RbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKF9yZWYgPSBMaW5rLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShMaW5rKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpcywgcHJvcHNdLmNvbmNhdChyZXN0KSkpO1xuXG4gICAgX3RoaXMubGlua0NsaWNrZWQgPSBfdGhpcy5saW5rQ2xpY2tlZC5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5mb3JtYXRVcmxzKHByb3BzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShMaW5rLCBbe1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdGhpcy5mb3JtYXRVcmxzKG5leHRQcm9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGlua0NsaWNrZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5rQ2xpY2tlZChlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKGUuY3VycmVudFRhcmdldC5ub2RlTmFtZSA9PT0gJ0EnICYmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5uYXRpdmVFdmVudCAmJiBlLm5hdGl2ZUV2ZW50LndoaWNoID09PSAyKSkge1xuICAgICAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIG5ldyB0YWIgLyBuZXcgd2luZG93IGJlaGF2aW9yXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNoYWxsb3cgPSB0aGlzLnByb3BzLnNoYWxsb3c7XG4gICAgICB2YXIgaHJlZiA9IHRoaXMuaHJlZixcbiAgICAgICAgICBhcyA9IHRoaXMuYXM7XG5cblxuICAgICAgaWYgKCFpc0xvY2FsKGhyZWYpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBjbGljayBpZiBpdCdzIG91dHNpZGUgb3VyIHNjb3BlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGhuYW1lID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuXG4gICAgICBocmVmID0gKDAsIF91cmwucmVzb2x2ZSkocGF0aG5hbWUsIGhyZWYpO1xuICAgICAgYXMgPSBhcyA/ICgwLCBfdXJsLnJlc29sdmUpKHBhdGhuYW1lLCBhcykgOiBocmVmO1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vICBhdm9pZCBzY3JvbGwgZm9yIHVybHMgd2l0aCBhbmNob3IgcmVmc1xuICAgICAgdmFyIHNjcm9sbCA9IHRoaXMucHJvcHMuc2Nyb2xsO1xuXG4gICAgICBpZiAoc2Nyb2xsID09IG51bGwpIHtcbiAgICAgICAgc2Nyb2xsID0gYXMuaW5kZXhPZignIycpIDwgMDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVwbGFjZSBzdGF0ZSBpbnN0ZWFkIG9mIHB1c2ggaWYgcHJvcCBpcyBwcmVzZW50XG4gICAgICB2YXIgcmVwbGFjZSA9IHRoaXMucHJvcHMucmVwbGFjZTtcblxuICAgICAgdmFyIGNoYW5nZU1ldGhvZCA9IHJlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCc7XG5cbiAgICAgIC8vIHN0cmFpZ2h0IHVwIHJlZGlyZWN0XG4gICAgICBfcm91dGVyMi5kZWZhdWx0W2NoYW5nZU1ldGhvZF0oaHJlZiwgYXMsIHsgc2hhbGxvdzogc2hhbGxvdyB9KS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgIGlmICghc3VjY2VzcykgcmV0dXJuO1xuICAgICAgICBpZiAoc2Nyb2xsKSB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChfdGhpczIucHJvcHMub25FcnJvcikgX3RoaXMyLnByb3BzLm9uRXJyb3IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ByZWZldGNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlZmV0Y2goKSB7XG4gICAgICBpZiAoIXRoaXMucHJvcHMucHJlZmV0Y2gpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuXG4gICAgICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gICAgICB2YXIgcGF0aG5hbWUgPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG5cbiAgICAgIHZhciBocmVmID0gKDAsIF91cmwucmVzb2x2ZSkocGF0aG5hbWUsIHRoaXMuaHJlZik7XG4gICAgICBfcm91dGVyMi5kZWZhdWx0LnByZWZldGNoKGhyZWYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLnByZWZldGNoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgaWYgKCgwLCBfc3RyaW5naWZ5Mi5kZWZhdWx0KSh0aGlzLnByb3BzLmhyZWYpICE9PSAoMCwgX3N0cmluZ2lmeTIuZGVmYXVsdCkocHJldlByb3BzLmhyZWYpKSB7XG4gICAgICAgIHRoaXMucHJlZmV0Y2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBhY2NlcHQgYm90aCAnaHJlZicgYW5kICdhcycgYXMgb2JqZWN0cyB3aGljaCB3ZSBjYW4gcGFzcyB0byBgdXJsLmZvcm1hdGAuXG4gICAgLy8gV2UnbGwgaGFuZGxlIGl0IGhlcmUuXG5cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdFVybHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRVcmxzKHByb3BzKSB7XG4gICAgICB0aGlzLmhyZWYgPSBwcm9wcy5ocmVmICYmICgwLCBfdHlwZW9mMy5kZWZhdWx0KShwcm9wcy5ocmVmKSA9PT0gJ29iamVjdCcgPyAoMCwgX3VybC5mb3JtYXQpKHByb3BzLmhyZWYpIDogcHJvcHMuaHJlZjtcbiAgICAgIHRoaXMuYXMgPSBwcm9wcy5hcyAmJiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkocHJvcHMuYXMpID09PSAnb2JqZWN0JyA/ICgwLCBfdXJsLmZvcm1hdCkocHJvcHMuYXMpIDogcHJvcHMuYXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBocmVmID0gdGhpcy5ocmVmLFxuICAgICAgICAgIGFzID0gdGhpcy5hcztcbiAgICAgIC8vIERlcHJlY2F0ZWQuIFdhcm5pbmcgc2hvd24gYnkgcHJvcFR5cGUgY2hlY2suIElmIHRoZSBjaGlsZGVuIHByb3ZpZGVkIGlzIGEgc3RyaW5nICg8TGluaz5leGFtcGxlPC9MaW5rPikgd2Ugd3JhcCBpdCBpbiBhbiA8YT4gdGFnXG5cbiAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNoaWxkcmVuID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2EnLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgICB2YXIgY2hpbGQgPSBfcmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIG9uQ2xpY2s6IHRoaXMubGlua0NsaWNrZWRcblxuICAgICAgICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgICAgICAgLy8gZGVmaW5lZCwgd2Ugc3BlY2lmeSB0aGUgY3VycmVudCAnaHJlZicsIHNvIHRoYXQgcmVwZXRpdGlvbiBpcyBub3QgbmVlZGVkIGJ5IHRoZSB1c2VyXG4gICAgICB9O2lmICh0aGlzLnByb3BzLnBhc3NIcmVmIHx8IGNoaWxkLnR5cGUgPT09ICdhJyAmJiAhKCdocmVmJyBpbiBjaGlsZC5wcm9wcykpIHtcbiAgICAgICAgcHJvcHMuaHJlZiA9IGFzIHx8IGhyZWY7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgZW5kaW5nIHNsYXNoIHRvIHRoZSBwYXRocy4gU28sIHdlIGNhbiBzZXJ2ZSB0aGVcbiAgICAgIC8vIFwiPHBhZ2U+L2luZGV4Lmh0bWxcIiBkaXJlY3RseS5cbiAgICAgIGlmIChwcm9wcy5ocmVmICYmIHR5cGVvZiBfX05FWFRfREFUQV9fICE9PSAndW5kZWZpbmVkJyAmJiBfX05FWFRfREFUQV9fLm5leHRFeHBvcnQpIHtcbiAgICAgICAgcHJvcHMuaHJlZiA9ICgwLCBfcm91dGVyLl9yZXdyaXRlVXJsRm9yTmV4dEV4cG9ydCkocHJvcHMuaHJlZik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBwcm9wcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMaW5rO1xufShfcmVhY3QuQ29tcG9uZW50KTtcblxuTGluay5wcm9wVHlwZXMgPSAoMCwgX3Byb3BUeXBlc0V4YWN0Mi5kZWZhdWx0KSh7XG4gIGhyZWY6IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZywgX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3RdKS5pc1JlcXVpcmVkLFxuICBhczogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLCBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdF0pLFxuICBwcmVmZXRjaDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICByZXBsYWNlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIHNoYWxsb3c6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgcGFzc0hyZWY6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgc2Nyb2xsOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5lbGVtZW50LCBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHdhcm5MaW5rKCdXYXJuaW5nOiBZb3VcXCdyZSB1c2luZyBhIHN0cmluZyBkaXJlY3RseSBpbnNpZGUgPExpbms+LiBUaGlzIHVzYWdlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSBhZGQgYW4gPGE+IHRhZyBhcyBjaGlsZCBvZiA8TGluaz4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfV0pLmlzUmVxdWlyZWRcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gTGluaztcblxuXG5mdW5jdGlvbiBpc0xvY2FsKGhyZWYpIHtcbiAgdmFyIHVybCA9ICgwLCBfdXJsLnBhcnNlKShocmVmLCBmYWxzZSwgdHJ1ZSk7XG4gIHZhciBvcmlnaW4gPSAoMCwgX3VybC5wYXJzZSkoKDAsIF91dGlscy5nZXRMb2NhdGlvbk9yaWdpbikoKSwgZmFsc2UsIHRydWUpO1xuICByZXR1cm4gIXVybC5ob3N0IHx8IHVybC5wcm90b2NvbCA9PT0gb3JpZ2luLnByb3RvY29sICYmIHVybC5ob3N0ID09PSBvcmlnaW4uaG9zdDtcbn1cblxudmFyIHdhcm5MaW5rID0gKDAsIF91dGlscy5leGVjT25jZSkoX3V0aWxzLndhcm4pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvbGluay5qc1xuLy8gbW9kdWxlIGlkID0gNDAxXG4vLyBtb2R1bGUgY2h1bmtzID0gNSA2IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSA0MDJcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDYiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKTtcbnZhciAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0geyBzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5IH0pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gNDAzXG4vLyBtb2R1bGUgY2h1bmtzID0gNSA2IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZvcmJpZEV4dHJhUHJvcHM7XG5cbnZhciBfb2JqZWN0ID0gcmVxdWlyZSgnb2JqZWN0LmFzc2lnbicpO1xuXG52YXIgX29iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3QpO1xuXG52YXIgX2hhcyA9IHJlcXVpcmUoJ2hhcycpO1xuXG52YXIgX2hhczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXMpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIHplcm9XaWR0aFNwYWNlID0gJ1xcdTIwMEInO1xudmFyIHNwZWNpYWxQcm9wZXJ0eSA9ICdwcm9wLXR5cGVzLWV4YWN0OiAnICsgemVyb1dpZHRoU3BhY2U7XG52YXIgc2VtYXBob3JlID0ge307XG5cbmZ1bmN0aW9uIGJyYW5kKGZuKSB7XG4gIHJldHVybiAoMCwgX29iamVjdDJbJ2RlZmF1bHQnXSkoZm4sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgc3BlY2lhbFByb3BlcnR5LCBzZW1hcGhvcmUpKTtcbn1cblxuZnVuY3Rpb24gaXNCcmFuZGVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZVtzcGVjaWFsUHJvcGVydHldID09PSBzZW1hcGhvcmU7XG59XG5cbmZ1bmN0aW9uIGZvcmJpZEV4dHJhUHJvcHMocHJvcFR5cGVzKSB7XG4gIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MlsnZGVmYXVsdCddKShwcm9wVHlwZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2l2ZW4gcHJvcFR5cGVzIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgaWYgKCgwLCBfaGFzMlsnZGVmYXVsdCddKShwcm9wVHlwZXMsIHNwZWNpYWxQcm9wZXJ0eSkgJiYgIWlzQnJhbmRlZChwcm9wVHlwZXNbc3BlY2lhbFByb3BlcnR5XSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBZ2FpbnN0IGFsbCBvZGRzLCB5b3UgY3JlYXRlZCBhIHByb3BUeXBlIGZvciBhIHByb3AgdGhhdCB1c2VzIGJvdGggdGhlIHplcm8td2lkdGggc3BhY2UgYW5kIG91ciBjdXN0b20gc3RyaW5nIC0gd2hpY2gsIHNhZGx5LCBjb25mbGljdHMgd2l0aCBgcHJvcC10eXBlcy1leGFjdGAnKTtcbiAgfVxuXG4gIHJldHVybiAoMCwgX29iamVjdDJbJ2RlZmF1bHQnXSkoe30sIHByb3BUeXBlcywgX2RlZmluZVByb3BlcnR5KHt9LCBzcGVjaWFsUHJvcGVydHksIGJyYW5kKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBmb3JiaWRVbmtub3duUHJvcHMocHJvcHMsIF8sIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIHZhciB1bmtub3duUHJvcHMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiAhKDAsIF9oYXMyWydkZWZhdWx0J10pKHByb3BUeXBlcywgcHJvcCk7XG4gICAgICB9KTtcbiAgICAgIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihTdHJpbmcoY29tcG9uZW50TmFtZSkgKyAnOiB1bmtub3duIHByb3BzIGZvdW5kOiAnICsgU3RyaW5nKHVua25vd25Qcm9wcy5qb2luKCcsICcpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9yYmlkVW5rbm93blByb3BzO1xuICB9KCkpKSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMtZXhhY3QvYnVpbGQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDUgNiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXG5kZWZpbmVQcm9wZXJ0aWVzKHBvbHlmaWxsLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDUgNiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDQwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDUgNiIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mb3JlYWNoL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MDdcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDYiLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDhcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDYiLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMTddLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDlcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDYiLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCdkZWZpbmUtcHJvcGVydGllcycpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1Bc3NpZ24oKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShcblx0XHRPYmplY3QsXG5cdFx0eyBhc3NpZ246IHBvbHlmaWxsIH0sXG5cdFx0eyBhc3NpZ246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5hc3NpZ24gIT09IHBvbHlmaWxsOyB9IH1cblx0KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC5hc3NpZ24vc2hpbS5qc1xuLy8gbW9kdWxlIGlkID0gNDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gNSA2IiwidmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDExXG4vLyBtb2R1bGUgY2h1bmtzID0gNSA2IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBpc1BsYWluT2JqZWN0O1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh4KSB7XG4gIHJldHVybiB4ICYmICh0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoeCkpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh4KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNQbGFpbk9iamVjdC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzLWV4YWN0L2J1aWxkL2hlbHBlcnMvaXNQbGFpbk9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gNSA2IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcblxudmFyIGNuID0gZnVuY3Rpb24gY24oKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBhcmdzLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJyk7XG59O1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgcHJpc21Db3JlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHR2YXIgX3NlbGYgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyAvLyBpZiBpbiBicm93c2VyXG5cdDogdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgPyBzZWxmIC8vIGlmIGluIHdvcmtlclxuXHQ6IHt9O1xuXG5cdC8qKlxuICAqIFByaXNtOiBMaWdodHdlaWdodCwgcm9idXN0LCBlbGVnYW50IHN5bnRheCBoaWdobGlnaHRpbmdcbiAgKiBNSVQgbGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC9cbiAgKiBAYXV0aG9yIExlYSBWZXJvdSBodHRwOi8vbGVhLnZlcm91Lm1lXG4gICovXG5cblx0dmFyIFByaXNtID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gUHJpdmF0ZSBoZWxwZXIgdmFyc1xuXHRcdHZhciBsYW5nID0gL1xcYmxhbmcoPzp1YWdlKT8tKFxcdyspXFxiL2k7XG5cdFx0dmFyIHVuaXF1ZUlkID0gMDtcblxuXHRcdHZhciBfID0gX3NlbGYuUHJpc20gPSB7XG5cdFx0XHR1dGlsOiB7XG5cdFx0XHRcdGVuY29kZTogZnVuY3Rpb24gZW5jb2RlKHRva2Vucykge1xuXHRcdFx0XHRcdGlmICh0b2tlbnMgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBUb2tlbih0b2tlbnMudHlwZSwgXy51dGlsLmVuY29kZSh0b2tlbnMuY29udGVudCksIHRva2Vucy5hbGlhcyk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChfLnV0aWwudHlwZSh0b2tlbnMpID09PSAnQXJyYXknKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zLm1hcChfLnV0aWwuZW5jb2RlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRva2Vucy5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC9cXHUwMGEwL2csICcgJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHR5cGU6IGZ1bmN0aW9uIHR5cGUobykge1xuXHRcdFx0XHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykubWF0Y2goL1xcW29iamVjdCAoXFx3KylcXF0vKVsxXTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHRvYmpJZDogZnVuY3Rpb24gb2JqSWQob2JqKSB7XG5cdFx0XHRcdFx0aWYgKCFvYmpbJ19faWQnXSkge1xuXHRcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ19faWQnLCB7IHZhbHVlOiArK3VuaXF1ZUlkIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gb2JqWydfX2lkJ107XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gRGVlcCBjbG9uZSBhIGxhbmd1YWdlIGRlZmluaXRpb24gKGUuZy4gdG8gZXh0ZW5kIGl0KVxuXHRcdFx0XHRjbG9uZTogZnVuY3Rpb24gY2xvbmUobykge1xuXHRcdFx0XHRcdHZhciB0eXBlID0gXy51dGlsLnR5cGUobyk7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRcdFx0XHRcdHZhciBjbG9uZSA9IHt9O1xuXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBvKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2xvbmVba2V5XSA9IF8udXRpbC5jbG9uZShvW2tleV0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBjbG9uZTtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRcdFx0XHQvLyBDaGVjayBmb3IgZXhpc3RlbmNlIGZvciBJRThcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG8ubWFwICYmIG8ubWFwKGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIF8udXRpbC5jbG9uZSh2KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIG87XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGxhbmd1YWdlczoge1xuXHRcdFx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChpZCwgcmVkZWYpIHtcblx0XHRcdFx0XHR2YXIgbGFuZyA9IF8udXRpbC5jbG9uZShfLmxhbmd1YWdlc1tpZF0pO1xuXG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlZGVmKSB7XG5cdFx0XHRcdFx0XHRsYW5nW2tleV0gPSByZWRlZltrZXldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBsYW5nO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8qKlxuICAgICAqIEluc2VydCBhIHRva2VuIGJlZm9yZSBhbm90aGVyIHRva2VuIGluIGEgbGFuZ3VhZ2UgbGl0ZXJhbFxuICAgICAqIEFzIHRoaXMgbmVlZHMgdG8gcmVjcmVhdGUgdGhlIG9iamVjdCAod2UgY2Fubm90IGFjdHVhbGx5IGluc2VydCBiZWZvcmUga2V5cyBpbiBvYmplY3QgbGl0ZXJhbHMpLFxuICAgICAqIHdlIGNhbm5vdCBqdXN0IHByb3ZpZGUgYW4gb2JqZWN0LCB3ZSBuZWVkIGFub2JqZWN0IGFuZCBhIGtleS5cbiAgICAgKiBAcGFyYW0gaW5zaWRlIFRoZSBrZXkgKG9yIGxhbmd1YWdlIGlkKSBvZiB0aGUgcGFyZW50XG4gICAgICogQHBhcmFtIGJlZm9yZSBUaGUga2V5IHRvIGluc2VydCBiZWZvcmUuIElmIG5vdCBwcm92aWRlZCwgdGhlIGZ1bmN0aW9uIGFwcGVuZHMgaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gaW5zZXJ0IE9iamVjdCB3aXRoIHRoZSBrZXkvdmFsdWUgcGFpcnMgdG8gaW5zZXJ0XG4gICAgICogQHBhcmFtIHJvb3QgVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIGBpbnNpZGVgLiBJZiBlcXVhbCB0byBQcmlzbS5sYW5ndWFnZXMsIGl0IGNhbiBiZSBvbWl0dGVkLlxuICAgICAqL1xuXHRcdFx0XHRpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShpbnNpZGUsIGJlZm9yZSwgaW5zZXJ0LCByb290KSB7XG5cdFx0XHRcdFx0cm9vdCA9IHJvb3QgfHwgXy5sYW5ndWFnZXM7XG5cdFx0XHRcdFx0dmFyIGdyYW1tYXIgPSByb290W2luc2lkZV07XG5cblx0XHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG5cdFx0XHRcdFx0XHRpbnNlcnQgPSBhcmd1bWVudHNbMV07XG5cblx0XHRcdFx0XHRcdGZvciAodmFyIG5ld1Rva2VuIGluIGluc2VydCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuXHRcdFx0XHRcdFx0XHRcdGdyYW1tYXJbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZ3JhbW1hcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgcmV0ID0ge307XG5cblx0XHRcdFx0XHRmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG5cblx0XHRcdFx0XHRcdGlmIChncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICh0b2tlbiA9PSBiZWZvcmUpIHtcblxuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIG5ld1Rva2VuIGluIGluc2VydCkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXRbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRyZXRbdG9rZW5dID0gZ3JhbW1hclt0b2tlbl07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVXBkYXRlIHJlZmVyZW5jZXMgaW4gb3RoZXIgbGFuZ3VhZ2UgZGVmaW5pdGlvbnNcblx0XHRcdFx0XHRfLmxhbmd1YWdlcy5ERlMoXy5sYW5ndWFnZXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgPT09IHJvb3RbaW5zaWRlXSAmJiBrZXkgIT0gaW5zaWRlKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXNba2V5XSA9IHJldDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHJldHVybiByb290W2luc2lkZV0gPSByZXQ7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gVHJhdmVyc2UgYSBsYW5ndWFnZSBkZWZpbml0aW9uIHdpdGggRGVwdGggRmlyc3QgU2VhcmNoXG5cdFx0XHRcdERGUzogZnVuY3Rpb24gREZTKG8sIGNhbGxiYWNrLCB0eXBlLCB2aXNpdGVkKSB7XG5cdFx0XHRcdFx0dmlzaXRlZCA9IHZpc2l0ZWQgfHwge307XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvKSB7XG5cdFx0XHRcdFx0XHRpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKG8sIGksIG9baV0sIHR5cGUgfHwgaSk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKF8udXRpbC50eXBlKG9baV0pID09PSAnT2JqZWN0JyAmJiAhdmlzaXRlZFtfLnV0aWwub2JqSWQob1tpXSldKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmlzaXRlZFtfLnV0aWwub2JqSWQob1tpXSldID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRfLmxhbmd1YWdlcy5ERlMob1tpXSwgY2FsbGJhY2ssIG51bGwsIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKF8udXRpbC50eXBlKG9baV0pID09PSAnQXJyYXknICYmICF2aXNpdGVkW18udXRpbC5vYmpJZChvW2ldKV0pIHtcblx0XHRcdFx0XHRcdFx0XHR2aXNpdGVkW18udXRpbC5vYmpJZChvW2ldKV0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdF8ubGFuZ3VhZ2VzLkRGUyhvW2ldLCBjYWxsYmFjaywgaSwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRwbHVnaW5zOiB7fSxcblxuXHRcdFx0aGlnaGxpZ2h0QWxsOiBmdW5jdGlvbiBoaWdobGlnaHRBbGwoYXN5bmMsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciBlbnYgPSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2s6IGNhbGxiYWNrLFxuXHRcdFx0XHRcdHNlbGVjdG9yOiAnY29kZVtjbGFzcyo9XCJsYW5ndWFnZS1cIl0sIFtjbGFzcyo9XCJsYW5ndWFnZS1cIl0gY29kZSwgY29kZVtjbGFzcyo9XCJsYW5nLVwiXSwgW2NsYXNzKj1cImxhbmctXCJdIGNvZGUnXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Xy5ob29rcy5ydW4oXCJiZWZvcmUtaGlnaGxpZ2h0YWxsXCIsIGVudik7XG5cblx0XHRcdFx0dmFyIGVsZW1lbnRzID0gZW52LmVsZW1lbnRzIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZW52LnNlbGVjdG9yKTtcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgZWxlbWVudDsgZWxlbWVudCA9IGVsZW1lbnRzW2krK107KSB7XG5cdFx0XHRcdFx0Xy5oaWdobGlnaHRFbGVtZW50KGVsZW1lbnQsIGFzeW5jID09PSB0cnVlLCBlbnYuY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRoaWdobGlnaHRFbGVtZW50OiBmdW5jdGlvbiBoaWdobGlnaHRFbGVtZW50KGVsZW1lbnQsIGFzeW5jLCBjYWxsYmFjaykge1xuXHRcdFx0XHQvLyBGaW5kIGxhbmd1YWdlXG5cdFx0XHRcdHZhciBsYW5ndWFnZSxcblx0XHRcdFx0ICAgIGdyYW1tYXIsXG5cdFx0XHRcdCAgICBwYXJlbnQgPSBlbGVtZW50O1xuXG5cdFx0XHRcdHdoaWxlIChwYXJlbnQgJiYgIWxhbmcudGVzdChwYXJlbnQuY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHRcdGxhbmd1YWdlID0gKHBhcmVudC5jbGFzc05hbWUubWF0Y2gobGFuZykgfHwgWywgJyddKVsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGdyYW1tYXIgPSBfLmxhbmd1YWdlc1tsYW5ndWFnZV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgbGFuZ3VhZ2Ugb24gdGhlIGVsZW1lbnQsIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShsYW5nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpICsgJyBsYW5ndWFnZS0nICsgbGFuZ3VhZ2U7XG5cblx0XHRcdFx0Ly8gU2V0IGxhbmd1YWdlIG9uIHRoZSBwYXJlbnQsIGZvciBzdHlsaW5nXG5cdFx0XHRcdHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuXHRcdFx0XHRpZiAoL3ByZS9pLnRlc3QocGFyZW50Lm5vZGVOYW1lKSkge1xuXHRcdFx0XHRcdHBhcmVudC5jbGFzc05hbWUgPSBwYXJlbnQuY2xhc3NOYW1lLnJlcGxhY2UobGFuZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKSArICcgbGFuZ3VhZ2UtJyArIGxhbmd1YWdlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNvZGUgPSBlbGVtZW50LnRleHRDb250ZW50O1xuXG5cdFx0XHRcdHZhciBlbnYgPSB7XG5cdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcblx0XHRcdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2UsXG5cdFx0XHRcdFx0Z3JhbW1hcjogZ3JhbW1hcixcblx0XHRcdFx0XHRjb2RlOiBjb2RlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1zYW5pdHktY2hlY2snLCBlbnYpO1xuXG5cdFx0XHRcdGlmICghZW52LmNvZGUgfHwgIWVudi5ncmFtbWFyKSB7XG5cdFx0XHRcdFx0aWYgKGVudi5jb2RlKSB7XG5cdFx0XHRcdFx0XHRlbnYuZWxlbWVudC50ZXh0Q29udGVudCA9IGVudi5jb2RlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtaGlnaGxpZ2h0JywgZW52KTtcblxuXHRcdFx0XHRpZiAoYXN5bmMgJiYgX3NlbGYuV29ya2VyKSB7XG5cdFx0XHRcdFx0dmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoXy5maWxlbmFtZSk7XG5cblx0XHRcdFx0XHR3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2dCkge1xuXHRcdFx0XHRcdFx0ZW52LmhpZ2hsaWdodGVkQ29kZSA9IGV2dC5kYXRhO1xuXG5cdFx0XHRcdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWluc2VydCcsIGVudik7XG5cblx0XHRcdFx0XHRcdGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG5cblx0XHRcdFx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZW52LmVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0Xy5ob29rcy5ydW4oJ2FmdGVyLWhpZ2hsaWdodCcsIGVudik7XG5cdFx0XHRcdFx0XHRfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0XHRcdFx0bGFuZ3VhZ2U6IGVudi5sYW5ndWFnZSxcblx0XHRcdFx0XHRcdGNvZGU6IGVudi5jb2RlLFxuXHRcdFx0XHRcdFx0aW1tZWRpYXRlQ2xvc2U6IHRydWVcblx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZW52LmhpZ2hsaWdodGVkQ29kZSA9IF8uaGlnaGxpZ2h0KGVudi5jb2RlLCBlbnYuZ3JhbW1hciwgZW52Lmxhbmd1YWdlKTtcblxuXHRcdFx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtaW5zZXJ0JywgZW52KTtcblxuXHRcdFx0XHRcdGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG5cblx0XHRcdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0Xy5ob29rcy5ydW4oJ2FmdGVyLWhpZ2hsaWdodCcsIGVudik7XG5cdFx0XHRcdFx0Xy5ob29rcy5ydW4oJ2NvbXBsZXRlJywgZW52KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0aGlnaGxpZ2h0OiBmdW5jdGlvbiBoaWdobGlnaHQodGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcblx0XHRcdFx0dmFyIHRva2VucyA9IF8udG9rZW5pemUodGV4dCwgZ3JhbW1hcik7XG5cdFx0XHRcdHJldHVybiBUb2tlbi5zdHJpbmdpZnkoXy51dGlsLmVuY29kZSh0b2tlbnMpLCBsYW5ndWFnZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHR0b2tlbml6ZTogZnVuY3Rpb24gdG9rZW5pemUodGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcblx0XHRcdFx0dmFyIFRva2VuID0gXy5Ub2tlbjtcblxuXHRcdFx0XHR2YXIgc3RyYXJyID0gW3RleHRdO1xuXG5cdFx0XHRcdHZhciByZXN0ID0gZ3JhbW1hci5yZXN0O1xuXG5cdFx0XHRcdGlmIChyZXN0KSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgdG9rZW4gaW4gcmVzdCkge1xuXHRcdFx0XHRcdFx0Z3JhbW1hclt0b2tlbl0gPSByZXN0W3Rva2VuXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkZWxldGUgZ3JhbW1hci5yZXN0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dG9rZW5sb29wOiBmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG5cdFx0XHRcdFx0aWYgKCFncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSB8fCAhZ3JhbW1hclt0b2tlbl0pIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBwYXR0ZXJucyA9IGdyYW1tYXJbdG9rZW5dO1xuXHRcdFx0XHRcdHBhdHRlcm5zID0gXy51dGlsLnR5cGUocGF0dGVybnMpID09PSBcIkFycmF5XCIgPyBwYXR0ZXJucyA6IFtwYXR0ZXJuc107XG5cblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHBhdHRlcm5zLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdFx0XHR2YXIgcGF0dGVybiA9IHBhdHRlcm5zW2pdLFxuXHRcdFx0XHRcdFx0ICAgIGluc2lkZSA9IHBhdHRlcm4uaW5zaWRlLFxuXHRcdFx0XHRcdFx0ICAgIGxvb2tiZWhpbmQgPSAhIXBhdHRlcm4ubG9va2JlaGluZCxcblx0XHRcdFx0XHRcdCAgICBncmVlZHkgPSAhIXBhdHRlcm4uZ3JlZWR5LFxuXHRcdFx0XHRcdFx0ICAgIGxvb2tiZWhpbmRMZW5ndGggPSAwLFxuXHRcdFx0XHRcdFx0ICAgIGFsaWFzID0gcGF0dGVybi5hbGlhcztcblxuXHRcdFx0XHRcdFx0aWYgKGdyZWVkeSAmJiAhcGF0dGVybi5wYXR0ZXJuLmdsb2JhbCkge1xuXHRcdFx0XHRcdFx0XHQvLyBXaXRob3V0IHRoZSBnbG9iYWwgZmxhZywgbGFzdEluZGV4IHdvbid0IHdvcmtcblx0XHRcdFx0XHRcdFx0dmFyIGZsYWdzID0gcGF0dGVybi5wYXR0ZXJuLnRvU3RyaW5nKCkubWF0Y2goL1tpbXV5XSokLylbMF07XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm4ucGF0dGVybiA9IFJlZ0V4cChwYXR0ZXJuLnBhdHRlcm4uc291cmNlLCBmbGFncyArIFwiZ1wiKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cGF0dGVybiA9IHBhdHRlcm4ucGF0dGVybiB8fCBwYXR0ZXJuO1xuXG5cdFx0XHRcdFx0XHQvLyBEb27igJl0IGNhY2hlIGxlbmd0aCBhcyBpdCBjaGFuZ2VzIGR1cmluZyB0aGUgbG9vcFxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIHBvcyA9IDA7IGkgPCBzdHJhcnIubGVuZ3RoOyBwb3MgKz0gc3RyYXJyW2ldLmxlbmd0aCwgKytpKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHN0ciA9IHN0cmFycltpXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoc3RyYXJyLmxlbmd0aCA+IHRleHQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gU29tZXRoaW5nIHdlbnQgdGVycmlibHkgd3JvbmcsIEFCT1JULCBBQk9SVCFcblx0XHRcdFx0XHRcdFx0XHRicmVhayB0b2tlbmxvb3A7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoc3RyIGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcblxuXHRcdFx0XHRcdFx0XHR2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyKSxcblx0XHRcdFx0XHRcdFx0ICAgIGRlbE51bSA9IDE7XG5cblx0XHRcdFx0XHRcdFx0Ly8gR3JlZWR5IHBhdHRlcm5zIGNhbiBvdmVycmlkZS9yZW1vdmUgdXAgdG8gdHdvIHByZXZpb3VzbHkgbWF0Y2hlZCB0b2tlbnNcblx0XHRcdFx0XHRcdFx0aWYgKCFtYXRjaCAmJiBncmVlZHkgJiYgaSAhPSBzdHJhcnIubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdHRlcm4ubGFzdEluZGV4ID0gcG9zO1xuXHRcdFx0XHRcdFx0XHRcdG1hdGNoID0gcGF0dGVybi5leGVjKHRleHQpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHZhciBmcm9tID0gbWF0Y2guaW5kZXggKyAobG9va2JlaGluZCA/IG1hdGNoWzFdLmxlbmd0aCA6IDApLFxuXHRcdFx0XHRcdFx0XHRcdCAgICB0byA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRcdCAgICBrID0gaSxcblx0XHRcdFx0XHRcdFx0XHQgICAgcCA9IHBvcztcblxuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGxlbiA9IHN0cmFyci5sZW5ndGg7IGsgPCBsZW4gJiYgcCA8IHRvOyArK2spIHtcblx0XHRcdFx0XHRcdFx0XHRcdHAgKz0gc3RyYXJyW2tdLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIE1vdmUgdGhlIGluZGV4IGkgdG8gdGhlIGVsZW1lbnQgaW4gc3RyYXJyIHRoYXQgaXMgY2xvc2VzdCB0byBmcm9tXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZnJvbSA+PSBwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsraTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zID0gcDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKlxuICAgICAgICAgKiBJZiBzdHJhcnJbaV0gaXMgYSBUb2tlbiwgdGhlbiB0aGUgbWF0Y2ggc3RhcnRzIGluc2lkZSBhbm90aGVyIFRva2VuLCB3aGljaCBpcyBpbnZhbGlkXG4gICAgICAgICAqIElmIHN0cmFycltrIC0gMV0gaXMgZ3JlZWR5IHdlIGFyZSBpbiBjb25mbGljdCB3aXRoIGFub3RoZXIgZ3JlZWR5IHBhdHRlcm5cbiAgICAgICAgICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0cmFycltpXSBpbnN0YW5jZW9mIFRva2VuIHx8IHN0cmFycltrIC0gMV0uZ3JlZWR5KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBOdW1iZXIgb2YgdG9rZW5zIHRvIGRlbGV0ZSBhbmQgcmVwbGFjZSB3aXRoIHRoZSBuZXcgbWF0Y2hcblx0XHRcdFx0XHRcdFx0XHRkZWxOdW0gPSBrIC0gaTtcblx0XHRcdFx0XHRcdFx0XHRzdHIgPSB0ZXh0LnNsaWNlKHBvcywgcCk7XG5cdFx0XHRcdFx0XHRcdFx0bWF0Y2guaW5kZXggLT0gcG9zO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGxvb2tiZWhpbmQpIHtcblx0XHRcdFx0XHRcdFx0XHRsb29rYmVoaW5kTGVuZ3RoID0gbWF0Y2hbMV0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dmFyIGZyb20gPSBtYXRjaC5pbmRleCArIGxvb2tiZWhpbmRMZW5ndGgsXG5cdFx0XHRcdFx0XHRcdCAgICBtYXRjaCA9IG1hdGNoWzBdLnNsaWNlKGxvb2tiZWhpbmRMZW5ndGgpLFxuXHRcdFx0XHRcdFx0XHQgICAgdG8gPSBmcm9tICsgbWF0Y2gubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHQgICAgYmVmb3JlID0gc3RyLnNsaWNlKDAsIGZyb20pLFxuXHRcdFx0XHRcdFx0XHQgICAgYWZ0ZXIgPSBzdHIuc2xpY2UodG8pO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBhcmdzID0gW2ksIGRlbE51bV07XG5cblx0XHRcdFx0XHRcdFx0aWYgKGJlZm9yZSkge1xuXHRcdFx0XHRcdFx0XHRcdGFyZ3MucHVzaChiZWZvcmUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dmFyIHdyYXBwZWQgPSBuZXcgVG9rZW4odG9rZW4sIGluc2lkZSA/IF8udG9rZW5pemUobWF0Y2gsIGluc2lkZSkgOiBtYXRjaCwgYWxpYXMsIG1hdGNoLCBncmVlZHkpO1xuXG5cdFx0XHRcdFx0XHRcdGFyZ3MucHVzaCh3cmFwcGVkKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0XHRcdFx0XHRhcmdzLnB1c2goYWZ0ZXIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShzdHJhcnIsIGFyZ3MpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBzdHJhcnI7XG5cdFx0XHR9LFxuXG5cdFx0XHRob29rczoge1xuXHRcdFx0XHRhbGw6IHt9LFxuXG5cdFx0XHRcdGFkZDogZnVuY3Rpb24gYWRkKG5hbWUsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0dmFyIGhvb2tzID0gXy5ob29rcy5hbGw7XG5cblx0XHRcdFx0XHRob29rc1tuYW1lXSA9IGhvb2tzW25hbWVdIHx8IFtdO1xuXG5cdFx0XHRcdFx0aG9va3NbbmFtZV0ucHVzaChjYWxsYmFjayk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0cnVuOiBmdW5jdGlvbiBydW4obmFtZSwgZW52KSB7XG5cdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IF8uaG9va3MuYWxsW25hbWVdO1xuXG5cdFx0XHRcdFx0aWYgKCFjYWxsYmFja3MgfHwgIWNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgY2FsbGJhY2s7IGNhbGxiYWNrID0gY2FsbGJhY2tzW2krK107KSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhlbnYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgVG9rZW4gPSBfLlRva2VuID0gZnVuY3Rpb24gKHR5cGUsIGNvbnRlbnQsIGFsaWFzLCBtYXRjaGVkU3RyLCBncmVlZHkpIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0XHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXHRcdFx0dGhpcy5hbGlhcyA9IGFsaWFzO1xuXHRcdFx0Ly8gQ29weSBvZiB0aGUgZnVsbCBzdHJpbmcgdGhpcyB0b2tlbiB3YXMgY3JlYXRlZCBmcm9tXG5cdFx0XHR0aGlzLmxlbmd0aCA9IChtYXRjaGVkU3RyIHx8IFwiXCIpLmxlbmd0aCB8IDA7XG5cdFx0XHR0aGlzLmdyZWVkeSA9ICEhZ3JlZWR5O1xuXHRcdH07XG5cblx0XHRUb2tlbi5zdHJpbmdpZnkgPSBmdW5jdGlvbiAobywgbGFuZ3VhZ2UsIHBhcmVudCkge1xuXHRcdFx0aWYgKHR5cGVvZiBvID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXy51dGlsLnR5cGUobykgPT09ICdBcnJheScpIHtcblx0XHRcdFx0cmV0dXJuIG8ubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0cmV0dXJuIFRva2VuLnN0cmluZ2lmeShlbGVtZW50LCBsYW5ndWFnZSwgbyk7XG5cdFx0XHRcdH0pLmpvaW4oJycpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZW52ID0ge1xuXHRcdFx0XHR0eXBlOiBvLnR5cGUsXG5cdFx0XHRcdGNvbnRlbnQ6IFRva2VuLnN0cmluZ2lmeShvLmNvbnRlbnQsIGxhbmd1YWdlLCBwYXJlbnQpLFxuXHRcdFx0XHR0YWc6ICdzcGFuJyxcblx0XHRcdFx0Y2xhc3NlczogWyd0b2tlbicsIG8udHlwZV0sXG5cdFx0XHRcdGF0dHJpYnV0ZXM6IHt9LFxuXHRcdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2UsXG5cdFx0XHRcdHBhcmVudDogcGFyZW50XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoZW52LnR5cGUgPT0gJ2NvbW1lbnQnKSB7XG5cdFx0XHRcdGVudi5hdHRyaWJ1dGVzWydzcGVsbGNoZWNrJ10gPSAndHJ1ZSc7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvLmFsaWFzKSB7XG5cdFx0XHRcdHZhciBhbGlhc2VzID0gXy51dGlsLnR5cGUoby5hbGlhcykgPT09ICdBcnJheScgPyBvLmFsaWFzIDogW28uYWxpYXNdO1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbnYuY2xhc3NlcywgYWxpYXNlcyk7XG5cdFx0XHR9XG5cblx0XHRcdF8uaG9va3MucnVuKCd3cmFwJywgZW52KTtcblxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhlbnYuYXR0cmlidXRlcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdHJldHVybiBuYW1lICsgJz1cIicgKyAoZW52LmF0dHJpYnV0ZXNbbmFtZV0gfHwgJycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSArICdcIic7XG5cdFx0XHR9KS5qb2luKCcgJyk7XG5cblx0XHRcdHJldHVybiAnPCcgKyBlbnYudGFnICsgJyBjbGFzcz1cIicgKyBlbnYuY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICsgKGF0dHJpYnV0ZXMgPyAnICcgKyBhdHRyaWJ1dGVzIDogJycpICsgJz4nICsgZW52LmNvbnRlbnQgKyAnPC8nICsgZW52LnRhZyArICc+Jztcblx0XHR9O1xuXG5cdFx0aWYgKCFfc2VsZi5kb2N1bWVudCkge1xuXHRcdFx0aWYgKCFfc2VsZi5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHRcdC8vIGluIE5vZGUuanNcblx0XHRcdFx0cmV0dXJuIF9zZWxmLlByaXNtO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSW4gd29ya2VyXG5cdFx0XHRfc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2dCkge1xuXHRcdFx0XHR2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZ0LmRhdGEpLFxuXHRcdFx0XHQgICAgbGFuZyA9IG1lc3NhZ2UubGFuZ3VhZ2UsXG5cdFx0XHRcdCAgICBjb2RlID0gbWVzc2FnZS5jb2RlLFxuXHRcdFx0XHQgICAgaW1tZWRpYXRlQ2xvc2UgPSBtZXNzYWdlLmltbWVkaWF0ZUNsb3NlO1xuXG5cdFx0XHRcdF9zZWxmLnBvc3RNZXNzYWdlKF8uaGlnaGxpZ2h0KGNvZGUsIF8ubGFuZ3VhZ2VzW2xhbmddLCBsYW5nKSk7XG5cdFx0XHRcdGlmIChpbW1lZGlhdGVDbG9zZSkge1xuXHRcdFx0XHRcdF9zZWxmLmNsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIGZhbHNlKTtcblxuXHRcdFx0cmV0dXJuIF9zZWxmLlByaXNtO1xuXHRcdH1cblxuXHRcdC8vR2V0IGN1cnJlbnQgc2NyaXB0IGFuZCBoaWdobGlnaHRcblx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdCB8fCBbXS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpKS5wb3AoKTtcblxuXHRcdGlmIChzY3JpcHQpIHtcblx0XHRcdF8uZmlsZW5hbWUgPSBzY3JpcHQuc3JjO1xuXG5cdFx0XHRpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAmJiAhc2NyaXB0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1tYW51YWwnKSkge1xuXHRcdFx0XHRpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIHtcblx0XHRcdFx0XHRpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdFx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShfLmhpZ2hsaWdodEFsbCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KF8uaGlnaGxpZ2h0QWxsLCAxNik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBfLmhpZ2hsaWdodEFsbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gX3NlbGYuUHJpc207XG5cdH0oKTtcblxuXHRpZiAoJ29iamVjdCcgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBQcmlzbTtcblx0fVxuXG5cdC8vIGhhY2sgZm9yIGNvbXBvbmVudHMgdG8gd29yayBjb3JyZWN0bHkgaW4gbm9kZS5qc1xuXHRpZiAodHlwZW9mIGNvbW1vbmpzR2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuXHRcdGNvbW1vbmpzR2xvYmFsLlByaXNtID0gUHJpc207XG5cdH1cbn0pO1xuXG52YXIgcHJpc21Db3JlXzEgPSBwcmlzbUNvcmUuaGlnaGxpZ2h0O1xudmFyIHByaXNtQ29yZV8yID0gcHJpc21Db3JlLmxhbmd1YWdlcztcblxuUHJpc20ubGFuZ3VhZ2VzLmNsaWtlID0ge1xuXHQnY29tbWVudCc6IFt7XG5cdFx0cGF0dGVybjogLyhefFteXFxcXF0pXFwvXFwqW1xcd1xcV10qP1xcKlxcLy8sXG5cdFx0bG9va2JlaGluZDogdHJ1ZVxuXHR9LCB7XG5cdFx0cGF0dGVybjogLyhefFteXFxcXDpdKVxcL1xcLy4qLyxcblx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdH1dLFxuXHQnc3RyaW5nJzoge1xuXHRcdHBhdHRlcm46IC8oW1wiJ10pKFxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQnY2xhc3MtbmFtZSc6IHtcblx0XHRwYXR0ZXJuOiAvKCg/OlxcYig/OmNsYXNzfGludGVyZmFjZXxleHRlbmRzfGltcGxlbWVudHN8dHJhaXR8aW5zdGFuY2VvZnxuZXcpXFxzKyl8KD86Y2F0Y2hcXHMrXFwoKSlbYS16MC05X1xcLlxcXFxdKy9pLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHRwdW5jdHVhdGlvbjogLyhcXC58XFxcXCkvXG5cdFx0fVxuXHR9LFxuXHQna2V5d29yZCc6IC9cXGIoaWZ8ZWxzZXx3aGlsZXxkb3xmb3J8cmV0dXJufGlufGluc3RhbmNlb2Z8ZnVuY3Rpb258bmV3fHRyeXx0aHJvd3xjYXRjaHxmaW5hbGx5fG51bGx8YnJlYWt8Y29udGludWUpXFxiLyxcblx0J2Jvb2xlYW4nOiAvXFxiKHRydWV8ZmFsc2UpXFxiLyxcblx0J2Z1bmN0aW9uJzogL1thLXowLTlfXSsoPz1cXCgpL2ksXG5cdCdudW1iZXInOiAvXFxiLT8oPzoweFtcXGRhLWZdK3xcXGQqXFwuP1xcZCsoPzplWystXT9cXGQrKT8pXFxiL2ksXG5cdCdvcGVyYXRvcic6IC8tLT98XFwrXFwrP3whPT89P3w8PT98Pj0/fD09Pz0/fCYmP3xcXHxcXHw/fFxcP3xcXCp8XFwvfH58XFxefCUvLFxuXHQncHVuY3R1YXRpb24nOiAvW3t9W1xcXTsoKSwuOl0vXG59O1xuXG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuXHQna2V5d29yZCc6IC9cXGIoYXN8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseXxmb3J8ZnJvbXxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvLFxuXHQnbnVtYmVyJzogL1xcYi0/KDB4W1xcZEEtRmEtZl0rfDBiWzAxXSt8MG9bMC03XSt8XFxkKlxcLj9cXGQrKFtFZV1bKy1dP1xcZCspP3xOYU58SW5maW5pdHkpXFxiLyxcblx0Ly8gQWxsb3cgZm9yIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycyAoU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMDg0NDQpXG5cdCdmdW5jdGlvbic6IC9bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKig/PVxcKCkvaSxcblx0J29wZXJhdG9yJzogLy0tP3xcXCtcXCs/fCE9Pz0/fDw9P3w+PT98PT0/PT98JiY/fFxcfFxcfD98XFw/fFxcKlxcKj98XFwvfH58XFxefCV8XFwuezN9L1xufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAna2V5d29yZCcsIHtcblx0J3JlZ2V4Jzoge1xuXHRcdHBhdHRlcm46IC8oXnxbXi9dKVxcLyg/IVxcLykoXFxbLis/XXxcXFxcLnxbXi9cXFxcXFxyXFxuXSkrXFwvW2dpbXl1XXswLDV9KD89XFxzKigkfFtcXHJcXG4sLjt9KV0pKS8sXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRncmVlZHk6IHRydWVcblx0fVxufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnc3RyaW5nJywge1xuXHQndGVtcGxhdGUtc3RyaW5nJzoge1xuXHRcdHBhdHRlcm46IC9gKD86XFxcXFxcXFx8XFxcXD9bXlxcXFxdKSo/YC8sXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J2ludGVycG9sYXRpb24nOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9cXCRcXHtbXn1dK1xcfS8sXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJzoge1xuXHRcdFx0XHRcdFx0cGF0dGVybjogL15cXCRcXHt8XFx9JC8sXG5cdFx0XHRcdFx0XHRhbGlhczogJ3B1bmN0dWF0aW9uJ1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVzdDogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdzdHJpbmcnOiAvW1xcc1xcU10rL1xuXHRcdH1cblx0fVxufSk7XG5cbmlmIChQcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICd0YWcnLCB7XG5cdFx0J3NjcmlwdCc6IHtcblx0XHRcdHBhdHRlcm46IC8oPHNjcmlwdFtcXHdcXFddKj8+KVtcXHdcXFddKj8oPz08XFwvc2NyaXB0PikvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0LFxuXHRcdFx0YWxpYXM6ICdsYW5ndWFnZS1qYXZhc2NyaXB0J1xuXHRcdH1cblx0fSk7XG59XG5cblByaXNtLmxhbmd1YWdlcy5qcyA9IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0O1xuXG5QcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuXHQnY29tbWVudCc6IC88IS0tW1xcd1xcV10qPy0tPi8sXG5cdCdwcm9sb2cnOiAvPFxcP1tcXHdcXFddKz9cXD8+Lyxcblx0J2RvY3R5cGUnOiAvPCFET0NUWVBFW1xcd1xcV10rPz4vaSxcblx0J2NkYXRhJzogLzwhXFxbQ0RBVEFcXFtbXFx3XFxXXSo/XV0+L2ksXG5cdCd0YWcnOiB7XG5cdFx0cGF0dGVybjogLzxcXC8/KD8hXFxkKVteXFxzPlxcLz0kPF0rKD86XFxzK1teXFxzPlxcLz1dKyg/Oj0oPzooXCJ8JykoPzpcXFxcXFwxfFxcXFw/KD8hXFwxKVtcXHdcXFddKSpcXDF8W15cXHMnXCI+PV0rKSk/KSpcXHMqXFwvPz4vaSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCd0YWcnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9ePFxcLz9bXlxccz5cXC9dKy9pLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXjxcXC8/Lyxcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0J2F0dHItdmFsdWUnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC89KD86KCd8XCIpW1xcd1xcV10qPyhcXDEpfFteXFxzPl0rKS9pLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiAvWz0+XCInXS9cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdwdW5jdHVhdGlvbic6IC9cXC8/Pi8sXG5cdFx0XHQnYXR0ci1uYW1lJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvW15cXHM+XFwvXSsvLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdH0sXG5cdCdlbnRpdHknOiAvJiM/W1xcZGEtel17MSw4fTsvaVxufTtcblxuLy8gUGx1Z2luIHRvIG1ha2UgZW50aXR5IHRpdGxlIHNob3cgdGhlIHJlYWwgZW50aXR5LCBpZGVhIGJ5IFJvbWFuIEtvbWFyb3ZcblByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uIChlbnYpIHtcblxuXHRpZiAoZW52LnR5cGUgPT09ICdlbnRpdHknKSB7XG5cdFx0ZW52LmF0dHJpYnV0ZXNbJ3RpdGxlJ10gPSBlbnYuY29udGVudC5yZXBsYWNlKC8mYW1wOy8sICcmJyk7XG5cdH1cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMueG1sID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblByaXNtLmxhbmd1YWdlcy5odG1sID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblByaXNtLmxhbmd1YWdlcy5tYXRobWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLnN2ZyA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cbihmdW5jdGlvbiAoUHJpc20pIHtcblxuXHR2YXIgamF2YXNjcmlwdCA9IFByaXNtLnV0aWwuY2xvbmUoUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQpO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5qc3ggPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdtYXJrdXAnLCBqYXZhc2NyaXB0KTtcblx0UHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcucGF0dGVybiA9IC88XFwvP1tcXHdcXC46LV0rXFxzKig/OlxccytbXFx3XFwuOi1dKyg/Oj0oPzooXCJ8JykoXFxcXD9bXFx3XFxXXSkqP1xcMXxbXlxccydcIj49XSt8KFxce1tcXHdcXFddKj9cXH0pKSk/XFxzKikqXFwvPz4vaTtcblxuXHRQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5pbnNpZGVbJ2F0dHItdmFsdWUnXS5wYXR0ZXJuID0gLz1bXlxce10oPzooJ3xcIilbXFx3XFxXXSo/KFxcMSl8W15cXHM+XSspL2k7XG5cblx0dmFyIGpzeEV4cHJlc3Npb24gPSBQcmlzbS51dGlsLmNsb25lKFByaXNtLmxhbmd1YWdlcy5qc3gpO1xuXG5cdGRlbGV0ZSBqc3hFeHByZXNzaW9uLnB1bmN0dWF0aW9uO1xuXG5cdGpzeEV4cHJlc3Npb24gPSBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqc3gnLCAnb3BlcmF0b3InLCB7XG5cdFx0J3B1bmN0dWF0aW9uJzogLz0oPz17KXxbe31bXFxdOygpLC46XS9cblx0fSwgeyBqc3g6IGpzeEV4cHJlc3Npb24gfSk7XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnaW5zaWRlJywgJ2F0dHItdmFsdWUnLCB7XG5cdFx0J3NjcmlwdCc6IHtcblx0XHRcdC8vIEFsbG93IGZvciBvbmUgbGV2ZWwgb2YgbmVzdGluZ1xuXHRcdFx0cGF0dGVybjogLz0oXFx7KD86XFx7W159XSpcXH18W159XSkrXFx9KS9pLFxuXHRcdFx0aW5zaWRlOiBqc3hFeHByZXNzaW9uLFxuXHRcdFx0J2FsaWFzJzogJ2xhbmd1YWdlLWphdmFzY3JpcHQnXG5cdFx0fVxuXHR9LCBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZyk7XG59KShQcmlzbSk7XG5cbnZhciBwcmlzbSA9IGZ1bmN0aW9uIHByaXNtKGNvZGUpIHtcbiAgcmV0dXJuIHByaXNtQ29yZV8xKGNvZGUsIHByaXNtQ29yZV8yLmpzeCk7XG59O1xuXG52YXIgaW5kZW50UmVnZXggPSAvXlxccysvO1xuXG52YXIgZ2V0SW5kZW50ID0gZnVuY3Rpb24gZ2V0SW5kZW50KHBsYWluLCBjdXJzb3JQb3MpIHtcbiAgdmFyIHN0YXJ0U2xpY2UgPSBwbGFpbi5zbGljZSgwLCBjdXJzb3JQb3MpO1xuICB2YXIgbGFzdE5ld2xpbmUgPSBzdGFydFNsaWNlLmxhc3RJbmRleE9mKCdcXG4nKSArIDE7XG4gIHZhciBsaW5lU2xpY2UgPSBzdGFydFNsaWNlLnNsaWNlKGxhc3ROZXdsaW5lKTtcbiAgdmFyIG1hdGNoZXMgPSBsaW5lU2xpY2UubWF0Y2goaW5kZW50UmVnZXgpO1xuICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzWzBdIHx8ICcnO1xufTtcblxudmFyIG5vcm1hbGl6ZUNvZGUgPSBmdW5jdGlvbiBub3JtYWxpemVDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUucmVwbGFjZSgvXigoICApKykvbWcsIGZ1bmN0aW9uIChfLCBwMSkge1xuICAgIHJldHVybiAnXFx0Jy5yZXBlYXQocDEubGVuZ3RoIC8gMik7XG4gIH0pO1xufTtcblxudmFyIG5vcm1hbGl6ZUh0bWwgPSBmdW5jdGlvbiBub3JtYWxpemVIdG1sKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwucmVwbGFjZSgnXFxuJywgJzxicj4nKTtcbn07XG5cbnZhciBpbmRleCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBjYWNoZTtcblxuICAvKipcbiAgICogQ29udmVydCBIVE1MIGVudGl0aWVzIHRvIEhUTUwgY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBgc3RyYCBTdHJpbmcgd2l0aCBIVE1MIGVudGl0aWVzIHRvIHVuLWVzY2FwZS5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICB2YXIgdW5lc2NhcGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcblxuICAgIHZhciByZSA9IGNhY2hlIHx8IChjYWNoZSA9IG5ldyBSZWdFeHAoJygnICsgT2JqZWN0LmtleXMoY2hhcnMpLmpvaW4oJ3wnKSArICcpJywgJ2cnKSk7XG4gICAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgcmV0dXJuIGNoYXJzW21hdGNoXTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgY2hhcnMgPSB1bmVzY2FwZS5jaGFycyA9IHtcbiAgICAnJmFwb3M7JzogJ1xcJycsXG4gICAgJyYjMzk7JzogJ1xcJycsXG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmcXVvdDsnOiAnXCInXG4gIH07XG59KTtcblxudmFyIGh0bWxUb1BsYWluID0gZnVuY3Rpb24gaHRtbFRvUGxhaW4oaHRtbCkge1xuICByZXR1cm4gaW5kZXgoaHRtbC5yZXBsYWNlKC88YnI+L2dtLCAnXFxuJykucmVwbGFjZSgvPFxcLz9bXj5dKj4vZ20sICcnKSk7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgeG9yYFxuICovXG5cbnZhciBpbmRleCQyID0geG9yJDE7XG5cbi8qKlxuICogWE9SIHV0aWxpdHlcbiAqXG4gKiBUIFQgRlxuICogVCBGIFRcbiAqIEYgVCBUXG4gKiBGIEYgRlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYVxuICogQHBhcmFtIHtCb29sZWFufSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIHhvciQxKGEsIGIpIHtcbiAgcmV0dXJuICFhICE9ICFiO1xufVxuXG4vKipcbiAqIEdsb2JhbCBOYW1lc1xuICovXG5cbnZhciBnbG9iYWxzID0gL1xcYihBcnJheXxEYXRlfE9iamVjdHxNYXRofEpTT04pXFxiL2c7XG5cbi8qKlxuICogUmV0dXJuIGltbWVkaWF0ZSBpZGVudGlmaWVycyBwYXJzZWQgZnJvbSBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gbWFwIGZ1bmN0aW9uIG9yIHByZWZpeFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBpbmRleCQ0ID0gZnVuY3Rpb24gaW5kZXgoc3RyLCBmbikge1xuICB2YXIgcCA9IHVuaXF1ZShwcm9wcyQxKHN0cikpO1xuICBpZiAoZm4gJiYgJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IHByZWZpeGVkKGZuKTtcbiAgaWYgKGZuKSByZXR1cm4gbWFwKHN0ciwgcCwgZm4pO1xuICByZXR1cm4gcDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGltbWVkaWF0ZSBpZGVudGlmaWVycyBpbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHByb3BzJDEoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFwuXFx3K3xcXHcrICpcXCh8XCJbXlwiXSpcInwnW14nXSonfFxcLyhbXi9dKylcXC8vZywgJycpLnJlcGxhY2UoZ2xvYmFscywgJycpLm1hdGNoKC9bYS16QS1aX11cXHcqL2cpIHx8IFtdO1xufVxuXG4vKipcbiAqIFJldHVybiBgc3RyYCB3aXRoIGBwcm9wc2AgbWFwcGVkIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1hcChzdHIsIHByb3BzLCBmbikge1xuICB2YXIgcmUgPSAvXFwuXFx3K3xcXHcrICpcXCh8XCJbXlwiXSpcInwnW14nXSonfFxcLyhbXi9dKylcXC98W2EtekEtWl9dXFx3Ki9nO1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCcoJyA9PSBfW18ubGVuZ3RoIC0gMV0pIHJldHVybiBmbihfKTtcbiAgICBpZiAoIX5wcm9wcy5pbmRleE9mKF8pKSByZXR1cm4gXztcbiAgICByZXR1cm4gZm4oXyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybiB1bmlxdWUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgdmFyIHJldCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKH5yZXQuaW5kZXhPZihhcnJbaV0pKSBjb250aW51ZTtcbiAgICByZXQucHVzaChhcnJbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBNYXAgd2l0aCBwcmVmaXggYHN0cmAuXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4ZWQoc3RyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoXykge1xuICAgIHJldHVybiBzdHIgKyBfO1xuICB9O1xufVxuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuXG5cblxuXG5cblxuXG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG5cblxuXG5cblxuXG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cbi8qKlxuICogTW9kdWxlIERlcGVuZGVuY2llc1xuICovXG5cbnZhciB4b3I7XG52YXIgcHJvcHM7XG5cbnRyeSB7XG4gIHhvciA9IGluZGV4JDI7XG59IGNhdGNoIChlKSB7XG4gIHhvciA9IGluZGV4JDI7XG59XG5cbnRyeSB7XG4gIHByb3BzID0gaW5kZXgkNDtcbn0gY2F0Y2ggKGUpIHtcbiAgcHJvcHMgPSBpbmRleCQ0O1xufVxuXG4vKipcbiAqIEV4cG9ydCBgSXRlcmF0b3JgXG4gKi9cblxudmFyIGluZGV4JDEgPSBJdGVyYXRvcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGBJdGVyYXRvcmBcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gcm9vdFxuICogQHJldHVybiB7SXRlcmF0b3J9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSXRlcmF0b3Iobm9kZSwgcm9vdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSXRlcmF0b3IpKSByZXR1cm4gbmV3IEl0ZXJhdG9yKG5vZGUsIHJvb3QpO1xuICB0aGlzLm5vZGUgPSB0aGlzLnN0YXJ0ID0gdGhpcy5wZWVrZWQgPSBub2RlO1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmNsb3NpbmdUYWcgPSBmYWxzZTtcbiAgdGhpcy5fcmV2aXNpdCA9IHRydWU7XG4gIHRoaXMuX3NlbGVjdHMgPSBbXTtcbiAgdGhpcy5fcmVqZWN0cyA9IFtdO1xuXG4gIGlmIChub2RlICYmIHRoaXMuaGlnaGVyKG5vZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyb290IG11c3QgYmUgYSBwYXJlbnQgb3IgYW5jZXN0b3IgdG8gbm9kZScpO1xuICB9XG59XG5cbi8qKlxuICogUmVzZXQgdGhlIEl0ZXJhdG9yXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIChvcHRpb25hbClcbiAqIEByZXR1cm4ge0l0ZXJhdG9yfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubm9kZSA9IG5vZGUgfHwgdGhpcy5zdGFydDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldmlzaXQgZWxlbWVudCBub2Rlcy4gRGVmYXVsdHMgdG8gYHRydWVgXG4gKi9cblxuSXRlcmF0b3IucHJvdG90eXBlLnJldmlzaXQgPSBmdW5jdGlvbiAocmV2aXNpdCkge1xuICB0aGlzLl9yZXZpc2l0ID0gdW5kZWZpbmVkID09IHJldmlzaXQgPyB0cnVlIDogcmV2aXNpdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEp1bXAgdG8gdGhlIG9wZW5pbmcgdGFnXG4gKi9cblxuSXRlcmF0b3IucHJvdG90eXBlLm9wZW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgxID09IHRoaXMubm9kZS5ub2RlVHlwZSkgdGhpcy5jbG9zaW5nVGFnID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBKdW1wIHRvIHRoZSBjbG9zaW5nIHRhZ1xuICovXG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5hdE9wZW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5jbG9zaW5nVGFnO1xufTtcblxuLyoqXG4gKiBKdW1wIHRvIHRoZSBjbG9zaW5nIHRhZ1xuICovXG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5jbG9zaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoMSA9PSB0aGlzLm5vZGUubm9kZVR5cGUpIHRoaXMuY2xvc2luZ1RhZyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBKdW1wIHRvIHRoZSBjbG9zaW5nIHRhZ1xuICovXG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5hdENsb3NpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsb3NpbmdUYWc7XG59O1xuXG4vKipcbiAqIE5leHQgbm9kZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlXG4gKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gdHJhdmVyc2UoJ25leHRTaWJsaW5nJywgJ2ZpcnN0Q2hpbGQnKTtcblxuLyoqXG4gKiBQcmV2aW91cyBub2RlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVcbiAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuSXRlcmF0b3IucHJvdG90eXBlLnByZXZpb3VzID0gSXRlcmF0b3IucHJvdG90eXBlLnByZXYgPSB0cmF2ZXJzZSgncHJldmlvdXNTaWJsaW5nJywgJ2xhc3RDaGlsZCcpO1xuXG4vKipcbiAqIE1ha2UgdHJhdmVyc2UgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGlyXG4gKiBAcGFyYW0ge1N0cmluZ30gY2hpbGRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdHJhdmVyc2UoZGlyLCBjaGlsZCkge1xuICB2YXIgbmV4dCA9IGRpciA9PSAnbmV4dFNpYmxpbmcnO1xuICByZXR1cm4gZnVuY3Rpb24gd2FsayhleHByLCBuLCBwZWVrKSB7XG4gICAgZXhwciA9IHRoaXMuY29tcGlsZShleHByKTtcbiAgICBuID0gbiAmJiBuID4gMCA/IG4gOiAxO1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xuICAgIHZhciBjbG9zaW5nID0gdGhpcy5jbG9zaW5nVGFnO1xuICAgIHZhciByZXZpc2l0ID0gdGhpcy5fcmV2aXNpdDtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBpZiAoeG9yKG5leHQsIGNsb3NpbmcpICYmIG5vZGVbY2hpbGRdKSB7XG4gICAgICAgIC8vIGVsZW1lbnQgd2l0aCBjaGlsZHJlbjogPGVtPi4uLjwvZW0+XG4gICAgICAgIG5vZGUgPSBub2RlW2NoaWxkXTtcbiAgICAgICAgY2xvc2luZyA9ICFuZXh0O1xuICAgICAgfSBlbHNlIGlmICgxID09IG5vZGUubm9kZVR5cGUgJiYgIW5vZGVbY2hpbGRdICYmIHhvcihuZXh0LCBjbG9zaW5nKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50IHRhZzogPGVtPjwvZW0+XG4gICAgICAgIGNsb3NpbmcgPSBuZXh0O1xuICAgICAgICBpZiAoIXJldmlzaXQpIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChub2RlW2Rpcl0pIHtcbiAgICAgICAgLy8gZWxlbWVudCBoYXMgYSBuZWlnaGJvcjogLi4uPGVtPjwvZW0+Li4uXG4gICAgICAgIG5vZGUgPSBub2RlW2Rpcl07XG4gICAgICAgIGNsb3NpbmcgPSAhbmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvbmUgd2l0aCBjdXJyZW50IGxheWVyLCBtb3ZlIHVwLlxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBjbG9zaW5nID0gbmV4dDtcbiAgICAgICAgaWYgKCFyZXZpc2l0KSBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFub2RlIHx8IHRoaXMuaGlnaGVyKG5vZGUsIHRoaXMucm9vdCkpIGJyZWFrO1xuXG4gICAgICBpZiAoZXhwcihub2RlKSAmJiB0aGlzLnNlbGVjdHMobm9kZSwgcGVlaykgJiYgdGhpcy5yZWplY3RzKG5vZGUsIHBlZWspKSB7XG4gICAgICAgIGlmICgtLW4pIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBlZWspIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuY2xvc2luZ1RhZyA9IGNsb3Npbmc7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuXG4vKipcbiAqIFNlbGVjdCBub2RlcyB0aGF0IGNhdXNlIGBleHByKG5vZGUpYFxuICogdG8gYmUgdHJ1dGh5XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEZ1bmN0aW9ufSBleHByXG4gKiBAcmV0dXJuIHtJdGVyYXRvcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5JdGVyYXRvci5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgZXhwciA9IHRoaXMuY29tcGlsZShleHByKTtcbiAgdGhpcy5fc2VsZWN0cy5wdXNoKGV4cHIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUnVuIHRocm91Z2ggdGhlIHNlbGVjdHMgT1JpbmcgZWFjaFxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtCb29sZWFufSBwZWVrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSXRlcmF0b3IucHJvdG90eXBlLnNlbGVjdHMgPSBmdW5jdGlvbiAobm9kZSwgcGVlaykge1xuICB2YXIgZXhwcnMgPSB0aGlzLl9zZWxlY3RzO1xuICB2YXIgbGVuID0gZXhwcnMubGVuZ3RoO1xuICBpZiAoIWxlbikgcmV0dXJuIHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHByc1tpXS5jYWxsKHRoaXMsIG5vZGUsIHBlZWspKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2VsZWN0IG5vZGVzIHRoYXQgY2F1c2UgYGV4cHIobm9kZSlgXG4gKiB0byBiZSBmYWxzeVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xGdW5jdGlvbn0gZXhwclxuICogQHJldHVybiB7SXRlcmF0b3J9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuSXRlcmF0b3IucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChleHByKSB7XG4gIGV4cHIgPSB0aGlzLmNvbXBpbGUoZXhwcik7XG4gIHRoaXMuX3JlamVjdHMucHVzaChleHByKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJ1biB0aHJvdWdoIHRoZSByZWplY3QgZXhwcmVzc2lvbnMgQU5EaW5nIGVhY2hcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVla1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5yZWplY3RzID0gZnVuY3Rpb24gKG5vZGUsIHBlZWspIHtcbiAgdmFyIGV4cHJzID0gdGhpcy5fcmVqZWN0cztcbiAgdmFyIGxlbiA9IGV4cHJzLmxlbmd0aDtcbiAgaWYgKCFsZW4pIHJldHVybiB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwcnNbaV0uY2FsbCh0aGlzLCBub2RlLCBwZWVrKSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIG5vZGUgaXMgaGlnaGVyXG4gKiB0aGFuIHJvb3QuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IHJvb3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5JdGVyYXRvci5wcm90b3R5cGUuaGlnaGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gIGlmICghcm9vdCkgcmV0dXJuIGZhbHNlO1xuICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB3aGlsZSAobm9kZSAmJiBub2RlICE9IHJvb3QpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9cmV0dXJuIG5vZGUgIT0gcm9vdDtcbn07XG5cbi8qKlxuICogQ29tcGlsZSBhbiBleHByZXNzaW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb258TnVtYmVyfSBleHByXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5JdGVyYXRvci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChleHByKSB7XG4gIHN3aXRjaCAodHlwZW9mIGV4cHIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGV4cHIpKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gZXhwciA9PSBub2RlLm5vZGVUeXBlO1xuICAgICAgfTtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbignbm9kZScsICdyZXR1cm4gJyArIHByb3BzKGV4cHIsICdub2RlLicpKTtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIFBlZWsgaW4gZWl0aGVyIGRpcmVjdGlvblxuICogYG5gIG5vZGVzLiBQZWVrIGJhY2t3YXJkc1xuICogdXNpbmcgbmVnYXRpdmUgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbiAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5wZWFrID0gSXRlcmF0b3IucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoZXhwciwgbikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSBuID0gZXhwciwgZXhwciA9IHRydWU7XG4gIG4gPSB1bmRlZmluZWQgPT0gbiA/IDEgOiBuO1xuICBpZiAoIW4pIHJldHVybiB0aGlzLm5vZGU7ZWxzZSBpZiAobiA+IDApIHJldHVybiB0aGlzLm5leHQoZXhwciwgbiwgdHJ1ZSk7ZWxzZSByZXR1cm4gdGhpcy5wcmV2KGV4cHIsIE1hdGguYWJzKG4pLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgcGx1Z2luXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5JdGVyYXRvci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIGZuKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHBvc2l0aW9uKGVsLCBwb3MpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgaWYgKCFzZWxlY3Rpb24ucmFuZ2VDb3VudCkgcmV0dXJuO1xuICAgIHZhciBpbmRleGVzID0ge307XG4gICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgdmFyIGNsb25lID0gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgIGNsb25lLnNlbGVjdE5vZGVDb250ZW50cyhlbCk7XG4gICAgY2xvbmUuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICBpbmRleGVzLmVuZCA9IGNsb25lLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgIGNsb25lLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgaW5kZXhlcy5zdGFydCA9IGluZGV4ZXMuZW5kIC0gY2xvbmUudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgaW5kZXhlcy5hdFN0YXJ0ID0gY2xvbmUuc3RhcnRPZmZzZXQgPT09IDA7XG4gICAgaW5kZXhlcy5jb21tb25BbmNlc3RvckNvbnRhaW5lciA9IGNsb25lLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIGluZGV4ZXMuZW5kQ29udGFpbmVyID0gY2xvbmUuZW5kQ29udGFpbmVyO1xuICAgIGluZGV4ZXMuc3RhcnRDb250YWluZXIgPSBjbG9uZS5zdGFydENvbnRhaW5lcjtcbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuXG4gIHZhciBzZXRTZWxlY3Rpb24gPSBwb3MuZW5kICYmIHBvcy5lbmQgIT09IHBvcy5zdGFydDtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHZhciBpdCA9IGluZGV4JDEoZWwpLnNlbGVjdChOb2RlLlRFWFRfTk9ERSkucmV2aXNpdChmYWxzZSk7XG4gIHZhciBuZXh0O1xuICB2YXIgc3RhcnRpbmRleDtcbiAgdmFyIHN0YXJ0ID0gcG9zLnN0YXJ0ID4gZWwudGV4dENvbnRlbnQubGVuZ3RoID8gZWwudGV4dENvbnRlbnQubGVuZ3RoIDogcG9zLnN0YXJ0O1xuICB2YXIgZW5kID0gcG9zLmVuZCA+IGVsLnRleHRDb250ZW50Lmxlbmd0aCA/IGVsLnRleHRDb250ZW50Lmxlbmd0aCA6IHBvcy5lbmQ7XG4gIHZhciBhdFN0YXJ0ID0gcG9zLmF0U3RhcnQ7XG5cbiAgd2hpbGUgKG5leHQgPSBpdC5uZXh0KCkpIHtcbiAgICB2YXIgb2xlbiA9IGxlbmd0aDtcbiAgICBsZW5ndGggKz0gbmV4dC50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAvLyBTZXQgc3RhcnQgcG9pbnQgb2Ygc2VsZWN0aW9uXG4gICAgdmFyIGF0TGVuZ3RoID0gYXRTdGFydCA/IGxlbmd0aCA+IHN0YXJ0IDogbGVuZ3RoID49IHN0YXJ0O1xuICAgIGlmICghc3RhcnRpbmRleCAmJiBhdExlbmd0aCkge1xuICAgICAgc3RhcnRpbmRleCA9IHRydWU7XG4gICAgICByYW5nZS5zZXRTdGFydChuZXh0LCBzdGFydCAtIG9sZW4pO1xuICAgICAgaWYgKCFzZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgIG1ha2VTZWxlY3Rpb24oZWwsIHJhbmdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGVuZCBwb2ludCBvZiBzZWxlY3Rpb25cbiAgICBpZiAoc2V0U2VsZWN0aW9uICYmIGxlbmd0aCA+PSBlbmQpIHtcbiAgICAgIHJhbmdlLnNldEVuZChuZXh0LCBlbmQgLSBvbGVuKTtcbiAgICAgIG1ha2VTZWxlY3Rpb24oZWwsIHJhbmdlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlU2VsZWN0aW9uKGVsLCByYW5nZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICBlbC5mb2N1cygpO1xuICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG59XG5cbnZhciBFZGl0b3IgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhFZGl0b3IsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEVkaXRvcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRpdG9yKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwuYXBwbHkoX0NvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnVuZG9TdGFjayA9IFtdLCBfdGhpcy51bmRvT2Zmc2V0ID0gMCwgX3RoaXMudW5kb1RpbWVzdGFtcCA9IDAsIF90aGlzLnN0YXRlID0ge1xuICAgICAgaHRtbDogJydcbiAgICB9LCBfdGhpcy5vblJlZiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBfdGhpcy5yZWYgPSBub2RlO1xuICAgIH0sIF90aGlzLmdldFBsYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLl9pbm5lckhUTUwgPT09IF90aGlzLnJlZi5pbm5lckhUTUwpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl9wbGFpbjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBsYWluID0gaHRtbFRvUGxhaW4obm9ybWFsaXplSHRtbChfdGhpcy5yZWYuaW5uZXJIVE1MKSk7XG5cbiAgICAgIF90aGlzLl9wbGFpbiA9IHBsYWluO1xuICAgICAgX3RoaXMuX2lubmVySFRNTCA9IF90aGlzLnJlZi5pbm5lckhUTUw7XG5cbiAgICAgIHJldHVybiBfdGhpcy5fcGxhaW47XG4gICAgfSwgX3RoaXMucmVjb3JkQ2hhbmdlID0gZnVuY3Rpb24gKHBsYWluLCBzZWxlY3Rpb24pIHtcbiAgICAgIGlmIChwbGFpbiA9PT0gX3RoaXMudW5kb1N0YWNrW190aGlzLnVuZG9TdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy51bmRvT2Zmc2V0ID4gMCkge1xuICAgICAgICBfdGhpcy51bmRvU3RhY2sgPSBfdGhpcy51bmRvU3RhY2suc2xpY2UoMCwgLV90aGlzLnVuZG9PZmZzZXQpO1xuICAgICAgICBfdGhpcy51bmRvT2Zmc2V0ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICB2YXIgcmVjb3JkID0geyBwbGFpbjogcGxhaW4sIHNlbGVjdGlvbjogc2VsZWN0aW9uIH07XG5cbiAgICAgIC8vIE92ZXJ3cml0ZSBsYXN0IHJlY29yZCBpZiB0aHJlc2hvbGQgaXMgbm90IGNyb3NzZWRcbiAgICAgIGlmICh0aW1lc3RhbXAgLSBfdGhpcy51bmRvVGltZXN0YW1wIDwgMzAwMCkge1xuICAgICAgICBfdGhpcy51bmRvU3RhY2tbX3RoaXMudW5kb1N0YWNrLmxlbmd0aCAtIDFdID0gcmVjb3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMudW5kb1N0YWNrLnB1c2gocmVjb3JkKTtcblxuICAgICAgICBpZiAoX3RoaXMudW5kb1N0YWNrLmxlbmd0aCA+IDUwKSB7XG4gICAgICAgICAgX3RoaXMudW5kb1N0YWNrLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXMudW5kb1RpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICB9LCBfdGhpcy51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gKHBsYWluKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7IGh0bWw6IHByaXNtKHBsYWluKSB9KTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uQ2hhbmdlKHBsYWluKTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5yZXN0b3JlU3RhY2tTdGF0ZSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIHZhciBfdGhpcyR1bmRvU3RhY2sgPSBfdGhpcy51bmRvU3RhY2tbX3RoaXMudW5kb1N0YWNrLmxlbmd0aCAtIDEgLSBvZmZzZXRdLFxuICAgICAgICAgIHBsYWluID0gX3RoaXMkdW5kb1N0YWNrLnBsYWluLFxuICAgICAgICAgIHNlbGVjdGlvbiA9IF90aGlzJHVuZG9TdGFjay5zZWxlY3Rpb247XG5cblxuICAgICAgX3RoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgX3RoaXMudW5kb09mZnNldCA9IG9mZnNldDtcbiAgICAgIF90aGlzLnVwZGF0ZUNvbnRlbnQocGxhaW4pO1xuICAgIH0sIF90aGlzLnVuZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gX3RoaXMudW5kb09mZnNldCArIDE7XG4gICAgICBpZiAob2Zmc2V0ID49IF90aGlzLnVuZG9TdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5yZXN0b3JlU3RhY2tTdGF0ZShvZmZzZXQpO1xuICAgIH0sIF90aGlzLnJlZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gX3RoaXMudW5kb09mZnNldCAtIDE7XG4gICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnJlc3RvcmVTdGFja1N0YXRlKG9mZnNldCk7XG4gICAgfSwgX3RoaXMub25LZXlEb3duID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uS2V5RG93bikge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbktleURvd24oZXZ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChldnQua2V5Q29kZSA9PT0gOSAmJiAhX3RoaXMucHJvcHMuaWdub3JlVGFiS2V5KSB7XG4gICAgICAgIC8vIFRhYiBLZXlcbiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2luc2VydEhUTUwnLCBmYWxzZSwgJyYjMDA5Jyk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIGlmIChldnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgLy8gRW50ZXIgS2V5XG4gICAgICAgIHZhciBfc2VsZWN0aW9uUmFuZ2UgPSBwb3NpdGlvbihfdGhpcy5yZWYpLFxuICAgICAgICAgICAgY3Vyc29yUG9zID0gX3NlbGVjdGlvblJhbmdlLnN0YXJ0O1xuXG4gICAgICAgIHZhciBpbmRlbnRhdGlvbiA9IGdldEluZGVudChfdGhpcy5nZXRQbGFpbigpLCBjdXJzb3JQb3MpO1xuXG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRIVE1MJywgZmFsc2UsICdcXG4nICsgaW5kZW50YXRpb24pO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBVbmRvIC8gUmVkb1xuICAgICAgZXZ0LmtleUNvZGUgPT09IDkwICYmIGV2dC5tZXRhS2V5ICE9PSBldnQuY3RybEtleSAmJiAhZXZ0LmFsdEtleSkge1xuICAgICAgICBpZiAoZXZ0LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgX3RoaXMucmVkbygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLnVuZG8oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0sIF90aGlzLm9uS2V5VXAgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMub25LZXlVcCkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbktleVVwKGV2dCk7XG4gICAgICB9XG4gICAgICBpZiAoZXZ0LmtleUNvZGUgPT09IDkxIHx8IC8vIGxlZnQgY21kXG4gICAgICBldnQua2V5Q29kZSA9PT0gOTMgfHwgLy8gcmlnaHQgY21kXG4gICAgICBldnQuY3RybEtleSB8fCBldnQubWV0YUtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEVudGVyIGtleVxuICAgICAgaWYgKGV2dC5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBfdGhpcy51bmRvVGltZXN0YW1wID0gMDtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2VsZWN0aW9uID0gcG9zaXRpb24oX3RoaXMucmVmKTtcblxuICAgICAgaWYgKGV2dC5rZXlDb2RlICE9PSAzNyAmJiAvLyBsZWZ0XG4gICAgICBldnQua2V5Q29kZSAhPT0gMzggJiYgLy8gdXBcbiAgICAgIGV2dC5rZXlDb2RlICE9PSAzOSAmJiAvLyByaWdodFxuICAgICAgZXZ0LmtleUNvZGUgIT09IDQwIC8vIGRvd25cbiAgICAgICkge1xuICAgICAgICAgIHZhciBwbGFpbiA9IF90aGlzLmdldFBsYWluKCk7XG5cbiAgICAgICAgICBfdGhpcy5yZWNvcmRDaGFuZ2UocGxhaW4sIF90aGlzLnNlbGVjdGlvbik7XG4gICAgICAgICAgX3RoaXMudXBkYXRlQ29udGVudChwbGFpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnVuZG9UaW1lc3RhbXAgPSAwO1xuICAgICAgfVxuICAgIH0sIF90aGlzLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMub25DbGljaykge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkNsaWNrKGV2dCk7XG4gICAgICB9XG4gICAgICBfdGhpcy51bmRvVGltZXN0YW1wID0gMDsgLy8gUmVzZXQgdGltZXN0YW1wXG4gICAgICBfdGhpcy5zZWxlY3Rpb24gPSBwb3NpdGlvbihfdGhpcy5yZWYpO1xuICAgIH0sIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBFZGl0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgaHRtbCA9IHByaXNtKG5vcm1hbGl6ZUNvZGUodGhpcy5wcm9wcy5jb2RlKSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGh0bWw6IGh0bWwgfSk7XG4gIH07XG5cbiAgRWRpdG9yLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMucmVjb3JkQ2hhbmdlKHRoaXMuZ2V0UGxhaW4oKSk7XG4gICAgdGhpcy51bmRvVGltZXN0YW1wID0gMDsgLy8gUmVzZXQgdGltZXN0YW1wXG4gIH07XG5cbiAgRWRpdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhfcmVmKSB7XG4gICAgdmFyIGNvZGUgPSBfcmVmLmNvZGU7XG5cbiAgICBpZiAoY29kZSAhPT0gdGhpcy5wcm9wcy5jb2RlKSB7XG4gICAgICB2YXIgaHRtbCA9IHByaXNtKG5vcm1hbGl6ZUNvZGUoY29kZSkpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGh0bWw6IGh0bWwgfSk7XG4gICAgfVxuICB9O1xuXG4gIEVkaXRvci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIHBvc2l0aW9uKHRoaXMucmVmLCBzZWxlY3Rpb24pO1xuICAgIH1cbiAgfTtcblxuICBFZGl0b3IucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY29udGVudEVkaXRhYmxlID0gX3Byb3BzLmNvbnRlbnRFZGl0YWJsZSxcbiAgICAgICAgY2xhc3NOYW1lID0gX3Byb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGUgPSBfcHJvcHMuc3R5bGUsXG4gICAgICAgIHJlc3QgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnY29udGVudEVkaXRhYmxlJywgJ2NsYXNzTmFtZScsICdzdHlsZSddKTtcbiAgICB2YXIgaHRtbCA9IHRoaXMuc3RhdGUuaHRtbDtcblxuICAgIGRlbGV0ZSByZXN0LmNvZGU7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncHJlJywgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgIHJlZjogdGhpcy5vblJlZixcbiAgICAgIGNsYXNzTmFtZTogY24oJ3ByaXNtLWNvZGUnLCBjbGFzc05hbWUpLFxuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgc3BlbGxDaGVjazogJ2ZhbHNlJyxcbiAgICAgIGNvbnRlbnRFZGl0YWJsZTogY29udGVudEVkaXRhYmxlLFxuICAgICAgb25LZXlEb3duOiBjb250ZW50RWRpdGFibGUgJiYgdGhpcy5vbktleURvd24sXG4gICAgICBvbktleVVwOiBjb250ZW50RWRpdGFibGUgJiYgdGhpcy5vbktleVVwLFxuICAgICAgb25DbGljazogY29udGVudEVkaXRhYmxlICYmIHRoaXMub25DbGljayxcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogaHRtbCB9XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBFZGl0b3I7XG59KENvbXBvbmVudCk7XG5cbkVkaXRvci5kZWZhdWx0UHJvcHMgPSB7XG4gIGNvbnRlbnRFZGl0YWJsZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxudmFyIGVtcHR5RnVuY3Rpb25fMSA9IGVtcHR5RnVuY3Rpb247XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxue1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbnZhciBpbnZhcmlhbnRfMSA9IGludmFyaWFudDtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uXzE7XG5cbntcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9O1xuXG4gICAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICAgIH1cblxuICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG59XG5cbnZhciB3YXJuaW5nXzEgPSB3YXJuaW5nO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXRfMSA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG57XG4gIHZhciBpbnZhcmlhbnQkMSA9IGludmFyaWFudF8xO1xuICB2YXIgd2FybmluZyQxID0gd2FybmluZ18xO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQkMSA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0XzE7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpbnZhcmlhbnQkMSh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0JDEpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyQxKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGVycm9yKSk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGNoZWNrUHJvcFR5cGVzXzEgPSBjaGVja1Byb3BUeXBlcztcblxudmFyIGZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzID0gZnVuY3Rpb24gZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXJcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldF8xKSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgaW52YXJpYW50XzEoZmFsc2UsICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICsgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmICghbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzKSB7XG4gICAgICAgICAgICB3YXJuaW5nXzEoZmFsc2UsICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICsgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICsgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICsgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLCBwcm9wRnVsbE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25fMS50aGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXRfMSk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgd2FybmluZ18xKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJyk7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbl8xLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldF8xKTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHdhcm5pbmdfMShmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKTtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uXzEudGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldF8xKSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXRfMSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwcm9wVmFsdWUpKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwcm9wVmFsdWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzXzE7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cbnZhciBpbmRleCQ2ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAvKipcbiAgICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICpcbiAgICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gICAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICAgKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAgICovXG5cbiAge1xuICAgIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IgJiYgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcblxuICAgIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmplY3QpKSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICAgIH07XG5cbiAgICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gICAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xuICB9XG59KTtcblxudmFyIGJ1YmxlX2RlcHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gIChmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgZmFjdG9yeShleHBvcnRzKTtcbiAgfSkoY29tbW9uanNHbG9iYWwsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIF9fY29tbW9uanNfZ2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgY29tbW9uanNHbG9iYWwgIT09ICd1bmRlZmluZWQnID8gY29tbW9uanNHbG9iYWwgOiB0aGlzO1xuICAgIGZ1bmN0aW9uIF9fY29tbW9uanMoZm4sIG1vZHVsZSkge1xuICAgICAgcmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX19jb21tb25qc19nbG9iYWwpLCBtb2R1bGUuZXhwb3J0cztcbiAgICB9XG5cbiAgICB2YXIgYWNvcm4gPSBfX2NvbW1vbmpzKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMsIGdsb2JhbCkge1xuICAgICAgKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgICAgKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihleHBvcnRzKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6IHR5cGVvZiB1bmRlZmluZWQgPT09ICdmdW5jdGlvbicgJiYgdW5kZWZpbmVkLmFtZCA/IHVuZGVmaW5lZChbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOiBmYWN0b3J5KGdsb2JhbC5hY29ybiA9IGdsb2JhbC5hY29ybiB8fCB7fSk7XG4gICAgICB9KShfX2NvbW1vbmpzX2dsb2JhbCwgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIC8vIFJlc2VydmVkIHdvcmQgbGlzdHMgZm9yIHZhcmlvdXMgZGlhbGVjdHMgb2YgdGhlIGxhbmd1YWdlXG5cbiAgICAgICAgdmFyIHJlc2VydmVkV29yZHMgPSB7XG4gICAgICAgICAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gICAgICAgICAgNTogXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiLFxuICAgICAgICAgIDY6IFwiZW51bVwiLFxuICAgICAgICAgIDc6IFwiZW51bVwiLFxuICAgICAgICAgIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gICAgICAgICAgc3RyaWN0QmluZDogXCJldmFsIGFyZ3VtZW50c1wiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQW5kIHRoZSBrZXl3b3Jkc1xuXG4gICAgICAgIHZhciBlY21hNUFuZExlc3NLZXl3b3JkcyA9IFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCI7XG5cbiAgICAgICAgdmFyIGtleXdvcmRzID0ge1xuICAgICAgICAgIDU6IGVjbWE1QW5kTGVzc0tleXdvcmRzLFxuICAgICAgICAgIDY6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgY29uc3QgY2xhc3MgZXh0ZW5kcyBleHBvcnQgaW1wb3J0IHN1cGVyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4gICAgICAgIC8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuICAgICAgICAvLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuICAgICAgICAvLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4gICAgICAgIC8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuICAgICAgICAvLyBHZW5lcmF0ZWQgYnkgYGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzYC5cblxuICAgICAgICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9ICdcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5Qi1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QUVcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGREMnO1xuICAgICAgICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSAnXFx1MjAwQ1xcdTIwMERcXHhCN1xcdTAzMDAtXFx1MDM2RlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NjlcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNkYwLVxcdTA2RjlcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdDMC1cXHUwN0M5XFx1MDdFQi1cXHUwN0YzXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDhENC1cXHUwOEUxXFx1MDhFMy1cXHUwOTAzXFx1MDkzQS1cXHUwOTNDXFx1MDkzRS1cXHUwOTRGXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTgxLVxcdTA5ODNcXHUwOUJDXFx1MDlCRS1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUU2LVxcdTA5RUZcXHUwQTAxLVxcdTBBMDNcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE2Ni1cXHUwQTcxXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBQkNcXHUwQUJFLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCM0NcXHUwQjNFLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjgyXFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDM0UtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQ0JDXFx1MENCRS1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBEMDEtXFx1MEQwM1xcdTBEM0UtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEODJcXHUwRDgzXFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRUIxXFx1MEVCNC1cXHUwRUI5XFx1MEVCQlxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0VcXHUwRjNGXFx1MEY3MS1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyQi1cXHUxMDNFXFx1MTA0MC1cXHUxMDQ5XFx1MTA1Ni1cXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZEXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhEXFx1MTA4Ri1cXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTM2OS1cXHUxMzcxXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjQtXFx1MTdEM1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxOEE5XFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTRGXFx1MTlEMC1cXHUxOURBXFx1MUExNy1cXHUxQTFCXFx1MUE1NS1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjA0XFx1MUIzNC1cXHUxQjQ0XFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQjgyXFx1MUJBMS1cXHUxQkFEXFx1MUJCMC1cXHUxQkI5XFx1MUJFNi1cXHUxQkYzXFx1MUMyNC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM1MC1cXHUxQzU5XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0U4XFx1MUNFRFxcdTFDRjItXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY1XFx1MURGQi1cXHUxREZGXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2MjAtXFx1QTYyOVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyMy1cXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzVcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjFcXHVBOTAwLVxcdUE5MDlcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTNcXHVBOTgwLVxcdUE5ODNcXHVBOUIzLVxcdUE5QzBcXHVBOUQwLVxcdUE5RDlcXHVBOUU1XFx1QTlGMC1cXHVBOUY5XFx1QUEyOS1cXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE3Qi1cXHVBQTdEXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQi1cXHVBQUVGXFx1QUFGNVxcdUFBRjZcXHVBQkUzLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZGMTAtXFx1RkYxOVxcdUZGM0YnO1xuXG4gICAgICAgIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuICAgICAgICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuICAgICAgICBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIFRoZXNlIGFyZSBhIHJ1bi1sZW5ndGggYW5kIG9mZnNldCBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyA+MHhmZmZmIGNvZGUgcG9pbnRzIHRoYXQgYXJlIGEgdmFsaWQgcGFydCBvZiBpZGVudGlmaWVycy4gVGhlXG4gICAgICAgIC8vIG9mZnNldCBzdGFydHMgYXQgMHgxMDAwMCwgYW5kIGVhY2ggcGFpciBvZiBudW1iZXJzIHJlcHJlc2VudHMgYW5cbiAgICAgICAgLy8gb2Zmc2V0IHRvIHRoZSBuZXh0IHJhbmdlLCBhbmQgdGhlbiBhIHNpemUgb2YgdGhlIHJhbmdlLiBUaGV5IHdlcmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGJ5IGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzXG4gICAgICAgIHZhciBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLCAxMSwgMiwgMjUsIDIsIDE4LCAyLCAxLCAyLCAxNCwgMywgMTMsIDM1LCAxMjIsIDcwLCA1MiwgMjY4LCAyOCwgNCwgNDgsIDQ4LCAzMSwgMTcsIDI2LCA2LCAzNywgMTEsIDI5LCAzLCAzNSwgNSwgNywgMiwgNCwgNDMsIDE1NywgMTksIDM1LCA1LCAzNSwgNSwgMzksIDksIDUxLCAxNTcsIDMxMCwgMTAsIDIxLCAxMSwgNywgMTUzLCA1LCAzLCAwLCAyLCA0MywgMiwgMSwgNCwgMCwgMywgMjIsIDExLCAyMiwgMTAsIDMwLCA2NiwgMTgsIDIsIDEsIDExLCAyMSwgMTEsIDI1LCA3MSwgNTUsIDcsIDEsIDY1LCAwLCAxNiwgMywgMiwgMiwgMiwgMjYsIDQ1LCAyOCwgNCwgMjgsIDM2LCA3LCAyLCAyNywgMjgsIDUzLCAxMSwgMjEsIDExLCAxOCwgMTQsIDE3LCAxMTEsIDcyLCA1NiwgNTAsIDE0LCA1MCwgNzg1LCA1MiwgNzYsIDQ0LCAzMywgMjQsIDI3LCAzNSwgNDIsIDM0LCA0LCAwLCAxMywgNDcsIDE1LCAzLCAyMiwgMCwgMiwgMCwgMzYsIDE3LCAyLCAyNCwgODUsIDYsIDIsIDAsIDIsIDMsIDIsIDE0LCAyLCA5LCA4LCA0NiwgMzksIDcsIDMsIDEsIDMsIDIxLCAyLCA2LCAyLCAxLCAyLCA0LCA0LCAwLCAxOSwgMCwgMTMsIDQsIDE1OSwgNTIsIDE5LCAzLCA1NCwgNDcsIDIxLCAxLCAyLCAwLCAxODUsIDQ2LCA0MiwgMywgMzcsIDQ3LCAyMSwgMCwgNjAsIDQyLCA4NiwgMjUsIDM5MSwgNjMsIDMyLCAwLCA0NDksIDU2LCAyNjQsIDgsIDIsIDM2LCAxOCwgMCwgNTAsIDI5LCA4ODEsIDkyMSwgMTAzLCAxMTAsIDE4LCAxOTUsIDI3NDksIDEwNzAsIDQwNTAsIDU4MiwgODYzNCwgNTY4LCA4LCAzMCwgMTE0LCAyOSwgMTksIDQ3LCAxNywgMywgMzIsIDIwLCA2LCAxOCwgODgxLCA2OCwgMTIsIDAsIDY3LCAxMiwgNjUsIDAsIDMyLCA2MTI0LCAyMCwgNzU0LCA5NDg2LCAxLCAzMDcxLCAxMDYsIDYsIDEyLCA0LCA4LCA4LCA5LCA1OTkxLCA4NCwgMiwgNzAsIDIsIDEsIDMsIDAsIDMsIDEsIDMsIDMsIDIsIDExLCAyLCAwLCAyLCA2LCAyLCA2NCwgMiwgMywgMywgNywgMiwgNiwgMiwgMjcsIDIsIDMsIDIsIDQsIDIsIDAsIDQsIDYsIDIsIDMzOSwgMywgMjQsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDcsIDQxNDksIDE5NiwgNjAsIDY3LCAxMjEzLCAzLCAyLCAyNiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgOSwgMiwgMywgMiwgMCwgMiwgMCwgNywgMCwgNSwgMCwgMiwgMCwgMiwgMCwgMiwgMiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMSwgMiwgMCwgMywgMywgMiwgNiwgMiwgMywgMiwgMywgMiwgMCwgMiwgOSwgMiwgMTYsIDYsIDIsIDIsIDQsIDIsIDE2LCA0NDIxLCA0MjcxMCwgNDIsIDQxNDgsIDEyLCAyMjEsIDMsIDU3NjEsIDEwNTkxLCA1NDFdO1xuICAgICAgICB2YXIgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwgMCwgMjI3LCAwLCAxNTAsIDQsIDI5NCwgOSwgMTM2OCwgMiwgMiwgMSwgNiwgMywgNDEsIDIsIDUsIDAsIDE2NiwgMSwgMTMwNiwgMiwgNTQsIDE0LCAzMiwgOSwgMTYsIDMsIDQ2LCAxMCwgNTQsIDksIDcsIDIsIDM3LCAxMywgMiwgOSwgNTIsIDAsIDEzLCAyLCA0OSwgMTMsIDEwLCAyLCA0LCA5LCA4MywgMTEsIDcsIDAsIDE2MSwgMTEsIDYsIDksIDcsIDMsIDU3LCAwLCAyLCA2LCAzLCAxLCAzLCAyLCAxMCwgMCwgMTEsIDEsIDMsIDYsIDQsIDQsIDE5MywgMTcsIDEwLCA5LCA4NywgMTksIDEzLCA5LCAyMTQsIDYsIDMsIDgsIDI4LCAxLCA4MywgMTYsIDE2LCA5LCA4MiwgMTIsIDksIDksIDg0LCAxNCwgNSwgOSwgNDIzLCA5LCA4MzgsIDcsIDIsIDcsIDE3LCA5LCA1NywgMjEsIDIsIDEzLCAxOTg4MiwgOSwgMTM1LCA0LCA2MCwgNiwgMjYsIDksIDEwMTYsIDQ1LCAxNywgMywgMTk3MjMsIDEsIDUzMTksIDQsIDQsIDUsIDksIDcsIDMsIDYsIDMxLCAzLCAxNDksIDIsIDE0MTgsIDQ5LCA1MTMsIDU0LCA1LCA0OSwgOSwgMCwgMTUsIDAsIDIzLCA0LCAyLCAxNCwgMTM2MSwgNiwgMiwgMTYsIDMsIDYsIDIsIDEsIDIsIDQsIDIyMTQsIDYsIDExMCwgNiwgNiwgOSwgNzkyNDg3LCAyMzldO1xuXG4gICAgICAgIC8vIFRoaXMgaGFzIGEgY29tcGxleGl0eSBsaW5lYXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb2RlLiBUaGVcbiAgICAgICAgLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuICAgICAgICAvLyByYXJlLlxuICAgICAgICBmdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCQkMSkge1xuICAgICAgICAgIHZhciBwb3MgPSAweDEwMDAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0JCQxLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBwb3MgKz0gc2V0JCQxW2ldO1xuICAgICAgICAgICAgaWYgKHBvcyA+IGNvZGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHBvcyArPSBzZXQkJDFbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSBjb2RlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuICAgICAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlLCBhc3RyYWwpIHtcbiAgICAgICAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gICAgICAgICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgICAgICAgIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBpZiAoY29kZSA8PSAweGZmZmYpIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgICAgICBpZiAoYXN0cmFsID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbiAgICAgICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlLCBhc3RyYWwpIHtcbiAgICAgICAgICBpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gICAgICAgICAgaWYgKGNvZGUgPCA1OCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgICAgICAgICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKGNvZGUgPD0gMHhmZmZmKSByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICAgICAgICAgIGlmIChhc3RyYWwgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpIHx8IGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllckNvZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICMjIFRva2VuIHR5cGVzXG5cbiAgICAgICAgLy8gVGhlIGFzc2lnbm1lbnQgb2YgZmluZS1ncmFpbmVkLCBpbmZvcm1hdGlvbi1jYXJyeWluZyB0eXBlIG9iamVjdHNcbiAgICAgICAgLy8gYWxsb3dzIHRoZSB0b2tlbml6ZXIgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGl0IGhhcyBhYm91dCBhXG4gICAgICAgIC8vIHRva2VuIGluIGEgd2F5IHRoYXQgaXMgdmVyeSBjaGVhcCBmb3IgdGhlIHBhcnNlciB0byBsb29rIHVwLlxuXG4gICAgICAgIC8vIEFsbCB0b2tlbiB0eXBlIHZhcmlhYmxlcyBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUsIHRvIG1ha2UgdGhlbVxuICAgICAgICAvLyBlYXN5IHRvIHJlY29nbml6ZS5cblxuICAgICAgICAvLyBUaGUgYGJlZm9yZUV4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gZGlzYW1iaWd1YXRlIGJldHdlZW4gcmVndWxhclxuICAgICAgICAvLyBleHByZXNzaW9ucyBhbmQgZGl2aXNpb25zLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgY2FuXG4gICAgICAgIC8vIGJlIGZvbGxvd2VkIGJ5IGFuIGV4cHJlc3Npb24gKHRodXMsIGEgc2xhc2ggYWZ0ZXIgdGhlbSB3b3VsZCBiZSBhXG4gICAgICAgIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbikuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBgc3RhcnRzRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBjaGVjayBpZiB0aGUgdG9rZW4gZW5kcyBhXG4gICAgICAgIC8vIGB5aWVsZGAgZXhwcmVzc2lvbi4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGVpdGhlciBjYW5cbiAgICAgICAgLy8gZGlyZWN0bHkgc3RhcnQgYW4gZXhwcmVzc2lvbiAobGlrZSBhIHF1b3RhdGlvbiBtYXJrKSBvciBjYW5cbiAgICAgICAgLy8gY29udGludWUgYW4gZXhwcmVzc2lvbiAobGlrZSB0aGUgYm9keSBvZiBhIHN0cmluZykuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuICAgICAgICAvLyB0byBrbm93IHdoZW4gcGFyc2luZyBhIGxhYmVsLCBpbiBvcmRlciB0byBhbGxvdyBvciBkaXNhbGxvd1xuICAgICAgICAvLyBjb250aW51ZSBqdW1wcyB0byB0aGF0IGxhYmVsLlxuXG4gICAgICAgIHZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgICAgICAgICBpZiAoY29uZiA9PT0gdm9pZCAwKSBjb25mID0ge307XG5cbiAgICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgdGhpcy5rZXl3b3JkID0gY29uZi5rZXl3b3JkO1xuICAgICAgICAgIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICAgICAgICAgIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICAgICAgICAgIHRoaXMuaXNMb29wID0gISFjb25mLmlzTG9vcDtcbiAgICAgICAgICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICAgICAgICAgIHRoaXMucHJlZml4ID0gISFjb25mLnByZWZpeDtcbiAgICAgICAgICB0aGlzLnBvc3RmaXggPSAhIWNvbmYucG9zdGZpeDtcbiAgICAgICAgICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICAgICAgICAgIHJldHVybiBuZXcgVG9rZW5UeXBlKG5hbWUsIHsgYmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZm9yZUV4cHIgPSB7IGJlZm9yZUV4cHI6IHRydWUgfTtcbiAgICAgICAgdmFyIHN0YXJ0c0V4cHIgPSB7IHN0YXJ0c0V4cHI6IHRydWUgfTtcbiAgICAgICAgLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbiAgICAgICAgdmFyIGtleXdvcmRUeXBlcyA9IHt9O1xuXG4gICAgICAgIC8vIFN1Y2NpbmN0IGRlZmluaXRpb25zIG9mIGtleXdvcmQgdG9rZW4gdHlwZXNcbiAgICAgICAgZnVuY3Rpb24ga3cobmFtZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcblxuICAgICAgICAgIG9wdGlvbnMua2V5d29yZCA9IG5hbWU7XG4gICAgICAgICAgcmV0dXJuIGtleXdvcmRUeXBlc1tuYW1lXSA9IG5ldyBUb2tlblR5cGUobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHQgPSB7XG4gICAgICAgICAgbnVtOiBuZXcgVG9rZW5UeXBlKFwibnVtXCIsIHN0YXJ0c0V4cHIpLFxuICAgICAgICAgIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgICAgICAgICBzdHJpbmc6IG5ldyBUb2tlblR5cGUoXCJzdHJpbmdcIiwgc3RhcnRzRXhwciksXG4gICAgICAgICAgbmFtZTogbmV3IFRva2VuVHlwZShcIm5hbWVcIiwgc3RhcnRzRXhwciksXG4gICAgICAgICAgZW9mOiBuZXcgVG9rZW5UeXBlKFwiZW9mXCIpLFxuXG4gICAgICAgICAgLy8gUHVuY3R1YXRpb24gdG9rZW4gdHlwZXMuXG4gICAgICAgICAgYnJhY2tldEw6IG5ldyBUb2tlblR5cGUoXCJbXCIsIHsgYmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZSB9KSxcbiAgICAgICAgICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gICAgICAgICAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7IGJlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWUgfSksXG4gICAgICAgICAgYnJhY2VSOiBuZXcgVG9rZW5UeXBlKFwifVwiKSxcbiAgICAgICAgICBwYXJlbkw6IG5ldyBUb2tlblR5cGUoXCIoXCIsIHsgYmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZSB9KSxcbiAgICAgICAgICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICAgICAgICAgIGNvbW1hOiBuZXcgVG9rZW5UeXBlKFwiLFwiLCBiZWZvcmVFeHByKSxcbiAgICAgICAgICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCBiZWZvcmVFeHByKSxcbiAgICAgICAgICBjb2xvbjogbmV3IFRva2VuVHlwZShcIjpcIiwgYmVmb3JlRXhwciksXG4gICAgICAgICAgZG90OiBuZXcgVG9rZW5UeXBlKFwiLlwiKSxcbiAgICAgICAgICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwgYmVmb3JlRXhwciksXG4gICAgICAgICAgYXJyb3c6IG5ldyBUb2tlblR5cGUoXCI9PlwiLCBiZWZvcmVFeHByKSxcbiAgICAgICAgICB0ZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcInRlbXBsYXRlXCIpLFxuICAgICAgICAgIGVsbGlwc2lzOiBuZXcgVG9rZW5UeXBlKFwiLi4uXCIsIGJlZm9yZUV4cHIpLFxuICAgICAgICAgIGJhY2tRdW90ZTogbmV3IFRva2VuVHlwZShcImBcIiwgc3RhcnRzRXhwciksXG4gICAgICAgICAgZG9sbGFyQnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwiJHtcIiwgeyBiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlIH0pLFxuXG4gICAgICAgICAgLy8gT3BlcmF0b3JzLiBUaGVzZSBjYXJyeSBzZXZlcmFsIGtpbmRzIG9mIHByb3BlcnRpZXMgdG8gaGVscCB0aGVcbiAgICAgICAgICAvLyBwYXJzZXIgdXNlIHRoZW0gcHJvcGVybHkgKHRoZSBwcmVzZW5jZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGlzXG4gICAgICAgICAgLy8gd2hhdCBjYXRlZ29yaXplcyB0aGVtIGFzIG9wZXJhdG9ycykuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBgYmlub3BgLCB3aGVuIHByZXNlbnQsIHNwZWNpZmllcyB0aGF0IHRoaXMgb3BlcmF0b3IgaXMgYSBiaW5hcnlcbiAgICAgICAgICAvLyBvcGVyYXRvciwgYW5kIHdpbGwgcmVmZXIgdG8gaXRzIHByZWNlZGVuY2UuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBgcHJlZml4YCBhbmQgYHBvc3RmaXhgIG1hcmsgdGhlIG9wZXJhdG9yIGFzIGEgcHJlZml4IG9yIHBvc3RmaXhcbiAgICAgICAgICAvLyB1bmFyeSBvcGVyYXRvci5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGBpc0Fzc2lnbmAgbWFya3MgYWxsIG9mIGA9YCwgYCs9YCwgYC09YCBldGNldGVyYSwgd2hpY2ggYWN0IGFzXG4gICAgICAgICAgLy8gYmluYXJ5IG9wZXJhdG9ycyB3aXRoIGEgdmVyeSBsb3cgcHJlY2VkZW5jZSwgdGhhdCBzaG91bGQgcmVzdWx0XG4gICAgICAgICAgLy8gaW4gQXNzaWdubWVudEV4cHJlc3Npb24gbm9kZXMuXG5cbiAgICAgICAgICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwgeyBiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZSB9KSxcbiAgICAgICAgICBhc3NpZ246IG5ldyBUb2tlblR5cGUoXCJfPVwiLCB7IGJlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlIH0pLFxuICAgICAgICAgIGluY0RlYzogbmV3IFRva2VuVHlwZShcIisrLy0tXCIsIHsgcHJlZml4OiB0cnVlLCBwb3N0Zml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlIH0pLFxuICAgICAgICAgIHByZWZpeDogbmV3IFRva2VuVHlwZShcInByZWZpeFwiLCB7IGJlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZSB9KSxcbiAgICAgICAgICBsb2dpY2FsT1I6IGJpbm9wKFwifHxcIiwgMSksXG4gICAgICAgICAgbG9naWNhbEFORDogYmlub3AoXCImJlwiLCAyKSxcbiAgICAgICAgICBiaXR3aXNlT1I6IGJpbm9wKFwifFwiLCAzKSxcbiAgICAgICAgICBiaXR3aXNlWE9SOiBiaW5vcChcIl5cIiwgNCksXG4gICAgICAgICAgYml0d2lzZUFORDogYmlub3AoXCImXCIsIDUpLFxuICAgICAgICAgIGVxdWFsaXR5OiBiaW5vcChcIj09LyE9XCIsIDYpLFxuICAgICAgICAgIHJlbGF0aW9uYWw6IGJpbm9wKFwiPC8+XCIsIDcpLFxuICAgICAgICAgIGJpdFNoaWZ0OiBiaW5vcChcIjw8Lz4+XCIsIDgpLFxuICAgICAgICAgIHBsdXNNaW46IG5ldyBUb2tlblR5cGUoXCIrLy1cIiwgeyBiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlIH0pLFxuICAgICAgICAgIG1vZHVsbzogYmlub3AoXCIlXCIsIDEwKSxcbiAgICAgICAgICBzdGFyOiBiaW5vcChcIipcIiwgMTApLFxuICAgICAgICAgIHNsYXNoOiBiaW5vcChcIi9cIiwgMTApLFxuICAgICAgICAgIHN0YXJzdGFyOiBuZXcgVG9rZW5UeXBlKFwiKipcIiwgeyBiZWZvcmVFeHByOiB0cnVlIH0pLFxuXG4gICAgICAgICAgLy8gS2V5d29yZCB0b2tlbiB0eXBlcy5cbiAgICAgICAgICBfYnJlYWs6IGt3KFwiYnJlYWtcIiksXG4gICAgICAgICAgX2Nhc2U6IGt3KFwiY2FzZVwiLCBiZWZvcmVFeHByKSxcbiAgICAgICAgICBfY2F0Y2g6IGt3KFwiY2F0Y2hcIiksXG4gICAgICAgICAgX2NvbnRpbnVlOiBrdyhcImNvbnRpbnVlXCIpLFxuICAgICAgICAgIF9kZWJ1Z2dlcjoga3coXCJkZWJ1Z2dlclwiKSxcbiAgICAgICAgICBfZGVmYXVsdDoga3coXCJkZWZhdWx0XCIsIGJlZm9yZUV4cHIpLFxuICAgICAgICAgIF9kbzoga3coXCJkb1wiLCB7IGlzTG9vcDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZSB9KSxcbiAgICAgICAgICBfZWxzZToga3coXCJlbHNlXCIsIGJlZm9yZUV4cHIpLFxuICAgICAgICAgIF9maW5hbGx5OiBrdyhcImZpbmFsbHlcIiksXG4gICAgICAgICAgX2Zvcjoga3coXCJmb3JcIiwgeyBpc0xvb3A6IHRydWUgfSksXG4gICAgICAgICAgX2Z1bmN0aW9uOiBrdyhcImZ1bmN0aW9uXCIsIHN0YXJ0c0V4cHIpLFxuICAgICAgICAgIF9pZjoga3coXCJpZlwiKSxcbiAgICAgICAgICBfcmV0dXJuOiBrdyhcInJldHVyblwiLCBiZWZvcmVFeHByKSxcbiAgICAgICAgICBfc3dpdGNoOiBrdyhcInN3aXRjaFwiKSxcbiAgICAgICAgICBfdGhyb3c6IGt3KFwidGhyb3dcIiwgYmVmb3JlRXhwciksXG4gICAgICAgICAgX3RyeToga3coXCJ0cnlcIiksXG4gICAgICAgICAgX3Zhcjoga3coXCJ2YXJcIiksXG4gICAgICAgICAgX2NvbnN0OiBrdyhcImNvbnN0XCIpLFxuICAgICAgICAgIF93aGlsZToga3coXCJ3aGlsZVwiLCB7IGlzTG9vcDogdHJ1ZSB9KSxcbiAgICAgICAgICBfd2l0aDoga3coXCJ3aXRoXCIpLFxuICAgICAgICAgIF9uZXc6IGt3KFwibmV3XCIsIHsgYmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZSB9KSxcbiAgICAgICAgICBfdGhpczoga3coXCJ0aGlzXCIsIHN0YXJ0c0V4cHIpLFxuICAgICAgICAgIF9zdXBlcjoga3coXCJzdXBlclwiLCBzdGFydHNFeHByKSxcbiAgICAgICAgICBfY2xhc3M6IGt3KFwiY2xhc3NcIiksXG4gICAgICAgICAgX2V4dGVuZHM6IGt3KFwiZXh0ZW5kc1wiLCBiZWZvcmVFeHByKSxcbiAgICAgICAgICBfZXhwb3J0OiBrdyhcImV4cG9ydFwiKSxcbiAgICAgICAgICBfaW1wb3J0OiBrdyhcImltcG9ydFwiKSxcbiAgICAgICAgICBfbnVsbDoga3coXCJudWxsXCIsIHN0YXJ0c0V4cHIpLFxuICAgICAgICAgIF90cnVlOiBrdyhcInRydWVcIiwgc3RhcnRzRXhwciksXG4gICAgICAgICAgX2ZhbHNlOiBrdyhcImZhbHNlXCIsIHN0YXJ0c0V4cHIpLFxuICAgICAgICAgIF9pbjoga3coXCJpblwiLCB7IGJlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3IH0pLFxuICAgICAgICAgIF9pbnN0YW5jZW9mOiBrdyhcImluc3RhbmNlb2ZcIiwgeyBiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogNyB9KSxcbiAgICAgICAgICBfdHlwZW9mOiBrdyhcInR5cGVvZlwiLCB7IGJlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZSB9KSxcbiAgICAgICAgICBfdm9pZDoga3coXCJ2b2lkXCIsIHsgYmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlIH0pLFxuICAgICAgICAgIF9kZWxldGU6IGt3KFwiZGVsZXRlXCIsIHsgYmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlIH0pXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuICAgICAgICAvLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxuICAgICAgICB2YXIgbGluZUJyZWFrID0gL1xcclxcbj98XFxufFxcdTIwMjh8XFx1MjAyOS87XG4gICAgICAgIHZhciBsaW5lQnJlYWtHID0gbmV3IFJlZ0V4cChsaW5lQnJlYWsuc291cmNlLCBcImdcIik7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgICAgICAgICByZXR1cm4gY29kZSA9PT0gMTAgfHwgY29kZSA9PT0gMTMgfHwgY29kZSA9PT0gMHgyMDI4IHx8IGNvZGUgPT0gMHgyMDI5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG5cbiAgICAgICAgdmFyIHNraXBXaGl0ZVNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKnxcXC9cXCpbXl0qP1xcKlxcLykqL2c7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuXG5cbiAgICAgICAgZnVuY3Rpb24gaGFzKG9iaiwgcHJvcE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcE5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlc2UgYXJlIHVzZWQgd2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIG9uLCBmb3IgdGhlXG4gICAgICAgIC8vIGBzdGFydExvY2AgYW5kIGBlbmRMb2NgIHByb3BlcnRpZXMuXG5cbiAgICAgICAgdmFyIFBvc2l0aW9uID0gZnVuY3Rpb24gUG9zaXRpb24obGluZSwgY29sKSB7XG4gICAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbDtcbiAgICAgICAgfTtcblxuICAgICAgICBQb3NpdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KG4pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgU291cmNlTG9jYXRpb24gPSBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihwLCBzdGFydCwgZW5kKSB7XG4gICAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICAgIGlmIChwLnNvdXJjZUZpbGUgIT09IG51bGwpIHRoaXMuc291cmNlID0gcC5zb3VyY2VGaWxlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRoZSBgZ2V0TGluZUluZm9gIGZ1bmN0aW9uIGlzIG1vc3RseSB1c2VmdWwgd2hlbiB0aGVcbiAgICAgICAgLy8gYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9mZiAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpIGFuZCB5b3VcbiAgICAgICAgLy8gd2FudCB0byBmaW5kIHRoZSBsaW5lL2NvbHVtbiBwb3NpdGlvbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXJcbiAgICAgICAgLy8gb2Zmc2V0LiBgaW5wdXRgIHNob3VsZCBiZSB0aGUgY29kZSBzdHJpbmcgdGhhdCB0aGUgb2Zmc2V0IHJlZmVyc1xuICAgICAgICAvLyBpbnRvLlxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmVJbmZvKGlucHV0LCBvZmZzZXQpIHtcbiAgICAgICAgICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgICAgICAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IGN1cjtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyhpbnB1dCk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICBjdXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obGluZSwgb2Zmc2V0IC0gY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBIHNlY29uZCBvcHRpb25hbCBhcmd1bWVudCBjYW4gYmUgZ2l2ZW4gdG8gZnVydGhlciBjb25maWd1cmVcbiAgICAgICAgLy8gdGhlIHBhcnNlciBwcm9jZXNzLiBUaGVzZSBvcHRpb25zIGFyZSByZWNvZ25pemVkOlxuXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAvLyBgZWNtYVZlcnNpb25gIGluZGljYXRlcyB0aGUgRUNNQVNjcmlwdCB2ZXJzaW9uIHRvIHBhcnNlLiBNdXN0XG4gICAgICAgICAgLy8gYmUgZWl0aGVyIDMsIG9yIDUsIG9yIDYuIFRoaXMgaW5mbHVlbmNlcyBzdXBwb3J0IGZvciBzdHJpY3RcbiAgICAgICAgICAvLyBtb2RlLCB0aGUgc2V0IG9mIHJlc2VydmVkIHdvcmRzLCBzdXBwb3J0IGZvciBnZXR0ZXJzIGFuZFxuICAgICAgICAgIC8vIHNldHRlcnMgYW5kIG90aGVyIGZlYXR1cmVzLiBUaGUgZGVmYXVsdCBpcyA2LlxuICAgICAgICAgIGVjbWFWZXJzaW9uOiA2LFxuICAgICAgICAgIC8vIFNvdXJjZSB0eXBlIChcInNjcmlwdFwiIG9yIFwibW9kdWxlXCIpIGZvciBkaWZmZXJlbnQgc2VtYW50aWNzXG4gICAgICAgICAgc291cmNlVHlwZTogXCJzY3JpcHRcIixcbiAgICAgICAgICAvLyBgb25JbnNlcnRlZFNlbWljb2xvbmAgY2FuIGJlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZFxuICAgICAgICAgIC8vIHdoZW4gYSBzZW1pY29sb24gaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZC4gSXQgd2lsbCBiZSBwYXNzZWRcbiAgICAgICAgICAvLyB0aCBwb3NpdGlvbiBvZiB0aGUgY29tbWEgYXMgYW4gb2Zmc2V0LCBhbmQgaWYgYGxvY2F0aW9uc2AgaXNcbiAgICAgICAgICAvLyBlbmFibGVkLCBpdCBpcyBnaXZlbiB0aGUgbG9jYXRpb24gYXMgYSBge2xpbmUsIGNvbHVtbn1gIG9iamVjdFxuICAgICAgICAgIC8vIGFzIHNlY29uZCBhcmd1bWVudC5cbiAgICAgICAgICBvbkluc2VydGVkU2VtaWNvbG9uOiBudWxsLFxuICAgICAgICAgIC8vIGBvblRyYWlsaW5nQ29tbWFgIGlzIHNpbWlsYXIgdG8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gLCBidXQgZm9yXG4gICAgICAgICAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICAgICAgICAgIG9uVHJhaWxpbmdDb21tYTogbnVsbCxcbiAgICAgICAgICAvLyBCeSBkZWZhdWx0LCByZXNlcnZlZCB3b3JkcyBhcmUgb25seSBlbmZvcmNlZCBpZiBlY21hVmVyc2lvbiA+PSA1LlxuICAgICAgICAgIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gICAgICAgICAgLy8gYW4gb2ZmLiBXaGVuIHRoaXMgb3B0aW9uIGhhcyB0aGUgdmFsdWUgXCJuZXZlclwiLCByZXNlcnZlZCB3b3Jkc1xuICAgICAgICAgIC8vIGFuZCBrZXl3b3JkcyBjYW4gYWxzbyBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgICAgICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAgICAgICAgIC8vIFdoZW4gZW5hYmxlZCwgYSByZXR1cm4gYXQgdGhlIHRvcCBsZXZlbCBpcyBub3QgY29uc2lkZXJlZCBhblxuICAgICAgICAgIC8vIGVycm9yLlxuICAgICAgICAgIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAvLyBXaGVuIGVuYWJsZWQsIGltcG9ydC9leHBvcnQgc3RhdGVtZW50cyBhcmUgbm90IGNvbnN0cmFpbmVkIHRvXG4gICAgICAgICAgLy8gYXBwZWFyaW5nIGF0IHRoZSB0b3Agb2YgdGhlIHByb2dyYW0uXG4gICAgICAgICAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgICAgICAgICAvLyBXaGVuIGVuYWJsZWQsIGhhc2hiYW5nIGRpcmVjdGl2ZSBpbiB0aGUgYmVnaW5uaW5nIG9mIGZpbGVcbiAgICAgICAgICAvLyBpcyBhbGxvd2VkIGFuZCB0cmVhdGVkIGFzIGEgbGluZSBjb21tZW50LlxuICAgICAgICAgIGFsbG93SGFzaEJhbmc6IGZhbHNlLFxuICAgICAgICAgIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIGBsb2NgIHByb3BlcnRpZXMgaG9sZGluZyBvYmplY3RzIHdpdGhcbiAgICAgICAgICAvLyBgc3RhcnRgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzIGluIGB7bGluZSwgY29sdW1ufWAgZm9ybSAod2l0aFxuICAgICAgICAgIC8vIGxpbmUgYmVpbmcgMS1iYXNlZCBhbmQgY29sdW1uIDAtYmFzZWQpIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlXG4gICAgICAgICAgLy8gbm9kZXMuXG4gICAgICAgICAgbG9jYXRpb25zOiBmYWxzZSxcbiAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uVG9rZW5gIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAgICAgICAgIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIG9iamVjdCBpbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGZvcm1hdCBhcyB0b2tlbnMgcmV0dXJuZWQgZnJvbSBgdG9rZW5pemVyKCkuZ2V0VG9rZW4oKWAuIE5vdGVcbiAgICAgICAgICAvLyB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGUgcGFyc2VyIGZyb20gdGhlXG4gICAgICAgICAgLy8gY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gICAgICAgICAgb25Ub2tlbjogbnVsbCxcbiAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uQ29tbWVudGAgb3B0aW9uLCB3aGljaCB3aWxsXG4gICAgICAgICAgLy8gY2F1c2UgQWNvcm4gdG8gY2FsbCB0aGF0IGZ1bmN0aW9uIHdpdGggYChibG9jaywgdGV4dCwgc3RhcnQsXG4gICAgICAgICAgLy8gZW5kKWAgcGFyYW1ldGVycyB3aGVuZXZlciBhIGNvbW1lbnQgaXMgc2tpcHBlZC4gYGJsb2NrYCBpcyBhXG4gICAgICAgICAgLy8gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIGJsb2NrIChgLyogKi9gKSBjb21tZW50LFxuICAgICAgICAgIC8vIGB0ZXh0YCBpcyB0aGUgY29udGVudCBvZiB0aGUgY29tbWVudCwgYW5kIGBzdGFydGAgYW5kIGBlbmRgIGFyZVxuICAgICAgICAgIC8vIGNoYXJhY3RlciBvZmZzZXRzIHRoYXQgZGVub3RlIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBjb21tZW50LlxuICAgICAgICAgIC8vIFdoZW4gdGhlIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvbiwgdHdvIG1vcmUgcGFyYW1ldGVycyBhcmVcbiAgICAgICAgICAvLyBwYXNzZWQsIHRoZSBmdWxsIGB7bGluZSwgY29sdW1ufWAgbG9jYXRpb25zIG9mIHRoZSBzdGFydCBhbmRcbiAgICAgICAgICAvLyBlbmQgb2YgdGhlIGNvbW1lbnRzLiBOb3RlIHRoYXQgeW91IGFyZSBub3QgYWxsb3dlZCB0byBjYWxsIHRoZVxuICAgICAgICAgIC8vIHBhcnNlciBmcm9tIHRoZSBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgICAgICBvbkNvbW1lbnQ6IG51bGwsXG4gICAgICAgICAgLy8gTm9kZXMgaGF2ZSB0aGVpciBzdGFydCBhbmQgZW5kIGNoYXJhY3RlcnMgb2Zmc2V0cyByZWNvcmRlZCBpblxuICAgICAgICAgIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgKGRpcmVjdGx5IG9uIHRoZSBub2RlLCByYXRoZXIgdGhhblxuICAgICAgICAgIC8vIHRoZSBgbG9jYCBvYmplY3QsIHdoaWNoIGhvbGRzIGxpbmUvY29sdW1uIGRhdGEuIFRvIGFsc28gYWRkIGFcbiAgICAgICAgICAvLyBbc2VtaS1zdGFuZGFyZGl6ZWRdW3JhbmdlXSBgcmFuZ2VgIHByb3BlcnR5IGhvbGRpbmcgYSBgW3N0YXJ0LFxuICAgICAgICAgIC8vIGVuZF1gIGFycmF5IHdpdGggdGhlIHNhbWUgbnVtYmVycywgc2V0IHRoZSBgcmFuZ2VzYCBvcHRpb24gdG9cbiAgICAgICAgICAvLyBgdHJ1ZWAuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBbcmFuZ2VdOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NDU2NzhcbiAgICAgICAgICByYW5nZXM6IGZhbHNlLFxuICAgICAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRvIHBhcnNlIG11bHRpcGxlIGZpbGVzIGludG8gYSBzaW5nbGUgQVNUIGJ5XG4gICAgICAgICAgLy8gcGFzc2luZyB0aGUgdHJlZSBwcm9kdWNlZCBieSBwYXJzaW5nIHRoZSBmaXJzdCBmaWxlIGFzXG4gICAgICAgICAgLy8gYHByb2dyYW1gIG9wdGlvbiBpbiBzdWJzZXF1ZW50IHBhcnNlcy4gVGhpcyB3aWxsIGFkZCB0aGVcbiAgICAgICAgICAvLyB0b3BsZXZlbCBmb3JtcyBvZiB0aGUgcGFyc2VkIGZpbGUgdG8gdGhlIGBQcm9ncmFtYCAodG9wKSBub2RlXG4gICAgICAgICAgLy8gb2YgYW4gZXhpc3RpbmcgcGFyc2UgdHJlZS5cbiAgICAgICAgICBwcm9ncmFtOiBudWxsLFxuICAgICAgICAgIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIHlvdSBjYW4gcGFzcyB0aGlzIHRvIHJlY29yZCB0aGUgc291cmNlXG4gICAgICAgICAgLy8gZmlsZSBpbiBldmVyeSBub2RlJ3MgYGxvY2Agb2JqZWN0LlxuICAgICAgICAgIHNvdXJjZUZpbGU6IG51bGwsXG4gICAgICAgICAgLy8gVGhpcyB2YWx1ZSwgaWYgZ2l2ZW4sIGlzIHN0b3JlZCBpbiBldmVyeSBub2RlLCB3aGV0aGVyXG4gICAgICAgICAgLy8gYGxvY2F0aW9uc2AgaXMgb24gb3Igb2ZmLlxuICAgICAgICAgIGRpcmVjdFNvdXJjZUZpbGU6IG51bGwsXG4gICAgICAgICAgLy8gV2hlbiBlbmFibGVkLCBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25zIGFyZSByZXByZXNlbnRlZCBieVxuICAgICAgICAgIC8vIChub24tc3RhbmRhcmQpIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIG5vZGVzXG4gICAgICAgICAgcHJlc2VydmVQYXJlbnM6IGZhbHNlLFxuICAgICAgICAgIHBsdWdpbnM6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJwcmV0IGFuZCBkZWZhdWx0IGFuIG9wdGlvbnMgb2JqZWN0XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRzKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBvcHQgaW4gZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbb3B0XSA9IG9wdHMgJiYgaGFzKG9wdHMsIG9wdCkgPyBvcHRzW29wdF0gOiBkZWZhdWx0T3B0aW9uc1tvcHRdO1xuICAgICAgICAgIH1pZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09IG51bGwpIG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9IG9wdGlvbnMuZWNtYVZlcnNpb24gPCA1O1xuXG4gICAgICAgICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgICAgICAgICAgdmFyIHRva2VucyA9IG9wdGlvbnMub25Ub2tlbjtcbiAgICAgICAgICAgIG9wdGlvbnMub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKSBvcHRpb25zLm9uQ29tbWVudCA9IHB1c2hDb21tZW50KG9wdGlvbnMsIG9wdGlvbnMub25Db21tZW50KTtcblxuICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHVzaENvbW1lbnQob3B0aW9ucywgYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogYmxvY2sgPyAnQmxvY2snIDogJ0xpbmUnLFxuICAgICAgICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykgY29tbWVudC5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24odGhpcywgc3RhcnRMb2MsIGVuZExvYyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yYW5nZXMpIGNvbW1lbnQucmFuZ2UgPSBbc3RhcnQsIGVuZF07XG4gICAgICAgICAgICBhcnJheS5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWdpc3RlcmVkIHBsdWdpbnNcbiAgICAgICAgdmFyIHBsdWdpbnMgPSB7fTtcblxuICAgICAgICBmdW5jdGlvbiBrZXl3b3JkUmVnZXhwKHdvcmRzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKFwiICsgd29yZHMucmVwbGFjZSgvIC9nLCBcInxcIikgKyBcIikkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIFBhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zLCBpbnB1dCwgc3RhcnRQb3MpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGU7XG4gICAgICAgICAgdGhpcy5rZXl3b3JkcyA9IGtleXdvcmRSZWdleHAoa2V5d29yZHNbb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gNiA6IDVdKTtcbiAgICAgICAgICB2YXIgcmVzZXJ2ZWQgPSBvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPyBcIlwiIDogcmVzZXJ2ZWRXb3Jkc1tvcHRpb25zLmVjbWFWZXJzaW9uXSArIChvcHRpb25zLnNvdXJjZVR5cGUgPT0gXCJtb2R1bGVcIiA/IFwiIGF3YWl0XCIgOiBcIlwiKTtcbiAgICAgICAgICB0aGlzLnJlc2VydmVkV29yZHMgPSBrZXl3b3JkUmVnZXhwKHJlc2VydmVkKTtcbiAgICAgICAgICB2YXIgcmVzZXJ2ZWRTdHJpY3QgPSAocmVzZXJ2ZWQgPyByZXNlcnZlZCArIFwiIFwiIDogXCJcIikgKyByZXNlcnZlZFdvcmRzLnN0cmljdDtcbiAgICAgICAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgPSBrZXl3b3JkUmVnZXhwKHJlc2VydmVkU3RyaWN0KTtcbiAgICAgICAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0ga2V5d29yZFJlZ2V4cChyZXNlcnZlZFN0cmljdCArIFwiIFwiICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbiAgICAgICAgICB0aGlzLmlucHV0ID0gU3RyaW5nKGlucHV0KTtcblxuICAgICAgICAgIC8vIFVzZWQgdG8gc2lnbmFsIHRvIGNhbGxlcnMgb2YgYHJlYWRXb3JkMWAgd2hldGhlciB0aGUgd29yZFxuICAgICAgICAgIC8vIGNvbnRhaW5lZCBhbnkgZXNjYXBlIHNlcXVlbmNlcy4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB3b3JkcyB3aXRoXG4gICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlcyBtdXN0IG5vdCBiZSBpbnRlcnByZXRlZCBhcyBrZXl3b3Jkcy5cbiAgICAgICAgICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBMb2FkIHBsdWdpbnNcbiAgICAgICAgICB0aGlzLmxvYWRQbHVnaW5zKG9wdGlvbnMucGx1Z2lucyk7XG5cbiAgICAgICAgICAvLyBTZXQgdXAgdG9rZW4gc3RhdGVcblxuICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSB0b2tlbml6ZXIgaW4gdGhlIGlucHV0LlxuICAgICAgICAgIGlmIChzdGFydFBvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydFBvcztcbiAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gTWF0aC5tYXgoMCwgdGhpcy5pbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCBzdGFydFBvcykpO1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pbnB1dC5zbGljZSgwLCB0aGlzLmxpbmVTdGFydCkuc3BsaXQobGluZUJyZWFrKS5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRva2VuOlxuICAgICAgICAgIC8vIEl0cyB0eXBlXG4gICAgICAgICAgdGhpcy50eXBlID0gdHQuZW9mO1xuICAgICAgICAgIC8vIEZvciB0b2tlbnMgdGhhdCBpbmNsdWRlIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGVpciB0eXBlLCB0aGUgdmFsdWVcbiAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAvLyBJdHMgc3RhcnQgYW5kIGVuZCBvZmZzZXRcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgICAgICAgICAvLyBBbmQsIGlmIGxvY2F0aW9ucyBhcmUgdXNlZCwgdGhlIHtsaW5lLCBjb2x1bW59IG9iamVjdFxuICAgICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2Ugb2Zmc2V0c1xuICAgICAgICAgIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcblxuICAgICAgICAgIC8vIFBvc2l0aW9uIGluZm9ybWF0aW9uIGZvciB0aGUgcHJldmlvdXMgdG9rZW5cbiAgICAgICAgICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gICAgICAgICAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLnBvcztcblxuICAgICAgICAgIC8vIFRoZSBjb250ZXh0IHN0YWNrIGlzIHVzZWQgdG8gc3VwZXJmaWNpYWxseSB0cmFjayBzeW50YWN0aWNcbiAgICAgICAgICAvLyBjb250ZXh0IHRvIHByZWRpY3Qgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGluIGFcbiAgICAgICAgICAvLyBnaXZlbiBwb3NpdGlvbi5cbiAgICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmluaXRpYWxDb250ZXh0KCk7XG4gICAgICAgICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBGaWd1cmUgb3V0IGlmIGl0J3MgYSBtb2R1bGUgY29kZS5cbiAgICAgICAgICB0aGlzLnN0cmljdCA9IHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG5cbiAgICAgICAgICAvLyBVc2VkIHRvIHNpZ25pZnkgdGhlIHN0YXJ0IG9mIGEgcG90ZW50aWFsIGFycm93IGZ1bmN0aW9uXG4gICAgICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gLTE7XG5cbiAgICAgICAgICAvLyBGbGFncyB0byB0cmFjayB3aGV0aGVyIHdlIGFyZSBpbiBhIGZ1bmN0aW9uLCBhIGdlbmVyYXRvci5cbiAgICAgICAgICB0aGlzLmluRnVuY3Rpb24gPSB0aGlzLmluR2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgLy8gTGFiZWxzIGluIHNjb3BlLlxuICAgICAgICAgIHRoaXMubGFiZWxzID0gW107XG5cbiAgICAgICAgICAvLyBJZiBlbmFibGVkLCBza2lwIGxlYWRpbmcgaGFzaGJhbmcgbGluZS5cbiAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09ICcjIScpIHRoaXMuc2tpcExpbmVDb21tZW50KDIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERFUFJFQ0FURUQgS2VwdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdW50aWwgMy4wIGluIGNhc2UgYSBwbHVnaW4gdXNlcyB0aGVtXG4gICAgICAgIFBhcnNlci5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gaXNLZXl3b3JkKHdvcmQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5rZXl3b3Jkcy50ZXN0KHdvcmQpO1xuICAgICAgICB9O1xuICAgICAgICBQYXJzZXIucHJvdG90eXBlLmlzUmVzZXJ2ZWRXb3JkID0gZnVuY3Rpb24gaXNSZXNlcnZlZFdvcmQod29yZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlc2VydmVkV29yZHMudGVzdCh3b3JkKTtcbiAgICAgICAgfTtcblxuICAgICAgICBQYXJzZXIucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChuYW1lLCBmKSB7XG4gICAgICAgICAgdGhpc1tuYW1lXSA9IGYodGhpc1tuYW1lXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5sb2FkUGx1Z2lucyA9IGZ1bmN0aW9uIGxvYWRQbHVnaW5zKHBsdWdpbkNvbmZpZ3MpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gcGx1Z2luQ29uZmlncykge1xuICAgICAgICAgICAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbbmFtZV07XG4gICAgICAgICAgICBpZiAoIXBsdWdpbikgdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luICdcIiArIG5hbWUgKyBcIicgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgcGx1Z2luKHRoaXMkMSwgcGx1Z2luQ29uZmlnc1tuYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRvcExldmVsKG5vZGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgICAgICAgLy8gIyMgUGFyc2VyIHV0aWxpdGllc1xuXG4gICAgICAgIC8vIFRlc3Qgd2hldGhlciBhIHN0YXRlbWVudCBub2RlIGlzIHRoZSBzdHJpbmcgbGl0ZXJhbCBgXCJ1c2Ugc3RyaWN0XCJgLlxuXG4gICAgICAgIHBwLmlzVXNlU3RyaWN0ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgc3RtdC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJiBzdG10LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgc3RtdC5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSkgPT09IFwidXNlIHN0cmljdFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFByZWRpY2F0ZSB0aGF0IHRlc3RzIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgb2YgdGhlIGdpdmVuXG4gICAgICAgIC8vIHR5cGUsIGFuZCBpZiB5ZXMsIGNvbnN1bWVzIGl0IGFzIGEgc2lkZSBlZmZlY3QuXG5cbiAgICAgICAgcHAuZWF0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRlc3RzIHdoZXRoZXIgcGFyc2VkIHRva2VuIGlzIGEgY29udGV4dHVhbCBrZXl3b3JkLlxuXG4gICAgICAgIHBwLmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHQubmFtZSAmJiB0aGlzLnZhbHVlID09PSBuYW1lO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENvbnN1bWVzIGNvbnRleHR1YWwga2V5d29yZCBpZiBwb3NzaWJsZS5cblxuICAgICAgICBwcC5lYXRDb250ZXh0dWFsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiB0aGlzLmVhdCh0dC5uYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBc3NlcnRzIHRoYXQgZm9sbG93aW5nIHRva2VuIGlzIGdpdmVuIGNvbnRleHR1YWwga2V5d29yZC5cblxuICAgICAgICBwcC5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZWF0Q29udGV4dHVhbChuYW1lKSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVGVzdCB3aGV0aGVyIGEgc2VtaWNvbG9uIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblxuICAgICAgICBwcC5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHQuZW9mIHx8IHRoaXMudHlwZSA9PT0gdHQuYnJhY2VSIHx8IGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAuaW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24pIHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDb25zdW1lIGEgc2VtaWNvbG9uLCBvciwgZmFpbGluZyB0aGF0LCBzZWUgaWYgd2UgYXJlIGFsbG93ZWQgdG9cbiAgICAgICAgLy8gcHJldGVuZCB0aGF0IHRoZXJlIGlzIGEgc2VtaWNvbG9uIGF0IHRoaXMgcG9zaXRpb24uXG5cbiAgICAgICAgcHAuc2VtaWNvbG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghdGhpcy5lYXQodHQuc2VtaSkgJiYgIXRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwLmFmdGVyVHJhaWxpbmdDb21tYSA9IGZ1bmN0aW9uICh0b2tUeXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PSB0b2tUeXBlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSkgdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRXhwZWN0IGEgdG9rZW4gb2YgYSBnaXZlbiB0eXBlLiBJZiBmb3VuZCwgY29uc3VtZSBpdCwgb3RoZXJ3aXNlLFxuICAgICAgICAvLyByYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG4gICAgICAgIHBwLmV4cGVjdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgdGhpcy5lYXQodHlwZSkgfHwgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxuICAgICAgICBwcC51bmV4cGVjdGVkID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgIHRoaXMucmFpc2UocG9zICE9IG51bGwgPyBwb3MgOiB0aGlzLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIERlc3RydWN0dXJpbmdFcnJvcnMgPSBmdW5jdGlvbiBEZXN0cnVjdHVyaW5nRXJyb3JzKCkge1xuICAgICAgICAgIHRoaXMuc2hvcnRoYW5kQXNzaWduID0gMDtcbiAgICAgICAgICB0aGlzLnRyYWlsaW5nQ29tbWEgPSAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwLmNoZWNrUGF0dGVybkVycm9ycyA9IGZ1bmN0aW9uIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhbmRUaHJvdykge1xuICAgICAgICAgIHZhciB0cmFpbGluZyA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hO1xuICAgICAgICAgIGlmICghYW5kVGhyb3cpIHJldHVybiAhIXRyYWlsaW5nO1xuICAgICAgICAgIGlmICh0cmFpbGluZykgdGhpcy5yYWlzZSh0cmFpbGluZywgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAuY2hlY2tFeHByZXNzaW9uRXJyb3JzID0gZnVuY3Rpb24gKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFuZFRocm93KSB7XG4gICAgICAgICAgdmFyIHBvcyA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ247XG4gICAgICAgICAgaWYgKCFhbmRUaHJvdykgcmV0dXJuICEhcG9zO1xuICAgICAgICAgIGlmIChwb3MpIHRoaXMucmFpc2UocG9zLCBcIlNob3J0aGFuZCBwcm9wZXJ0eSBhc3NpZ25tZW50cyBhcmUgdmFsaWQgb25seSBpbiBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcCQxID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAgICAgICAvLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuICAgICAgICAvLyBQYXJzZSBhIHByb2dyYW0uIEluaXRpYWxpemVzIHRoZSBwYXJzZXIsIHJlYWRzIGFueSBudW1iZXIgb2ZcbiAgICAgICAgLy8gc3RhdGVtZW50cywgYW5kIHdyYXBzIHRoZW0gaW4gYSBQcm9ncmFtIG5vZGUuICBPcHRpb25hbGx5IHRha2VzIGFcbiAgICAgICAgLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuICAgICAgICAvLyB0byBpdHMgYm9keSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG5vZGUuXG5cbiAgICAgICAgcHAkMS5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgaWYgKCFub2RlLmJvZHkpIG5vZGUuYm9keSA9IFtdO1xuICAgICAgICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR0LmVvZikge1xuICAgICAgICAgICAgdmFyIHN0bXQgPSB0aGlzJDEucGFyc2VTdGF0ZW1lbnQodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICBpZiAodGhpcyQxLmlzVXNlU3RyaWN0KHN0bXQpKSB0aGlzJDEuc2V0U3RyaWN0KHRydWUpO1xuICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgICAgIG5vZGUuc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbG9vcExhYmVsID0geyBraW5kOiBcImxvb3BcIiB9O1xuICAgICAgICB2YXIgc3dpdGNoTGFiZWwgPSB7IGtpbmQ6IFwic3dpdGNoXCIgfTtcbiAgICAgICAgcHAkMS5pc0xldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy50eXBlICE9PSB0dC5uYW1lIHx8IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgdGhpcy52YWx1ZSAhPSBcImxldFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgICAgICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCxcbiAgICAgICAgICAgICAgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICAgIGlmIChuZXh0Q2ggPT09IDkxIHx8IG5leHRDaCA9PSAxMjMpIHJldHVybiB0cnVlOyAvLyAneycgYW5kICdbJ1xuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwb3MgPSBuZXh0ICsgMTsgaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSk7ICsrcG9zKSB7fVxuICAgICAgICAgICAgdmFyIGlkZW50ID0gdGhpcy5pbnB1dC5zbGljZShuZXh0LCBwb3MpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzS2V5d29yZChpZGVudCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBleHBlY3RpbmcgYSBzdGF0ZW1lbnQgYW5kIGZpbmRpbmcgYSBzbGFzaCBvcGVyYXRvciwgcGFyc2UgYVxuICAgICAgICAvLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbC4gVGhpcyBpcyB0byBoYW5kbGUgY2FzZXMgbGlrZVxuICAgICAgICAvLyBgaWYgKGZvbykgL2JsYWgvLmV4ZWMoZm9vKWAsIHdoZXJlIGxvb2tpbmcgYXQgdGhlIHByZXZpb3VzIHRva2VuXG4gICAgICAgIC8vIGRvZXMgbm90IGhlbHAuXG5cbiAgICAgICAgcHAkMS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChkZWNsYXJhdGlvbiwgdG9wTGV2ZWwpIHtcbiAgICAgICAgICB2YXIgc3RhcnR0eXBlID0gdGhpcy50eXBlLFxuICAgICAgICAgICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKSxcbiAgICAgICAgICAgICAga2luZDtcblxuICAgICAgICAgIGlmICh0aGlzLmlzTGV0KCkpIHtcbiAgICAgICAgICAgIHN0YXJ0dHlwZSA9IHR0Ll92YXI7XG4gICAgICAgICAgICBraW5kID0gXCJsZXRcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAgICAgICAgIC8vIHN0YXJ0IHdpdGguIE1hbnkgYXJlIHRyaXZpYWwgdG8gcGFyc2UsIHNvbWUgcmVxdWlyZSBhIGJpdCBvZlxuICAgICAgICAgIC8vIGNvbXBsZXhpdHkuXG5cbiAgICAgICAgICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICAgICAgICAgICAgY2FzZSB0dC5fYnJlYWs6Y2FzZSB0dC5fY29udGludWU6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZCk7XG4gICAgICAgICAgICBjYXNlIHR0Ll9kZWJ1Z2dlcjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgdHQuX2RvOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZURvU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSB0dC5fZm9yOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgdHQuX2Z1bmN0aW9uOlxuICAgICAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgdHQuX2NsYXNzOlxuICAgICAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgdHQuX2lmOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUlmU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSB0dC5fcmV0dXJuOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgdHQuX3N3aXRjaDpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlIHR0Ll90aHJvdzpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgdHQuX3RyeTpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlIHR0Ll9jb25zdDpjYXNlIHR0Ll92YXI6XG4gICAgICAgICAgICAgIGtpbmQgPSBraW5kIHx8IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgIGlmICghZGVjbGFyYXRpb24gJiYga2luZCAhPSBcInZhclwiKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZCk7XG4gICAgICAgICAgICBjYXNlIHR0Ll93aGlsZTpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgdHQuX3dpdGg6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgdHQuYnJhY2VMOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgICAgICAgICBjYXNlIHR0LnNlbWk6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlIHR0Ll9leHBvcnQ6XG4gICAgICAgICAgICBjYXNlIHR0Ll9pbXBvcnQ6XG4gICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgICAgICAgICAgIGlmICghdG9wTGV2ZWwpIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKSB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzdGFydHR5cGUgPT09IHR0Ll9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgICAgICAgICAgLy8gYnJhY2UsIGl0J3MgYW4gRXhwcmVzc2lvblN0YXRlbWVudCBvciBMYWJlbGVkU3RhdGVtZW50LiBXZVxuICAgICAgICAgICAgLy8gc2ltcGx5IHN0YXJ0IHBhcnNpbmcgYW4gZXhwcmVzc2lvbiwgYW5kIGFmdGVyd2FyZHMsIGlmIHRoZVxuICAgICAgICAgICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAgICAgICAgIC8vIElkZW50aWZpZXIgbm9kZSwgd2Ugc3dpdGNoIHRvIGludGVycHJldGluZyBpdCBhcyBhIGxhYmVsLlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHQubmFtZSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuZWF0KHR0LmNvbG9uKSkgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwcik7ZWxzZSByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDEucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIGtleXdvcmQpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PSBcImJyZWFrXCI7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgaWYgKHRoaXMuZWF0KHR0LnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIG5vZGUubGFiZWwgPSBudWxsO2Vsc2UgaWYgKHRoaXMudHlwZSAhPT0gdHQubmFtZSkgdGhpcy51bmV4cGVjdGVkKCk7ZWxzZSB7XG4gICAgICAgICAgICBub2RlLmxhYmVsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICAgICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGlzIGFuIGFjdHVhbCBkZXN0aW5hdGlvbiB0byBicmVhayBvclxuICAgICAgICAgIC8vIGNvbnRpbnVlIHRvLlxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsYWIgPSB0aGlzJDEubGFiZWxzW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICAgICAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIGJyZWFrO1xuICAgICAgICAgICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IHRoaXMubGFiZWxzLmxlbmd0aCkgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsga2V5d29yZCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQxLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDEucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgICAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICAgICAgICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHR0Ll93aGlsZSk7XG4gICAgICAgICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgdGhpcy5lYXQodHQuc2VtaSk7ZWxzZSB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERpc2FtYmlndWF0aW5nIGJldHdlZW4gYSBgZm9yYCBhbmQgYSBgZm9yYC9gaW5gIG9yIGBmb3JgL2BvZmBcbiAgICAgICAgLy8gbG9vcCBpcyBub24tdHJpdmlhbC4gQmFzaWNhbGx5LCB3ZSBoYXZlIHRvIHBhcnNlIHRoZSBpbml0IGB2YXJgXG4gICAgICAgIC8vIHN0YXRlbWVudCBvciBleHByZXNzaW9uLCBkaXNhbGxvd2luZyB0aGUgYGluYCBvcGVyYXRvciAoc2VlXG4gICAgICAgIC8vIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGBwYXJzZUV4cHJlc3Npb25gKSwgYW5kIHRoZW4gY2hlY2tcbiAgICAgICAgLy8gd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBgaW5gIG9yIGBvZmAuIFdoZW4gdGhlcmUgaXMgbm8gaW5pdFxuICAgICAgICAvLyBwYXJ0IChzZW1pY29sb24gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMpLCBpdFxuICAgICAgICAvLyBpcyBhIHJlZ3VsYXIgYGZvcmAgbG9vcC5cblxuICAgICAgICBwcCQxLnBhcnNlRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgICAgICAgdGhpcy5leHBlY3QodHQucGFyZW5MKTtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0dC5zZW1pKSByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBudWxsKTtcbiAgICAgICAgICB2YXIgaXNMZXQgPSB0aGlzLmlzTGV0KCk7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHQuX3ZhciB8fCB0aGlzLnR5cGUgPT09IHR0Ll9jb25zdCB8fCBpc0xldCkge1xuICAgICAgICAgICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksXG4gICAgICAgICAgICAgICAga2luZCA9IGlzTGV0ID8gXCJsZXRcIiA6IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VWYXIoaW5pdCQxLCB0cnVlLCBraW5kKTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTm9kZShpbml0JDEsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgICAgICAgIGlmICgodGhpcy50eXBlID09PSB0dC5faW4gfHwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkgJiYgaW5pdCQxLmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgIShraW5kICE9PSBcInZhclwiICYmIGluaXQkMS5kZWNsYXJhdGlvbnNbMF0uaW5pdCkpIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCQxKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQkMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMoKTtcbiAgICAgICAgICB2YXIgaW5pdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR0Ll9pbiB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0xWYWwoaW5pdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkMS5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDEucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgICAgICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQodHQuX2Vsc2UpID8gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSkgOiBudWxsO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQxLnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKSB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgICAgIC8vIEluIGByZXR1cm5gIChhbmQgYGJyZWFrYC9gY29udGludWVgKSwgdGhlIGtleXdvcmRzIHdpdGhcbiAgICAgICAgICAvLyBvcHRpb25hbCBhcmd1bWVudHMsIHdlIGVhZ2VybHkgbG9vayBmb3IgYSBzZW1pY29sb24gb3IgdGhlXG4gICAgICAgICAgLy8gcG9zc2liaWxpdHkgdG8gaW5zZXJ0IG9uZS5cblxuICAgICAgICAgIGlmICh0aGlzLmVhdCh0dC5zZW1pKSB8fCB0aGlzLmluc2VydFNlbWljb2xvbigpKSBub2RlLmFyZ3VtZW50ID0gbnVsbDtlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO3RoaXMuc2VtaWNvbG9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkMS5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICBub2RlLmNhc2VzID0gW107XG4gICAgICAgICAgdGhpcy5leHBlY3QodHQuYnJhY2VMKTtcbiAgICAgICAgICB0aGlzLmxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcblxuICAgICAgICAgIC8vIFN0YXRlbWVudHMgdW5kZXIgbXVzdCBiZSBncm91cGVkIChieSBsYWJlbCkgaW4gU3dpdGNoQ2FzZVxuICAgICAgICAgIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gICAgICAgICAgLy8gYWRkaW5nIHN0YXRlbWVudHMgdG8uXG5cbiAgICAgICAgICBmb3IgKHZhciBjdXIsIHNhd0RlZmF1bHQgPSBmYWxzZTsgdGhpcy50eXBlICE9IHR0LmJyYWNlUjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzJDEudHlwZSA9PT0gdHQuX2Nhc2UgfHwgdGhpcyQxLnR5cGUgPT09IHR0Ll9kZWZhdWx0KSB7XG4gICAgICAgICAgICAgIHZhciBpc0Nhc2UgPSB0aGlzJDEudHlwZSA9PT0gdHQuX2Nhc2U7XG4gICAgICAgICAgICAgIGlmIChjdXIpIHRoaXMkMS5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpO1xuICAgICAgICAgICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gdGhpcyQxLnN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgICAgICAgY3VyLmNvbnNlcXVlbnQgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcyQxLm5leHQoKTtcbiAgICAgICAgICAgICAgaWYgKGlzQ2FzZSkge1xuICAgICAgICAgICAgICAgIGN1ci50ZXN0ID0gdGhpcyQxLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzYXdEZWZhdWx0KSB0aGlzJDEucmFpc2VSZWNvdmVyYWJsZSh0aGlzJDEubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTtcbiAgICAgICAgICAgICAgICBzYXdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXIudGVzdCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcyQxLmV4cGVjdCh0dC5jb2xvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWN1cikgdGhpcyQxLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaCh0aGlzJDEucGFyc2VTdGF0ZW1lbnQodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7IC8vIENsb3NpbmcgYnJhY2VcbiAgICAgICAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDEucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpIHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTtcbiAgICAgICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXVzZWQgZW1wdHkgYXJyYXkgYWRkZWQgZm9yIG5vZGUgZmllbGRzIHRoYXQgYXJlIGFsd2F5cyBlbXB0eS5cblxuICAgICAgICB2YXIgZW1wdHkgPSBbXTtcblxuICAgICAgICBwcCQxLnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgICAgICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0dC5fY2F0Y2gpIHtcbiAgICAgICAgICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCh0dC5wYXJlbkwpO1xuICAgICAgICAgICAgY2xhdXNlLnBhcmFtID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrTFZhbChjbGF1c2UucGFyYW0sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5leHBlY3QodHQucGFyZW5SKTtcbiAgICAgICAgICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgICAgICAgICBub2RlLmhhbmRsZXIgPSB0aGlzLmZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KHR0Ll9maW5hbGx5KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcbiAgICAgICAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkMS5wYXJzZVZhclN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBraW5kKSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCk7XG4gICAgICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQxLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gICAgICAgICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDEucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdHJpY3QpIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkMS5wYXJzZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkMS5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgbWF5YmVOYW1lLCBleHByKSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcyQxLmxhYmVsc1tpXS5uYW1lID09PSBtYXliZU5hbWUpIHRoaXMkMS5yYWlzZShleHByLnN0YXJ0LCBcIkxhYmVsICdcIiArIG1heWJlTmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICAgICAgICAgIH12YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHQuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IHRoaXMubGFiZWxzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gdGhpcyQxLmxhYmVsc1tpJDFdO1xuICAgICAgICAgICAgaWYgKGxhYmVsLnN0YXRlbWVudFN0YXJ0ID09IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgICAgICAgbGFiZWwuc3RhdGVtZW50U3RhcnQgPSB0aGlzJDEuc3RhcnQ7XG4gICAgICAgICAgICAgIGxhYmVsLmtpbmQgPSBraW5kO1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxhYmVscy5wdXNoKHsgbmFtZTogbWF5YmVOYW1lLCBraW5kOiBraW5kLCBzdGF0ZW1lbnRTdGFydDogdGhpcy5zdGFydCB9KTtcbiAgICAgICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KHRydWUpO1xuICAgICAgICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgICAgICAgIG5vZGUubGFiZWwgPSBleHByO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDEucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIGV4cHIpIHtcbiAgICAgICAgICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICAgICAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGFyc2UgYSBzZW1pY29sb24tZW5jbG9zZWQgYmxvY2sgb2Ygc3RhdGVtZW50cywgaGFuZGxpbmcgYFwidXNlXG4gICAgICAgIC8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4gICAgICAgIC8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbiAgICAgICAgcHAkMS5wYXJzZUJsb2NrID0gZnVuY3Rpb24gKGFsbG93U3RyaWN0KSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksXG4gICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgb2xkU3RyaWN0O1xuICAgICAgICAgIG5vZGUuYm9keSA9IFtdO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHR0LmJyYWNlTCk7XG4gICAgICAgICAgd2hpbGUgKCF0aGlzLmVhdCh0dC5icmFjZVIpKSB7XG4gICAgICAgICAgICB2YXIgc3RtdCA9IHRoaXMkMS5wYXJzZVN0YXRlbWVudCh0cnVlKTtcbiAgICAgICAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIGFsbG93U3RyaWN0ICYmIHRoaXMkMS5pc1VzZVN0cmljdChzdG10KSkge1xuICAgICAgICAgICAgICBvbGRTdHJpY3QgPSB0aGlzJDEuc3RyaWN0O1xuICAgICAgICAgICAgICB0aGlzJDEuc2V0U3RyaWN0KHRoaXMkMS5zdHJpY3QgPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvbGRTdHJpY3QgPT09IGZhbHNlKSB0aGlzLnNldFN0cmljdChmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlIGEgcmVndWxhciBgZm9yYCBsb29wLiBUaGUgZGlzYW1iaWd1YXRpb24gY29kZSBpblxuICAgICAgICAvLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3JcbiAgICAgICAgLy8gZXhwcmVzc2lvbi5cblxuICAgICAgICBwcCQxLnBhcnNlRm9yID0gZnVuY3Rpb24gKG5vZGUsIGluaXQpIHtcbiAgICAgICAgICBub2RlLmluaXQgPSBpbml0O1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHR0LnNlbWkpO1xuICAgICAgICAgIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gdHQuc2VtaSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHR0LnNlbWkpO1xuICAgICAgICAgIG5vZGUudXBkYXRlID0gdGhpcy50eXBlID09PSB0dC5wYXJlblIgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICB0aGlzLmV4cGVjdCh0dC5wYXJlblIpO1xuICAgICAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICAgICAgICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGFyc2UgYSBgZm9yYC9gaW5gIGFuZCBgZm9yYC9gb2ZgIGxvb3AsIHdoaWNoIGFyZSBhbG1vc3RcbiAgICAgICAgLy8gc2FtZSBmcm9tIHBhcnNlcidzIHBlcnNwZWN0aXZlLlxuXG4gICAgICAgIHBwJDEucGFyc2VGb3JJbiA9IGZ1bmN0aW9uIChub2RlLCBpbml0KSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGUgPT09IHR0Ll9pbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIjtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBub2RlLmxlZnQgPSBpbml0O1xuICAgICAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHR0LnBhcmVuUik7XG4gICAgICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gICAgICAgICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQYXJzZSBhIGxpc3Qgb2YgdmFyaWFibGUgZGVjbGFyYXRpb25zLlxuXG4gICAgICAgIHBwJDEucGFyc2VWYXIgPSBmdW5jdGlvbiAobm9kZSwgaXNGb3IsIGtpbmQpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gICAgICAgICAgbm9kZS5raW5kID0ga2luZDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB2YXIgZGVjbCA9IHRoaXMkMS5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgIHRoaXMkMS5wYXJzZVZhcklkKGRlY2wpO1xuICAgICAgICAgICAgaWYgKHRoaXMkMS5lYXQodHQuZXEpKSB7XG4gICAgICAgICAgICAgIGRlY2wuaW5pdCA9IHRoaXMkMS5wYXJzZU1heWJlQXNzaWduKGlzRm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCJjb25zdFwiICYmICEodGhpcyQxLnR5cGUgPT09IHR0Ll9pbiB8fCB0aGlzJDEub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMkMS5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICAgICAgICAgICAgdGhpcyQxLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVjbC5pZC50eXBlICE9IFwiSWRlbnRpZmllclwiICYmICEoaXNGb3IgJiYgKHRoaXMkMS50eXBlID09PSB0dC5faW4gfHwgdGhpcyQxLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgICAgICAgICAgdGhpcyQxLnJhaXNlKHRoaXMkMS5sYXN0VG9rRW5kLCBcIkNvbXBsZXggYmluZGluZyBwYXR0ZXJucyByZXF1aXJlIGFuIGluaXRpYWxpemF0aW9uIHZhbHVlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVjbC5pbml0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuZGVjbGFyYXRpb25zLnB1c2godGhpcyQxLmZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgICAgICAgICAgaWYgKCF0aGlzJDEuZWF0KHR0LmNvbW1hKSkgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDEucGFyc2VWYXJJZCA9IGZ1bmN0aW9uIChkZWNsKSB7XG4gICAgICAgICAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgICAgICAgIHRoaXMuY2hlY2tMVmFsKGRlY2wuaWQsIHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlIGEgZnVuY3Rpb24gZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuICAgICAgICAvLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbiAgICAgICAgcHAkMS5wYXJzZUZ1bmN0aW9uID0gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGVtZW50LCBhbGxvd0V4cHJlc3Npb25Cb2R5KSB7XG4gICAgICAgICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSBub2RlLmdlbmVyYXRvciA9IHRoaXMuZWF0KHR0LnN0YXIpO1xuICAgICAgICAgIHZhciBvbGRJbkdlbiA9IHRoaXMuaW5HZW5lcmF0b3I7XG4gICAgICAgICAgdGhpcy5pbkdlbmVyYXRvciA9IG5vZGUuZ2VuZXJhdG9yO1xuICAgICAgICAgIGlmIChpc1N0YXRlbWVudCB8fCB0aGlzLnR5cGUgPT09IHR0Lm5hbWUpIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgICAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gICAgICAgICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5KTtcbiAgICAgICAgICB0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW47XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkMS5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB0aGlzLmV4cGVjdCh0dC5wYXJlbkwpO1xuICAgICAgICAgIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR0LnBhcmVuUiwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQYXJzZSBhIGNsYXNzIGRlY2xhcmF0aW9uIG9yIGxpdGVyYWwgKGRlcGVuZGluZyBvbiB0aGVcbiAgICAgICAgLy8gYGlzU3RhdGVtZW50YCBwYXJhbWV0ZXIpLlxuXG4gICAgICAgIHBwJDEucGFyc2VDbGFzcyA9IGZ1bmN0aW9uIChub2RlLCBpc1N0YXRlbWVudCkge1xuICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgdGhpcy5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQpO1xuICAgICAgICAgIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICAgICAgICAgIHZhciBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHZhciBoYWRDb25zdHJ1Y3RvciA9IGZhbHNlO1xuICAgICAgICAgIGNsYXNzQm9keS5ib2R5ID0gW107XG4gICAgICAgICAgdGhpcy5leHBlY3QodHQuYnJhY2VMKTtcbiAgICAgICAgICB3aGlsZSAoIXRoaXMuZWF0KHR0LmJyYWNlUikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzJDEuZWF0KHR0LnNlbWkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSB0aGlzJDEuc3RhcnROb2RlKCk7XG4gICAgICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSB0aGlzJDEuZWF0KHR0LnN0YXIpO1xuICAgICAgICAgICAgdmFyIGlzTWF5YmVTdGF0aWMgPSB0aGlzJDEudHlwZSA9PT0gdHQubmFtZSAmJiB0aGlzJDEudmFsdWUgPT09IFwic3RhdGljXCI7XG4gICAgICAgICAgICB0aGlzJDEucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTtcbiAgICAgICAgICAgIG1ldGhvZC5zdGF0aWMgPSBpc01heWJlU3RhdGljICYmIHRoaXMkMS50eXBlICE9PSB0dC5wYXJlbkw7XG4gICAgICAgICAgICBpZiAobWV0aG9kLnN0YXRpYykge1xuICAgICAgICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHRoaXMkMS51bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgIGlzR2VuZXJhdG9yID0gdGhpcyQxLmVhdCh0dC5zdGFyKTtcbiAgICAgICAgICAgICAgdGhpcyQxLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgICAgICAgICB2YXIgaXNHZXRTZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghbWV0aG9kLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuICAgICAgICAgICAgICBpZiAoIWlzR2VuZXJhdG9yICYmIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzJDEudHlwZSAhPT0gdHQucGFyZW5MICYmIChrZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBrZXkubmFtZSA9PT0gXCJzZXRcIikpIHtcbiAgICAgICAgICAgICAgICBpc0dldFNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmtpbmQgPSBrZXkubmFtZTtcbiAgICAgICAgICAgICAgICBrZXkgPSB0aGlzJDEucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIW1ldGhvZC5zdGF0aWMgJiYgKGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IGtleS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHRoaXMkMS5yYWlzZShrZXkuc3RhcnQsIFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIpO1xuICAgICAgICAgICAgICAgIGlmIChpc0dldFNldCkgdGhpcyQxLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGlzR2VuZXJhdG9yKSB0aGlzJDEucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGEgZ2VuZXJhdG9yXCIpO1xuICAgICAgICAgICAgICAgIG1ldGhvZC5raW5kID0gXCJjb25zdHJ1Y3RvclwiO1xuICAgICAgICAgICAgICAgIGhhZENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcyQxLnBhcnNlQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yKTtcbiAgICAgICAgICAgIGlmIChpc0dldFNldCkge1xuICAgICAgICAgICAgICB2YXIgcGFyYW1Db3VudCA9IG1ldGhvZC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgICAgICAgICAgIGlmIChtZXRob2QudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IG1ldGhvZC52YWx1ZS5zdGFydDtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIpIHRoaXMkMS5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7ZWxzZSB0aGlzJDEucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKSB0aGlzJDEucmFpc2UobWV0aG9kLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkMS5wYXJzZUNsYXNzTWV0aG9kID0gZnVuY3Rpb24gKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvcikge1xuICAgICAgICAgIG1ldGhvZC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IpO1xuICAgICAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJNZXRob2REZWZpbml0aW9uXCIpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQxLnBhcnNlQ2xhc3NJZCA9IGZ1bmN0aW9uIChub2RlLCBpc1N0YXRlbWVudCkge1xuICAgICAgICAgIG5vZGUuaWQgPSB0aGlzLnR5cGUgPT09IHR0Lm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IGlzU3RhdGVtZW50ID8gdGhpcy51bmV4cGVjdGVkKCkgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDEucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0dC5fZXh0ZW5kcykgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKSA6IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGFyc2VzIG1vZHVsZSBleHBvcnQgZGVjbGFyYXRpb24uXG5cbiAgICAgICAgcHAkMS5wYXJzZUV4cG9ydCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAvLyBleHBvcnQgKiBmcm9tICcuLi4nXG4gICAgICAgICAgaWYgKHRoaXMuZWF0KHR0LnN0YXIpKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgICAgICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IHR0LnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5lYXQodHQuX2RlZmF1bHQpKSB7XG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICAgICAgICAgIHZhciBwYXJlbnMgPSB0aGlzLnR5cGUgPT0gdHQucGFyZW5MO1xuICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgICAgICAgIHZhciBuZWVkc1NlbWkgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnMgJiYgKGV4cHIudHlwZSA9PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IGV4cHIudHlwZSA9PSBcIkNsYXNzRXhwcmVzc2lvblwiKSkge1xuICAgICAgICAgICAgICBuZWVkc1NlbWkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGV4cHIuaWQpIHtcbiAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBleHByLnR5cGUgPT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJDbGFzc0RlY2xhcmF0aW9uXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSBleHByO1xuICAgICAgICAgICAgaWYgKG5lZWRzU2VtaSkgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGV4cG9ydCB2YXJ8Y29uc3R8bGV0fGZ1bmN0aW9ufGNsYXNzIC4uLlxuICAgICAgICAgIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICAgICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlU3RhdGVtZW50KHRydWUpO1xuICAgICAgICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgICAgICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgICAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICAgICAgICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IHR0LnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHMgdXNlZCBhcyBsb2NhbCBuYW1lc1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuc3BlY2lmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzJDEua2V5d29yZHMudGVzdChub2RlLnNwZWNpZmllcnNbaV0ubG9jYWwubmFtZSkgfHwgdGhpcyQxLnJlc2VydmVkV29yZHMudGVzdChub2RlLnNwZWNpZmllcnNbaV0ubG9jYWwubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMkMS51bmV4cGVjdGVkKG5vZGUuc3BlY2lmaWVyc1tpXS5sb2NhbC5zdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkMS5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmtleXdvcmQgfHwgdGhpcy5pc0xldCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBleHBvcnRzLlxuXG4gICAgICAgIHBwJDEucGFyc2VFeHBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgICAgdmFyIG5vZGVzID0gW10sXG4gICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICAgICAgICB0aGlzLmV4cGVjdCh0dC5icmFjZUwpO1xuICAgICAgICAgIHdoaWxlICghdGhpcy5lYXQodHQuYnJhY2VSKSkge1xuICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICB0aGlzJDEuZXhwZWN0KHR0LmNvbW1hKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMkMS5hZnRlclRyYWlsaW5nQ29tbWEodHQuYnJhY2VSKSkgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgZmlyc3QgPSBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzJDEuc3RhcnROb2RlKCk7XG4gICAgICAgICAgICBub2RlLmxvY2FsID0gdGhpcyQxLnBhcnNlSWRlbnQodGhpcyQxLnR5cGUgPT09IHR0Ll9kZWZhdWx0KTtcbiAgICAgICAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzJDEuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcyQxLnBhcnNlSWRlbnQodHJ1ZSkgOiBub2RlLmxvY2FsO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh0aGlzJDEuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQYXJzZXMgaW1wb3J0IGRlY2xhcmF0aW9uLlxuXG4gICAgICAgIHBwJDEucGFyc2VJbXBvcnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIC8vIGltcG9ydCAnLi4uJ1xuICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR0LnN0cmluZykge1xuICAgICAgICAgICAgbm9kZS5zcGVjaWZpZXJzID0gZW1wdHk7XG4gICAgICAgICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVycygpO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICAgICAgICAgIG5vZGUuc291cmNlID0gdGhpcy50eXBlID09PSB0dC5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgaW1wb3J0cy5cblxuICAgICAgICBwcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgIHZhciBub2RlcyA9IFtdLFxuICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHQubmFtZSkge1xuICAgICAgICAgICAgLy8gaW1wb3J0IGRlZmF1bHRPYmosIHsgeCwgeSBhcyB6IH0gZnJvbSAnLi4uJ1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0xWYWwobm9kZS5sb2NhbCwgdHJ1ZSk7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVhdCh0dC5jb21tYSkpIHJldHVybiBub2RlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHQuc3Rhcikge1xuICAgICAgICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImFzXCIpO1xuICAgICAgICAgICAgbm9kZSQxLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrTFZhbChub2RlJDEubG9jYWwsIHRydWUpO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZXhwZWN0KHR0LmJyYWNlTCk7XG4gICAgICAgICAgd2hpbGUgKCF0aGlzLmVhdCh0dC5icmFjZVIpKSB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgIHRoaXMkMS5leHBlY3QodHQuY29tbWEpO1xuICAgICAgICAgICAgICBpZiAodGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYSh0dC5icmFjZVIpKSBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBmaXJzdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgbm9kZSQyID0gdGhpcyQxLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgbm9kZSQyLmltcG9ydGVkID0gdGhpcyQxLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcyQxLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgICAgICAgICBub2RlJDIubG9jYWwgPSB0aGlzJDEucGFyc2VJZGVudCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZSQyLmxvY2FsID0gbm9kZSQyLmltcG9ydGVkO1xuICAgICAgICAgICAgICBpZiAodGhpcyQxLmlzS2V5d29yZChub2RlJDIubG9jYWwubmFtZSkpIHRoaXMkMS51bmV4cGVjdGVkKG5vZGUkMi5sb2NhbC5zdGFydCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzJDEucmVzZXJ2ZWRXb3Jkc1N0cmljdC50ZXN0KG5vZGUkMi5sb2NhbC5uYW1lKSkgdGhpcyQxLnJhaXNlKG5vZGUkMi5sb2NhbC5zdGFydCwgXCJUaGUga2V5d29yZCAnXCIgKyBub2RlJDIubG9jYWwubmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMkMS5jaGVja0xWYWwobm9kZSQyLmxvY2FsLCB0cnVlKTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godGhpcyQxLmZpbmlzaE5vZGUobm9kZSQyLCBcIkltcG9ydFNwZWNpZmllclwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHAkMiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgICAgICAgLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4gICAgICAgIC8vIGlmIHBvc3NpYmxlLlxuXG4gICAgICAgIHBwJDIudG9Bc3NpZ25hYmxlID0gZnVuY3Rpb24gKG5vZGUsIGlzQmluZGluZykge1xuICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IG5vZGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICAgIGlmIChwcm9wLmtpbmQgIT09IFwiaW5pdFwiKSB0aGlzJDEucmFpc2UocHJvcC5rZXkuc3RhcnQsIFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyXCIpO1xuICAgICAgICAgICAgICAgICAgdGhpcyQxLnRvQXNzaWduYWJsZShwcm9wLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgICAgICAgICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5lbGVtZW50cywgaXNCaW5kaW5nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vcGVyYXRvciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaCB0byBBc3NpZ25tZW50UGF0dGVyblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucmlnaHQudHlwZSA9PT0gXCJZaWVsZEV4cHJlc3Npb25cIikgdGhpcy5yYWlzZShub2RlLnJpZ2h0LnN0YXJ0LCBcIllpZWxkIGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgICBpZiAoIWlzQmluZGluZykgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29udmVydCBsaXN0IG9mIGV4cHJlc3Npb24gYXRvbXMgdG8gYmluZGluZyBsaXN0LlxuXG4gICAgICAgIHBwJDIudG9Bc3NpZ25hYmxlTGlzdCA9IGZ1bmN0aW9uIChleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICB2YXIgZW5kID0gZXhwckxpc3QubGVuZ3RoO1xuICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LnR5cGUgPT0gXCJSZXN0RWxlbWVudFwiKSB7XG4gICAgICAgICAgICAgIC0tZW5kO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0ICYmIGxhc3QudHlwZSA9PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgICAgICAgICBsYXN0LnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICAgICAgICAgIHZhciBhcmcgPSBsYXN0LmFyZ3VtZW50O1xuICAgICAgICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShhcmcsIGlzQmluZGluZyk7XG4gICAgICAgICAgICAgIGlmIChhcmcudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgYXJnLnR5cGUgIT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIGFyZy50eXBlICE9PSBcIkFycmF5UGF0dGVyblwiKSB0aGlzLnVuZXhwZWN0ZWQoYXJnLnN0YXJ0KTtcbiAgICAgICAgICAgICAgLS1lbmQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB0aGlzLnVuZXhwZWN0ZWQobGFzdC5hcmd1bWVudC5zdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlbHQgPSBleHByTGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChlbHQpIHRoaXMkMS50b0Fzc2lnbmFibGUoZWx0LCBpc0JpbmRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXhwckxpc3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGFyc2VzIHNwcmVhZCBlbGVtZW50LlxuXG4gICAgICAgIHBwJDIucGFyc2VTcHJlYWQgPSBmdW5jdGlvbiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQyLnBhcnNlUmVzdCA9IGZ1bmN0aW9uIChhbGxvd05vbklkZW50KSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgICAgLy8gUmVzdEVsZW1lbnQgaW5zaWRlIG9mIGEgZnVuY3Rpb24gcGFyYW1ldGVyIG11c3QgYmUgYW4gaWRlbnRpZmllclxuICAgICAgICAgIGlmIChhbGxvd05vbklkZW50KSBub2RlLmFyZ3VtZW50ID0gdGhpcy50eXBlID09PSB0dC5uYW1lID8gdGhpcy5wYXJzZUlkZW50KCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtlbHNlIG5vZGUuYXJndW1lbnQgPSB0aGlzLnR5cGUgPT09IHR0Lm5hbWUgfHwgdGhpcy50eXBlID09PSB0dC5icmFja2V0TCA/IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGFyc2VzIGx2YWx1ZSAoYXNzaWduYWJsZSkgYXRvbS5cblxuICAgICAgICBwcCQyLnBhcnNlQmluZGluZ0F0b20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSB0dC5uYW1lOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50KCk7XG5cbiAgICAgICAgICAgIGNhc2UgdHQuYnJhY2tldEw6XG4gICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHQuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpO1xuXG4gICAgICAgICAgICBjYXNlIHR0LmJyYWNlTDpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmoodHJ1ZSk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBwcCQyLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbiAoY2xvc2UsIGFsbG93RW1wdHksIGFsbG93VHJhaWxpbmdDb21tYSwgYWxsb3dOb25JZGVudCkge1xuICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgICAgdmFyIGVsdHMgPSBbXSxcbiAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3QpIGZpcnN0ID0gZmFsc2U7ZWxzZSB0aGlzJDEuZXhwZWN0KHR0LmNvbW1hKTtcbiAgICAgICAgICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMkMS50eXBlID09PSB0dC5jb21tYSkge1xuICAgICAgICAgICAgICBlbHRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzJDEuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcyQxLnR5cGUgPT09IHR0LmVsbGlwc2lzKSB7XG4gICAgICAgICAgICAgIHZhciByZXN0ID0gdGhpcyQxLnBhcnNlUmVzdChhbGxvd05vbklkZW50KTtcbiAgICAgICAgICAgICAgdGhpcyQxLnBhcnNlQmluZGluZ0xpc3RJdGVtKHJlc3QpO1xuICAgICAgICAgICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzJDEudHlwZSA9PT0gdHQuY29tbWEpIHRoaXMkMS5yYWlzZSh0aGlzJDEuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpO1xuICAgICAgICAgICAgICB0aGlzJDEuZXhwZWN0KGNsb3NlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMkMS5wYXJzZU1heWJlRGVmYXVsdCh0aGlzJDEuc3RhcnQsIHRoaXMkMS5zdGFydExvYyk7XG4gICAgICAgICAgICAgIHRoaXMkMS5wYXJzZUJpbmRpbmdMaXN0SXRlbShlbGVtKTtcbiAgICAgICAgICAgICAgZWx0cy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZWx0cztcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQyLnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlcyBhc3NpZ25tZW50IHBhdHRlcm4gYXJvdW5kIGdpdmVuIGF0b20gaWYgcG9zc2libGUuXG5cbiAgICAgICAgcHAkMi5wYXJzZU1heWJlRGVmYXVsdCA9IGZ1bmN0aW9uIChzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgICAgICAgICBsZWZ0ID0gbGVmdCB8fCB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHQuZXEpKSByZXR1cm4gbGVmdDtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgYSBub2RlIGlzIGFuIGx2YWwg4oCUIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBhc3NpZ25lZFxuICAgICAgICAvLyB0by5cblxuICAgICAgICBwcCQyLmNoZWNrTFZhbCA9IGZ1bmN0aW9uIChleHByLCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcykge1xuICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgICAgICAgIGlmICh0aGlzLnN0cmljdCAmJiB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kLnRlc3QoZXhwci5uYW1lKSkgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChpc0JpbmRpbmcgPyBcIkJpbmRpbmcgXCIgOiBcIkFzc2lnbmluZyB0byBcIikgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgICAgICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgICAgICAgICAgIGlmIChoYXMoY2hlY2tDbGFzaGVzLCBleHByLm5hbWUpKSB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJBcmd1bWVudCBuYW1lIGNsYXNoXCIpO1xuICAgICAgICAgICAgICAgIGNoZWNrQ2xhc2hlc1tleHByLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgaWYgKGlzQmluZGluZykgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChpc0JpbmRpbmcgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgbWVtYmVyIGV4cHJlc3Npb25cIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMkMS5jaGVja0xWYWwoZXhwci5wcm9wZXJ0aWVzW2ldLnZhbHVlLCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICAgICAgICAgIH1icmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBleHByLmVsZW1lbnRzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGV4cHIuZWxlbWVudHNbaSQxXTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbSkgdGhpcyQxLmNoZWNrTFZhbChlbGVtLCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrTFZhbChleHByLmxlZnQsIGlzQmluZGluZywgY2hlY2tDbGFzaGVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrTFZhbChleHByLmFyZ3VtZW50LCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci5leHByZXNzaW9uLCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChpc0JpbmRpbmcgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgcHJvcGVydHkgbmFtZSBjbGFzaGVzIHdpdGggYWxyZWFkeSBhZGRlZC5cbiAgICAgICAgLy8gT2JqZWN0L2NsYXNzIGdldHRlcnMgYW5kIHNldHRlcnMgYXJlIG5vdCBhbGxvd2VkIHRvIGNsYXNoIOKAlFxuICAgICAgICAvLyBlaXRoZXIgd2l0aCBlYWNoIG90aGVyIG9yIHdpdGggYW4gaW5pdCBwcm9wZXJ0eSDigJQgYW5kIGluXG4gICAgICAgIC8vIHN0cmljdCBtb2RlLCBpbml0IHByb3BlcnRpZXMgYXJlIGFsc28gbm90IGFsbG93ZWQgdG8gYmUgcmVwZWF0ZWQuXG5cbiAgICAgICAgcHAkMy5jaGVja1Byb3BDbGFzaCA9IGZ1bmN0aW9uIChwcm9wLCBwcm9wSGFzaCkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAocHJvcC5jb21wdXRlZCB8fCBwcm9wLm1ldGhvZCB8fCBwcm9wLnNob3J0aGFuZCkpIHJldHVybjtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgc3dpdGNoIChrZXkudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgICAgICAgbmFtZSA9IGtleS5uYW1lO2JyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkxpdGVyYWxcIjpcbiAgICAgICAgICAgICAgbmFtZSA9IFN0cmluZyhrZXkudmFsdWUpO2JyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIga2luZCA9IHByb3Aua2luZDtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiICYmIGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9wSGFzaC5wcm90bykgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpO1xuICAgICAgICAgICAgICBwcm9wSGFzaC5wcm90byA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gICAgICAgICAgdmFyIG90aGVyID0gcHJvcEhhc2hbbmFtZV07XG4gICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICB2YXIgaXNHZXRTZXQgPSBraW5kICE9PSBcImluaXRcIjtcbiAgICAgICAgICAgIGlmICgodGhpcy5zdHJpY3QgfHwgaXNHZXRTZXQpICYmIG90aGVyW2tpbmRdIHx8ICEoaXNHZXRTZXQgXiBvdGhlci5pbml0KSkgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICAgICAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgICAgICAgICBnZXQ6IGZhbHNlLFxuICAgICAgICAgICAgICBzZXQ6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdGhlcltraW5kXSA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gIyMjIEV4cHJlc3Npb24gcGFyc2luZ1xuXG4gICAgICAgIC8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuICAgICAgICAvLyAnYXRvbWljJywgbm9uZGl2aXNpYmxlIGV4cHJlc3Npb24gdHlwZXMgYXQgdGhlIGJvdHRvbS4gTW9zdCBvZlxuICAgICAgICAvLyB0aGUgZnVuY3Rpb25zIHdpbGwgc2ltcGx5IGxldCB0aGUgZnVuY3Rpb24ocykgYmVsb3cgdGhlbSBwYXJzZSxcbiAgICAgICAgLy8gYW5kLCAqaWYqIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHRoZXkgaGFuZGxlIGlzIHByZXNlbnQsIHdyYXBcbiAgICAgICAgLy8gdGhlIEFTVCBub2RlIHRoYXQgdGhlIGlubmVyIHBhcnNlciBnYXZlIHRoZW0gaW4gYW5vdGhlciBub2RlLlxuXG4gICAgICAgIC8vIFBhcnNlIGEgZnVsbCBleHByZXNzaW9uLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIHRvXG4gICAgICAgIC8vIGZvcmJpZCB0aGUgYGluYCBvcGVyYXRvciAoaW4gZm9yIGxvb3BzIGluaXRhbGl6YXRpb24gZXhwcmVzc2lvbnMpXG4gICAgICAgIC8vIGFuZCBwcm92aWRlIHJlZmVyZW5jZSBmb3Igc3RvcmluZyAnPScgb3BlcmF0b3IgaW5zaWRlIHNob3J0aGFuZFxuICAgICAgICAvLyBwcm9wZXJ0eSBhc3NpZ25tZW50IGluIGNvbnRleHRzIHdoZXJlIGJvdGggb2JqZWN0IGV4cHJlc3Npb25cbiAgICAgICAgLy8gYW5kIG9iamVjdCBwYXR0ZXJuIG1pZ2h0IGFwcGVhciAoc28gaXQncyBwb3NzaWJsZSB0byByYWlzZVxuICAgICAgICAvLyBkZWxheWVkIHN5bnRheCBlcnJvciBhdCBjb3JyZWN0IHBvc2l0aW9uKS5cblxuICAgICAgICBwcCQzLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHQuY29tbWEpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmVhdCh0dC5jb21tYSkpIHtcbiAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMkMS5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKTtcbiAgICAgICAgICAgIH1yZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQYXJzZSBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24uIFRoaXMgaW5jbHVkZXMgYXBwbGljYXRpb25zIG9mXG4gICAgICAgIC8vIG9wZXJhdG9ycyBsaWtlIGArPWAuXG5cbiAgICAgICAgcHAkMy5wYXJzZU1heWJlQXNzaWduID0gZnVuY3Rpb24gKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaW5HZW5lcmF0b3IgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJ5aWVsZFwiKSkgcmV0dXJuIHRoaXMucGFyc2VZaWVsZCgpO1xuXG4gICAgICAgICAgdmFyIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycygpO1xuICAgICAgICAgICAgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09IHR0LnBhcmVuTCB8fCB0aGlzLnR5cGUgPT0gdHQubmFtZSkgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICAgIGlmIChhZnRlckxlZnRQYXJzZSkgbGVmdCA9IGFmdGVyTGVmdFBhcnNlLmNhbGwodGhpcywgbGVmdCwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgICBpZiAodGhpcy50eXBlLmlzQXNzaWduKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgRGVzdHJ1Y3R1cmluZ0Vycm9ycy5jYWxsKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIG5vZGUubGVmdCA9IHRoaXMudHlwZSA9PT0gdHQuZXEgPyB0aGlzLnRvQXNzaWduYWJsZShsZWZ0KSA6IGxlZnQ7XG4gICAgICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IDA7IC8vIHJlc2V0IGJlY2F1c2Ugc2hvcnRoYW5kIGRlZmF1bHQgd2FzIHVzZWQgY29ycmVjdGx5XG4gICAgICAgICAgICB0aGlzLmNoZWNrTFZhbChsZWZ0KTtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQYXJzZSBhIHRlcm5hcnkgY29uZGl0aW9uYWwgKGA/OmApIG9wZXJhdG9yLlxuXG4gICAgICAgIHBwJDMucGFyc2VNYXliZUNvbmRpdGlvbmFsID0gZnVuY3Rpb24gKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHJldHVybiBleHByO1xuICAgICAgICAgIGlmICh0aGlzLmVhdCh0dC5xdWVzdGlvbikpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICAgICAgICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgICAgICAgdGhpcy5leHBlY3QodHQuY29sb24pO1xuICAgICAgICAgICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTdGFydCB0aGUgcHJlY2VkZW5jZSBwYXJzZXIuXG5cbiAgICAgICAgcHAkMy5wYXJzZUV4cHJPcHMgPSBmdW5jdGlvbiAobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgICAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHJldHVybiBleHByO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgLTEsIG5vSW4pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlIGJpbmFyeSBvcGVyYXRvcnMgd2l0aCB0aGUgb3BlcmF0b3IgcHJlY2VkZW5jZSBwYXJzaW5nXG4gICAgICAgIC8vIGFsZ29yaXRobS4gYGxlZnRgIGlzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgb3BlcmF0b3IuXG4gICAgICAgIC8vIGBtaW5QcmVjYCBwcm92aWRlcyBjb250ZXh0IHRoYXQgYWxsb3dzIHRoZSBmdW5jdGlvbiB0byBzdG9wIGFuZFxuICAgICAgICAvLyBkZWZlciBmdXJ0aGVyIHBhcnNlciB0byBvbmUgb2YgaXRzIGNhbGxlcnMgd2hlbiBpdCBlbmNvdW50ZXJzIGFuXG4gICAgICAgIC8vIG9wZXJhdG9yIHRoYXQgaGFzIGEgbG93ZXIgcHJlY2VkZW5jZSB0aGFuIHRoZSBzZXQgaXQgaXMgcGFyc2luZy5cblxuICAgICAgICBwcCQzLnBhcnNlRXhwck9wID0gZnVuY3Rpb24gKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKSB7XG4gICAgICAgICAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gICAgICAgICAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgdGhpcy50eXBlICE9PSB0dC5faW4pKSB7XG4gICAgICAgICAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgICAgICAgICAgdmFyIGxvZ2ljYWwgPSB0aGlzLnR5cGUgPT09IHR0LmxvZ2ljYWxPUiB8fCB0aGlzLnR5cGUgPT09IHR0LmxvZ2ljYWxBTkQ7XG4gICAgICAgICAgICAgIHZhciBvcCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBub0luKTtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJ1aWxkQmluYXJ5KGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChub2RlLCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9Jbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDMuYnVpbGRCaW5hcnkgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgICAgICAgICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlIHVuYXJ5IG9wZXJhdG9ycywgYm90aCBwcmVmaXggYW5kIHBvc3RmaXguXG5cbiAgICAgICAgcHAkMy5wYXJzZU1heWJlVW5hcnkgPSBmdW5jdGlvbiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgc2F3VW5hcnkpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYyxcbiAgICAgICAgICAgICAgZXhwcjtcbiAgICAgICAgICBpZiAodGhpcy50eXBlLnByZWZpeCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHQuaW5jRGVjO1xuICAgICAgICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBub2RlLnByZWZpeCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZSkgdGhpcy5jaGVja0xWYWwobm9kZS5hcmd1bWVudCk7ZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJiBub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKTtlbHNlIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgcmV0dXJuIGV4cHI7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy50eXBlLnBvc3RmaXggJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUkMSA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgICAgICBub2RlJDEub3BlcmF0b3IgPSB0aGlzJDEudmFsdWU7XG4gICAgICAgICAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgICAgICAgICAgbm9kZSQxLmFyZ3VtZW50ID0gZXhwcjtcbiAgICAgICAgICAgICAgdGhpcyQxLmNoZWNrTFZhbChleHByKTtcbiAgICAgICAgICAgICAgdGhpcyQxLm5leHQoKTtcbiAgICAgICAgICAgICAgZXhwciA9IHRoaXMkMS5maW5pc2hOb2RlKG5vZGUkMSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghc2F3VW5hcnkgJiYgdGhpcy5lYXQodHQuc3RhcnN0YXIpKSByZXR1cm4gdGhpcy5idWlsZEJpbmFyeShzdGFydFBvcywgc3RhcnRMb2MsIGV4cHIsIHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgXCIqKlwiLCBmYWxzZSk7ZWxzZSByZXR1cm4gZXhwcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQYXJzZSBjYWxsLCBkb3QsIGFuZCBgW11gLXN1YnNjcmlwdCBleHByZXNzaW9ucy5cblxuICAgICAgICBwcCQzLnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgICB2YXIgc2tpcEFycm93U3Vic2NyaXB0cyA9IGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva0VuZCkgIT09IFwiKVwiO1xuICAgICAgICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB8fCBza2lwQXJyb3dTdWJzY3JpcHRzKSByZXR1cm4gZXhwcjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQzLnBhcnNlU3Vic2NyaXB0cyA9IGZ1bmN0aW9uIChiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzJDEuZWF0KHR0LmRvdCkpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgICAgICAgICBub2RlLnByb3BlcnR5ID0gdGhpcyQxLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICAgICAgICAgIG5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYmFzZSA9IHRoaXMkMS5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcyQxLmVhdCh0dC5icmFja2V0TCkpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUkMSA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgICAgICBub2RlJDEub2JqZWN0ID0gYmFzZTtcbiAgICAgICAgICAgICAgbm9kZSQxLnByb3BlcnR5ID0gdGhpcyQxLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICBub2RlJDEuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzJDEuZXhwZWN0KHR0LmJyYWNrZXRSKTtcbiAgICAgICAgICAgICAgYmFzZSA9IHRoaXMkMS5maW5pc2hOb2RlKG5vZGUkMSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbm9DYWxscyAmJiB0aGlzJDEuZWF0KHR0LnBhcmVuTCkpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUkMiA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgICAgICBub2RlJDIuY2FsbGVlID0gYmFzZTtcbiAgICAgICAgICAgICAgbm9kZSQyLmFyZ3VtZW50cyA9IHRoaXMkMS5wYXJzZUV4cHJMaXN0KHR0LnBhcmVuUiwgZmFsc2UpO1xuICAgICAgICAgICAgICBiYXNlID0gdGhpcyQxLmZpbmlzaE5vZGUobm9kZSQyLCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzJDEudHlwZSA9PT0gdHQuYmFja1F1b3RlKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlJDMgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgICAgICAgbm9kZSQzLnRhZyA9IGJhc2U7XG4gICAgICAgICAgICAgIG5vZGUkMy5xdWFzaSA9IHRoaXMkMS5wYXJzZVRlbXBsYXRlKCk7XG4gICAgICAgICAgICAgIGJhc2UgPSB0aGlzJDEuZmluaXNoTm9kZShub2RlJDMsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuICAgICAgICAvLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuICAgICAgICAvLyBgbmV3YCwgb3IgYW4gZXhwcmVzc2lvbiB3cmFwcGVkIGluIHB1bmN0dWF0aW9uIGxpa2UgYCgpYCwgYFtdYCxcbiAgICAgICAgLy8gb3IgYHt9YC5cblxuICAgICAgICBwcCQzLnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgIHZhciBub2RlLFxuICAgICAgICAgICAgICBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09IHRoaXMuc3RhcnQ7XG4gICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgdHQuX3N1cGVyOlxuICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5GdW5jdGlvbikgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidzdXBlcicgb3V0c2lkZSBvZiBmdW5jdGlvbiBvciBjbGFzc1wiKTtcblxuICAgICAgICAgICAgY2FzZSB0dC5fdGhpczpcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGUgPT09IHR0Ll90aGlzID8gXCJUaGlzRXhwcmVzc2lvblwiIDogXCJTdXBlclwiO1xuICAgICAgICAgICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG5cbiAgICAgICAgICAgIGNhc2UgdHQubmFtZTpcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50KHRoaXMudHlwZSAhPT0gdHQubmFtZSk7XG4gICAgICAgICAgICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR0LmFycm93KSkgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuXG4gICAgICAgICAgICBjYXNlIHR0LnJlZ2V4cDpcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgbm9kZSA9IHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgbm9kZS5yZWdleCA9IHsgcGF0dGVybjogdmFsdWUucGF0dGVybiwgZmxhZ3M6IHZhbHVlLmZsYWdzIH07XG4gICAgICAgICAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICAgICAgICBjYXNlIHR0Lm51bTpjYXNlIHR0LnN0cmluZzpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpO1xuXG4gICAgICAgICAgICBjYXNlIHR0Ll9udWxsOmNhc2UgdHQuX3RydWU6Y2FzZSB0dC5fZmFsc2U6XG4gICAgICAgICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICBub2RlLnZhbHVlID0gdGhpcy50eXBlID09PSB0dC5fbnVsbCA/IG51bGwgOiB0aGlzLnR5cGUgPT09IHR0Ll90cnVlO1xuICAgICAgICAgICAgICBub2RlLnJhdyA9IHRoaXMudHlwZS5rZXl3b3JkO1xuICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIik7XG5cbiAgICAgICAgICAgIGNhc2UgdHQucGFyZW5MOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKGNhbkJlQXJyb3cpO1xuXG4gICAgICAgICAgICBjYXNlIHR0LmJyYWNrZXRMOlxuICAgICAgICAgICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHQuYnJhY2tldFIsIHRydWUsIHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpO1xuXG4gICAgICAgICAgICBjYXNlIHR0LmJyYWNlTDpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmooZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuXG4gICAgICAgICAgICBjYXNlIHR0Ll9mdW5jdGlvbjpcbiAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgY2FzZSB0dC5fY2xhc3M6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5zdGFydE5vZGUoKSwgZmFsc2UpO1xuXG4gICAgICAgICAgICBjYXNlIHR0Ll9uZXc6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTmV3KCk7XG5cbiAgICAgICAgICAgIGNhc2UgdHQuYmFja1F1b3RlOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKCk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBwcCQzLnBhcnNlTGl0ZXJhbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgbm9kZS5yYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQzLnBhcnNlUGFyZW5FeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHR0LnBhcmVuTCk7XG4gICAgICAgICAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgdGhpcy5leHBlY3QodHQucGFyZW5SKTtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChjYW5CZUFycm93KSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsXG4gICAgICAgICAgICAgIHZhbDtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgICAgICB2YXIgaW5uZXJTdGFydFBvcyA9IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICAgICAgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgICAgICB2YXIgZXhwckxpc3QgPSBbXSxcbiAgICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzKCksXG4gICAgICAgICAgICAgICAgc3ByZWFkU3RhcnQsXG4gICAgICAgICAgICAgICAgaW5uZXJQYXJlblN0YXJ0O1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHQucGFyZW5SKSB7XG4gICAgICAgICAgICAgIGZpcnN0ID8gZmlyc3QgPSBmYWxzZSA6IHRoaXMkMS5leHBlY3QodHQuY29tbWEpO1xuICAgICAgICAgICAgICBpZiAodGhpcyQxLnR5cGUgPT09IHR0LmVsbGlwc2lzKSB7XG4gICAgICAgICAgICAgICAgc3ByZWFkU3RhcnQgPSB0aGlzJDEuc3RhcnQ7XG4gICAgICAgICAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzJDEucGFyc2VQYXJlbkl0ZW0odGhpcyQxLnBhcnNlUmVzdCgpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMkMS50eXBlID09PSB0dC5wYXJlbkwgJiYgIWlubmVyUGFyZW5TdGFydCkge1xuICAgICAgICAgICAgICAgICAgaW5uZXJQYXJlblN0YXJ0ID0gdGhpcyQxLnN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMkMS5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0aGlzJDEucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlubmVyRW5kUG9zID0gdGhpcy5zdGFydCxcbiAgICAgICAgICAgICAgICBpbm5lckVuZExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCh0dC5wYXJlblIpO1xuXG4gICAgICAgICAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0dC5hcnJvdykpIHtcbiAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICAgICAgICAgIGlmIChpbm5lclBhcmVuU3RhcnQpIHRoaXMudW5leHBlY3RlZChpbm5lclBhcmVuU3RhcnQpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBhcmVuQXJyb3dMaXN0KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCkgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICAgICAgICAgIGlmIChzcHJlYWRTdGFydCkgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgICAgICAgICB2YWwuZXhwcmVzc2lvbnMgPSBleHByTGlzdDtcbiAgICAgICAgICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgICAgICAgICB2YXIgcGFyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkMy5wYXJzZVBhcmVuSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkMy5wYXJzZVBhcmVuQXJyb3dMaXN0ID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBOZXcncyBwcmVjZWRlbmNlIGlzIHNsaWdodGx5IHRyaWNreS4gSXQgbXVzdCBhbGxvdyBpdHMgYXJndW1lbnQgdG9cbiAgICAgICAgLy8gYmUgYSBgW11gIG9yIGRvdCBzdWJzY3JpcHQgZXhwcmVzc2lvbiwgYnV0IG5vdCBhIGNhbGwg4oCUIGF0IGxlYXN0LFxuICAgICAgICAvLyBub3Qgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBwYXJlbnRoZXNlcy4gVGh1cywgaXQgdXNlcyB0aGUgbm9DYWxsc1xuICAgICAgICAvLyBhcmd1bWVudCB0byBwYXJzZVN1YnNjcmlwdHMgdG8gcHJldmVudCBpdCBmcm9tIGNvbnN1bWluZyB0aGVcbiAgICAgICAgLy8gYXJndW1lbnQgbGlzdC5cblxuICAgICAgICB2YXIgZW1wdHkkMSA9IFtdO1xuXG4gICAgICAgIHBwJDMucGFyc2VOZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmVhdCh0dC5kb3QpKSB7XG4gICAgICAgICAgICBub2RlLm1ldGEgPSBtZXRhO1xuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgICAgICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwidGFyZ2V0XCIpIHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIG5ldyBpcyBuZXcudGFyZ2V0XCIpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluRnVuY3Rpb24pIHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIm5ldy50YXJnZXQgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnNcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgICAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20oKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCB0cnVlKTtcbiAgICAgICAgICBpZiAodGhpcy5lYXQodHQucGFyZW5MKSkgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHQucGFyZW5SLCBmYWxzZSk7ZWxzZSBub2RlLmFyZ3VtZW50cyA9IGVtcHR5JDE7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGFyc2UgdGVtcGxhdGUgZXhwcmVzc2lvbi5cblxuICAgICAgICBwcCQzLnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csICdcXG4nKSxcbiAgICAgICAgICAgIGNvb2tlZDogdGhpcy52YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgZWxlbS50YWlsID0gdGhpcy50eXBlID09PSB0dC5iYWNrUXVvdGU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQzLnBhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgbm9kZS5leHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgIHZhciBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KCk7XG4gICAgICAgICAgbm9kZS5xdWFzaXMgPSBbY3VyRWx0XTtcbiAgICAgICAgICB3aGlsZSAoIWN1ckVsdC50YWlsKSB7XG4gICAgICAgICAgICB0aGlzJDEuZXhwZWN0KHR0LmRvbGxhckJyYWNlTCk7XG4gICAgICAgICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcyQxLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgIHRoaXMkMS5leHBlY3QodHQuYnJhY2VSKTtcbiAgICAgICAgICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcyQxLnBhcnNlVGVtcGxhdGVFbGVtZW50KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlIGFuIG9iamVjdCBsaXRlcmFsIG9yIGJpbmRpbmcgcGF0dGVybi5cblxuICAgICAgICBwcCQzLnBhcnNlT2JqID0gZnVuY3Rpb24gKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLFxuICAgICAgICAgICAgICBmaXJzdCA9IHRydWUsXG4gICAgICAgICAgICAgIHByb3BIYXNoID0ge307XG4gICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgd2hpbGUgKCF0aGlzLmVhdCh0dC5icmFjZVIpKSB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgIHRoaXMkMS5leHBlY3QodHQuY29tbWEpO1xuICAgICAgICAgICAgICBpZiAodGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYSh0dC5icmFjZVIpKSBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBmaXJzdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgcHJvcCA9IHRoaXMkMS5zdGFydE5vZGUoKSxcbiAgICAgICAgICAgICAgICBpc0dlbmVyYXRvcixcbiAgICAgICAgICAgICAgICBzdGFydFBvcyxcbiAgICAgICAgICAgICAgICBzdGFydExvYztcbiAgICAgICAgICAgIGlmICh0aGlzJDEub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICAgICAgICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgICAgICAgICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChpc1BhdHRlcm4gfHwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gdGhpcyQxLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHN0YXJ0TG9jID0gdGhpcyQxLnN0YXJ0TG9jO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNQYXR0ZXJuKSBpc0dlbmVyYXRvciA9IHRoaXMkMS5lYXQodHQuc3Rhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzJDEucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgICAgICAgICB0aGlzJDEucGFyc2VQcm9wZXJ0eVZhbHVlKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICAgICAgICB0aGlzJDEuY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gpO1xuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2godGhpcyQxLmZpbmlzaE5vZGUocHJvcCwgXCJQcm9wZXJ0eVwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkMy5wYXJzZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiAocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWF0KHR0LmNvbG9uKSkge1xuICAgICAgICAgICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLnR5cGUgPT09IHR0LnBhcmVuTCkge1xuICAgICAgICAgICAgaWYgKGlzUGF0dGVybikgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgICAgICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmIHRoaXMudHlwZSAhPSB0dC5jb21tYSAmJiB0aGlzLnR5cGUgIT0gdHQuYnJhY2VSKSB7XG4gICAgICAgICAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNQYXR0ZXJuKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWU7XG4gICAgICAgICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgICAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoZmFsc2UpO1xuICAgICAgICAgICAgdmFyIHBhcmFtQ291bnQgPSBwcm9wLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgICAgICAgICAgIGlmIChwcm9wLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcHJvcC52YWx1ZS5zdGFydDtcbiAgICAgICAgICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJnZXRcIikgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7ZWxzZSB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJzZXRcIiAmJiBwcm9wLnZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHRoaXMucmFpc2VSZWNvdmVyYWJsZShwcm9wLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KHByb3Aua2V5Lm5hbWUpIHx8ICh0aGlzLnN0cmljdCA/IHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQgOiB0aGlzLnJlc2VydmVkV29yZHMpLnRlc3QocHJvcC5rZXkubmFtZSkgfHwgdGhpcy5pbkdlbmVyYXRvciAmJiBwcm9wLmtleS5uYW1lID09IFwieWllbGRcIikgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHByb3Aua2V5LnN0YXJ0LCBcIidcIiArIHByb3Aua2V5Lm5hbWUgKyBcIicgY2FuIG5vdCBiZSB1c2VkIGFzIHNob3J0aGFuZCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgICAgICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0dC5lcSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgICAgICAgIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24pIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gdGhpcy5zdGFydDtcbiAgICAgICAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcm9wLmtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9wLnZhbHVlID0gcHJvcC5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wLnNob3J0aGFuZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDMucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWF0KHR0LmJyYWNrZXRMKSkge1xuICAgICAgICAgICAgICBwcm9wLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgICAgICAgICAgdGhpcy5leHBlY3QodHQuYnJhY2tldFIpO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcC5rZXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcm9wLmtleSA9IHRoaXMudHlwZSA9PT0gdHQubnVtIHx8IHRoaXMudHlwZSA9PT0gdHQuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBlbXB0eSBmdW5jdGlvbiBub2RlLlxuXG4gICAgICAgIHBwJDMuaW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgICAgIG5vZGUuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IG9yIGNsYXNzIG1ldGhvZC5cblxuICAgICAgICBwcCQzLnBhcnNlTWV0aG9kID0gZnVuY3Rpb24gKGlzR2VuZXJhdG9yKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLFxuICAgICAgICAgICAgICBvbGRJbkdlbiA9IHRoaXMuaW5HZW5lcmF0b3I7XG4gICAgICAgICAgdGhpcy5pbkdlbmVyYXRvciA9IGlzR2VuZXJhdG9yO1xuICAgICAgICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHR0LnBhcmVuTCk7XG4gICAgICAgICAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHQucGFyZW5SLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjtcbiAgICAgICAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW47XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQYXJzZSBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy5cblxuICAgICAgICBwcCQzLnBhcnNlQXJyb3dFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHBhcmFtcykge1xuICAgICAgICAgIHZhciBvbGRJbkdlbiA9IHRoaXMuaW5HZW5lcmF0b3I7XG4gICAgICAgICAgdGhpcy5pbkdlbmVyYXRvciA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgICAgICAgIG5vZGUucGFyYW1zID0gdGhpcy50b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW47XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlIGZ1bmN0aW9uIGJvZHkgYW5kIGNoZWNrIHBhcmFtZXRlcnMuXG5cbiAgICAgICAgcHAkMy5wYXJzZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uIChub2RlLCBpc0Fycm93RnVuY3Rpb24pIHtcbiAgICAgICAgICB2YXIgaXNFeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMudHlwZSAhPT0gdHQuYnJhY2VMO1xuXG4gICAgICAgICAgaWYgKGlzRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICAgICAgICBub2RlLmV4cHJlc3Npb24gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdGFydCBhIG5ldyBzY29wZSB3aXRoIHJlZ2FyZCB0byBsYWJlbHMgYW5kIHRoZSBgaW5GdW5jdGlvbmBcbiAgICAgICAgICAgIC8vIGZsYWcgKHJlc3RvcmUgdGhlbSB0byB0aGVpciBvbGQgdmFsdWUgYWZ0ZXJ3YXJkcykuXG4gICAgICAgICAgICB2YXIgb2xkSW5GdW5jID0gdGhpcy5pbkZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIG9sZExhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgICAgICAgICAgdGhpcy5pbkZ1bmN0aW9uID0gdHJ1ZTt0aGlzLmxhYmVscyA9IFtdO1xuICAgICAgICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKHRydWUpO1xuICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmluRnVuY3Rpb24gPSBvbGRJbkZ1bmM7dGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmljdCBtb2RlIGZ1bmN0aW9uLCB2ZXJpZnkgdGhhdCBhcmd1bWVudCBuYW1lc1xuICAgICAgICAgIC8vIGFyZSBub3QgcmVwZWF0ZWQsIGFuZCBpdCBkb2VzIG5vdCB0cnkgdG8gYmluZCB0aGUgd29yZHMgYGV2YWxgXG4gICAgICAgICAgLy8gb3IgYGFyZ3VtZW50c2AuXG4gICAgICAgICAgdmFyIHVzZVN0cmljdCA9ICFpc0V4cHJlc3Npb24gJiYgbm9kZS5ib2R5LmJvZHkubGVuZ3RoICYmIHRoaXMuaXNVc2VTdHJpY3Qobm9kZS5ib2R5LmJvZHlbMF0pID8gbm9kZS5ib2R5LmJvZHlbMF0gOiBudWxsO1xuICAgICAgICAgIGlmICh0aGlzLnN0cmljdCB8fCB1c2VTdHJpY3QpIHtcbiAgICAgICAgICAgIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdDtcbiAgICAgICAgICAgIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChub2RlLmlkKSB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgdXNlU3RyaWN0KTtcbiAgICAgICAgICAgIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJvd0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIHVzZVN0cmljdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENoZWNrcyBmdW5jdGlvbiBwYXJhbXMgZm9yIHZhcmlvdXMgZGlzYWxsb3dlZCBwYXR0ZXJucyBzdWNoIGFzIHVzaW5nIFwiZXZhbFwiXG4gICAgICAgIC8vIG9yIFwiYXJndW1lbnRzXCIgYW5kIGR1cGxpY2F0ZSBwYXJhbWV0ZXJzLlxuXG4gICAgICAgIHBwJDMuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbiAobm9kZSwgdXNlU3RyaWN0KSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICB2YXIgbmFtZUhhc2ggPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodXNlU3RyaWN0ICYmIHRoaXMkMS5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgbm9kZS5wYXJhbXNbaV0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHRoaXMkMS5yYWlzZVJlY292ZXJhYmxlKHVzZVN0cmljdC5zdGFydCwgXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIpO1xuICAgICAgICAgICAgdGhpcyQxLmNoZWNrTFZhbChub2RlLnBhcmFtc1tpXSwgdHJ1ZSwgbmFtZUhhc2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBleHByZXNzaW9ucywgYW5kIHJldHVybnMgdGhlbSBhc1xuICAgICAgICAvLyBhbiBhcnJheS4gYGNsb3NlYCBpcyB0aGUgdG9rZW4gdHlwZSB0aGF0IGVuZHMgdGhlIGxpc3QsIGFuZFxuICAgICAgICAvLyBgYWxsb3dFbXB0eWAgY2FuIGJlIHR1cm5lZCBvbiB0byBhbGxvdyBzdWJzZXF1ZW50IGNvbW1hcyB3aXRoXG4gICAgICAgIC8vIG5vdGhpbmcgaW4gYmV0d2VlbiB0aGVtIHRvIGJlIHBhcnNlZCBhcyBgbnVsbGAgKHdoaWNoIGlzIG5lZWRlZFxuICAgICAgICAvLyBmb3IgYXJyYXkgbGl0ZXJhbHMpLlxuXG4gICAgICAgIHBwJDMucGFyc2VFeHByTGlzdCA9IGZ1bmN0aW9uIChjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICB2YXIgZWx0cyA9IFtdLFxuICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgdGhpcyQxLmV4cGVjdCh0dC5jb21tYSk7XG4gICAgICAgICAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGZpcnN0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBlbHQ7XG4gICAgICAgICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzJDEudHlwZSA9PT0gdHQuY29tbWEpIGVsdCA9IG51bGw7ZWxzZSBpZiAodGhpcyQxLnR5cGUgPT09IHR0LmVsbGlwc2lzKSB7XG4gICAgICAgICAgICAgIGVsdCA9IHRoaXMkMS5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMkMS50eXBlID09PSB0dC5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmICFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEpIHtcbiAgICAgICAgICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzJDEubGFzdFRva1N0YXJ0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgZWx0ID0gdGhpcyQxLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICAgICAgZWx0cy5wdXNoKGVsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbHRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4gICAgICAgIC8vIHdoZW4gcGFyc2luZyBwcm9wZXJ0aWVzKSwgaXQgd2lsbCBhbHNvIGNvbnZlcnQga2V5d29yZHMgaW50b1xuICAgICAgICAvLyBpZGVudGlmaWVycy5cblxuICAgICAgICBwcCQzLnBhcnNlSWRlbnQgPSBmdW5jdGlvbiAobGliZXJhbCkge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICBpZiAobGliZXJhbCAmJiB0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PSBcIm5ldmVyXCIpIGxpYmVyYWwgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0dC5uYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWxpYmVyYWwgJiYgKHRoaXMuc3RyaWN0ID8gdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0IDogdGhpcy5yZXNlcnZlZFdvcmRzKS50ZXN0KHRoaXMudmFsdWUpICYmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiB8fCB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5pbmRleE9mKFwiXFxcXFwiKSA9PSAtMSkpIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIlRoZSBrZXl3b3JkICdcIiArIHRoaXMudmFsdWUgKyBcIicgaXMgcmVzZXJ2ZWRcIik7XG4gICAgICAgICAgICBpZiAoIWxpYmVyYWwgJiYgdGhpcy5pbkdlbmVyYXRvciAmJiB0aGlzLnZhbHVlID09PSBcInlpZWxkXCIpIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkNhbiBub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3JcIik7XG4gICAgICAgICAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGliZXJhbCAmJiB0aGlzLnR5cGUua2V5d29yZCkge1xuICAgICAgICAgICAgbm9kZS5uYW1lID0gdGhpcy50eXBlLmtleXdvcmQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG4gICAgICAgIHBwJDMucGFyc2VZaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PSB0dC5zZW1pIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgdGhpcy50eXBlICE9IHR0LnN0YXIgJiYgIXRoaXMudHlwZS5zdGFydHNFeHByKSB7XG4gICAgICAgICAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR0LnN0YXIpO1xuICAgICAgICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiWWllbGRFeHByZXNzaW9uXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcCQ0ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmFpc2UgZXhjZXB0aW9ucyBvbiBwYXJzZSBlcnJvcnMuIEl0XG4gICAgICAgIC8vIHRha2VzIGFuIG9mZnNldCBpbnRlZ2VyIChpbnRvIHRoZSBjdXJyZW50IGBpbnB1dGApIHRvIGluZGljYXRlXG4gICAgICAgIC8vIHRoZSBsb2NhdGlvbiBvZiB0aGUgZXJyb3IsIGF0dGFjaGVzIHRoZSBwb3NpdGlvbiB0byB0aGUgZW5kXG4gICAgICAgIC8vIG9mIHRoZSBlcnJvciBtZXNzYWdlLCBhbmQgdGhlbiByYWlzZXMgYSBgU3ludGF4RXJyb3JgIHdpdGggdGhhdFxuICAgICAgICAvLyBtZXNzYWdlLlxuXG4gICAgICAgIHBwJDQucmFpc2UgPSBmdW5jdGlvbiAocG9zLCBtZXNzYWdlKSB7XG4gICAgICAgICAgdmFyIGxvYyA9IGdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHBvcyk7XG4gICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuICAgICAgICAgIHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgZXJyLnBvcyA9IHBvcztlcnIubG9jID0gbG9jO2Vyci5yYWlzZWRBdCA9IHRoaXMucG9zO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQ0LnJhaXNlUmVjb3ZlcmFibGUgPSBwcCQ0LnJhaXNlO1xuXG4gICAgICAgIHBwJDQuY3VyUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBcIlwiO1xuICAgICAgICAgIHRoaXMuc3RhcnQgPSBwb3M7XG4gICAgICAgICAgdGhpcy5lbmQgPSAwO1xuICAgICAgICAgIGlmIChwYXJzZXIub3B0aW9ucy5sb2NhdGlvbnMpIHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHBhcnNlciwgbG9jKTtcbiAgICAgICAgICBpZiAocGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSkgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTtcbiAgICAgICAgICBpZiAocGFyc2VyLm9wdGlvbnMucmFuZ2VzKSB0aGlzLnJhbmdlID0gW3BvcywgMF07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3RhcnQgYW4gQVNUIG5vZGUsIGF0dGFjaGluZyBhIHN0YXJ0IG9mZnNldC5cblxuICAgICAgICB2YXIgcHAkNSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgICAgICAgcHAkNS5zdGFydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDUuc3RhcnROb2RlQXQgPSBmdW5jdGlvbiAocG9zLCBsb2MpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgcG9zLCBsb2MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuICAgICAgICBmdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgICAgICAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIG5vZGUuZW5kID0gcG9zO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSBub2RlLmxvYy5lbmQgPSBsb2M7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIG5vZGUucmFuZ2VbMV0gPSBwb3M7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBwcCQ1LmZpbmlzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSwgdHlwZSkge1xuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCB0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRmluaXNoIG5vZGUgYXQgZ2l2ZW4gcG9zaXRpb25cblxuICAgICAgICBwcCQ1LmZpbmlzaE5vZGVBdCA9IGZ1bmN0aW9uIChub2RlLCB0eXBlLCBwb3MsIGxvYykge1xuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIFRva0NvbnRleHQgPSBmdW5jdGlvbiBUb2tDb250ZXh0KHRva2VuLCBpc0V4cHIsIHByZXNlcnZlU3BhY2UsIG92ZXJyaWRlKSB7XG4gICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgIHRoaXMuaXNFeHByID0gISFpc0V4cHI7XG4gICAgICAgICAgdGhpcy5wcmVzZXJ2ZVNwYWNlID0gISFwcmVzZXJ2ZVNwYWNlO1xuICAgICAgICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdHlwZXMgPSB7XG4gICAgICAgICAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICAgICAgICAgIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICAgICAgICAgIGJfdG1wbDogbmV3IFRva0NvbnRleHQoXCIke1wiLCB0cnVlKSxcbiAgICAgICAgICBwX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCBmYWxzZSksXG4gICAgICAgICAgcF9leHByOiBuZXcgVG9rQ29udGV4dChcIihcIiwgdHJ1ZSksXG4gICAgICAgICAgcV90bXBsOiBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHJldHVybiBwLnJlYWRUbXBsVG9rZW4oKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBmX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHAkNiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgICAgICAgcHAkNi5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gW3R5cGVzLmJfc3RhdF07XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkNi5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbiAocHJldlR5cGUpIHtcbiAgICAgICAgICBpZiAocHJldlR5cGUgPT09IHR0LmNvbG9uKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSB0eXBlcy5iX3N0YXQgfHwgcGFyZW50ID09PSB0eXBlcy5iX2V4cHIpIHJldHVybiAhcGFyZW50LmlzRXhwcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXZUeXBlID09PSB0dC5fcmV0dXJuKSByZXR1cm4gbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKTtcbiAgICAgICAgICBpZiAocHJldlR5cGUgPT09IHR0Ll9lbHNlIHx8IHByZXZUeXBlID09PSB0dC5zZW1pIHx8IHByZXZUeXBlID09PSB0dC5lb2YgfHwgcHJldlR5cGUgPT09IHR0LnBhcmVuUikgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKHByZXZUeXBlID09IHR0LmJyYWNlTCkgcmV0dXJuIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5iX3N0YXQ7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDYudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChwcmV2VHlwZSkge1xuICAgICAgICAgIHZhciB1cGRhdGUsXG4gICAgICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgICAgaWYgKHR5cGUua2V5d29yZCAmJiBwcmV2VHlwZSA9PSB0dC5kb3QpIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtlbHNlIGlmICh1cGRhdGUgPSB0eXBlLnVwZGF0ZUNvbnRleHQpIHVwZGF0ZS5jYWxsKHRoaXMsIHByZXZUeXBlKTtlbHNlIHRoaXMuZXhwckFsbG93ZWQgPSB0eXBlLmJlZm9yZUV4cHI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVG9rZW4tc3BlY2lmaWMgY29udGV4dCB1cGRhdGUgY29kZVxuXG4gICAgICAgIHR0LnBhcmVuUi51cGRhdGVDb250ZXh0ID0gdHQuYnJhY2VSLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgICAgICAgaWYgKG91dCA9PT0gdHlwZXMuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5mX2V4cHIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG91dCA9PT0gdHlwZXMuYl90bXBsKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0dC5icmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChwcmV2VHlwZSkge1xuICAgICAgICAgIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzLmJfc3RhdCA6IHR5cGVzLmJfZXhwcik7XG4gICAgICAgICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdHQuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LnB1c2godHlwZXMuYl90bXBsKTtcbiAgICAgICAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0dC5wYXJlbkwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChwcmV2VHlwZSkge1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRQYXJlbnMgPSBwcmV2VHlwZSA9PT0gdHQuX2lmIHx8IHByZXZUeXBlID09PSB0dC5fZm9yIHx8IHByZXZUeXBlID09PSB0dC5fd2l0aCB8fCBwcmV2VHlwZSA9PT0gdHQuX3doaWxlO1xuICAgICAgICAgIHRoaXMuY29udGV4dC5wdXNoKHN0YXRlbWVudFBhcmVucyA/IHR5cGVzLnBfc3RhdCA6IHR5cGVzLnBfZXhwcik7XG4gICAgICAgICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdHQuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gdG9rRXhwckFsbG93ZWQgc3RheXMgdW5jaGFuZ2VkXG4gICAgICAgIH07XG5cbiAgICAgICAgdHQuX2Z1bmN0aW9uLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAocHJldlR5cGUpIHtcbiAgICAgICAgICBpZiAocHJldlR5cGUuYmVmb3JlRXhwciAmJiBwcmV2VHlwZSAhPT0gdHQuc2VtaSAmJiBwcmV2VHlwZSAhPT0gdHQuX2Vsc2UgJiYgISgocHJldlR5cGUgPT09IHR0LmNvbG9uIHx8IHByZXZUeXBlID09PSB0dC5icmFjZUwpICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5iX3N0YXQpKSB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5mX2V4cHIpO1xuICAgICAgICAgIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0dC5iYWNrUXVvdGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLnFfdG1wbCkgdGhpcy5jb250ZXh0LnBvcCgpO2Vsc2UgdGhpcy5jb250ZXh0LnB1c2godHlwZXMucV90bXBsKTtcbiAgICAgICAgICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gT2JqZWN0IHR5cGUgdXNlZCB0byByZXByZXNlbnQgdG9rZW5zLiBOb3RlIHRoYXQgbm9ybWFsbHksIHRva2Vuc1xuICAgICAgICAvLyBzaW1wbHkgZXhpc3QgYXMgcHJvcGVydGllcyBvbiB0aGUgcGFyc2VyIG9iamVjdC4gVGhpcyBpcyBvbmx5XG4gICAgICAgIC8vIHVzZWQgZm9yIHRoZSBvblRva2VuIGNhbGxiYWNrIGFuZCB0aGUgZXh0ZXJuYWwgdG9rZW5pemVyLlxuXG4gICAgICAgIHZhciBUb2tlbiA9IGZ1bmN0aW9uIFRva2VuKHApIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBwLnR5cGU7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHAudmFsdWU7XG4gICAgICAgICAgdGhpcy5zdGFydCA9IHAuc3RhcnQ7XG4gICAgICAgICAgdGhpcy5lbmQgPSBwLmVuZDtcbiAgICAgICAgICBpZiAocC5vcHRpb25zLmxvY2F0aW9ucykgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocCwgcC5zdGFydExvYywgcC5lbmRMb2MpO1xuICAgICAgICAgIGlmIChwLm9wdGlvbnMucmFuZ2VzKSB0aGlzLnJhbmdlID0gW3Auc3RhcnQsIHAuZW5kXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyAjIyBUb2tlbml6ZXJcblxuICAgICAgICB2YXIgcHAkNyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgICAgICAgLy8gQXJlIHdlIHJ1bm5pbmcgdW5kZXIgUmhpbm8/XG4gICAgICAgIHZhciBpc1JoaW5vID0gKHR5cGVvZiBQYWNrYWdlcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoUGFja2FnZXMpKSA9PSBcIm9iamVjdFwiICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQYWNrYWdlcykgPT0gXCJbb2JqZWN0IEphdmFQYWNrYWdlXVwiO1xuXG4gICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgdG9rZW5cblxuICAgICAgICBwcCQ3Lm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblRva2VuKSB0aGlzLm9wdGlvbnMub25Ub2tlbihuZXcgVG9rZW4odGhpcykpO1xuXG4gICAgICAgICAgdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5lbmQ7XG4gICAgICAgICAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMuZW5kTG9jO1xuICAgICAgICAgIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDcuZ2V0VG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUb2tlbih0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhbiBFUzYgZW52aXJvbm1lbnQsIG1ha2UgcGFyc2VycyBpdGVyYWJsZVxuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIikgcHAkN1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICByZXR1cm4geyBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBzZWxmLmdldFRva2VuKCk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZG9uZTogdG9rZW4udHlwZSA9PT0gdHQuZW9mLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvZ2dsZSBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0byBwbGVhc2VcbiAgICAgICAgLy8gcGVkYW50aWMgdGVzdHMgKGBcInVzZSBzdHJpY3RcIjsgMDEwO2Agc2hvdWxkIGZhaWwpLlxuXG4gICAgICAgIHBwJDcuc2V0U3RyaWN0ID0gZnVuY3Rpb24gKHN0cmljdCkge1xuICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgICAgdGhpcy5zdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHQubnVtICYmIHRoaXMudHlwZSAhPT0gdHQuc3RyaW5nKSByZXR1cm47XG4gICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmxpbmVTdGFydCkge1xuICAgICAgICAgICAgICB0aGlzJDEubGluZVN0YXJ0ID0gdGhpcyQxLmlucHV0Lmxhc3RJbmRleE9mKFwiXFxuXCIsIHRoaXMkMS5saW5lU3RhcnQgLSAyKSArIDE7XG4gICAgICAgICAgICAgIC0tdGhpcyQxLmN1ckxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkNy5jdXJDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlYWQgYSBzaW5nbGUgdG9rZW4sIHVwZGF0aW5nIHRoZSBwYXJzZXIgb2JqZWN0J3MgdG9rZW4tcmVsYXRlZFxuICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuXG4gICAgICAgIHBwJDcubmV4dFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgICAgICAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHRoaXMuc2tpcFNwYWNlKCk7XG5cbiAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG4gICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0dC5lb2YpO1xuXG4gICAgICAgICAgaWYgKGN1ckNvbnRleHQub3ZlcnJpZGUpIHJldHVybiBjdXJDb250ZXh0Lm92ZXJyaWRlKHRoaXMpO2Vsc2UgdGhpcy5yZWFkVG9rZW4odGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQ3LnJlYWRUb2tlbiA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgLy8gSWRlbnRpZmllciBvciBrZXl3b3JkLiAnXFx1WFhYWCcgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIGluXG4gICAgICAgICAgLy8gaWRlbnRpZmllcnMsIHNvICdcXCcgYWxzbyBkaXNwYXRjaGVzIHRvIHRoYXQuXG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB8fCBjb2RlID09PSA5MiAvKiAnXFwnICovKSByZXR1cm4gdGhpcy5yZWFkV29yZCgpO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQ3LmZ1bGxDaGFyQ29kZUF0UG9zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGUwMDApIHJldHVybiBjb2RlO1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgICAgICAgcmV0dXJuIChjb2RlIDw8IDEwKSArIG5leHQgLSAweDM1ZmRjMDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkNy5za2lwQmxvY2tDb21tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgICAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsXG4gICAgICAgICAgICAgIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpO1xuICAgICAgICAgIGlmIChlbmQgPT09IC0xKSB0aGlzLnJhaXNlKHRoaXMucG9zIC0gMiwgXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKTtcbiAgICAgICAgICB0aGlzLnBvcyA9IGVuZCArIDI7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrRy5leGVjKHRoaXMuaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHRoaXMucG9zKSB7XG4gICAgICAgICAgICAgICsrdGhpcyQxLmN1ckxpbmU7XG4gICAgICAgICAgICAgIHRoaXMkMS5saW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpIHRoaXMub3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksIHN0YXJ0LCB0aGlzLnBvcywgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkNy5za2lwTGluZUNvbW1lbnQgPSBmdW5jdGlvbiAoc3RhcnRTa2lwKSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgICAgICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiBjaCAhPT0gMTAgJiYgY2ggIT09IDEzICYmIGNoICE9PSA4MjMyICYmIGNoICE9PSA4MjMzKSB7XG4gICAgICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICAgICAgICBjaCA9IHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudCkgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbGxlZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHBhcnNlIGFuZCBhZnRlciBldmVyeSB0b2tlbi4gU2tpcHNcbiAgICAgICAgLy8gd2hpdGVzcGFjZSBhbmQgY29tbWVudHMsIGFuZC5cblxuICAgICAgICBwcCQ3LnNraXBTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zKTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgY2FzZSAzMjpjYXNlIDE2MDpcbiAgICAgICAgICAgICAgICAvLyAnICdcbiAgICAgICAgICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMTA6Y2FzZSA4MjMyOmNhc2UgODIzMzpcbiAgICAgICAgICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMkMS5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICAgICAgICAgKyt0aGlzJDEuY3VyTGluZTtcbiAgICAgICAgICAgICAgICAgIHRoaXMkMS5saW5lU3RhcnQgPSB0aGlzJDEucG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgICAvLyAnLydcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAgICAgICAgLy8gJyonXG4gICAgICAgICAgICAgICAgICAgIHRoaXMkMS5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcyQxLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2ggPiA4ICYmIGNoIDwgMTQgfHwgY2ggPj0gNTc2MCAmJiBub25BU0NJSXdoaXRlc3BhY2UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpIHtcbiAgICAgICAgICAgICAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHRva2VuLiBTZXRzIGBlbmRgLCBgdmFsYCwgYW5kXG4gICAgICAgIC8vIG1haW50YWlucyBgY29udGV4dGAgYW5kIGBleHByQWxsb3dlZGAsIGFuZCBza2lwcyB0aGUgc3BhY2UgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIHRva2VuLCBzbyB0aGF0IHRoZSBuZXh0IG9uZSdzIGBzdGFydGAgd2lsbCBwb2ludCBhdCB0aGVcbiAgICAgICAgLy8gcmlnaHQgcG9zaXRpb24uXG5cbiAgICAgICAgcHAkNy5maW5pc2hUb2tlbiA9IGZ1bmN0aW9uICh0eXBlLCB2YWwpIHtcbiAgICAgICAgICB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgICAgICAgICB2YXIgcHJldlR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGZldGNoIHRoZSBuZXh0IHRva2VuLiBJdFxuICAgICAgICAvLyBpcyBzb21ld2hhdCBvYnNjdXJlLCBiZWNhdXNlIGl0IHdvcmtzIGluIGNoYXJhY3RlciBjb2RlcyByYXRoZXJcbiAgICAgICAgLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbiAgICAgICAgLy8gaW50byBpdC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuICAgICAgICAvL1xuICAgICAgICBwcCQ3LnJlYWRUb2tlbl9kb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpO1xuICAgICAgICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHtcbiAgICAgICAgICAgIC8vIDQ2ID0gZG90ICcuJ1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LmVsbGlwc2lzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LmRvdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDcucmVhZFRva2VuX3NsYXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICcvJ1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgICAgICAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7cmV0dXJuIHRoaXMucmVhZFJlZ2V4cCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR0LmFzc2lnbiwgMik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHQuc2xhc2gsIDEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDcucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgLy8gJyUqJ1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgICAgICAgdmFyIHNpemUgPSAxO1xuICAgICAgICAgIHZhciB0b2tlbnR5cGUgPSBjb2RlID09PSA0MiA/IHR0LnN0YXIgOiB0dC5tb2R1bG87XG5cbiAgICAgICAgICAvLyBleHBvbmVudGlhdGlvbiBvcGVyYXRvciAqKiBhbmQgKio9XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmIG5leHQgPT09IDQyKSB7XG4gICAgICAgICAgICArK3NpemU7XG4gICAgICAgICAgICB0b2tlbnR5cGUgPSB0dC5zdGFyc3RhcjtcbiAgICAgICAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR0LmFzc2lnbiwgc2l6ZSArIDEpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHRva2VudHlwZSwgc2l6ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkNy5yZWFkVG9rZW5fcGlwZV9hbXAgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIC8vICd8JidcbiAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSBjb2RlKSByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0dC5sb2dpY2FsT1IgOiB0dC5sb2dpY2FsQU5ELCAyKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR0LmFzc2lnbiwgMik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHQuYml0d2lzZU9SIDogdHQuYml0d2lzZUFORCwgMSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkNy5yZWFkVG9rZW5fY2FyZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gJ14nXG4gICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR0LmFzc2lnbiwgMik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHQuYml0d2lzZVhPUiwgMSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkNy5yZWFkVG9rZW5fcGx1c19taW4gPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIC8vICcrLSdcbiAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSA0NSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PSA2MiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5wb3MpKSkge1xuICAgICAgICAgICAgICAvLyBBIGAtLT5gIGxpbmUgY29tbWVudFxuICAgICAgICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgICAgICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0dC5pbmNEZWMsIDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR0LmFzc2lnbiwgMik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHQucGx1c01pbiwgMSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkNy5yZWFkVG9rZW5fbHRfZ3QgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIC8vICc8PidcbiAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgICAgICAgIHZhciBzaXplID0gMTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgICAgICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIHNpemUpID09PSA2MSkgcmV0dXJuIHRoaXMuZmluaXNoT3AodHQuYXNzaWduLCBzaXplICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0dC5iaXRTaGlmdCwgc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXh0ID09IDMzICYmIGNvZGUgPT0gNjAgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT0gNDUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMykgPT0gNDUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluTW9kdWxlKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIC8vIGA8IS0tYCwgYW4gWE1MLXN0eWxlIGNvbW1lbnQgdGhhdCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSBsaW5lIGNvbW1lbnRcbiAgICAgICAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDQpO1xuICAgICAgICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjEpIHNpemUgPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR0LnJlbGF0aW9uYWwsIHNpemUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDcucmVhZFRva2VuX2VxX2V4Y2wgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIC8vICc9ISdcbiAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgICAgICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIHRoaXMuZmluaXNoT3AodHQuZXF1YWxpdHksIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MSA/IDMgOiAyKTtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gNjEgJiYgbmV4dCA9PT0gNjIgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgICAgIC8vICc9PidcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0dC5hcnJvdyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYxID8gdHQuZXEgOiB0dC5wcmVmaXgsIDEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwJDcuZ2V0VG9rZW5Gcm9tQ29kZSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAvLyBUaGUgaW50ZXJwcmV0YXRpb24gb2YgYSBkb3QgZGVwZW5kcyBvbiB3aGV0aGVyIGl0IGlzIGZvbGxvd2VkXG4gICAgICAgICAgICAvLyBieSBhIGRpZ2l0IG9yIGFub3RoZXIgdHdvIGRvdHMuXG4gICAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgICAvLyAnLidcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpO1xuXG4gICAgICAgICAgICAvLyBQdW5jdHVhdGlvbiB0b2tlbnMuXG4gICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICArK3RoaXMucG9zO3JldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LnBhcmVuTCk7XG4gICAgICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgICAgICArK3RoaXMucG9zO3JldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LnBhcmVuUik7XG4gICAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgICArK3RoaXMucG9zO3JldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LnNlbWkpO1xuICAgICAgICAgICAgY2FzZSA0NDpcbiAgICAgICAgICAgICAgKyt0aGlzLnBvcztyZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0dC5jb21tYSk7XG4gICAgICAgICAgICBjYXNlIDkxOlxuICAgICAgICAgICAgICArK3RoaXMucG9zO3JldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LmJyYWNrZXRMKTtcbiAgICAgICAgICAgIGNhc2UgOTM6XG4gICAgICAgICAgICAgICsrdGhpcy5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQuYnJhY2tldFIpO1xuICAgICAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgICAgICsrdGhpcy5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQuYnJhY2VMKTtcbiAgICAgICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgICAgICArK3RoaXMucG9zO3JldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LmJyYWNlUik7XG4gICAgICAgICAgICBjYXNlIDU4OlxuICAgICAgICAgICAgICArK3RoaXMucG9zO3JldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LmNvbG9uKTtcbiAgICAgICAgICAgIGNhc2UgNjM6XG4gICAgICAgICAgICAgICsrdGhpcy5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQucXVlc3Rpb24pO1xuXG4gICAgICAgICAgICBjYXNlIDk2OlxuICAgICAgICAgICAgICAvLyAnYCdcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIGJyZWFrO1xuICAgICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0dC5iYWNrUXVvdGUpO1xuXG4gICAgICAgICAgICBjYXNlIDQ4OlxuICAgICAgICAgICAgICAvLyAnMCdcbiAgICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICAgICAgICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDE2KTsgLy8gJzB4JywgJzBYJyAtIGhleCBudW1iZXJcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpOyAvLyAnMG8nLCAnME8nIC0gb2N0YWwgbnVtYmVyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMik7IC8vICcwYicsICcwQicgLSBiaW5hcnkgbnVtYmVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFueXRoaW5nIGVsc2UgYmVnaW5uaW5nIHdpdGggYSBkaWdpdCBpcyBhbiBpbnRlZ2VyLCBvY3RhbFxuICAgICAgICAgICAgLy8gbnVtYmVyLCBvciBmbG9hdC5cbiAgICAgICAgICAgIGNhc2UgNDk6Y2FzZSA1MDpjYXNlIDUxOmNhc2UgNTI6Y2FzZSA1MzpjYXNlIDU0OmNhc2UgNTU6Y2FzZSA1NjpjYXNlIDU3OlxuICAgICAgICAgICAgICAvLyAxLTlcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZE51bWJlcihmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIFF1b3RlcyBwcm9kdWNlIHN0cmluZ3MuXG4gICAgICAgICAgICBjYXNlIDM0OmNhc2UgMzk6XG4gICAgICAgICAgICAgIC8vICdcIicsIFwiJ1wiXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoY29kZSk7XG5cbiAgICAgICAgICAgIC8vIE9wZXJhdG9ycyBhcmUgcGFyc2VkIGlubGluZSBpbiB0aW55IHN0YXRlIG1hY2hpbmVzLiAnPScgKDYxKSBpc1xuICAgICAgICAgICAgLy8gb2Z0ZW4gcmVmZXJyZWQgdG8uIGBmaW5pc2hPcGAgc2ltcGx5IHNraXBzIHRoZSBhbW91bnQgb2ZcbiAgICAgICAgICAgIC8vIGNoYXJhY3RlcnMgaXQgaXMgZ2l2ZW4gYXMgc2Vjb25kIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhIHRva2VuXG4gICAgICAgICAgICAvLyBvZiB0aGUgdHlwZSBnaXZlbiBieSBpdHMgZmlyc3QgYXJndW1lbnQuXG5cbiAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgIC8vICcvJ1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fc2xhc2goKTtcblxuICAgICAgICAgICAgY2FzZSAzNzpjYXNlIDQyOlxuICAgICAgICAgICAgICAvLyAnJSonXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAoY29kZSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTI0OmNhc2UgMzg6XG4gICAgICAgICAgICAgIC8vICd8JidcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpO1xuXG4gICAgICAgICAgICBjYXNlIDk0OlxuICAgICAgICAgICAgICAvLyAnXidcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2NhcmV0KCk7XG5cbiAgICAgICAgICAgIGNhc2UgNDM6Y2FzZSA0NTpcbiAgICAgICAgICAgICAgLy8gJystJ1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oY29kZSk7XG5cbiAgICAgICAgICAgIGNhc2UgNjA6Y2FzZSA2MjpcbiAgICAgICAgICAgICAgLy8gJzw+J1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSk7XG5cbiAgICAgICAgICAgIGNhc2UgNjE6Y2FzZSAzMzpcbiAgICAgICAgICAgICAgLy8gJz0hJ1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZXFfZXhjbChjb2RlKTtcblxuICAgICAgICAgICAgY2FzZSAxMjY6XG4gICAgICAgICAgICAgIC8vICd+J1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0dC5wcmVmaXgsIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmcoY29kZSkgKyBcIidcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHAkNy5maW5pc2hPcCA9IGZ1bmN0aW9uICh0eXBlLCBzaXplKSB7XG4gICAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgc2l6ZSk7XG4gICAgICAgICAgdGhpcy5wb3MgKz0gc2l6ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCBzdHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlIGEgcmVndWxhciBleHByZXNzaW9uLiBTb21lIGNvbnRleHQtYXdhcmVuZXNzIGlzIG5lY2Vzc2FyeSxcbiAgICAgICAgLy8gc2luY2UgYSAnLycgaW5zaWRlIGEgJ1tdJyBzZXQgZG9lcyBub3QgZW5kIHRoZSBleHByZXNzaW9uLlxuXG4gICAgICAgIGZ1bmN0aW9uIHRyeUNyZWF0ZVJlZ2V4cChzcmMsIGZsYWdzLCB0aHJvd0Vycm9yQXQsIHBhcnNlcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChzcmMsIGZsYWdzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodGhyb3dFcnJvckF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikgcGFyc2VyLnJhaXNlKHRocm93RXJyb3JBdCwgXCJFcnJvciBwYXJzaW5nIHJlZ3VsYXIgZXhwcmVzc2lvbjogXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWdleHBVbmljb2RlU3VwcG9ydCA9ICEhdHJ5Q3JlYXRlUmVnZXhwKCdcXHVGRkZGJywgXCJ1XCIpO1xuXG4gICAgICAgIHBwJDcucmVhZFJlZ2V4cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgIHZhciBlc2NhcGVkLFxuICAgICAgICAgICAgICBpbkNsYXNzLFxuICAgICAgICAgICAgICBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzJDEucG9zID49IHRoaXMkMS5pbnB1dC5sZW5ndGgpIHRoaXMkMS5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpO1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpcyQxLmlucHV0LmNoYXJBdCh0aGlzJDEucG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lQnJlYWsudGVzdChjaCkpIHRoaXMkMS5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpO1xuICAgICAgICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gXCJbXCIpIGluQ2xhc3MgPSB0cnVlO2Vsc2UgaWYgKGNoID09PSBcIl1cIiAmJiBpbkNsYXNzKSBpbkNsYXNzID0gZmFsc2U7ZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSBicmVhaztcbiAgICAgICAgICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICAgICAgICAgIH0gZWxzZSBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgLy8gTmVlZCB0byB1c2UgYHJlYWRXb3JkMWAgYmVjYXVzZSAnXFx1WFhYWCcgc2VxdWVuY2VzIGFyZSBhbGxvd2VkXG4gICAgICAgICAgLy8gaGVyZSAoZG9uJ3QgYXNrKS5cbiAgICAgICAgICB2YXIgbW9kcyA9IHRoaXMucmVhZFdvcmQxKCk7XG4gICAgICAgICAgdmFyIHRtcCA9IGNvbnRlbnQsXG4gICAgICAgICAgICAgIHRtcEZsYWdzID0gXCJcIjtcbiAgICAgICAgICBpZiAobW9kcykge1xuICAgICAgICAgICAgdmFyIHZhbGlkRmxhZ3MgPSAvXltnaW1dKiQvO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB2YWxpZEZsYWdzID0gL15bZ2ltdXldKiQvO1xuICAgICAgICAgICAgaWYgKCF2YWxpZEZsYWdzLnRlc3QobW9kcykpIHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICAgICAgICAgIGlmIChtb2RzLmluZGV4T2YoXCJ1XCIpID49IDApIHtcbiAgICAgICAgICAgICAgaWYgKHJlZ2V4cFVuaWNvZGVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgdG1wRmxhZ3MgPSBcInVcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGVhY2ggYXN0cmFsIHN5bWJvbCBhbmQgZXZlcnkgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgdGhhdFxuICAgICAgICAgICAgICAgIC8vIHBvc3NpYmx5IHJlcHJlc2VudHMgYW4gYXN0cmFsIHN5bWJvbCBvciBhIHBhaXJlZCBzdXJyb2dhdGUgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gc2luZ2xlIEFTQ0lJIHN5bWJvbCB0byBhdm9pZCB0aHJvd2luZyBvbiByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBhcmUgb25seSB2YWxpZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSBgL3VgIGZsYWcuXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogcmVwbGFjaW5nIHdpdGggdGhlIEFTQ0lJIHN5bWJvbCBgeGAgbWlnaHQgY2F1c2UgZmFsc2VcbiAgICAgICAgICAgICAgICAvLyBuZWdhdGl2ZXMgaW4gdW5saWtlbHkgc2NlbmFyaW9zLiBGb3IgZXhhbXBsZSwgYFtcXHV7NjF9LWJdYCBpcyBhXG4gICAgICAgICAgICAgICAgLy8gcGVyZmVjdGx5IHZhbGlkIHBhdHRlcm4gdGhhdCBpcyBlcXVpdmFsZW50IHRvIGBbYS1iXWAsIGJ1dCBpdCB3b3VsZFxuICAgICAgICAgICAgICAgIC8vIGJlIHJlcGxhY2VkIGJ5IGBbeC1iXWAgd2hpY2ggdGhyb3dzIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5yZXBsYWNlKC9cXFxcdVxceyhbMC05YS1mQS1GXSspXFx9L2csIGZ1bmN0aW9uIChfbWF0Y2gsIGNvZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgY29kZSA9IE51bWJlcihcIjB4XCIgKyBjb2RlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHRoaXMkMS5yYWlzZShzdGFydCArIG9mZnNldCArIDMsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwieFwiO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5yZXBsYWNlKC9cXFxcdShbYS1mQS1GMC05XXs0fSl8W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCBcInhcIik7XG4gICAgICAgICAgICAgICAgdG1wRmxhZ3MgPSB0bXBGbGFncy5yZXBsYWNlKFwidVwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgLy8gUmhpbm8ncyByZWd1bGFyIGV4cHJlc3Npb24gcGFyc2VyIGlzIGZsYWt5IGFuZCB0aHJvd3MgdW5jYXRjaGFibGUgZXhjZXB0aW9ucyxcbiAgICAgICAgICAvLyBzbyBkb24ndCBkbyBkZXRlY3Rpb24gaWYgd2UgYXJlIHJ1bm5pbmcgdW5kZXIgUmhpbm9cbiAgICAgICAgICBpZiAoIWlzUmhpbm8pIHtcbiAgICAgICAgICAgIHRyeUNyZWF0ZVJlZ2V4cCh0bXAsIHRtcEZsYWdzLCBzdGFydCwgdGhpcyk7XG4gICAgICAgICAgICAvLyBHZXQgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIHBhdHRlcm4tZmxhZyBwYWlyLCBvciBgbnVsbGAgaW5cbiAgICAgICAgICAgIC8vIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdCB1c2VzLlxuICAgICAgICAgICAgdmFsdWUgPSB0cnlDcmVhdGVSZWdleHAoY29udGVudCwgbW9kcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LnJlZ2V4cCwgeyBwYXR0ZXJuOiBjb250ZW50LCBmbGFnczogbW9kcywgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlYWQgYW4gaW50ZWdlciBpbiB0aGUgZ2l2ZW4gcmFkaXguIFJldHVybiBudWxsIGlmIHplcm8gZGlnaXRzXG4gICAgICAgIC8vIHdlcmUgcmVhZCwgdGhlIGludGVnZXIgdmFsdWUgb3RoZXJ3aXNlLiBXaGVuIGBsZW5gIGlzIGdpdmVuLCB0aGlzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIGBudWxsYCB1bmxlc3MgdGhlIGludGVnZXIgaGFzIGV4YWN0bHkgYGxlbmAgZGlnaXRzLlxuXG4gICAgICAgIHBwJDcucmVhZEludCA9IGZ1bmN0aW9uIChyYWRpeCwgbGVuKSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgdG90YWwgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSB0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zKSxcbiAgICAgICAgICAgICAgICB2YWw7XG4gICAgICAgICAgICBpZiAoY29kZSA+PSA5NykgdmFsID0gY29kZSAtIDk3ICsgMTA7IC8vIGFcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUpIHZhbCA9IGNvZGUgLSA2NSArIDEwOyAvLyBBXG4gICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgdmFsID0gY29kZSAtIDQ4OyAvLyAwLTlcbiAgICAgICAgICAgICAgICBlbHNlIHZhbCA9IEluZmluaXR5O1xuICAgICAgICAgICAgaWYgKHZhbCA+PSByYWRpeCkgYnJlYWs7XG4gICAgICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgdGhpcy5wb3MgLSBzdGFydCAhPT0gbGVuKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgfTtcblxuICAgICAgICBwcCQ3LnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uIChyYWRpeCkge1xuICAgICAgICAgIHRoaXMucG9zICs9IDI7IC8vIDB4XG4gICAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZEludChyYWRpeCk7XG4gICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB0aGlzLnJhaXNlKHRoaXMuc3RhcnQgKyAyLCBcIkV4cGVjdGVkIG51bWJlciBpbiByYWRpeCBcIiArIHJhZGl4KTtcbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0dC5udW0sIHZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVhZCBhbiBpbnRlZ2VyLCBvY3RhbCBpbnRlZ2VyLCBvciBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbiAgICAgICAgcHAkNy5yZWFkTnVtYmVyID0gZnVuY3Rpb24gKHN0YXJ0c1dpdGhEb3QpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgaXNGbG9hdCA9IGZhbHNlLFxuICAgICAgICAgICAgICBvY3RhbCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDQ4O1xuICAgICAgICAgIGlmICghc3RhcnRzV2l0aERvdCAmJiB0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gNDYpIHtcbiAgICAgICAgICAgIC8vICcuJ1xuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgICAgICAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICAgICAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSB7XG4gICAgICAgICAgICAvLyAnZUUnXG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgICAgICAgICAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSArK3RoaXMucG9zOyAvLyAnKy0nXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTtcbiAgICAgICAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTtcblxuICAgICAgICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyksXG4gICAgICAgICAgICAgIHZhbDtcbiAgICAgICAgICBpZiAoaXNGbG9hdCkgdmFsID0gcGFyc2VGbG9hdChzdHIpO2Vsc2UgaWYgKCFvY3RhbCB8fCBzdHIubGVuZ3RoID09PSAxKSB2YWwgPSBwYXJzZUludChzdHIsIDEwKTtlbHNlIGlmICgvWzg5XS8udGVzdChzdHIpIHx8IHRoaXMuc3RyaWN0KSB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO2Vsc2UgdmFsID0gcGFyc2VJbnQoc3RyLCA4KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0dC5udW0sIHZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVhZCBhIHN0cmluZyB2YWx1ZSwgaW50ZXJwcmV0aW5nIGJhY2tzbGFzaC1lc2NhcGVzLlxuXG4gICAgICAgIHBwJDcucmVhZENvZGVQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLFxuICAgICAgICAgICAgICBjb2RlO1xuXG4gICAgICAgICAgaWYgKGNoID09PSAxMjMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnBvcztcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKHRoaXMuaW5wdXQuaW5kZXhPZignfScsIHRoaXMucG9zKSAtIHRoaXMucG9zKTtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB0aGlzLnJhaXNlKGNvZGVQb3MsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcig0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmcoY29kZSkge1xuICAgICAgICAgIC8vIFVURi0xNiBEZWNvZGluZ1xuICAgICAgICAgIGlmIChjb2RlIDw9IDB4RkZGRikgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgY29kZSAtPSAweDEwMDAwO1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4RDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4REMwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcCQ3LnJlYWRTdHJpbmcgPSBmdW5jdGlvbiAocXVvdGUpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgIHZhciBvdXQgPSBcIlwiLFxuICAgICAgICAgICAgICBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvcztcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcyQxLnBvcyA+PSB0aGlzJDEuaW5wdXQubGVuZ3RoKSB0aGlzJDEucmFpc2UodGhpcyQxLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgICAgICAgICAvLyAnXFwnXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzJDEuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcyQxLnBvcyk7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzJDEucmVhZEVzY2FwZWRDaGFyKGZhbHNlKTtcbiAgICAgICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMkMS5wb3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaXNOZXdMaW5lKGNoKSkgdGhpcyQxLnJhaXNlKHRoaXMkMS5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuICAgICAgICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKyspO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LnN0cmluZywgb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZWFkcyB0ZW1wbGF0ZSBzdHJpbmcgdG9rZW5zLlxuXG4gICAgICAgIHBwJDcucmVhZFRtcGxUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICAgIHZhciBvdXQgPSBcIlwiLFxuICAgICAgICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMkMS5wb3MgPj0gdGhpcyQxLmlucHV0Lmxlbmd0aCkgdGhpcyQxLnJhaXNlKHRoaXMkMS5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MgKyAxKSA9PT0gMTIzKSB7XG4gICAgICAgICAgICAgIC8vICdgJywgJyR7J1xuICAgICAgICAgICAgICBpZiAodGhpcyQxLnBvcyA9PT0gdGhpcyQxLnN0YXJ0ICYmIHRoaXMkMS50eXBlID09PSB0dC50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMkMS5wb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzJDEuZmluaXNoVG9rZW4odHQuZG9sbGFyQnJhY2VMKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgKyt0aGlzJDEucG9zO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMkMS5maW5pc2hUb2tlbih0dC5iYWNrUXVvdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gdGhpcyQxLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMkMS5wb3MpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcyQxLmZpbmlzaFRva2VuKHR0LnRlbXBsYXRlLCBvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgICAgICAgICAvLyAnXFwnXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzJDEuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcyQxLnBvcyk7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzJDEucmVhZEVzY2FwZWRDaGFyKHRydWUpO1xuICAgICAgICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICAgICAgICBvdXQgKz0gdGhpcyQxLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMkMS5wb3MpO1xuICAgICAgICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpID09PSAxMCkgKyt0aGlzJDEucG9zO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcyQxLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgKyt0aGlzJDEuY3VyTGluZTtcbiAgICAgICAgICAgICAgICB0aGlzJDEubGluZVN0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXNlZCB0byByZWFkIGVzY2FwZWQgY2hhcmFjdGVyc1xuXG4gICAgICAgIHBwJDcucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24gKGluVGVtcGxhdGUpIHtcbiAgICAgICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICBjYXNlIDExMDpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxuXCI7IC8vICduJyAtPiAnXFxuJ1xuICAgICAgICAgICAgY2FzZSAxMTQ6XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcclwiOyAvLyAncicgLT4gJ1xccidcbiAgICAgICAgICAgIGNhc2UgMTIwOlxuICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKTsgLy8gJ3gnXG4gICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nKHRoaXMucmVhZENvZGVQb2ludCgpKTsgLy8gJ3UnXG4gICAgICAgICAgICBjYXNlIDExNjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFx0XCI7IC8vICd0JyAtPiAnXFx0J1xuICAgICAgICAgICAgY2FzZSA5ODpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxiXCI7IC8vICdiJyAtPiAnXFxiJ1xuICAgICAgICAgICAgY2FzZSAxMTg6XG4gICAgICAgICAgICAgIHJldHVybiAnXFx4MEInOyAvLyAndicgLT4gJ1xcdTAwMGInXG4gICAgICAgICAgICBjYXNlIDEwMjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxmXCI7IC8vICdmJyAtPiAnXFxmJ1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSArK3RoaXMucG9zOyAvLyAnXFxyXFxuJ1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgLy8gJyBcXG4nXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvczsrK3RoaXMuY3VyTGluZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgICAgICAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgICAgICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgICAgICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2N0YWxTdHIgIT09IFwiMFwiICYmICh0aGlzLnN0cmljdCB8fCBpblRlbXBsYXRlKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnBvcyAtIDIsIFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVc2VkIHRvIHJlYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZXMgKCdcXHgnLCAnXFx1JywgJ1xcVScpLlxuXG4gICAgICAgIHBwJDcucmVhZEhleENoYXIgPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgICAgICAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICB2YXIgbiA9IHRoaXMucmVhZEludCgxNiwgbGVuKTtcbiAgICAgICAgICBpZiAobiA9PT0gbnVsbCkgdGhpcy5yYWlzZShjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpO1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlYWQgYW4gaWRlbnRpZmllciwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4gU2V0cyBgdGhpcy5jb250YWluc0VzY2BcbiAgICAgICAgLy8gdG8gd2hldGhlciB0aGUgd29yZCBjb250YWluZWQgYSAnXFx1JyBlc2NhcGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbiAgICAgICAgLy8gYXMgYSBtaWNyby1vcHRpbWl6YXRpb24uXG5cbiAgICAgICAgcHAkNy5yZWFkV29yZDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHdvcmQgPSBcIlwiLFxuICAgICAgICAgICAgICBmaXJzdCA9IHRydWUsXG4gICAgICAgICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgICB2YXIgYXN0cmFsID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gICAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHRoaXMkMS5mdWxsQ2hhckNvZGVBdFBvcygpO1xuICAgICAgICAgICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gsIGFzdHJhbCkpIHtcbiAgICAgICAgICAgICAgdGhpcyQxLnBvcyArPSBjaCA8PSAweGZmZmYgPyAxIDogMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7XG4gICAgICAgICAgICAgIC8vIFwiXFxcIlxuICAgICAgICAgICAgICB0aGlzJDEuY29udGFpbnNFc2MgPSB0cnVlO1xuICAgICAgICAgICAgICB3b3JkICs9IHRoaXMkMS5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzJDEucG9zKTtcbiAgICAgICAgICAgICAgdmFyIGVzY1N0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICAgICAgICAgICAgaWYgKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcyQxLnBvcykgIT0gMTE3KSAvLyBcInVcIlxuICAgICAgICAgICAgICAgIHRoaXMkMS5yYWlzZSh0aGlzJDEucG9zLCAnRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWCcpO1xuICAgICAgICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICAgICAgICAgIHZhciBlc2MgPSB0aGlzJDEucmVhZENvZGVQb2ludCgpO1xuICAgICAgICAgICAgICBpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcikoZXNjLCBhc3RyYWwpKSB0aGlzJDEucmFpc2UoZXNjU3RhcnQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTtcbiAgICAgICAgICAgICAgd29yZCArPSBjb2RlUG9pbnRUb1N0cmluZyhlc2MpO1xuICAgICAgICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdvcmQgKyB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZWFkIGFuIGlkZW50aWZpZXIgb3Iga2V5d29yZCB0b2tlbi4gV2lsbCBjaGVjayBmb3IgcmVzZXJ2ZWRcbiAgICAgICAgLy8gd29yZHMgd2hlbiBuZWNlc3NhcnkuXG5cbiAgICAgICAgcHAkNy5yZWFkV29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgd29yZCA9IHRoaXMucmVhZFdvcmQxKCk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0dC5uYW1lO1xuICAgICAgICAgIGlmICgodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgfHwgIXRoaXMuY29udGFpbnNFc2MpICYmIHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSkgdHlwZSA9IGtleXdvcmRUeXBlc1t3b3JkXTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCB3b3JkKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdmVyc2lvbiA9IFwiMy4zLjBcIjtcblxuICAgICAgICAvLyBUaGUgbWFpbiBleHBvcnRlZCBpbnRlcmZhY2UgKHVuZGVyIGBzZWxmLmFjb3JuYCB3aGVuIGluIHRoZVxuICAgICAgICAvLyBicm93c2VyKSBpcyBhIGBwYXJzZWAgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGNvZGUgc3RyaW5nIGFuZFxuICAgICAgICAvLyByZXR1cm5zIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlIGFzIHNwZWNpZmllZCBieSBbTW96aWxsYSBwYXJzZXJcbiAgICAgICAgLy8gQVBJXVthcGldLlxuICAgICAgICAvL1xuICAgICAgICAvLyBbYXBpXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9TcGlkZXJNb25rZXkvUGFyc2VyX0FQSVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIob3B0aW9ucywgaW5wdXQpLnBhcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHRyaWVzIHRvIHBhcnNlIGEgc2luZ2xlIGV4cHJlc3Npb24gYXQgYSBnaXZlblxuICAgICAgICAvLyBvZmZzZXQgaW4gYSBzdHJpbmcuIFVzZWZ1bCBmb3IgcGFyc2luZyBtaXhlZC1sYW5ndWFnZSBmb3JtYXRzXG4gICAgICAgIC8vIHRoYXQgZW1iZWQgSmF2YVNjcmlwdCBleHByZXNzaW9ucy5cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIHAgPSBuZXcgUGFyc2VyKG9wdGlvbnMsIGlucHV0LCBwb3MpO1xuICAgICAgICAgIHAubmV4dFRva2VuKCk7XG4gICAgICAgICAgcmV0dXJuIHAucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY29ybiBpcyBvcmdhbml6ZWQgYXMgYSB0b2tlbml6ZXIgYW5kIGEgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyLlxuICAgICAgICAvLyBUaGUgYHRva2VuaXplcmAgZXhwb3J0IHByb3ZpZGVzIGFuIGludGVyZmFjZSB0byB0aGUgdG9rZW5pemVyLlxuXG4gICAgICAgIGZ1bmN0aW9uIHRva2VuaXplcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VyKG9wdGlvbnMsIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbiAgICAgICAgZXhwb3J0cy5wYXJzZUV4cHJlc3Npb25BdCA9IHBhcnNlRXhwcmVzc2lvbkF0O1xuICAgICAgICBleHBvcnRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgICAgICAgZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG4gICAgICAgIGV4cG9ydHMucGx1Z2lucyA9IHBsdWdpbnM7XG4gICAgICAgIGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgZXhwb3J0cy5Qb3NpdGlvbiA9IFBvc2l0aW9uO1xuICAgICAgICBleHBvcnRzLlNvdXJjZUxvY2F0aW9uID0gU291cmNlTG9jYXRpb247XG4gICAgICAgIGV4cG9ydHMuZ2V0TGluZUluZm8gPSBnZXRMaW5lSW5mbztcbiAgICAgICAgZXhwb3J0cy5Ob2RlID0gTm9kZTtcbiAgICAgICAgZXhwb3J0cy5Ub2tlblR5cGUgPSBUb2tlblR5cGU7XG4gICAgICAgIGV4cG9ydHMudG9rVHlwZXMgPSB0dDtcbiAgICAgICAgZXhwb3J0cy5Ub2tDb250ZXh0ID0gVG9rQ29udGV4dDtcbiAgICAgICAgZXhwb3J0cy50b2tDb250ZXh0cyA9IHR5cGVzO1xuICAgICAgICBleHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBpc0lkZW50aWZpZXJDaGFyO1xuICAgICAgICBleHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gaXNJZGVudGlmaWVyU3RhcnQ7XG4gICAgICAgIGV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcbiAgICAgICAgZXhwb3J0cy5pc05ld0xpbmUgPSBpc05ld0xpbmU7XG4gICAgICAgIGV4cG9ydHMubGluZUJyZWFrID0gbGluZUJyZWFrO1xuICAgICAgICBleHBvcnRzLmxpbmVCcmVha0cgPSBsaW5lQnJlYWtHO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBhY29ybiQxID0gYWNvcm4gJiYgKHR5cGVvZiBhY29ybiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYWNvcm4pKSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGFjb3JuID8gYWNvcm5bJ2RlZmF1bHQnXSA6IGFjb3JuO1xuXG4gICAgdmFyIHhodG1sID0gX19jb21tb25qcyhmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgcXVvdDogJ1wiJyxcbiAgICAgICAgYW1wOiAnJicsXG4gICAgICAgIGFwb3M6ICdcXCcnLFxuICAgICAgICBsdDogJzwnLFxuICAgICAgICBndDogJz4nLFxuICAgICAgICBuYnNwOiAnXFx4QTAnLFxuICAgICAgICBpZXhjbDogJ1xceEExJyxcbiAgICAgICAgY2VudDogJ1xceEEyJyxcbiAgICAgICAgcG91bmQ6ICdcXHhBMycsXG4gICAgICAgIGN1cnJlbjogJ1xceEE0JyxcbiAgICAgICAgeWVuOiAnXFx4QTUnLFxuICAgICAgICBicnZiYXI6ICdcXHhBNicsXG4gICAgICAgIHNlY3Q6ICdcXHhBNycsXG4gICAgICAgIHVtbDogJ1xceEE4JyxcbiAgICAgICAgY29weTogJ1xceEE5JyxcbiAgICAgICAgb3JkZjogJ1xceEFBJyxcbiAgICAgICAgbGFxdW86ICdcXHhBQicsXG4gICAgICAgIG5vdDogJ1xceEFDJyxcbiAgICAgICAgc2h5OiAnXFx4QUQnLFxuICAgICAgICByZWc6ICdcXHhBRScsXG4gICAgICAgIG1hY3I6ICdcXHhBRicsXG4gICAgICAgIGRlZzogJ1xceEIwJyxcbiAgICAgICAgcGx1c21uOiAnXFx4QjEnLFxuICAgICAgICBzdXAyOiAnXFx4QjInLFxuICAgICAgICBzdXAzOiAnXFx4QjMnLFxuICAgICAgICBhY3V0ZTogJ1xceEI0JyxcbiAgICAgICAgbWljcm86ICdcXHhCNScsXG4gICAgICAgIHBhcmE6ICdcXHhCNicsXG4gICAgICAgIG1pZGRvdDogJ1xceEI3JyxcbiAgICAgICAgY2VkaWw6ICdcXHhCOCcsXG4gICAgICAgIHN1cDE6ICdcXHhCOScsXG4gICAgICAgIG9yZG06ICdcXHhCQScsXG4gICAgICAgIHJhcXVvOiAnXFx4QkInLFxuICAgICAgICBmcmFjMTQ6ICdcXHhCQycsXG4gICAgICAgIGZyYWMxMjogJ1xceEJEJyxcbiAgICAgICAgZnJhYzM0OiAnXFx4QkUnLFxuICAgICAgICBpcXVlc3Q6ICdcXHhCRicsXG4gICAgICAgIEFncmF2ZTogJ1xceEMwJyxcbiAgICAgICAgQWFjdXRlOiAnXFx4QzEnLFxuICAgICAgICBBY2lyYzogJ1xceEMyJyxcbiAgICAgICAgQXRpbGRlOiAnXFx4QzMnLFxuICAgICAgICBBdW1sOiAnXFx4QzQnLFxuICAgICAgICBBcmluZzogJ1xceEM1JyxcbiAgICAgICAgQUVsaWc6ICdcXHhDNicsXG4gICAgICAgIENjZWRpbDogJ1xceEM3JyxcbiAgICAgICAgRWdyYXZlOiAnXFx4QzgnLFxuICAgICAgICBFYWN1dGU6ICdcXHhDOScsXG4gICAgICAgIEVjaXJjOiAnXFx4Q0EnLFxuICAgICAgICBFdW1sOiAnXFx4Q0InLFxuICAgICAgICBJZ3JhdmU6ICdcXHhDQycsXG4gICAgICAgIElhY3V0ZTogJ1xceENEJyxcbiAgICAgICAgSWNpcmM6ICdcXHhDRScsXG4gICAgICAgIEl1bWw6ICdcXHhDRicsXG4gICAgICAgIEVUSDogJ1xceEQwJyxcbiAgICAgICAgTnRpbGRlOiAnXFx4RDEnLFxuICAgICAgICBPZ3JhdmU6ICdcXHhEMicsXG4gICAgICAgIE9hY3V0ZTogJ1xceEQzJyxcbiAgICAgICAgT2NpcmM6ICdcXHhENCcsXG4gICAgICAgIE90aWxkZTogJ1xceEQ1JyxcbiAgICAgICAgT3VtbDogJ1xceEQ2JyxcbiAgICAgICAgdGltZXM6ICdcXHhENycsXG4gICAgICAgIE9zbGFzaDogJ1xceEQ4JyxcbiAgICAgICAgVWdyYXZlOiAnXFx4RDknLFxuICAgICAgICBVYWN1dGU6ICdcXHhEQScsXG4gICAgICAgIFVjaXJjOiAnXFx4REInLFxuICAgICAgICBVdW1sOiAnXFx4REMnLFxuICAgICAgICBZYWN1dGU6ICdcXHhERCcsXG4gICAgICAgIFRIT1JOOiAnXFx4REUnLFxuICAgICAgICBzemxpZzogJ1xceERGJyxcbiAgICAgICAgYWdyYXZlOiAnXFx4RTAnLFxuICAgICAgICBhYWN1dGU6ICdcXHhFMScsXG4gICAgICAgIGFjaXJjOiAnXFx4RTInLFxuICAgICAgICBhdGlsZGU6ICdcXHhFMycsXG4gICAgICAgIGF1bWw6ICdcXHhFNCcsXG4gICAgICAgIGFyaW5nOiAnXFx4RTUnLFxuICAgICAgICBhZWxpZzogJ1xceEU2JyxcbiAgICAgICAgY2NlZGlsOiAnXFx4RTcnLFxuICAgICAgICBlZ3JhdmU6ICdcXHhFOCcsXG4gICAgICAgIGVhY3V0ZTogJ1xceEU5JyxcbiAgICAgICAgZWNpcmM6ICdcXHhFQScsXG4gICAgICAgIGV1bWw6ICdcXHhFQicsXG4gICAgICAgIGlncmF2ZTogJ1xceEVDJyxcbiAgICAgICAgaWFjdXRlOiAnXFx4RUQnLFxuICAgICAgICBpY2lyYzogJ1xceEVFJyxcbiAgICAgICAgaXVtbDogJ1xceEVGJyxcbiAgICAgICAgZXRoOiAnXFx4RjAnLFxuICAgICAgICBudGlsZGU6ICdcXHhGMScsXG4gICAgICAgIG9ncmF2ZTogJ1xceEYyJyxcbiAgICAgICAgb2FjdXRlOiAnXFx4RjMnLFxuICAgICAgICBvY2lyYzogJ1xceEY0JyxcbiAgICAgICAgb3RpbGRlOiAnXFx4RjUnLFxuICAgICAgICBvdW1sOiAnXFx4RjYnLFxuICAgICAgICBkaXZpZGU6ICdcXHhGNycsXG4gICAgICAgIG9zbGFzaDogJ1xceEY4JyxcbiAgICAgICAgdWdyYXZlOiAnXFx4RjknLFxuICAgICAgICB1YWN1dGU6ICdcXHhGQScsXG4gICAgICAgIHVjaXJjOiAnXFx4RkInLFxuICAgICAgICB1dW1sOiAnXFx4RkMnLFxuICAgICAgICB5YWN1dGU6ICdcXHhGRCcsXG4gICAgICAgIHRob3JuOiAnXFx4RkUnLFxuICAgICAgICB5dW1sOiAnXFx4RkYnLFxuICAgICAgICBPRWxpZzogJ1xcdTAxNTInLFxuICAgICAgICBvZWxpZzogJ1xcdTAxNTMnLFxuICAgICAgICBTY2Fyb246ICdcXHUwMTYwJyxcbiAgICAgICAgc2Nhcm9uOiAnXFx1MDE2MScsXG4gICAgICAgIFl1bWw6ICdcXHUwMTc4JyxcbiAgICAgICAgZm5vZjogJ1xcdTAxOTInLFxuICAgICAgICBjaXJjOiAnXFx1MDJDNicsXG4gICAgICAgIHRpbGRlOiAnXFx1MDJEQycsXG4gICAgICAgIEFscGhhOiAnXFx1MDM5MScsXG4gICAgICAgIEJldGE6ICdcXHUwMzkyJyxcbiAgICAgICAgR2FtbWE6ICdcXHUwMzkzJyxcbiAgICAgICAgRGVsdGE6ICdcXHUwMzk0JyxcbiAgICAgICAgRXBzaWxvbjogJ1xcdTAzOTUnLFxuICAgICAgICBaZXRhOiAnXFx1MDM5NicsXG4gICAgICAgIEV0YTogJ1xcdTAzOTcnLFxuICAgICAgICBUaGV0YTogJ1xcdTAzOTgnLFxuICAgICAgICBJb3RhOiAnXFx1MDM5OScsXG4gICAgICAgIEthcHBhOiAnXFx1MDM5QScsXG4gICAgICAgIExhbWJkYTogJ1xcdTAzOUInLFxuICAgICAgICBNdTogJ1xcdTAzOUMnLFxuICAgICAgICBOdTogJ1xcdTAzOUQnLFxuICAgICAgICBYaTogJ1xcdTAzOUUnLFxuICAgICAgICBPbWljcm9uOiAnXFx1MDM5RicsXG4gICAgICAgIFBpOiAnXFx1MDNBMCcsXG4gICAgICAgIFJobzogJ1xcdTAzQTEnLFxuICAgICAgICBTaWdtYTogJ1xcdTAzQTMnLFxuICAgICAgICBUYXU6ICdcXHUwM0E0JyxcbiAgICAgICAgVXBzaWxvbjogJ1xcdTAzQTUnLFxuICAgICAgICBQaGk6ICdcXHUwM0E2JyxcbiAgICAgICAgQ2hpOiAnXFx1MDNBNycsXG4gICAgICAgIFBzaTogJ1xcdTAzQTgnLFxuICAgICAgICBPbWVnYTogJ1xcdTAzQTknLFxuICAgICAgICBhbHBoYTogJ1xcdTAzQjEnLFxuICAgICAgICBiZXRhOiAnXFx1MDNCMicsXG4gICAgICAgIGdhbW1hOiAnXFx1MDNCMycsXG4gICAgICAgIGRlbHRhOiAnXFx1MDNCNCcsXG4gICAgICAgIGVwc2lsb246ICdcXHUwM0I1JyxcbiAgICAgICAgemV0YTogJ1xcdTAzQjYnLFxuICAgICAgICBldGE6ICdcXHUwM0I3JyxcbiAgICAgICAgdGhldGE6ICdcXHUwM0I4JyxcbiAgICAgICAgaW90YTogJ1xcdTAzQjknLFxuICAgICAgICBrYXBwYTogJ1xcdTAzQkEnLFxuICAgICAgICBsYW1iZGE6ICdcXHUwM0JCJyxcbiAgICAgICAgbXU6ICdcXHUwM0JDJyxcbiAgICAgICAgbnU6ICdcXHUwM0JEJyxcbiAgICAgICAgeGk6ICdcXHUwM0JFJyxcbiAgICAgICAgb21pY3JvbjogJ1xcdTAzQkYnLFxuICAgICAgICBwaTogJ1xcdTAzQzAnLFxuICAgICAgICByaG86ICdcXHUwM0MxJyxcbiAgICAgICAgc2lnbWFmOiAnXFx1MDNDMicsXG4gICAgICAgIHNpZ21hOiAnXFx1MDNDMycsXG4gICAgICAgIHRhdTogJ1xcdTAzQzQnLFxuICAgICAgICB1cHNpbG9uOiAnXFx1MDNDNScsXG4gICAgICAgIHBoaTogJ1xcdTAzQzYnLFxuICAgICAgICBjaGk6ICdcXHUwM0M3JyxcbiAgICAgICAgcHNpOiAnXFx1MDNDOCcsXG4gICAgICAgIG9tZWdhOiAnXFx1MDNDOScsXG4gICAgICAgIHRoZXRhc3ltOiAnXFx1MDNEMScsXG4gICAgICAgIHVwc2loOiAnXFx1MDNEMicsXG4gICAgICAgIHBpdjogJ1xcdTAzRDYnLFxuICAgICAgICBlbnNwOiAnXFx1MjAwMicsXG4gICAgICAgIGVtc3A6ICdcXHUyMDAzJyxcbiAgICAgICAgdGhpbnNwOiAnXFx1MjAwOScsXG4gICAgICAgIHp3bmo6ICdcXHUyMDBDJyxcbiAgICAgICAgendqOiAnXFx1MjAwRCcsXG4gICAgICAgIGxybTogJ1xcdTIwMEUnLFxuICAgICAgICBybG06ICdcXHUyMDBGJyxcbiAgICAgICAgbmRhc2g6ICdcXHUyMDEzJyxcbiAgICAgICAgbWRhc2g6ICdcXHUyMDE0JyxcbiAgICAgICAgbHNxdW86ICdcXHUyMDE4JyxcbiAgICAgICAgcnNxdW86ICdcXHUyMDE5JyxcbiAgICAgICAgc2JxdW86ICdcXHUyMDFBJyxcbiAgICAgICAgbGRxdW86ICdcXHUyMDFDJyxcbiAgICAgICAgcmRxdW86ICdcXHUyMDFEJyxcbiAgICAgICAgYmRxdW86ICdcXHUyMDFFJyxcbiAgICAgICAgZGFnZ2VyOiAnXFx1MjAyMCcsXG4gICAgICAgIERhZ2dlcjogJ1xcdTIwMjEnLFxuICAgICAgICBidWxsOiAnXFx1MjAyMicsXG4gICAgICAgIGhlbGxpcDogJ1xcdTIwMjYnLFxuICAgICAgICBwZXJtaWw6ICdcXHUyMDMwJyxcbiAgICAgICAgcHJpbWU6ICdcXHUyMDMyJyxcbiAgICAgICAgUHJpbWU6ICdcXHUyMDMzJyxcbiAgICAgICAgbHNhcXVvOiAnXFx1MjAzOScsXG4gICAgICAgIHJzYXF1bzogJ1xcdTIwM0EnLFxuICAgICAgICBvbGluZTogJ1xcdTIwM0UnLFxuICAgICAgICBmcmFzbDogJ1xcdTIwNDQnLFxuICAgICAgICBldXJvOiAnXFx1MjBBQycsXG4gICAgICAgIGltYWdlOiAnXFx1MjExMScsXG4gICAgICAgIHdlaWVycDogJ1xcdTIxMTgnLFxuICAgICAgICByZWFsOiAnXFx1MjExQycsXG4gICAgICAgIHRyYWRlOiAnXFx1MjEyMicsXG4gICAgICAgIGFsZWZzeW06ICdcXHUyMTM1JyxcbiAgICAgICAgbGFycjogJ1xcdTIxOTAnLFxuICAgICAgICB1YXJyOiAnXFx1MjE5MScsXG4gICAgICAgIHJhcnI6ICdcXHUyMTkyJyxcbiAgICAgICAgZGFycjogJ1xcdTIxOTMnLFxuICAgICAgICBoYXJyOiAnXFx1MjE5NCcsXG4gICAgICAgIGNyYXJyOiAnXFx1MjFCNScsXG4gICAgICAgIGxBcnI6ICdcXHUyMUQwJyxcbiAgICAgICAgdUFycjogJ1xcdTIxRDEnLFxuICAgICAgICByQXJyOiAnXFx1MjFEMicsXG4gICAgICAgIGRBcnI6ICdcXHUyMUQzJyxcbiAgICAgICAgaEFycjogJ1xcdTIxRDQnLFxuICAgICAgICBmb3JhbGw6ICdcXHUyMjAwJyxcbiAgICAgICAgcGFydDogJ1xcdTIyMDInLFxuICAgICAgICBleGlzdDogJ1xcdTIyMDMnLFxuICAgICAgICBlbXB0eTogJ1xcdTIyMDUnLFxuICAgICAgICBuYWJsYTogJ1xcdTIyMDcnLFxuICAgICAgICBpc2luOiAnXFx1MjIwOCcsXG4gICAgICAgIG5vdGluOiAnXFx1MjIwOScsXG4gICAgICAgIG5pOiAnXFx1MjIwQicsXG4gICAgICAgIHByb2Q6ICdcXHUyMjBGJyxcbiAgICAgICAgc3VtOiAnXFx1MjIxMScsXG4gICAgICAgIG1pbnVzOiAnXFx1MjIxMicsXG4gICAgICAgIGxvd2FzdDogJ1xcdTIyMTcnLFxuICAgICAgICByYWRpYzogJ1xcdTIyMUEnLFxuICAgICAgICBwcm9wOiAnXFx1MjIxRCcsXG4gICAgICAgIGluZmluOiAnXFx1MjIxRScsXG4gICAgICAgIGFuZzogJ1xcdTIyMjAnLFxuICAgICAgICBhbmQ6ICdcXHUyMjI3JyxcbiAgICAgICAgb3I6ICdcXHUyMjI4JyxcbiAgICAgICAgY2FwOiAnXFx1MjIyOScsXG4gICAgICAgIGN1cDogJ1xcdTIyMkEnLFxuICAgICAgICAnaW50JzogJ1xcdTIyMkInLFxuICAgICAgICB0aGVyZTQ6ICdcXHUyMjM0JyxcbiAgICAgICAgc2ltOiAnXFx1MjIzQycsXG4gICAgICAgIGNvbmc6ICdcXHUyMjQ1JyxcbiAgICAgICAgYXN5bXA6ICdcXHUyMjQ4JyxcbiAgICAgICAgbmU6ICdcXHUyMjYwJyxcbiAgICAgICAgZXF1aXY6ICdcXHUyMjYxJyxcbiAgICAgICAgbGU6ICdcXHUyMjY0JyxcbiAgICAgICAgZ2U6ICdcXHUyMjY1JyxcbiAgICAgICAgc3ViOiAnXFx1MjI4MicsXG4gICAgICAgIHN1cDogJ1xcdTIyODMnLFxuICAgICAgICBuc3ViOiAnXFx1MjI4NCcsXG4gICAgICAgIHN1YmU6ICdcXHUyMjg2JyxcbiAgICAgICAgc3VwZTogJ1xcdTIyODcnLFxuICAgICAgICBvcGx1czogJ1xcdTIyOTUnLFxuICAgICAgICBvdGltZXM6ICdcXHUyMjk3JyxcbiAgICAgICAgcGVycDogJ1xcdTIyQTUnLFxuICAgICAgICBzZG90OiAnXFx1MjJDNScsXG4gICAgICAgIGxjZWlsOiAnXFx1MjMwOCcsXG4gICAgICAgIHJjZWlsOiAnXFx1MjMwOScsXG4gICAgICAgIGxmbG9vcjogJ1xcdTIzMEEnLFxuICAgICAgICByZmxvb3I6ICdcXHUyMzBCJyxcbiAgICAgICAgbGFuZzogJ1xcdTIzMjknLFxuICAgICAgICByYW5nOiAnXFx1MjMyQScsXG4gICAgICAgIGxvejogJ1xcdTI1Q0EnLFxuICAgICAgICBzcGFkZXM6ICdcXHUyNjYwJyxcbiAgICAgICAgY2x1YnM6ICdcXHUyNjYzJyxcbiAgICAgICAgaGVhcnRzOiAnXFx1MjY2NScsXG4gICAgICAgIGRpYW1zOiAnXFx1MjY2NidcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgcmVxdWlyZSQkMCA9IHhodG1sICYmICh0eXBlb2YgeGh0bWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHhodG1sKSkgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiB4aHRtbCA/IHhodG1sWydkZWZhdWx0J10gOiB4aHRtbDtcblxuICAgIHZhciBpbmplY3QgPSBfX2NvbW1vbmpzKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIFhIVE1MRW50aXRpZXMgPSByZXF1aXJlJCQwO1xuXG4gICAgICB2YXIgaGV4TnVtYmVyID0gL15bXFxkYS1mQS1GXSskLztcbiAgICAgIHZhciBkZWNpbWFsTnVtYmVyID0gL15cXGQrJC87XG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjb3JuKSB7XG4gICAgICAgIHZhciB0dCA9IGFjb3JuLnRva1R5cGVzO1xuICAgICAgICB2YXIgdGMgPSBhY29ybi50b2tDb250ZXh0cztcblxuICAgICAgICB0Yy5qX29UYWcgPSBuZXcgYWNvcm4uVG9rQ29udGV4dCgnPHRhZycsIGZhbHNlKTtcbiAgICAgICAgdGMual9jVGFnID0gbmV3IGFjb3JuLlRva0NvbnRleHQoJzwvdGFnJywgZmFsc2UpO1xuICAgICAgICB0Yy5qX2V4cHIgPSBuZXcgYWNvcm4uVG9rQ29udGV4dCgnPHRhZz4uLi48L3RhZz4nLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICB0dC5qc3hOYW1lID0gbmV3IGFjb3JuLlRva2VuVHlwZSgnanN4TmFtZScpO1xuICAgICAgICB0dC5qc3hUZXh0ID0gbmV3IGFjb3JuLlRva2VuVHlwZSgnanN4VGV4dCcsIHsgYmVmb3JlRXhwcjogdHJ1ZSB9KTtcbiAgICAgICAgdHQuanN4VGFnU3RhcnQgPSBuZXcgYWNvcm4uVG9rZW5UeXBlKCdqc3hUYWdTdGFydCcpO1xuICAgICAgICB0dC5qc3hUYWdFbmQgPSBuZXcgYWNvcm4uVG9rZW5UeXBlKCdqc3hUYWdFbmQnKTtcblxuICAgICAgICB0dC5qc3hUYWdTdGFydC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuY29udGV4dC5wdXNoKHRjLmpfZXhwcik7IC8vIHRyZWF0IGFzIGJlZ2lubmluZyBvZiBKU1ggZXhwcmVzc2lvblxuICAgICAgICAgIHRoaXMuY29udGV4dC5wdXNoKHRjLmpfb1RhZyk7IC8vIHN0YXJ0IG9wZW5pbmcgdGFnIGNvbnRleHRcbiAgICAgICAgICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHR0LmpzeFRhZ0VuZC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKHByZXZUeXBlKSB7XG4gICAgICAgICAgdmFyIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICAgICAgICBpZiAob3V0ID09PSB0Yy5qX29UYWcgJiYgcHJldlR5cGUgPT09IHR0LnNsYXNoIHx8IG91dCA9PT0gdGMual9jVGFnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgICAgICAgICB0aGlzLmV4cHJBbGxvd2VkID0gdGhpcy5jdXJDb250ZXh0KCkgPT09IHRjLmpfZXhwcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcCA9IGFjb3JuLlBhcnNlci5wcm90b3R5cGU7XG5cbiAgICAgICAgLy8gUmVhZHMgaW5saW5lIEpTWCBjb250ZW50cyB0b2tlbi5cblxuICAgICAgICBwcC5qc3hfcmVhZFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBvdXQgPSAnJyxcbiAgICAgICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCAnVW50ZXJtaW5hdGVkIEpTWCBjb250ZW50cycpO1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcblxuICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICBjYXNlIDYwOiAvLyAnPCdcbiAgICAgICAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgICAgICAgLy8gJ3snXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDYwICYmIHRoaXMuZXhwckFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQuanN4VGFnU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Gcm9tQ29kZShjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0dC5qc3hUZXh0LCBvdXQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgICAgLy8gJyYnXG4gICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLmpzeF9yZWFkRW50aXR5KCk7XG4gICAgICAgICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGFjb3JuLmlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLmpzeF9yZWFkTmV3TGluZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHBwLmpzeF9yZWFkTmV3TGluZSA9IGZ1bmN0aW9uIChub3JtYWxpemVDUkxGKSB7XG4gICAgICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgICB2YXIgb3V0O1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgaWYgKGNoID09PSAxMyAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkge1xuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgIG91dCA9IG5vcm1hbGl6ZUNSTEYgPyAnXFxuJyA6ICdcXHJcXG4nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwLmpzeF9yZWFkU3RyaW5nID0gZnVuY3Rpb24gKHF1b3RlKSB7XG4gICAgICAgICAgdmFyIG91dCA9ICcnLFxuICAgICAgICAgICAgICBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvcztcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHRoaXMucmFpc2UodGhpcy5zdGFydCwgJ1VudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnQnKTtcbiAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSBicmVhaztcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMzgpIHtcbiAgICAgICAgICAgICAgLy8gJyYnXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMuanN4X3JlYWRFbnRpdHkoKTtcbiAgICAgICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhY29ybi5pc05ld0xpbmUoY2gpKSB7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMuanN4X3JlYWROZXdMaW5lKGZhbHNlKTtcbiAgICAgICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MrKyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQuc3RyaW5nLCBvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHBwLmpzeF9yZWFkRW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdHIgPSAnJyxcbiAgICAgICAgICAgICAgY291bnQgPSAwLFxuICAgICAgICAgICAgICBlbnRpdHk7XG4gICAgICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dFt0aGlzLnBvc107XG4gICAgICAgICAgaWYgKGNoICE9PSAnJicpIHRoaXMucmFpc2UodGhpcy5wb3MsICdFbnRpdHkgbXVzdCBzdGFydCB3aXRoIGFuIGFtcGVyc2FuZCcpO1xuICAgICAgICAgIHZhciBzdGFydFBvcyA9ICsrdGhpcy5wb3M7XG4gICAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgY291bnQrKyA8IDEwKSB7XG4gICAgICAgICAgICBjaCA9IHRoaXMuaW5wdXRbdGhpcy5wb3MrK107XG4gICAgICAgICAgICBpZiAoY2ggPT09ICc7Jykge1xuICAgICAgICAgICAgICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyWzFdID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMik7XG4gICAgICAgICAgICAgICAgICBpZiAoaGV4TnVtYmVyLnRlc3Qoc3RyKSkgZW50aXR5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzdHIsIDE2KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICBpZiAoZGVjaW1hbE51bWJlci50ZXN0KHN0cikpIGVudGl0eSA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoc3RyLCAxMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSBYSFRNTEVudGl0aWVzW3N0cl07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zO1xuICAgICAgICAgICAgcmV0dXJuICcmJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZWFkIGEgSlNYIGlkZW50aWZpZXIgKHZhbGlkIHRhZyBvciBhdHRyaWJ1dGUgbmFtZSkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE9wdGltaXplZCB2ZXJzaW9uIHNpbmNlIEpTWCBpZGVudGlmaWVycyBjYW4ndCBjb250YWluXG4gICAgICAgIC8vIGVzY2FwZSBjaGFyYWN0ZXJzIGFuZCBzbyBjYW4gYmUgcmVhZCBhcyBzaW5nbGUgc2xpY2UuXG4gICAgICAgIC8vIEFsc28gYXNzdW1lcyB0aGF0IGZpcnN0IGNoYXJhY3RlciB3YXMgYWxyZWFkeSBjaGVja2VkXG4gICAgICAgIC8vIGJ5IGlzSWRlbnRpZmllclN0YXJ0IGluIHJlYWRUb2tlbi5cblxuICAgICAgICBwcC5qc3hfcmVhZFdvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGNoLFxuICAgICAgICAgICAgICBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgICAgICAgIH0gd2hpbGUgKGFjb3JuLmlzSWRlbnRpZmllckNoYXIoY2gpIHx8IGNoID09PSA0NSk7IC8vICctJ1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LmpzeE5hbWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtcyBKU1ggZWxlbWVudCBuYW1lIHRvIHN0cmluZy5cblxuICAgICAgICBmdW5jdGlvbiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QudHlwZSA9PT0gJ0pTWElkZW50aWZpZXInKSByZXR1cm4gb2JqZWN0Lm5hbWU7XG5cbiAgICAgICAgICBpZiAob2JqZWN0LnR5cGUgPT09ICdKU1hOYW1lc3BhY2VkTmFtZScpIHJldHVybiBvYmplY3QubmFtZXNwYWNlLm5hbWUgKyAnOicgKyBvYmplY3QubmFtZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKG9iamVjdC50eXBlID09PSAnSlNYTWVtYmVyRXhwcmVzc2lvbicpIHJldHVybiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5vYmplY3QpICsgJy4nICsgZ2V0UXVhbGlmaWVkSlNYTmFtZShvYmplY3QucHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyc2UgbmV4dCB0b2tlbiBhcyBKU1ggaWRlbnRpZmllclxuXG4gICAgICAgIHBwLmpzeF9wYXJzZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR0LmpzeE5hbWUpIG5vZGUubmFtZSA9IHRoaXMudmFsdWU7ZWxzZSBpZiAodGhpcy50eXBlLmtleXdvcmQpIG5vZGUubmFtZSA9IHRoaXMudHlwZS5rZXl3b3JkO2Vsc2UgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCAnSlNYSWRlbnRpZmllcicpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlIG5hbWVzcGFjZWQgaWRlbnRpZmllci5cblxuICAgICAgICBwcC5qc3hfcGFyc2VOYW1lc3BhY2VkTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmpzeF9wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wbHVnaW5zLmpzeC5hbGxvd05hbWVzcGFjZXMgfHwgIXRoaXMuZWF0KHR0LmNvbG9uKSkgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgICAgbm9kZS5uYW1lc3BhY2UgPSBuYW1lO1xuICAgICAgICAgIG5vZGUubmFtZSA9IHRoaXMuanN4X3BhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgJ0pTWE5hbWVzcGFjZWROYW1lJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGFyc2VzIGVsZW1lbnQgbmFtZSBpbiBhbnkgZm9ybSAtIG5hbWVzcGFjZWQsIG1lbWJlclxuICAgICAgICAvLyBvciBzaW5nbGUgaWRlbnRpZmllci5cblxuICAgICAgICBwcC5qc3hfcGFyc2VFbGVtZW50TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmpzeF9wYXJzZU5hbWVzcGFjZWROYW1lKCk7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHQuZG90ICYmIG5vZGUudHlwZSA9PT0gJ0pTWE5hbWVzcGFjZWROYW1lJyAmJiAhdGhpcy5vcHRpb25zLnBsdWdpbnMuanN4LmFsbG93TmFtZXNwYWNlZE9iamVjdHMpIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAodGhpcy5lYXQodHQuZG90KSkge1xuICAgICAgICAgICAgdmFyIG5ld05vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgICAgICBuZXdOb2RlLm9iamVjdCA9IG5vZGU7XG4gICAgICAgICAgICBuZXdOb2RlLnByb3BlcnR5ID0gdGhpcy5qc3hfcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5maW5pc2hOb2RlKG5ld05vZGUsICdKU1hNZW1iZXJFeHByZXNzaW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlcyBhbnkgdHlwZSBvZiBKU1ggYXR0cmlidXRlIHZhbHVlLlxuXG4gICAgICAgIHBwLmpzeF9wYXJzZUF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIHR0LmJyYWNlTDpcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmpzeF9wYXJzZUV4cHJlc3Npb25Db250YWluZXIoKTtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSAnSlNYRW1wdHlFeHByZXNzaW9uJykgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCAnSlNYIGF0dHJpYnV0ZXMgbXVzdCBvbmx5IGJlIGFzc2lnbmVkIGEgbm9uLWVtcHR5IGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICAgICAgICAgIGNhc2UgdHQuanN4VGFnU3RhcnQ6XG4gICAgICAgICAgICBjYXNlIHR0LnN0cmluZzpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByQXRvbSgpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsICdKU1ggdmFsdWUgc2hvdWxkIGJlIGVpdGhlciBhbiBleHByZXNzaW9uIG9yIGEgcXVvdGVkIEpTWCB0ZXh0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEpTWEVtcHR5RXhwcmVzc2lvbiBpcyB1bmlxdWUgdHlwZSBzaW5jZSBpdCBkb2Vzbid0IGFjdHVhbGx5IHBhcnNlIGFueXRoaW5nLFxuICAgICAgICAvLyBhbmQgc28gaXQgc2hvdWxkIHN0YXJ0IGF0IHRoZSBlbmQgb2YgbGFzdCByZWFkIHRva2VuIChsZWZ0IGJyYWNlKSBhbmQgZmluaXNoXG4gICAgICAgIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgb25lIChyaWdodCBicmFjZSkuXG5cbiAgICAgICAgcHAuanN4X3BhcnNlRW1wdHlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdCh0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KG5vZGUsICdKU1hFbXB0eUV4cHJlc3Npb24nLCB0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQYXJzZXMgSlNYIGV4cHJlc3Npb24gZW5jbG9zZWQgaW50byBjdXJseSBicmFja2V0cy5cblxuXG4gICAgICAgIHBwLmpzeF9wYXJzZUV4cHJlc3Npb25Db250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMudHlwZSA9PT0gdHQuYnJhY2VSID8gdGhpcy5qc3hfcGFyc2VFbXB0eUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgdGhpcy5leHBlY3QodHQuYnJhY2VSKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsICdKU1hFeHByZXNzaW9uQ29udGFpbmVyJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGFyc2VzIGZvbGxvd2luZyBKU1ggYXR0cmlidXRlIG5hbWUtdmFsdWUgcGFpci5cblxuICAgICAgICBwcC5qc3hfcGFyc2VBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIGlmICh0aGlzLmVhdCh0dC5icmFjZUwpKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCh0dC5lbGxpcHNpcyk7XG4gICAgICAgICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCh0dC5icmFjZVIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCAnSlNYU3ByZWFkQXR0cmlidXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUubmFtZSA9IHRoaXMuanN4X3BhcnNlTmFtZXNwYWNlZE5hbWUoKTtcbiAgICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5lYXQodHQuZXEpID8gdGhpcy5qc3hfcGFyc2VBdHRyaWJ1dGVWYWx1ZSgpIDogbnVsbDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsICdKU1hBdHRyaWJ1dGUnKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQYXJzZXMgSlNYIG9wZW5pbmcgdGFnIHN0YXJ0aW5nIGFmdGVyICc8Jy5cblxuICAgICAgICBwcC5qc3hfcGFyc2VPcGVuaW5nRWxlbWVudEF0ID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBzdGFydExvYykge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgIG5vZGUuYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICAgIG5vZGUubmFtZSA9IHRoaXMuanN4X3BhcnNlRWxlbWVudE5hbWUoKTtcbiAgICAgICAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0dC5zbGFzaCAmJiB0aGlzLnR5cGUgIT09IHR0LmpzeFRhZ0VuZCkge1xuICAgICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnB1c2godGhpcy5qc3hfcGFyc2VBdHRyaWJ1dGUoKSk7XG4gICAgICAgICAgfW5vZGUuc2VsZkNsb3NpbmcgPSB0aGlzLmVhdCh0dC5zbGFzaCk7XG4gICAgICAgICAgdGhpcy5leHBlY3QodHQuanN4VGFnRW5kKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsICdKU1hPcGVuaW5nRWxlbWVudCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlcyBKU1ggY2xvc2luZyB0YWcgc3RhcnRpbmcgYWZ0ZXIgJzwvJy5cblxuICAgICAgICBwcC5qc3hfcGFyc2VDbG9zaW5nRWxlbWVudEF0ID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBzdGFydExvYykge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgIG5vZGUubmFtZSA9IHRoaXMuanN4X3BhcnNlRWxlbWVudE5hbWUoKTtcbiAgICAgICAgICB0aGlzLmV4cGVjdCh0dC5qc3hUYWdFbmQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgJ0pTWENsb3NpbmdFbGVtZW50Jyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGFyc2VzIGVudGlyZSBKU1ggZWxlbWVudCwgaW5jbHVkaW5nIGl0J3Mgb3BlbmluZyB0YWdcbiAgICAgICAgLy8gKHN0YXJ0aW5nIGFmdGVyICc8JyksIGF0dHJpYnV0ZXMsIGNvbnRlbnRzIGFuZCBjbG9zaW5nIHRhZy5cblxuICAgICAgICBwcC5qc3hfcGFyc2VFbGVtZW50QXQgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgICAgdmFyIG9wZW5pbmdFbGVtZW50ID0gdGhpcy5qc3hfcGFyc2VPcGVuaW5nRWxlbWVudEF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgICAgdmFyIGNsb3NpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgICAgICAgIGlmICghb3BlbmluZ0VsZW1lbnQuc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0dC5qc3hUYWdTdGFydDpcbiAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGFydDtzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVhdCh0dC5zbGFzaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2luZ0VsZW1lbnQgPSB0aGlzLmpzeF9wYXJzZUNsb3NpbmdFbGVtZW50QXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgY29udGVudHM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuanN4X3BhcnNlRWxlbWVudEF0KHN0YXJ0UG9zLCBzdGFydExvYykpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIHR0LmpzeFRleHQ6XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMucGFyc2VFeHByQXRvbSgpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSB0dC5icmFjZUw6XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuanN4X3BhcnNlRXhwcmVzc2lvbkNvbnRhaW5lcigpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UXVhbGlmaWVkSlNYTmFtZShjbG9zaW5nRWxlbWVudC5uYW1lKSAhPT0gZ2V0UXVhbGlmaWVkSlNYTmFtZShvcGVuaW5nRWxlbWVudC5uYW1lKSkge1xuICAgICAgICAgICAgICB0aGlzLnJhaXNlKGNsb3NpbmdFbGVtZW50LnN0YXJ0LCAnRXhwZWN0ZWQgY29ycmVzcG9uZGluZyBKU1ggY2xvc2luZyB0YWcgZm9yIDwnICsgZ2V0UXVhbGlmaWVkSlNYTmFtZShvcGVuaW5nRWxlbWVudC5uYW1lKSArICc+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZS5vcGVuaW5nRWxlbWVudCA9IG9wZW5pbmdFbGVtZW50O1xuICAgICAgICAgIG5vZGUuY2xvc2luZ0VsZW1lbnQgPSBjbG9zaW5nRWxlbWVudDtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHQucmVsYXRpb25hbCAmJiB0aGlzLnZhbHVlID09PSBcIjxcIikge1xuICAgICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkFkamFjZW50IEpTWCBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gYW4gZW5jbG9zaW5nIHRhZ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCAnSlNYRWxlbWVudCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlcyBlbnRpcmUgSlNYIGVsZW1lbnQgZnJvbSBjdXJyZW50IHBvc2l0aW9uLlxuXG4gICAgICAgIHBwLmpzeF9wYXJzZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCxcbiAgICAgICAgICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmpzeF9wYXJzZUVsZW1lbnRBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFjb3JuLnBsdWdpbnMuanN4ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRzKSB7XG4gICAgICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCh0eXBlb2Ygb3B0cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0cykpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluc3RhbmNlLm9wdGlvbnMucGx1Z2lucy5qc3ggPSB7XG4gICAgICAgICAgICBhbGxvd05hbWVzcGFjZXM6IG9wdHMuYWxsb3dOYW1lc3BhY2VzICE9PSBmYWxzZSxcbiAgICAgICAgICAgIGFsbG93TmFtZXNwYWNlZE9iamVjdHM6ICEhb3B0cy5hbGxvd05hbWVzcGFjZWRPYmplY3RzXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGluc3RhbmNlLmV4dGVuZCgncGFyc2VFeHByQXRvbScsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZWZTaG9ydEhhbmREZWZhdWx0UG9zKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR0LmpzeFRleHQpIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnZhbHVlKTtlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR0LmpzeFRhZ1N0YXJ0KSByZXR1cm4gdGhpcy5qc3hfcGFyc2VFbGVtZW50KCk7ZWxzZSByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCByZWZTaG9ydEhhbmREZWZhdWx0UG9zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpbnN0YW5jZS5leHRlbmQoJ3JlYWRUb2tlbicsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbnRleHQgPT09IHRjLmpfZXhwcikgcmV0dXJuIHRoaXMuanN4X3JlYWRUb2tlbigpO1xuXG4gICAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSB0Yy5qX29UYWcgfHwgY29udGV4dCA9PT0gdGMual9jVGFnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjb3JuLmlzSWRlbnRpZmllclN0YXJ0KGNvZGUpKSByZXR1cm4gdGhpcy5qc3hfcmVhZFdvcmQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb2RlID09IDYyKSB7XG4gICAgICAgICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQuanN4VGFnRW5kKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoKGNvZGUgPT09IDM0IHx8IGNvZGUgPT09IDM5KSAmJiBjb250ZXh0ID09IHRjLmpfb1RhZykgcmV0dXJuIHRoaXMuanN4X3JlYWRTdHJpbmcoY29kZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gNjAgJiYgdGhpcy5leHByQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQuanN4VGFnU3RhcnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIGNvZGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGluc3RhbmNlLmV4dGVuZCgndXBkYXRlQ29udGV4dCcsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcmV2VHlwZSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09IHR0LmJyYWNlTCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1ckNvbnRleHQgPT0gdGMual9vVGFnKSB0aGlzLmNvbnRleHQucHVzaCh0Yy5iX2V4cHIpO2Vsc2UgaWYgKGN1ckNvbnRleHQgPT0gdGMual9leHByKSB0aGlzLmNvbnRleHQucHVzaCh0Yy5iX3RtcGwpO2Vsc2UgaW5uZXIuY2FsbCh0aGlzLCBwcmV2VHlwZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0dC5zbGFzaCAmJiBwcmV2VHlwZSA9PT0gdHQuanN4VGFnU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQubGVuZ3RoIC09IDI7IC8vIGRvIG5vdCBjb25zaWRlciBKU1ggZXhwciAtPiBKU1ggb3BlbiB0YWcgLT4gLi4uIGFueW1vcmVcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucHVzaCh0Yy5qX2NUYWcpOyAvLyByZWNvbnNpZGVyIGFzIGNsb3NpbmcgdGFnIGNvbnRleHRcbiAgICAgICAgICAgICAgICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyLmNhbGwodGhpcywgcHJldlR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBhY29ybjtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgYWNvcm5Kc3ggPSBpbmplY3QgJiYgKHR5cGVvZiBpbmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGluamVjdCkpID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gaW5qZWN0ID8gaW5qZWN0WydkZWZhdWx0J10gOiBpbmplY3Q7XG5cbiAgICB2YXIgaW5qZWN0JDEgPSBfX2NvbW1vbmpzKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWNvcm4pIHtcbiAgICAgICAgdmFyIHR0ID0gYWNvcm4udG9rVHlwZXM7XG4gICAgICAgIHZhciBwcCA9IGFjb3JuLlBhcnNlci5wcm90b3R5cGU7XG5cbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBwYXJzZU9iaiB0aGF0IGFjb3JuIGhhcyB3aXRoLi4uXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlT2JqKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLFxuICAgICAgICAgICAgICBmaXJzdCA9IHRydWUsXG4gICAgICAgICAgICAgIHByb3BIYXNoID0ge307XG4gICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgd2hpbGUgKCF0aGlzJDEuZWF0KHR0LmJyYWNlUikpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgdGhpcyQxLmV4cGVjdCh0dC5jb21tYSk7XG4gICAgICAgICAgICAgIGlmICh0aGlzJDEuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR0LmJyYWNlUikpIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGZpcnN0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBwcm9wID0gdGhpcyQxLnN0YXJ0Tm9kZSgpLFxuICAgICAgICAgICAgICAgIGlzR2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHN0YXJ0UG9zLFxuICAgICAgICAgICAgICAgIHN0YXJ0TG9jO1xuICAgICAgICAgICAgaWYgKHRoaXMkMS5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgICAgICAgLy8gLi4udGhlIHNwcmVhZCBsb2dpYyBib3Jyb3dlZCBmcm9tIGJhYnlsb24gOilcbiAgICAgICAgICAgICAgaWYgKHRoaXMkMS50eXBlID09PSB0dC5lbGxpcHNpcykge1xuICAgICAgICAgICAgICAgIHByb3AgPSB0aGlzJDEucGFyc2VTcHJlYWQoKTtcbiAgICAgICAgICAgICAgICBwcm9wLnR5cGUgPSBpc1BhdHRlcm4gPyBcIlJlc3RQcm9wZXJ0eVwiIDogXCJTcHJlYWRQcm9wZXJ0eVwiO1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcHJvcC5zaG9ydGhhbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGlzUGF0dGVybiB8fCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRQb3MgPSB0aGlzJDEuc3RhcnQ7XG4gICAgICAgICAgICAgICAgc3RhcnRMb2MgPSB0aGlzJDEuc3RhcnRMb2M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc1BhdHRlcm4pIGlzR2VuZXJhdG9yID0gdGhpcyQxLmVhdCh0dC5zdGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMkMS5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICAgICAgICAgIHRoaXMkMS5wYXJzZVByb3BlcnR5VmFsdWUocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgICAgIHRoaXMkMS5jaGVja1Byb3BDbGFzaChwcm9wLCBwcm9wSGFzaCk7XG4gICAgICAgICAgICBub2RlLnByb3BlcnRpZXMucHVzaCh0aGlzJDEuZmluaXNoTm9kZShwcm9wLCBcIlByb3BlcnR5XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1BhdHRlcm4gPyBcIk9iamVjdFBhdHRlcm5cIiA6IFwiT2JqZWN0RXhwcmVzc2lvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjb3JuLnBsdWdpbnMub2JqZWN0U3ByZWFkID0gZnVuY3Rpb24gb2JqZWN0U3ByZWFkUGx1Z2luKGluc3RhbmNlKSB7XG4gICAgICAgICAgcHAucGFyc2VPYmogPSBwYXJzZU9iajtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYWNvcm47XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIGFjb3JuT2JqZWN0U3ByZWFkID0gaW5qZWN0JDEgJiYgKHR5cGVvZiBpbmplY3QkMSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaW5qZWN0JDEpKSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGluamVjdCQxID8gaW5qZWN0JDFbJ2RlZmF1bHQnXSA6IGluamVjdCQxO1xuXG4gICAgdmFyIGNoYXJUb0ludGVnZXIgPSB7fTtcbiAgICB2YXIgaW50ZWdlclRvQ2hhciA9IHt9O1xuXG4gICAgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hhciwgaSkge1xuICAgICAgY2hhclRvSW50ZWdlcltjaGFyXSA9IGk7XG4gICAgICBpbnRlZ2VyVG9DaGFyW2ldID0gY2hhcjtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCwgaTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmVzdWx0ID0gZW5jb2RlSW50ZWdlcih2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGVuY29kZUludGVnZXIodmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5jb2RlSW50ZWdlcihudW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICBjbGFtcGVkO1xuXG4gICAgICBpZiAobnVtIDwgMCkge1xuICAgICAgICBudW0gPSAtbnVtIDw8IDEgfCAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbnVtIDw8PSAxO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIGNsYW1wZWQgPSBudW0gJiAzMTtcbiAgICAgICAgbnVtID4+PSA1O1xuXG4gICAgICAgIGlmIChudW0gPiAwKSB7XG4gICAgICAgICAgY2xhbXBlZCB8PSAzMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBpbnRlZ2VyVG9DaGFyW2NsYW1wZWRdO1xuICAgICAgfSB3aGlsZSAobnVtID4gMCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ2h1bmsoc3RhcnQsIGVuZCwgY29udGVudCkge1xuICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICB0aGlzLm9yaWdpbmFsID0gY29udGVudDtcblxuICAgICAgdGhpcy5pbnRybyA9ICcnO1xuICAgICAgdGhpcy5vdXRybyA9ICcnO1xuXG4gICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgdGhpcy5zdG9yZU5hbWUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZWRpdGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIHdlIG1ha2UgdGhlc2Ugbm9uLWVudW1lcmFibGUsIGZvciBzYW5pdHkgd2hpbGUgZGVidWdnaW5nXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgIHByZXZpb3VzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogbnVsbCB9LFxuICAgICAgICBuZXh0OiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogbnVsbCB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBDaHVuay5wcm90b3R5cGUgPSB7XG4gICAgICBhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZChjb250ZW50KSB7XG4gICAgICAgIHRoaXMub3V0cm8gKz0gY29udGVudDtcbiAgICAgIH0sXG5cbiAgICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIGNodW5rID0gbmV3IENodW5rKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB0aGlzLm9yaWdpbmFsKTtcblxuICAgICAgICBjaHVuay5pbnRybyA9IHRoaXMuaW50cm87XG4gICAgICAgIGNodW5rLm91dHJvID0gdGhpcy5vdXRybztcbiAgICAgICAgY2h1bmsuY29udGVudCA9IHRoaXMuY29udGVudDtcbiAgICAgICAgY2h1bmsuc3RvcmVOYW1lID0gdGhpcy5zdG9yZU5hbWU7XG4gICAgICAgIGNodW5rLmVkaXRlZCA9IHRoaXMuZWRpdGVkO1xuXG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICAgIH0sXG5cbiAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbiBjb250YWlucyhpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCA8IGluZGV4ICYmIGluZGV4IDwgdGhpcy5lbmQ7XG4gICAgICB9LFxuXG4gICAgICBlYWNoTmV4dDogZnVuY3Rpb24gZWFjaE5leHQoZm4pIHtcbiAgICAgICAgdmFyIGNodW5rID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGNodW5rKSB7XG4gICAgICAgICAgZm4oY2h1bmspO1xuICAgICAgICAgIGNodW5rID0gY2h1bmsubmV4dDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZWFjaFByZXZpb3VzOiBmdW5jdGlvbiBlYWNoUHJldmlvdXMoZm4pIHtcbiAgICAgICAgdmFyIGNodW5rID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGNodW5rKSB7XG4gICAgICAgICAgZm4oY2h1bmspO1xuICAgICAgICAgIGNodW5rID0gY2h1bmsucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGVkaXQ6IGZ1bmN0aW9uIGVkaXQoY29udGVudCwgc3RvcmVOYW1lKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuc3RvcmVOYW1lID0gc3RvcmVOYW1lO1xuXG4gICAgICAgIHRoaXMuZWRpdGVkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIHByZXBlbmQ6IGZ1bmN0aW9uIHByZXBlbmQoY29udGVudCkge1xuICAgICAgICB0aGlzLmludHJvID0gY29udGVudCArIHRoaXMuaW50cm87XG4gICAgICB9LFxuXG4gICAgICBzcGxpdDogZnVuY3Rpb24gc3BsaXQoaW5kZXgpIHtcbiAgICAgICAgdmFyIHNsaWNlSW5kZXggPSBpbmRleCAtIHRoaXMuc3RhcnQ7XG5cbiAgICAgICAgdmFyIG9yaWdpbmFsQmVmb3JlID0gdGhpcy5vcmlnaW5hbC5zbGljZSgwLCBzbGljZUluZGV4KTtcbiAgICAgICAgdmFyIG9yaWdpbmFsQWZ0ZXIgPSB0aGlzLm9yaWdpbmFsLnNsaWNlKHNsaWNlSW5kZXgpO1xuXG4gICAgICAgIHRoaXMub3JpZ2luYWwgPSBvcmlnaW5hbEJlZm9yZTtcblxuICAgICAgICB2YXIgbmV3Q2h1bmsgPSBuZXcgQ2h1bmsoaW5kZXgsIHRoaXMuZW5kLCBvcmlnaW5hbEFmdGVyKTtcbiAgICAgICAgbmV3Q2h1bmsub3V0cm8gPSB0aGlzLm91dHJvO1xuICAgICAgICB0aGlzLm91dHJvID0gJyc7XG5cbiAgICAgICAgdGhpcy5lbmQgPSBpbmRleDtcblxuICAgICAgICBpZiAodGhpcy5lZGl0ZWQpIHtcbiAgICAgICAgICAvLyBUT0RPIGlzIHRoaXMgYmxvY2sgbmVjZXNzYXJ5Py4uLlxuICAgICAgICAgIG5ld0NodW5rLmVkaXQoJycsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLmNvbnRlbnQgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBvcmlnaW5hbEJlZm9yZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0NodW5rLm5leHQgPSB0aGlzLm5leHQ7XG4gICAgICAgIGlmIChuZXdDaHVuay5uZXh0KSBuZXdDaHVuay5uZXh0LnByZXZpb3VzID0gbmV3Q2h1bms7XG4gICAgICAgIG5ld0NodW5rLnByZXZpb3VzID0gdGhpcztcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV3Q2h1bms7XG5cbiAgICAgICAgcmV0dXJuIG5ld0NodW5rO1xuICAgICAgfSxcblxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRybyArIHRoaXMuY29udGVudCArIHRoaXMub3V0cm87XG4gICAgICB9LFxuXG4gICAgICB0cmltRW5kOiBmdW5jdGlvbiB0cmltRW5kKHJ4KSB7XG4gICAgICAgIHRoaXMub3V0cm8gPSB0aGlzLm91dHJvLnJlcGxhY2UocngsICcnKTtcbiAgICAgICAgaWYgKHRoaXMub3V0cm8ubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB2YXIgdHJpbW1lZCA9IHRoaXMuY29udGVudC5yZXBsYWNlKHJ4LCAnJyk7XG5cbiAgICAgICAgaWYgKHRyaW1tZWQubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRyaW1tZWQgIT09IHRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5zcGxpdCh0aGlzLnN0YXJ0ICsgdHJpbW1lZC5sZW5ndGgpLmVkaXQoJycsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVkaXQoJycsIGZhbHNlKTtcblxuICAgICAgICAgIHRoaXMuaW50cm8gPSB0aGlzLmludHJvLnJlcGxhY2UocngsICcnKTtcbiAgICAgICAgICBpZiAodGhpcy5pbnRyby5sZW5ndGgpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB0cmltU3RhcnQ6IGZ1bmN0aW9uIHRyaW1TdGFydChyeCkge1xuICAgICAgICB0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKHJ4LCAnJyk7XG4gICAgICAgIGlmICh0aGlzLmludHJvLmxlbmd0aCkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgdmFyIHRyaW1tZWQgPSB0aGlzLmNvbnRlbnQucmVwbGFjZShyeCwgJycpO1xuXG4gICAgICAgIGlmICh0cmltbWVkLmxlbmd0aCkge1xuICAgICAgICAgIGlmICh0cmltbWVkICE9PSB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaXQodGhpcy5lbmQgLSB0cmltbWVkLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmVkaXQoJycsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVkaXQoJycsIGZhbHNlKTtcblxuICAgICAgICAgIHRoaXMub3V0cm8gPSB0aGlzLm91dHJvLnJlcGxhY2UocngsICcnKTtcbiAgICAgICAgICBpZiAodGhpcy5vdXRyby5sZW5ndGgpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfYnRvYTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIF9idG9hID0gd2luZG93LmJ0b2E7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBfYnRvYSA9IGZ1bmN0aW9uIF9idG9hKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdHIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF9idG9hID0gZnVuY3Rpb24gX2J0b2EoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZW52aXJvbm1lbnQ6IGB3aW5kb3cuYnRvYWAgb3IgYEJ1ZmZlcmAgc2hvdWxkIGJlIHN1cHBvcnRlZC4nKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGJ0b2EgPSBfYnRvYTtcblxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcChwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLnZlcnNpb24gPSAzO1xuXG4gICAgICB0aGlzLmZpbGUgPSBwcm9wZXJ0aWVzLmZpbGU7XG4gICAgICB0aGlzLnNvdXJjZXMgPSBwcm9wZXJ0aWVzLnNvdXJjZXM7XG4gICAgICB0aGlzLnNvdXJjZXNDb250ZW50ID0gcHJvcGVydGllcy5zb3VyY2VzQ29udGVudDtcbiAgICAgIHRoaXMubmFtZXMgPSBwcm9wZXJ0aWVzLm5hbWVzO1xuICAgICAgdGhpcy5tYXBwaW5ncyA9IHByb3BlcnRpZXMubWFwcGluZ3M7XG4gICAgfVxuXG4gICAgU291cmNlTWFwLnByb3RvdHlwZSA9IHtcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgfSxcblxuICAgICAgdG9Vcmw6IGZ1bmN0aW9uIHRvVXJsKCkge1xuICAgICAgICByZXR1cm4gJ2RhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYnRvYSh0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBndWVzc0luZGVudChjb2RlKSB7XG4gICAgICB2YXIgbGluZXMgPSBjb2RlLnNwbGl0KCdcXG4nKTtcblxuICAgICAgdmFyIHRhYmJlZCA9IGxpbmVzLmZpbHRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgICByZXR1cm4gKC9eXFx0Ky8udGVzdChsaW5lKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3BhY2VkID0gbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiAoL14gezIsfS8udGVzdChsaW5lKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0YWJiZWQubGVuZ3RoID09PSAwICYmIHNwYWNlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIE1vcmUgbGluZXMgdGFiYmVkIHRoYW4gc3BhY2VkPyBBc3N1bWUgdGFicywgYW5kXG4gICAgICAvLyBkZWZhdWx0IHRvIHRhYnMgaW4gdGhlIGNhc2Ugb2YgYSB0aWUgKG9yIG5vdGhpbmdcbiAgICAgIC8vIHRvIGdvIG9uKVxuICAgICAgaWYgKHRhYmJlZC5sZW5ndGggPj0gc3BhY2VkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJ1xcdCc7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBndWVzcyB0aGUgbXVsdGlwbGVcbiAgICAgIHZhciBtaW4gPSBzcGFjZWQucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgICAgICB2YXIgbnVtU3BhY2VzID0gL14gKy8uZXhlYyhjdXJyZW50KVswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihudW1TcGFjZXMsIHByZXZpb3VzKTtcbiAgICAgIH0sIEluZmluaXR5KTtcblxuICAgICAgcmV0dXJuIG5ldyBBcnJheShtaW4gKyAxKS5qb2luKCcgJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TG9jYXRvcihzb3VyY2UpIHtcbiAgICAgIHZhciBvcmlnaW5hbExpbmVzID0gc291cmNlLnNwbGl0KCdcXG4nKTtcblxuICAgICAgdmFyIHN0YXJ0ID0gMDtcbiAgICAgIHZhciBsaW5lUmFuZ2VzID0gb3JpZ2luYWxMaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgbGluZS5sZW5ndGggKyAxO1xuICAgICAgICB2YXIgcmFuZ2UgPSB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIGxpbmU6IGkgfTtcblxuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgZnVuY3Rpb24gcmFuZ2VDb250YWlucyhyYW5nZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0IDw9IGluZGV4ICYmIGluZGV4IDwgcmFuZ2UuZW5kO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRMb2NhdGlvbihyYW5nZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHsgbGluZTogcmFuZ2UubGluZSwgY29sdW1uOiBpbmRleCAtIHJhbmdlLnN0YXJ0IH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBsb2NhdGUoaW5kZXgpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gbGluZVJhbmdlc1tpXTtcblxuICAgICAgICB2YXIgZCA9IGluZGV4ID49IHJhbmdlLmVuZCA/IDEgOiAtMTtcblxuICAgICAgICB3aGlsZSAocmFuZ2UpIHtcbiAgICAgICAgICBpZiAocmFuZ2VDb250YWlucyhyYW5nZSwgaW5kZXgpKSByZXR1cm4gZ2V0TG9jYXRpb24ocmFuZ2UsIGluZGV4KTtcblxuICAgICAgICAgIGkgKz0gZDtcbiAgICAgICAgICByYW5nZSA9IGxpbmVSYW5nZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5jb2RlTWFwcGluZ3Mob3JpZ2luYWwsIGludHJvLCBjaHVuaywgaGlyZXMsIHNvdXJjZW1hcExvY2F0aW9ucywgc291cmNlSW5kZXgsIG9mZnNldHMsIG5hbWVzKSB7XG4gICAgICB2YXIgcmF3TGluZXMgPSBbXTtcblxuICAgICAgdmFyIGdlbmVyYXRlZENvZGVMaW5lID0gaW50cm8uc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgcmF3U2VnbWVudHMgPSByYXdMaW5lc1tnZW5lcmF0ZWRDb2RlTGluZV0gPSBbXTtcblxuICAgICAgdmFyIGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuXG4gICAgICB2YXIgbG9jYXRlID0gZ2V0TG9jYXRvcihvcmlnaW5hbCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZEVkaXQoY29udGVudCwgb3JpZ2luYWwsIGxvYywgbmFtZUluZGV4LCBpKSB7XG4gICAgICAgIGlmIChpIHx8IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgcmF3U2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICBnZW5lcmF0ZWRDb2RlTGluZTogZ2VuZXJhdGVkQ29kZUxpbmUsXG4gICAgICAgICAgICBnZW5lcmF0ZWRDb2RlQ29sdW1uOiBnZW5lcmF0ZWRDb2RlQ29sdW1uLFxuICAgICAgICAgICAgc291cmNlQ29kZUxpbmU6IGxvYy5saW5lLFxuICAgICAgICAgICAgc291cmNlQ29kZUNvbHVtbjogbG9jLmNvbHVtbixcbiAgICAgICAgICAgIHNvdXJjZUNvZGVOYW1lOiBuYW1lSW5kZXgsXG4gICAgICAgICAgICBzb3VyY2VJbmRleDogc291cmNlSW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICB2YXIgbGFzdExpbmUgPSBsaW5lcy5wb3AoKTtcblxuICAgICAgICBpZiAobGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkQ29kZUxpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgIHJhd0xpbmVzW2dlbmVyYXRlZENvZGVMaW5lXSA9IHJhd1NlZ21lbnRzID0gW107XG4gICAgICAgICAgZ2VuZXJhdGVkQ29kZUNvbHVtbiA9IGxhc3RMaW5lLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW5lcmF0ZWRDb2RlQ29sdW1uICs9IGxhc3RMaW5lLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gb3JpZ2luYWwuc3BsaXQoJ1xcbicpO1xuICAgICAgICBsYXN0TGluZSA9IGxpbmVzLnBvcCgpO1xuXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICBsb2MubGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgbG9jLmNvbHVtbiA9IGxhc3RMaW5lLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2MuY29sdW1uICs9IGxhc3RMaW5lLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRVbmVkaXRlZENodW5rKGNodW5rLCBsb2MpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ2hhckluZGV4ID0gY2h1bmsuc3RhcnQ7XG4gICAgICAgIHZhciBmaXJzdCA9IHRydWU7XG5cbiAgICAgICAgd2hpbGUgKG9yaWdpbmFsQ2hhckluZGV4IDwgY2h1bmsuZW5kKSB7XG4gICAgICAgICAgaWYgKGhpcmVzIHx8IGZpcnN0IHx8IHNvdXJjZW1hcExvY2F0aW9uc1tvcmlnaW5hbENoYXJJbmRleF0pIHtcbiAgICAgICAgICAgIHJhd1NlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICBnZW5lcmF0ZWRDb2RlTGluZTogZ2VuZXJhdGVkQ29kZUxpbmUsXG4gICAgICAgICAgICAgIGdlbmVyYXRlZENvZGVDb2x1bW46IGdlbmVyYXRlZENvZGVDb2x1bW4sXG4gICAgICAgICAgICAgIHNvdXJjZUNvZGVMaW5lOiBsb2MubGluZSxcbiAgICAgICAgICAgICAgc291cmNlQ29kZUNvbHVtbjogbG9jLmNvbHVtbixcbiAgICAgICAgICAgICAgc291cmNlQ29kZU5hbWU6IC0xLFxuICAgICAgICAgICAgICBzb3VyY2VJbmRleDogc291cmNlSW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcmlnaW5hbFtvcmlnaW5hbENoYXJJbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBsb2MubGluZSArPSAxO1xuICAgICAgICAgICAgbG9jLmNvbHVtbiA9IDA7XG4gICAgICAgICAgICBnZW5lcmF0ZWRDb2RlTGluZSArPSAxO1xuICAgICAgICAgICAgcmF3TGluZXNbZ2VuZXJhdGVkQ29kZUxpbmVdID0gcmF3U2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2MuY29sdW1uICs9IDE7XG4gICAgICAgICAgICBnZW5lcmF0ZWRDb2RlQ29sdW1uICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3JpZ2luYWxDaGFySW5kZXggKz0gMTtcbiAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjaHVuaykge1xuICAgICAgICB2YXIgbG9jID0gbG9jYXRlKGNodW5rLnN0YXJ0KTtcblxuICAgICAgICBpZiAoY2h1bmsuaW50cm8ubGVuZ3RoKSB7XG4gICAgICAgICAgYWRkRWRpdChjaHVuay5pbnRybywgJycsIGxvYywgLTEsICEhY2h1bmsucHJldmlvdXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNodW5rLmVkaXRlZCkge1xuICAgICAgICAgIGFkZEVkaXQoY2h1bmsuY29udGVudCwgY2h1bmsub3JpZ2luYWwsIGxvYywgY2h1bmsuc3RvcmVOYW1lID8gbmFtZXMuaW5kZXhPZihjaHVuay5vcmlnaW5hbCkgOiAtMSwgISFjaHVuay5wcmV2aW91cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkVW5lZGl0ZWRDaHVuayhjaHVuaywgbG9jKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaHVuay5vdXRyby5sZW5ndGgpIHtcbiAgICAgICAgICBhZGRFZGl0KGNodW5rLm91dHJvLCAnJywgbG9jLCAtMSwgISFjaHVuay5wcmV2aW91cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dENodW5rID0gY2h1bmsubmV4dDtcbiAgICAgICAgY2h1bmsgPSBuZXh0Q2h1bms7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldHMuc291cmNlSW5kZXggPSBvZmZzZXRzLnNvdXJjZUluZGV4IHx8IDA7XG4gICAgICBvZmZzZXRzLnNvdXJjZUNvZGVMaW5lID0gb2Zmc2V0cy5zb3VyY2VDb2RlTGluZSB8fCAwO1xuICAgICAgb2Zmc2V0cy5zb3VyY2VDb2RlQ29sdW1uID0gb2Zmc2V0cy5zb3VyY2VDb2RlQ29sdW1uIHx8IDA7XG4gICAgICBvZmZzZXRzLnNvdXJjZUNvZGVOYW1lID0gb2Zmc2V0cy5zb3VyY2VDb2RlTmFtZSB8fCAwO1xuXG4gICAgICB2YXIgZW5jb2RlZCA9IHJhd0xpbmVzLm1hcChmdW5jdGlvbiAoc2VnbWVudHMpIHtcbiAgICAgICAgdmFyIGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuXG4gICAgICAgIHJldHVybiBzZWdtZW50cy5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgICB2YXIgYXJyID0gW3NlZ21lbnQuZ2VuZXJhdGVkQ29kZUNvbHVtbiAtIGdlbmVyYXRlZENvZGVDb2x1bW4sIHNlZ21lbnQuc291cmNlSW5kZXggLSBvZmZzZXRzLnNvdXJjZUluZGV4LCBzZWdtZW50LnNvdXJjZUNvZGVMaW5lIC0gb2Zmc2V0cy5zb3VyY2VDb2RlTGluZSwgc2VnbWVudC5zb3VyY2VDb2RlQ29sdW1uIC0gb2Zmc2V0cy5zb3VyY2VDb2RlQ29sdW1uXTtcblxuICAgICAgICAgIGdlbmVyYXRlZENvZGVDb2x1bW4gPSBzZWdtZW50LmdlbmVyYXRlZENvZGVDb2x1bW47XG4gICAgICAgICAgb2Zmc2V0cy5zb3VyY2VJbmRleCA9IHNlZ21lbnQuc291cmNlSW5kZXg7XG4gICAgICAgICAgb2Zmc2V0cy5zb3VyY2VDb2RlTGluZSA9IHNlZ21lbnQuc291cmNlQ29kZUxpbmU7XG4gICAgICAgICAgb2Zmc2V0cy5zb3VyY2VDb2RlQ29sdW1uID0gc2VnbWVudC5zb3VyY2VDb2RlQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKH5zZWdtZW50LnNvdXJjZUNvZGVOYW1lKSB7XG4gICAgICAgICAgICBhcnIucHVzaChzZWdtZW50LnNvdXJjZUNvZGVOYW1lIC0gb2Zmc2V0cy5zb3VyY2VDb2RlTmFtZSk7XG4gICAgICAgICAgICBvZmZzZXRzLnNvdXJjZUNvZGVOYW1lID0gc2VnbWVudC5zb3VyY2VDb2RlTmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZW5jb2RlKGFycik7XG4gICAgICAgIH0pLmpvaW4oJywnKTtcbiAgICAgIH0pLmpvaW4oJzsnKTtcblxuICAgICAgcmV0dXJuIGVuY29kZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmVsYXRpdmVQYXRoKGZyb20sIHRvKSB7XG4gICAgICB2YXIgZnJvbVBhcnRzID0gZnJvbS5zcGxpdCgvW1xcL1xcXFxdLyk7XG4gICAgICB2YXIgdG9QYXJ0cyA9IHRvLnNwbGl0KC9bXFwvXFxcXF0vKTtcblxuICAgICAgZnJvbVBhcnRzLnBvcCgpOyAvLyBnZXQgZGlybmFtZVxuXG4gICAgICB3aGlsZSAoZnJvbVBhcnRzWzBdID09PSB0b1BhcnRzWzBdKSB7XG4gICAgICAgIGZyb21QYXJ0cy5zaGlmdCgpO1xuICAgICAgICB0b1BhcnRzLnNoaWZ0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmcm9tUGFydHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpID0gZnJvbVBhcnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGZyb21QYXJ0c1tpXSA9ICcuLic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZyb21QYXJ0cy5jb25jYXQodG9QYXJ0cykuam9pbignLycpO1xuICAgIH1cblxuICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodGhpbmcpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNYWdpY1N0cmluZyhzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcblxuICAgICAgdmFyIGNodW5rID0gbmV3IENodW5rKDAsIHN0cmluZy5sZW5ndGgsIHN0cmluZyk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgb3JpZ2luYWw6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBzdHJpbmcgfSxcbiAgICAgICAgb3V0cm86IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiAnJyB9LFxuICAgICAgICBpbnRybzogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6ICcnIH0sXG4gICAgICAgIGZpcnN0Q2h1bms6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBjaHVuayB9LFxuICAgICAgICBsYXN0Q2h1bms6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBjaHVuayB9LFxuICAgICAgICBsYXN0U2VhcmNoZWRDaHVuazogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGNodW5rIH0sXG4gICAgICAgIGJ5U3RhcnQ6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICAgICAgICBieUVuZDogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gICAgICAgIGZpbGVuYW1lOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogb3B0aW9ucy5maWxlbmFtZSB9LFxuICAgICAgICBpbmRlbnRFeGNsdXNpb25SYW5nZXM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBvcHRpb25zLmluZGVudEV4Y2x1c2lvblJhbmdlcyB9LFxuICAgICAgICBzb3VyY2VtYXBMb2NhdGlvbnM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICAgICAgICBzdG9yZWROYW1lczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gICAgICAgIGluZGVudFN0cjogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGd1ZXNzSW5kZW50KHN0cmluZykgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuYnlTdGFydFswXSA9IGNodW5rO1xuICAgICAgdGhpcy5ieUVuZFtzdHJpbmcubGVuZ3RoXSA9IGNodW5rO1xuICAgIH1cblxuICAgIE1hZ2ljU3RyaW5nLnByb3RvdHlwZSA9IHtcbiAgICAgIGFkZFNvdXJjZW1hcExvY2F0aW9uOiBmdW5jdGlvbiBhZGRTb3VyY2VtYXBMb2NhdGlvbihjaGFyKSB7XG4gICAgICAgIHRoaXMuc291cmNlbWFwTG9jYXRpb25zW2NoYXJdID0gdHJ1ZTtcbiAgICAgIH0sXG5cbiAgICAgIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignb3V0cm8gY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICAgICAgdGhpcy5vdXRybyArPSBjb250ZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIGNsb25lZCA9IG5ldyBNYWdpY1N0cmluZyh0aGlzLm9yaWdpbmFsLCB7IGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lIH0pO1xuXG4gICAgICAgIHZhciBvcmlnaW5hbENodW5rID0gdGhpcy5maXJzdENodW5rO1xuICAgICAgICB2YXIgY2xvbmVkQ2h1bmsgPSBjbG9uZWQuZmlyc3RDaHVuayA9IGNsb25lZC5sYXN0U2VhcmNoZWRDaHVuayA9IG9yaWdpbmFsQ2h1bmsuY2xvbmUoKTtcblxuICAgICAgICB3aGlsZSAob3JpZ2luYWxDaHVuaykge1xuICAgICAgICAgIGNsb25lZC5ieVN0YXJ0W2Nsb25lZENodW5rLnN0YXJ0XSA9IGNsb25lZENodW5rO1xuICAgICAgICAgIGNsb25lZC5ieUVuZFtjbG9uZWRDaHVuay5lbmRdID0gY2xvbmVkQ2h1bms7XG5cbiAgICAgICAgICB2YXIgbmV4dE9yaWdpbmFsQ2h1bmsgPSBvcmlnaW5hbENodW5rLm5leHQ7XG4gICAgICAgICAgdmFyIG5leHRDbG9uZWRDaHVuayA9IG5leHRPcmlnaW5hbENodW5rICYmIG5leHRPcmlnaW5hbENodW5rLmNsb25lKCk7XG5cbiAgICAgICAgICBpZiAobmV4dENsb25lZENodW5rKSB7XG4gICAgICAgICAgICBjbG9uZWRDaHVuay5uZXh0ID0gbmV4dENsb25lZENodW5rO1xuICAgICAgICAgICAgbmV4dENsb25lZENodW5rLnByZXZpb3VzID0gY2xvbmVkQ2h1bms7XG5cbiAgICAgICAgICAgIGNsb25lZENodW5rID0gbmV4dENsb25lZENodW5rO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9yaWdpbmFsQ2h1bmsgPSBuZXh0T3JpZ2luYWxDaHVuaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb25lZC5sYXN0Q2h1bmsgPSBjbG9uZWRDaHVuaztcblxuICAgICAgICBpZiAodGhpcy5pbmRlbnRFeGNsdXNpb25SYW5nZXMpIHtcbiAgICAgICAgICBjbG9uZWQuaW5kZW50RXhjbHVzaW9uUmFuZ2VzID0gdHlwZW9mIHRoaXMuaW5kZW50RXhjbHVzaW9uUmFuZ2VzWzBdID09PSAnbnVtYmVyJyA/IFt0aGlzLmluZGVudEV4Y2x1c2lvblJhbmdlc1swXSwgdGhpcy5pbmRlbnRFeGNsdXNpb25SYW5nZXNbMV1dIDogdGhpcy5pbmRlbnRFeGNsdXNpb25SYW5nZXMubWFwKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtyYW5nZS5zdGFydCwgcmFuZ2UuZW5kXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuc291cmNlbWFwTG9jYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChsb2MpIHtcbiAgICAgICAgICBjbG9uZWQuc291cmNlbWFwTG9jYXRpb25zW2xvY10gPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgfSxcblxuICAgICAgZ2VuZXJhdGVNYXA6IGZ1bmN0aW9uIGdlbmVyYXRlTWFwKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXModGhpcy5zdG9yZWROYW1lcyk7XG5cbiAgICAgICAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXAoe1xuICAgICAgICAgIGZpbGU6IG9wdGlvbnMuZmlsZSA/IG9wdGlvbnMuZmlsZS5zcGxpdCgvW1xcL1xcXFxdLykucG9wKCkgOiBudWxsLFxuICAgICAgICAgIHNvdXJjZXM6IFtvcHRpb25zLnNvdXJjZSA/IGdldFJlbGF0aXZlUGF0aChvcHRpb25zLmZpbGUgfHwgJycsIG9wdGlvbnMuc291cmNlKSA6IG51bGxdLFxuICAgICAgICAgIHNvdXJjZXNDb250ZW50OiBvcHRpb25zLmluY2x1ZGVDb250ZW50ID8gW3RoaXMub3JpZ2luYWxdIDogW251bGxdLFxuICAgICAgICAgIG5hbWVzOiBuYW1lcyxcbiAgICAgICAgICBtYXBwaW5nczogdGhpcy5nZXRNYXBwaW5ncyhvcHRpb25zLmhpcmVzLCAwLCB7fSwgbmFtZXMpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfSxcblxuICAgICAgZ2V0SW5kZW50U3RyaW5nOiBmdW5jdGlvbiBnZXRJbmRlbnRTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGVudFN0ciA9PT0gbnVsbCA/ICdcXHQnIDogdGhpcy5pbmRlbnRTdHI7XG4gICAgICB9LFxuXG4gICAgICBnZXRNYXBwaW5nczogZnVuY3Rpb24gZ2V0TWFwcGluZ3MoaGlyZXMsIHNvdXJjZUluZGV4LCBvZmZzZXRzLCBuYW1lcykge1xuICAgICAgICByZXR1cm4gZW5jb2RlTWFwcGluZ3ModGhpcy5vcmlnaW5hbCwgdGhpcy5pbnRybywgdGhpcy5maXJzdENodW5rLCBoaXJlcywgdGhpcy5zb3VyY2VtYXBMb2NhdGlvbnMsIHNvdXJjZUluZGV4LCBvZmZzZXRzLCBuYW1lcyk7XG4gICAgICB9LFxuXG4gICAgICBpbmRlbnQ6IGZ1bmN0aW9uIGluZGVudChpbmRlbnRTdHIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHBhdHRlcm4gPSAvXlteXFxyXFxuXS9nbTtcblxuICAgICAgICBpZiAoaXNPYmplY3QoaW5kZW50U3RyKSkge1xuICAgICAgICAgIG9wdGlvbnMgPSBpbmRlbnRTdHI7XG4gICAgICAgICAgaW5kZW50U3RyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZW50U3RyID0gaW5kZW50U3RyICE9PSB1bmRlZmluZWQgPyBpbmRlbnRTdHIgOiB0aGlzLmluZGVudFN0ciB8fCAnXFx0JztcblxuICAgICAgICBpZiAoaW5kZW50U3RyID09PSAnJykgcmV0dXJuIHRoaXM7IC8vIG5vb3BcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBQcm9jZXNzIGV4Y2x1c2lvbiByYW5nZXNcbiAgICAgICAgdmFyIGlzRXhjbHVkZWQgPSB7fTtcblxuICAgICAgICBpZiAob3B0aW9ucy5leGNsdWRlKSB7XG4gICAgICAgICAgdmFyIGV4Y2x1c2lvbnMgPSB0eXBlb2Ygb3B0aW9ucy5leGNsdWRlWzBdID09PSAnbnVtYmVyJyA/IFtvcHRpb25zLmV4Y2x1ZGVdIDogb3B0aW9ucy5leGNsdWRlO1xuICAgICAgICAgIGV4Y2x1c2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZXhjbHVzaW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZXhjbHVzaW9uWzBdOyBpIDwgZXhjbHVzaW9uWzFdOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgaXNFeGNsdWRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvdWxkSW5kZW50TmV4dENoYXJhY3RlciA9IG9wdGlvbnMuaW5kZW50U3RhcnQgIT09IGZhbHNlO1xuICAgICAgICB2YXIgcmVwbGFjZXIgPSBmdW5jdGlvbiByZXBsYWNlcihtYXRjaCkge1xuICAgICAgICAgIGlmIChzaG91bGRJbmRlbnROZXh0Q2hhcmFjdGVyKSByZXR1cm4gXCJcIiArIGluZGVudFN0ciArIG1hdGNoO1xuICAgICAgICAgIHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VyKTtcblxuICAgICAgICB2YXIgY2hhckluZGV4ID0gMDtcblxuICAgICAgICB2YXIgY2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG5cbiAgICAgICAgd2hpbGUgKGNodW5rKSB7XG4gICAgICAgICAgdmFyIGVuZCA9IGNodW5rLmVuZDtcblxuICAgICAgICAgIGlmIChjaHVuay5lZGl0ZWQpIHtcbiAgICAgICAgICAgIGlmICghaXNFeGNsdWRlZFtjaGFySW5kZXhdKSB7XG4gICAgICAgICAgICAgIGNodW5rLmNvbnRlbnQgPSBjaHVuay5jb250ZW50LnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZXIpO1xuXG4gICAgICAgICAgICAgIGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSBjaHVuay5jb250ZW50W2NodW5rLmNvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICdcXG4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYXJJbmRleCA9IGNodW5rLnN0YXJ0O1xuXG4gICAgICAgICAgICB3aGlsZSAoY2hhckluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICAgIGlmICghaXNFeGNsdWRlZFtjaGFySW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXIgPSB0aGlzJDEub3JpZ2luYWxbY2hhckluZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgc2hvdWxkSW5kZW50TmV4dENoYXJhY3RlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyICE9PSAnXFxyJyAmJiBzaG91bGRJbmRlbnROZXh0Q2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICBzaG91bGRJbmRlbnROZXh0Q2hhcmFjdGVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFySW5kZXggPT09IGNodW5rLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnByZXBlbmQoaW5kZW50U3RyKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByaHMgPSBjaHVuay5zcGxpdChjaGFySW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByaHMucHJlcGVuZChpbmRlbnRTdHIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMkMS5ieVN0YXJ0W2NoYXJJbmRleF0gPSByaHM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMkMS5ieUVuZFtjaGFySW5kZXhdID0gY2h1bms7XG5cbiAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSByaHM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2hhckluZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hhckluZGV4ID0gY2h1bmsuZW5kO1xuICAgICAgICAgIGNodW5rID0gY2h1bmsubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3V0cm8gPSB0aGlzLm91dHJvLnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZXIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFnaWNTdHJpbmcuaW5zZXJ0KC4uLikgaXMgZGVwcmVjYXRlZC4gVXNlIGluc2VydFJpZ2h0KC4uLikgb3IgaW5zZXJ0TGVmdCguLi4pJyk7XG4gICAgICB9LFxuXG4gICAgICBpbnNlcnRMZWZ0OiBmdW5jdGlvbiBpbnNlcnRMZWZ0KGluZGV4LCBjb250ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luc2VydGVkIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG4gICAgICAgIHRoaXMuX3NwbGl0KGluZGV4KTtcblxuICAgICAgICB2YXIgY2h1bmsgPSB0aGlzLmJ5RW5kW2luZGV4XTtcblxuICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICBjaHVuay5hcHBlbmQoY29udGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbnRybyArPSBjb250ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBpbnNlcnRSaWdodDogZnVuY3Rpb24gaW5zZXJ0UmlnaHQoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5zZXJ0ZWQgY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICAgICAgdGhpcy5fc3BsaXQoaW5kZXgpO1xuXG4gICAgICAgIHZhciBjaHVuayA9IHRoaXMuYnlTdGFydFtpbmRleF07XG5cbiAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgY2h1bmsucHJlcGVuZChjb250ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm91dHJvICs9IGNvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUoc3RhcnQsIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHN0YXJ0ICYmIGluZGV4IDw9IGVuZCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbW92ZSBhIHNlbGVjdGlvbiBpbnNpZGUgaXRzZWxmJyk7XG5cbiAgICAgICAgdGhpcy5fc3BsaXQoc3RhcnQpO1xuICAgICAgICB0aGlzLl9zcGxpdChlbmQpO1xuICAgICAgICB0aGlzLl9zcGxpdChpbmRleCk7XG5cbiAgICAgICAgdmFyIGZpcnN0ID0gdGhpcy5ieVN0YXJ0W3N0YXJ0XTtcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmJ5RW5kW2VuZF07XG5cbiAgICAgICAgdmFyIG9sZExlZnQgPSBmaXJzdC5wcmV2aW91cztcbiAgICAgICAgdmFyIG9sZFJpZ2h0ID0gbGFzdC5uZXh0O1xuXG4gICAgICAgIHZhciBuZXdSaWdodCA9IHRoaXMuYnlTdGFydFtpbmRleF07XG4gICAgICAgIGlmICghbmV3UmlnaHQgJiYgbGFzdCA9PT0gdGhpcy5sYXN0Q2h1bmspIHJldHVybiB0aGlzO1xuICAgICAgICB2YXIgbmV3TGVmdCA9IG5ld1JpZ2h0ID8gbmV3UmlnaHQucHJldmlvdXMgOiB0aGlzLmxhc3RDaHVuaztcblxuICAgICAgICBpZiAob2xkTGVmdCkgb2xkTGVmdC5uZXh0ID0gb2xkUmlnaHQ7XG4gICAgICAgIGlmIChvbGRSaWdodCkgb2xkUmlnaHQucHJldmlvdXMgPSBvbGRMZWZ0O1xuXG4gICAgICAgIGlmIChuZXdMZWZ0KSBuZXdMZWZ0Lm5leHQgPSBmaXJzdDtcbiAgICAgICAgaWYgKG5ld1JpZ2h0KSBuZXdSaWdodC5wcmV2aW91cyA9IGxhc3Q7XG5cbiAgICAgICAgaWYgKCFmaXJzdC5wcmV2aW91cykgdGhpcy5maXJzdENodW5rID0gbGFzdC5uZXh0O1xuICAgICAgICBpZiAoIWxhc3QubmV4dCkge1xuICAgICAgICAgIHRoaXMubGFzdENodW5rID0gZmlyc3QucHJldmlvdXM7XG4gICAgICAgICAgdGhpcy5sYXN0Q2h1bmsubmV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmaXJzdC5wcmV2aW91cyA9IG5ld0xlZnQ7XG4gICAgICAgIGxhc3QubmV4dCA9IG5ld1JpZ2h0O1xuXG4gICAgICAgIGlmICghbmV3TGVmdCkgdGhpcy5maXJzdENodW5rID0gZmlyc3Q7XG4gICAgICAgIGlmICghbmV3UmlnaHQpIHRoaXMubGFzdENodW5rID0gbGFzdDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIG92ZXJ3cml0ZTogZnVuY3Rpb24gb3ZlcndyaXRlKHN0YXJ0LCBlbmQsIGNvbnRlbnQsIHN0b3JlTmFtZSkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXBsYWNlbWVudCBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcblxuICAgICAgICB3aGlsZSAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgc3RhcnQgKz0gdGhpcyQxLm9yaWdpbmFsLmxlbmd0aDtcbiAgICAgICAgfXdoaWxlIChlbmQgPCAwKSB7XG4gICAgICAgICAgZW5kICs9IHRoaXMkMS5vcmlnaW5hbC5sZW5ndGg7XG4gICAgICAgIH1pZiAoZW5kID4gdGhpcy5vcmlnaW5hbC5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignZW5kIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG92ZXJ3cml0ZSBhIHplcm8tbGVuZ3RoIHJhbmdlIOKAkyB1c2UgaW5zZXJ0TGVmdCBvciBpbnNlcnRSaWdodCBpbnN0ZWFkJyk7XG5cbiAgICAgICAgdGhpcy5fc3BsaXQoc3RhcnQpO1xuICAgICAgICB0aGlzLl9zcGxpdChlbmQpO1xuXG4gICAgICAgIGlmIChzdG9yZU5hbWUpIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLm9yaWdpbmFsLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIHRoaXMuc3RvcmVkTmFtZXNbb3JpZ2luYWxdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXJzdCA9IHRoaXMuYnlTdGFydFtzdGFydF07XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5ieUVuZFtlbmRdO1xuXG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgIGZpcnN0LmVkaXQoY29udGVudCwgc3RvcmVOYW1lKTtcblxuICAgICAgICAgIGlmIChmaXJzdCAhPT0gbGFzdCkge1xuICAgICAgICAgICAgZmlyc3Qub3V0cm8gPSAnJztcblxuICAgICAgICAgICAgdmFyIGNodW5rID0gZmlyc3QubmV4dDtcbiAgICAgICAgICAgIHdoaWxlIChjaHVuayAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICBjaHVuay5lZGl0KCcnLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGNodW5rLmludHJvID0gY2h1bmsub3V0cm8gPSAnJztcbiAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaHVuay5lZGl0KCcnLCBmYWxzZSk7XG4gICAgICAgICAgICBjaHVuay5pbnRybyA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtdXN0IGJlIGluc2VydGluZyBhdCB0aGUgZW5kXG4gICAgICAgICAgdmFyIG5ld0NodW5rID0gbmV3IENodW5rKHN0YXJ0LCBlbmQsICcnKS5lZGl0KGNvbnRlbnQsIHN0b3JlTmFtZSk7XG5cbiAgICAgICAgICAvLyBUT0RPIGxhc3QgY2h1bmsgaW4gdGhlIGFycmF5IG1heSBub3QgYmUgdGhlIGxhc3QgY2h1bmssIGlmIGl0J3MgbW92ZWQuLi5cbiAgICAgICAgICBsYXN0Lm5leHQgPSBuZXdDaHVuaztcbiAgICAgICAgICBuZXdDaHVuay5wcmV2aW91cyA9IGxhc3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIHByZXBlbmQ6IGZ1bmN0aW9uIHByZXBlbmQoY29udGVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdvdXRybyBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcblxuICAgICAgICB0aGlzLmludHJvID0gY29udGVudCArIHRoaXMuaW50cm87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICB3aGlsZSAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgc3RhcnQgKz0gdGhpcyQxLm9yaWdpbmFsLmxlbmd0aDtcbiAgICAgICAgfXdoaWxlIChlbmQgPCAwKSB7XG4gICAgICAgICAgZW5kICs9IHRoaXMkMS5vcmlnaW5hbC5sZW5ndGg7XG4gICAgICAgIH1pZiAoc3RhcnQgPT09IGVuZCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0aGlzLm9yaWdpbmFsLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDaGFyYWN0ZXIgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHRocm93IG5ldyBFcnJvcignZW5kIG11c3QgYmUgZ3JlYXRlciB0aGFuIHN0YXJ0Jyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMub3ZlcndyaXRlKHN0YXJ0LCBlbmQsICcnLCBmYWxzZSk7XG4gICAgICB9LFxuXG4gICAgICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHN0YXJ0ID0gMDtcbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSBlbmQgPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgc3RhcnQgKz0gdGhpcyQxLm9yaWdpbmFsLmxlbmd0aDtcbiAgICAgICAgfXdoaWxlIChlbmQgPCAwKSB7XG4gICAgICAgICAgZW5kICs9IHRoaXMkMS5vcmlnaW5hbC5sZW5ndGg7XG4gICAgICAgIH12YXIgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgLy8gZmluZCBzdGFydCBjaHVua1xuICAgICAgICB2YXIgY2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG4gICAgICAgIHdoaWxlIChjaHVuayAmJiAoY2h1bmsuc3RhcnQgPiBzdGFydCB8fCBjaHVuay5lbmQgPD0gc3RhcnQpKSB7XG5cbiAgICAgICAgICAvLyBmb3VuZCBlbmQgY2h1bmsgYmVmb3JlIHN0YXJ0XG4gICAgICAgICAgaWYgKGNodW5rLnN0YXJ0IDwgZW5kICYmIGNodW5rLmVuZCA+PSBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2h1bmsgPSBjaHVuay5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNodW5rICYmIGNodW5rLmVkaXRlZCAmJiBjaHVuay5zdGFydCAhPT0gc3RhcnQpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgcmVwbGFjZWQgY2hhcmFjdGVyIFwiICsgc3RhcnQgKyBcIiBhcyBzbGljZSBzdGFydCBhbmNob3IuXCIpO1xuXG4gICAgICAgIHZhciBzdGFydENodW5rID0gY2h1bms7XG4gICAgICAgIHdoaWxlIChjaHVuaykge1xuICAgICAgICAgIGlmIChjaHVuay5pbnRybyAmJiAoc3RhcnRDaHVuayAhPT0gY2h1bmsgfHwgY2h1bmsuc3RhcnQgPT09IHN0YXJ0KSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNodW5rLmludHJvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb250YWluc0VuZCA9IGNodW5rLnN0YXJ0IDwgZW5kICYmIGNodW5rLmVuZCA+PSBlbmQ7XG4gICAgICAgICAgaWYgKGNvbnRhaW5zRW5kICYmIGNodW5rLmVkaXRlZCAmJiBjaHVuay5lbmQgIT09IGVuZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSByZXBsYWNlZCBjaGFyYWN0ZXIgXCIgKyBlbmQgKyBcIiBhcyBzbGljZSBlbmQgYW5jaG9yLlwiKTtcblxuICAgICAgICAgIHZhciBzbGljZVN0YXJ0ID0gc3RhcnRDaHVuayA9PT0gY2h1bmsgPyBzdGFydCAtIGNodW5rLnN0YXJ0IDogMDtcbiAgICAgICAgICB2YXIgc2xpY2VFbmQgPSBjb250YWluc0VuZCA/IGNodW5rLmNvbnRlbnQubGVuZ3RoICsgZW5kIC0gY2h1bmsuZW5kIDogY2h1bmsuY29udGVudC5sZW5ndGg7XG5cbiAgICAgICAgICByZXN1bHQgKz0gY2h1bmsuY29udGVudC5zbGljZShzbGljZVN0YXJ0LCBzbGljZUVuZCk7XG5cbiAgICAgICAgICBpZiAoY2h1bmsub3V0cm8gJiYgKCFjb250YWluc0VuZCB8fCBjaHVuay5lbmQgPT09IGVuZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaHVuay5vdXRybztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGFpbnNFbmQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNodW5rID0gY2h1bmsubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuXG4gICAgICAvLyBUT0RPIGRlcHJlY2F0ZSB0aGlzPyBub3QgcmVhbGx5IHZlcnkgdXNlZnVsXG4gICAgICBzbmlwOiBmdW5jdGlvbiBzbmlwKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIGNsb25lID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBjbG9uZS5yZW1vdmUoMCwgc3RhcnQpO1xuICAgICAgICBjbG9uZS5yZW1vdmUoZW5kLCBjbG9uZS5vcmlnaW5hbC5sZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgIH0sXG5cbiAgICAgIF9zcGxpdDogZnVuY3Rpb24gX3NwbGl0KGluZGV4KSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5U3RhcnRbaW5kZXhdIHx8IHRoaXMuYnlFbmRbaW5kZXhdKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGNodW5rID0gdGhpcy5sYXN0U2VhcmNoZWRDaHVuaztcbiAgICAgICAgdmFyIHNlYXJjaEZvcndhcmQgPSBpbmRleCA+IGNodW5rLmVuZDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmIChjaHVuay5jb250YWlucyhpbmRleCkpIHJldHVybiB0aGlzJDEuX3NwbGl0Q2h1bmsoY2h1bmssIGluZGV4KTtcblxuICAgICAgICAgIGNodW5rID0gc2VhcmNoRm9yd2FyZCA/IHRoaXMkMS5ieVN0YXJ0W2NodW5rLmVuZF0gOiB0aGlzJDEuYnlFbmRbY2h1bmsuc3RhcnRdO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfc3BsaXRDaHVuazogZnVuY3Rpb24gX3NwbGl0Q2h1bmsoY2h1bmssIGluZGV4KSB7XG4gICAgICAgIGlmIChjaHVuay5lZGl0ZWQgJiYgY2h1bmsuY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyB6ZXJvLWxlbmd0aCBlZGl0ZWQgY2h1bmtzIGFyZSBhIHNwZWNpYWwgY2FzZSAob3ZlcmxhcHBpbmcgcmVwbGFjZW1lbnRzKVxuICAgICAgICAgIHZhciBsb2MgPSBnZXRMb2NhdG9yKHRoaXMub3JpZ2luYWwpKGluZGV4KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3BsaXQgYSBjaHVuayB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZWRpdGVkIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIg4oCTIFxcXCJcIiArIGNodW5rLm9yaWdpbmFsICsgXCJcXFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdDaHVuayA9IGNodW5rLnNwbGl0KGluZGV4KTtcblxuICAgICAgICB0aGlzLmJ5RW5kW2luZGV4XSA9IGNodW5rO1xuICAgICAgICB0aGlzLmJ5U3RhcnRbaW5kZXhdID0gbmV3Q2h1bms7XG4gICAgICAgIHRoaXMuYnlFbmRbbmV3Q2h1bmsuZW5kXSA9IG5ld0NodW5rO1xuXG4gICAgICAgIGlmIChjaHVuayA9PT0gdGhpcy5sYXN0Q2h1bmspIHRoaXMubGFzdENodW5rID0gbmV3Q2h1bms7XG5cbiAgICAgICAgdGhpcy5sYXN0U2VhcmNoZWRDaHVuayA9IGNodW5rO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG5cbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW50cm87XG5cbiAgICAgICAgdmFyIGNodW5rID0gdGhpcy5maXJzdENodW5rO1xuICAgICAgICB3aGlsZSAoY2h1bmspIHtcbiAgICAgICAgICBzdHIgKz0gY2h1bmsudG9TdHJpbmcoKTtcbiAgICAgICAgICBjaHVuayA9IGNodW5rLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyICsgdGhpcy5vdXRybztcbiAgICAgIH0sXG5cbiAgICAgIHRyaW1MaW5lczogZnVuY3Rpb24gdHJpbUxpbmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmltKCdbXFxcXHJcXFxcbl0nKTtcbiAgICAgIH0sXG5cbiAgICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0oY2hhclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpbVN0YXJ0KGNoYXJUeXBlKS50cmltRW5kKGNoYXJUeXBlKTtcbiAgICAgIH0sXG5cbiAgICAgIHRyaW1FbmQ6IGZ1bmN0aW9uIHRyaW1FbmQoY2hhclR5cGUpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHJ4ID0gbmV3IFJlZ0V4cCgoY2hhclR5cGUgfHwgJ1xcXFxzJykgKyAnKyQnKTtcblxuICAgICAgICB0aGlzLm91dHJvID0gdGhpcy5vdXRyby5yZXBsYWNlKHJ4LCAnJyk7XG4gICAgICAgIGlmICh0aGlzLm91dHJvLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIGNodW5rID0gdGhpcy5sYXN0Q2h1bms7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBlbmQgPSBjaHVuay5lbmQ7XG4gICAgICAgICAgdmFyIGFib3J0ZWQgPSBjaHVuay50cmltRW5kKHJ4KTtcblxuICAgICAgICAgIC8vIGlmIGNodW5rIHdhcyB0cmltbWVkLCB3ZSBoYXZlIGEgbmV3IGxhc3RDaHVua1xuICAgICAgICAgIGlmIChjaHVuay5lbmQgIT09IGVuZCkge1xuICAgICAgICAgICAgdGhpcyQxLmxhc3RDaHVuayA9IGNodW5rLm5leHQ7XG5cbiAgICAgICAgICAgIHRoaXMkMS5ieUVuZFtjaHVuay5lbmRdID0gY2h1bms7XG4gICAgICAgICAgICB0aGlzJDEuYnlTdGFydFtjaHVuay5uZXh0LnN0YXJ0XSA9IGNodW5rLm5leHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVybiB0aGlzJDE7XG4gICAgICAgICAgY2h1bmsgPSBjaHVuay5wcmV2aW91cztcbiAgICAgICAgfSB3aGlsZSAoY2h1bmspO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgdHJpbVN0YXJ0OiBmdW5jdGlvbiB0cmltU3RhcnQoY2hhclR5cGUpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHJ4ID0gbmV3IFJlZ0V4cCgnXicgKyAoY2hhclR5cGUgfHwgJ1xcXFxzJykgKyAnKycpO1xuXG4gICAgICAgIHRoaXMuaW50cm8gPSB0aGlzLmludHJvLnJlcGxhY2UocngsICcnKTtcbiAgICAgICAgaWYgKHRoaXMuaW50cm8ubGVuZ3RoKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgY2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBlbmQgPSBjaHVuay5lbmQ7XG4gICAgICAgICAgdmFyIGFib3J0ZWQgPSBjaHVuay50cmltU3RhcnQocngpO1xuXG4gICAgICAgICAgaWYgKGNodW5rLmVuZCAhPT0gZW5kKSB7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UuLi5cbiAgICAgICAgICAgIGlmIChjaHVuayA9PT0gdGhpcyQxLmxhc3RDaHVuaykgdGhpcyQxLmxhc3RDaHVuayA9IGNodW5rLm5leHQ7XG5cbiAgICAgICAgICAgIHRoaXMkMS5ieUVuZFtjaHVuay5lbmRdID0gY2h1bms7XG4gICAgICAgICAgICB0aGlzJDEuYnlTdGFydFtjaHVuay5uZXh0LnN0YXJ0XSA9IGNodW5rLm5leHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVybiB0aGlzJDE7XG4gICAgICAgICAgY2h1bmsgPSBjaHVuay5uZXh0O1xuICAgICAgICB9IHdoaWxlIChjaHVuayk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIGZ1bmN0aW9uIEJ1bmRsZShvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG5cbiAgICAgIHRoaXMuaW50cm8gPSBvcHRpb25zLmludHJvIHx8ICcnO1xuICAgICAgdGhpcy5zZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zZXBhcmF0b3IgOiAnXFxuJztcblxuICAgICAgdGhpcy5zb3VyY2VzID0gW107XG5cbiAgICAgIHRoaXMudW5pcXVlU291cmNlcyA9IFtdO1xuICAgICAgdGhpcy51bmlxdWVTb3VyY2VJbmRleEJ5RmlsZW5hbWUgPSB7fTtcbiAgICB9XG5cbiAgICBCdW5kbGUucHJvdG90eXBlID0ge1xuICAgICAgYWRkU291cmNlOiBmdW5jdGlvbiBhZGRTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBNYWdpY1N0cmluZykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFkZFNvdXJjZSh7XG4gICAgICAgICAgICBjb250ZW50OiBzb3VyY2UsXG4gICAgICAgICAgICBmaWxlbmFtZTogc291cmNlLmZpbGVuYW1lLFxuICAgICAgICAgICAgc2VwYXJhdG9yOiB0aGlzLnNlcGFyYXRvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc09iamVjdChzb3VyY2UpIHx8ICFzb3VyY2UuY29udGVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYnVuZGxlLmFkZFNvdXJjZSgpIHRha2VzIGFuIG9iamVjdCB3aXRoIGEgYGNvbnRlbnRgIHByb3BlcnR5LCB3aGljaCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgTWFnaWNTdHJpbmcsIGFuZCBhbiBvcHRpb25hbCBgZmlsZW5hbWVgJyk7XG4gICAgICAgIH1cblxuICAgICAgICBbJ2ZpbGVuYW1lJywgJ2luZGVudEV4Y2x1c2lvblJhbmdlcycsICdzZXBhcmF0b3InXS5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICBpZiAoIWhhc093blByb3AuY2FsbChzb3VyY2UsIG9wdGlvbikpIHNvdXJjZVtvcHRpb25dID0gc291cmNlLmNvbnRlbnRbb3B0aW9uXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNvdXJjZS5zZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFRPRE8gdGhlcmUncyBhIGJ1bmNoIG9mIHRoaXMgc29ydCBvZiB0aGluZywgbmVlZHMgY2xlYW5pbmcgdXBcbiAgICAgICAgICBzb3VyY2Uuc2VwYXJhdG9yID0gdGhpcy5zZXBhcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc291cmNlLmZpbGVuYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNPd25Qcm9wLmNhbGwodGhpcy51bmlxdWVTb3VyY2VJbmRleEJ5RmlsZW5hbWUsIHNvdXJjZS5maWxlbmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lW3NvdXJjZS5maWxlbmFtZV0gPSB0aGlzLnVuaXF1ZVNvdXJjZXMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy51bmlxdWVTb3VyY2VzLnB1c2goeyBmaWxlbmFtZTogc291cmNlLmZpbGVuYW1lLCBjb250ZW50OiBzb3VyY2UuY29udGVudC5vcmlnaW5hbCB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVuaXF1ZVNvdXJjZSA9IHRoaXMudW5pcXVlU291cmNlc1t0aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZVtzb3VyY2UuZmlsZW5hbWVdXTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuY29udGVudC5vcmlnaW5hbCAhPT0gdW5pcXVlU291cmNlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzb3VyY2U6IHNhbWUgZmlsZW5hbWUgKFwiICsgc291cmNlLmZpbGVuYW1lICsgXCIpLCBkaWZmZXJlbnQgY29udGVudHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZChzdHIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hZGRTb3VyY2Uoe1xuICAgICAgICAgIGNvbnRlbnQ6IG5ldyBNYWdpY1N0cmluZyhzdHIpLFxuICAgICAgICAgIHNlcGFyYXRvcjogb3B0aW9ucyAmJiBvcHRpb25zLnNlcGFyYXRvciB8fCAnJ1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgdmFyIGJ1bmRsZSA9IG5ldyBCdW5kbGUoe1xuICAgICAgICAgIGludHJvOiB0aGlzLmludHJvLFxuICAgICAgICAgIHNlcGFyYXRvcjogdGhpcy5zZXBhcmF0b3JcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgIGJ1bmRsZS5hZGRTb3VyY2Uoe1xuICAgICAgICAgICAgZmlsZW5hbWU6IHNvdXJjZS5maWxlbmFtZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHNvdXJjZS5jb250ZW50LmNsb25lKCksXG4gICAgICAgICAgICBzZXBhcmF0b3I6IHNvdXJjZS5zZXBhcmF0b3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1bmRsZTtcbiAgICAgIH0sXG5cbiAgICAgIGdlbmVyYXRlTWFwOiBmdW5jdGlvbiBnZW5lcmF0ZU1hcChvcHRpb25zKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvZmZzZXRzID0ge307XG5cbiAgICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICAgIHRoaXMuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UuY29udGVudC5zdG9yZWROYW1lcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCF+bmFtZXMuaW5kZXhPZihuYW1lKSkgbmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGVuY29kZWQgPSBnZXRTZW1pcyh0aGlzLmludHJvKSArIHRoaXMuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSwgaSkge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBpID4gMCA/IGdldFNlbWlzKHNvdXJjZS5zZXBhcmF0b3IpIHx8ICcsJyA6ICcnO1xuICAgICAgICAgIHZhciBtYXBwaW5ncztcblxuICAgICAgICAgIC8vIHdlIGRvbid0IGJvdGhlciBlbmNvZGluZyBzb3VyY2VzIHdpdGhvdXQgYSBmaWxlbmFtZVxuICAgICAgICAgIGlmICghc291cmNlLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICBtYXBwaW5ncyA9IGdldFNlbWlzKHNvdXJjZS5jb250ZW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc291cmNlSW5kZXggPSB0aGlzJDEudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lW3NvdXJjZS5maWxlbmFtZV07XG4gICAgICAgICAgICBtYXBwaW5ncyA9IHNvdXJjZS5jb250ZW50LmdldE1hcHBpbmdzKG9wdGlvbnMuaGlyZXMsIHNvdXJjZUluZGV4LCBvZmZzZXRzLCBuYW1lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIG1hcHBpbmdzO1xuICAgICAgICB9KS5qb2luKCcnKTtcblxuICAgICAgICByZXR1cm4gbmV3IFNvdXJjZU1hcCh7XG4gICAgICAgICAgZmlsZTogb3B0aW9ucy5maWxlID8gb3B0aW9ucy5maWxlLnNwbGl0KC9bXFwvXFxcXF0vKS5wb3AoKSA6IG51bGwsXG4gICAgICAgICAgc291cmNlczogdGhpcy51bmlxdWVTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5maWxlID8gZ2V0UmVsYXRpdmVQYXRoKG9wdGlvbnMuZmlsZSwgc291cmNlLmZpbGVuYW1lKSA6IHNvdXJjZS5maWxlbmFtZTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzb3VyY2VzQ29udGVudDogdGhpcy51bmlxdWVTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5pbmNsdWRlQ29udGVudCA/IHNvdXJjZS5jb250ZW50IDogbnVsbDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBuYW1lczogbmFtZXMsXG4gICAgICAgICAgbWFwcGluZ3M6IGVuY29kZWRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBnZXRJbmRlbnRTdHJpbmc6IGZ1bmN0aW9uIGdldEluZGVudFN0cmluZygpIHtcbiAgICAgICAgdmFyIGluZGVudFN0cmluZ0NvdW50cyA9IHt9O1xuXG4gICAgICAgIHRoaXMuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICB2YXIgaW5kZW50U3RyID0gc291cmNlLmNvbnRlbnQuaW5kZW50U3RyO1xuXG4gICAgICAgICAgaWYgKGluZGVudFN0ciA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgICAgaWYgKCFpbmRlbnRTdHJpbmdDb3VudHNbaW5kZW50U3RyXSkgaW5kZW50U3RyaW5nQ291bnRzW2luZGVudFN0cl0gPSAwO1xuICAgICAgICAgIGluZGVudFN0cmluZ0NvdW50c1tpbmRlbnRTdHJdICs9IDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhpbmRlbnRTdHJpbmdDb3VudHMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZW50U3RyaW5nQ291bnRzW2FdIC0gaW5kZW50U3RyaW5nQ291bnRzW2JdO1xuICAgICAgICB9KVswXSB8fCAnXFx0JztcbiAgICAgIH0sXG5cbiAgICAgIGluZGVudDogZnVuY3Rpb24gaW5kZW50KGluZGVudFN0cikge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBpbmRlbnRTdHIgPSB0aGlzLmdldEluZGVudFN0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGVudFN0ciA9PT0gJycpIHJldHVybiB0aGlzOyAvLyBub29wXG5cbiAgICAgICAgdmFyIHRyYWlsaW5nTmV3bGluZSA9ICF0aGlzLmludHJvIHx8IHRoaXMuaW50cm8uc2xpY2UoLTEpID09PSAnXFxuJztcblxuICAgICAgICB0aGlzLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlLCBpKSB7XG4gICAgICAgICAgdmFyIHNlcGFyYXRvciA9IHNvdXJjZS5zZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IHNvdXJjZS5zZXBhcmF0b3IgOiB0aGlzJDEuc2VwYXJhdG9yO1xuICAgICAgICAgIHZhciBpbmRlbnRTdGFydCA9IHRyYWlsaW5nTmV3bGluZSB8fCBpID4gMCAmJiAvXFxyP1xcbiQvLnRlc3Qoc2VwYXJhdG9yKTtcblxuICAgICAgICAgIHNvdXJjZS5jb250ZW50LmluZGVudChpbmRlbnRTdHIsIHtcbiAgICAgICAgICAgIGV4Y2x1ZGU6IHNvdXJjZS5pbmRlbnRFeGNsdXNpb25SYW5nZXMsXG4gICAgICAgICAgICBpbmRlbnRTdGFydDogaW5kZW50U3RhcnQgLy86IHRyYWlsaW5nTmV3bGluZSB8fCAvXFxyP1xcbiQvLnRlc3QoIHNlcGFyYXRvciApICAvL3RydWUvLy9cXHI/XFxuLy50ZXN0KCBzZXBhcmF0b3IgKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gVE9ETyB0aGlzIGlzIGEgdmVyeSBzbG93IHdheSB0byBkZXRlcm1pbmUgdGhpc1xuICAgICAgICAgIHRyYWlsaW5nTmV3bGluZSA9IHNvdXJjZS5jb250ZW50LnRvU3RyaW5nKCkuc2xpY2UoMCwgLTEpID09PSAnXFxuJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW50cm8pIHtcbiAgICAgICAgICB0aGlzLmludHJvID0gaW5kZW50U3RyICsgdGhpcy5pbnRyby5yZXBsYWNlKC9eW15cXG5dL2dtLCBmdW5jdGlvbiAobWF0Y2gsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggPiAwID8gaW5kZW50U3RyICsgbWF0Y2ggOiBtYXRjaDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgcHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZChzdHIpIHtcbiAgICAgICAgdGhpcy5pbnRybyA9IHN0ciArIHRoaXMuaW50cm87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICB2YXIgYm9keSA9IHRoaXMuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSwgaSkge1xuICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSBzb3VyY2Uuc2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBzb3VyY2Uuc2VwYXJhdG9yIDogdGhpcyQxLnNlcGFyYXRvcjtcbiAgICAgICAgICB2YXIgc3RyID0gKGkgPiAwID8gc2VwYXJhdG9yIDogJycpICsgc291cmNlLmNvbnRlbnQudG9TdHJpbmcoKTtcblxuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmludHJvICsgYm9keTtcbiAgICAgIH0sXG5cbiAgICAgIHRyaW1MaW5lczogZnVuY3Rpb24gdHJpbUxpbmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmltKCdbXFxcXHJcXFxcbl0nKTtcbiAgICAgIH0sXG5cbiAgICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0oY2hhclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpbVN0YXJ0KGNoYXJUeXBlKS50cmltRW5kKGNoYXJUeXBlKTtcbiAgICAgIH0sXG5cbiAgICAgIHRyaW1TdGFydDogZnVuY3Rpb24gdHJpbVN0YXJ0KGNoYXJUeXBlKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciByeCA9IG5ldyBSZWdFeHAoJ14nICsgKGNoYXJUeXBlIHx8ICdcXFxccycpICsgJysnKTtcbiAgICAgICAgdGhpcy5pbnRybyA9IHRoaXMuaW50cm8ucmVwbGFjZShyeCwgJycpO1xuXG4gICAgICAgIGlmICghdGhpcy5pbnRybykge1xuICAgICAgICAgIHZhciBzb3VyY2U7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgc291cmNlID0gdGhpcyQxLnNvdXJjZXNbaV07XG5cbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzb3VyY2UuY29udGVudC50cmltU3RhcnQoY2hhclR5cGUpO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIH0gd2hpbGUgKHNvdXJjZS5jb250ZW50LnRvU3RyaW5nKCkgPT09ICcnKTsgLy8gVE9ETyBmYXN0ZXIgd2F5IHRvIGRldGVybWluZSBub24tZW1wdHkgc291cmNlP1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICB0cmltRW5kOiBmdW5jdGlvbiB0cmltRW5kKGNoYXJUeXBlKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciByeCA9IG5ldyBSZWdFeHAoKGNoYXJUeXBlIHx8ICdcXFxccycpICsgJyskJyk7XG5cbiAgICAgICAgdmFyIHNvdXJjZTtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnNvdXJjZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgc291cmNlID0gdGhpcyQxLnNvdXJjZXNbaV07XG5cbiAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcyQxLmludHJvID0gdGhpcyQxLmludHJvLnJlcGxhY2UocngsICcnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNvdXJjZS5jb250ZW50LnRyaW1FbmQoY2hhclR5cGUpO1xuICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfSB3aGlsZSAoc291cmNlLmNvbnRlbnQudG9TdHJpbmcoKSA9PT0gJycpOyAvLyBUT0RPIGZhc3RlciB3YXkgdG8gZGV0ZXJtaW5lIG5vbi1lbXB0eSBzb3VyY2U/XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFNlbWlzKHN0cikge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheShzdHIuc3BsaXQoJ1xcbicpLmxlbmd0aCkuam9pbignOycpO1xuICAgIH1cblxuICAgIE1hZ2ljU3RyaW5nLkJ1bmRsZSA9IEJ1bmRsZTtcblxuICAgIHZhciBrZXlzID0ge1xuICAgICAgUHJvZ3JhbTogWydib2R5J10sXG4gICAgICBMaXRlcmFsOiBbXVxuICAgIH07XG5cbiAgICAvLyB1c2VkIGZvciBkZWJ1Z2dpbmcsIHdpdGhvdXQgdGhlIG5vaXNlIGNyZWF0ZWQgYnlcbiAgICAvLyBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgZnVuY3Rpb24gdG9KU09OKG5vZGUpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcblxuICAgICAgT2JqZWN0LmtleXMobm9kZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdwYXJlbnQnIHx8IGtleSA9PT0gJ3Byb2dyYW0nIHx8IGtleSA9PT0gJ2tleXMnIHx8IGtleSA9PT0gJ19fd3JhcHBlZCcpIHJldHVybjtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlW2tleV0pKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBub2RlW2tleV0ubWFwKHRvSlNPTik7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZVtrZXldICYmIG5vZGVba2V5XS50b0pTT04pIHtcbiAgICAgICAgICBvYmpba2V5XSA9IG5vZGVba2V5XS50b0pTT04oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpba2V5XSA9IG5vZGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKHJhdywgcGFyZW50KSB7XG4gICAgICByYXcucGFyZW50ID0gcGFyZW50O1xuICAgICAgcmF3LnByb2dyYW0gPSBwYXJlbnQucHJvZ3JhbSB8fCBwYXJlbnQ7XG4gICAgICByYXcuZGVwdGggPSBwYXJlbnQuZGVwdGggKyAxO1xuICAgICAgcmF3LmtleXMgPSBrZXlzW3Jhdy50eXBlXTtcbiAgICAgIHJhdy5pbmRlbnRhdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBrZXlzW3Jhdy50eXBlXTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGtleSA9IGxpc3RbaV07XG5cbiAgICAgICAgd3JhcChyYXdba2V5XSwgcmF3KTtcbiAgICAgIH1cblxuICAgICAgcmF3LnByb2dyYW0ubWFnaWNTdHJpbmcuYWRkU291cmNlbWFwTG9jYXRpb24ocmF3LnN0YXJ0KTtcbiAgICAgIHJhdy5wcm9ncmFtLm1hZ2ljU3RyaW5nLmFkZFNvdXJjZW1hcExvY2F0aW9uKHJhdy5lbmQpO1xuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS5hbmNlc3RvciA9IGZ1bmN0aW9uIGFuY2VzdG9yKGxldmVsKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICB3aGlsZSAobGV2ZWwtLSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKG5vZGUpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcyQxKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLmZpbmRMZXhpY2FsQm91bmRhcnkgPSBmdW5jdGlvbiBmaW5kTGV4aWNhbEJvdW5kYXJ5KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmZpbmRMZXhpY2FsQm91bmRhcnkoKTtcbiAgICB9O1xuXG4gICAgTm9kZS5wcm90b3R5cGUuZmluZE5lYXJlc3QgPSBmdW5jdGlvbiBmaW5kTmVhcmVzdCh0eXBlKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB0eXBlID0gbmV3IFJlZ0V4cChcIl5cIiArIHR5cGUgKyBcIiRcIik7XG4gICAgICBpZiAodHlwZS50ZXN0KHRoaXMudHlwZSkpIHJldHVybiB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmZpbmROZWFyZXN0KHR5cGUpO1xuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS51bnBhcmVudGhlc2l6ZWRQYXJlbnQgPSBmdW5jdGlvbiB1bnBhcmVudGhlc2l6ZWRQYXJlbnQoKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMucGFyZW50O1xuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS50eXBlID09PSAnUGFyZW50aGVzaXplZEV4cHJlc3Npb24nKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS51bnBhcmVudGhlc2l6ZSA9IGZ1bmN0aW9uIHVucGFyZW50aGVzaXplKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzO1xuICAgICAgd2hpbGUgKG5vZGUudHlwZSA9PT0gJ1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uJykge1xuICAgICAgICBub2RlID0gbm9kZS5leHByZXNzaW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLmZpbmRTY29wZSA9IGZ1bmN0aW9uIGZpbmRTY29wZShmdW5jdGlvblNjb3BlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZmluZFNjb3BlKGZ1bmN0aW9uU2NvcGUpO1xuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS5nZXRJbmRlbnRhdGlvbiA9IGZ1bmN0aW9uIGdldEluZGVudGF0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldEluZGVudGF0aW9uKCk7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKHRyYW5zZm9ybXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5rZXlzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIga2V5ID0gbGlzdFtpXTtcblxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5pbml0aWFsaXNlKHRyYW5zZm9ybXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdmFsdWUuaW5pdGlhbGlzZSh0cmFuc2Zvcm1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04kMSgpIHtcbiAgICAgIHJldHVybiB0b0pTT04odGhpcyk7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmFtLm1hZ2ljU3RyaW5nLm9yaWdpbmFsLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICB9O1xuXG4gICAgTm9kZS5wcm90b3R5cGUudHJhbnNwaWxlID0gZnVuY3Rpb24gdHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gdGhpcy5rZXlzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIga2V5ID0gbGlzdFtpXTtcblxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS50cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB2YWx1ZS50cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNBcmd1bWVudHMobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmIG5vZGUubmFtZSA9PT0gJ2FyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3ByZWFkKGNvZGUsIGVsZW1lbnRzLCBzdGFydCwgYXJndW1lbnRzQXJyYXlBbGlhcywgaXNOZXcpIHtcbiAgICAgIHZhciBpID0gZWxlbWVudHMubGVuZ3RoO1xuICAgICAgdmFyIGZpcnN0U3ByZWFkSW5kZXggPSAtMTtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgZWxlbWVudCQxID0gZWxlbWVudHNbaV07XG4gICAgICAgIGlmIChlbGVtZW50JDEgJiYgZWxlbWVudCQxLnR5cGUgPT09ICdTcHJlYWRFbGVtZW50Jykge1xuICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhlbGVtZW50JDEuYXJndW1lbnQpKSB7XG4gICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShlbGVtZW50JDEuYXJndW1lbnQuc3RhcnQsIGVsZW1lbnQkMS5hcmd1bWVudC5lbmQsIGFyZ3VtZW50c0FycmF5QWxpYXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpcnN0U3ByZWFkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdFNwcmVhZEluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlOyAvLyBmYWxzZSBpbmRpY2F0ZXMgbm8gc3ByZWFkIGVsZW1lbnRzXG5cbiAgICAgIGlmIChpc05ldykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCQyID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgaWYgKGVsZW1lbnQkMi50eXBlID09PSAnU3ByZWFkRWxlbWVudCcpIHtcbiAgICAgICAgICAgIGNvZGUucmVtb3ZlKGVsZW1lbnQkMi5zdGFydCwgZWxlbWVudCQyLmFyZ3VtZW50LnN0YXJ0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodChlbGVtZW50JDIuc3RhcnQsICdbJyk7XG4gICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KGVsZW1lbnQkMi5lbmQsICddJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIHRydWUgaW5kaWNhdGVzIHNvbWUgc3ByZWFkIGVsZW1lbnRzXG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbZmlyc3RTcHJlYWRJbmRleF07XG4gICAgICB2YXIgcHJldmlvdXNFbGVtZW50ID0gZWxlbWVudHNbZmlyc3RTcHJlYWRJbmRleCAtIDFdO1xuXG4gICAgICBpZiAoIXByZXZpb3VzRWxlbWVudCkge1xuICAgICAgICBjb2RlLnJlbW92ZShzdGFydCwgZWxlbWVudC5zdGFydCk7XG4gICAgICAgIGNvZGUub3ZlcndyaXRlKGVsZW1lbnQuZW5kLCBlbGVtZW50c1sxXS5zdGFydCwgJy5jb25jYXQoICcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5vdmVyd3JpdGUocHJldmlvdXNFbGVtZW50LmVuZCwgZWxlbWVudC5zdGFydCwgJyBdLmNvbmNhdCggJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IGZpcnN0U3ByZWFkSW5kZXg7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XG5cbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAnU3ByZWFkRWxlbWVudCcpIHtcbiAgICAgICAgICAgIGNvZGUucmVtb3ZlKGVsZW1lbnQuc3RhcnQsIGVsZW1lbnQuYXJndW1lbnQuc3RhcnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlLmluc2VydExlZnQoZWxlbWVudC5zdGFydCwgJ1snKTtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChlbGVtZW50LmVuZCwgJ10nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7IC8vIHRydWUgaW5kaWNhdGVzIHNvbWUgc3ByZWFkIGVsZW1lbnRzXG4gICAgfVxuXG4gICAgdmFyIEFycmF5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBBcnJheUV4cHJlc3Npb24oKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIEFycmF5RXhwcmVzc2lvbi5fX3Byb3RvX18gPSBOb2RlO1xuICAgICAgQXJyYXlFeHByZXNzaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBBcnJheUV4cHJlc3Npb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXJyYXlFeHByZXNzaW9uO1xuXG4gICAgICBBcnJheUV4cHJlc3Npb24ucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKHRyYW5zZm9ybXMpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybXMuc3ByZWFkUmVzdCAmJiB0aGlzLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBsZXhpY2FsQm91bmRhcnkgPSB0aGlzLmZpbmRMZXhpY2FsQm91bmRhcnkoKTtcblxuICAgICAgICAgIHZhciBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzJDEuZWxlbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09ICdTcHJlYWRFbGVtZW50JyAmJiBpc0FyZ3VtZW50cyhlbGVtZW50LmFyZ3VtZW50KSkge1xuICAgICAgICAgICAgICB0aGlzJDEuYXJndW1lbnRzQXJyYXlBbGlhcyA9IGxleGljYWxCb3VuZGFyeS5nZXRBcmd1bWVudHNBcnJheUFsaWFzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgTm9kZS5wcm90b3R5cGUuaW5pdGlhbGlzZS5jYWxsKHRoaXMsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgQXJyYXlFeHByZXNzaW9uLnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAodHJhbnNmb3Jtcy5zcHJlYWRSZXN0KSB7XG4gICAgICAgICAgLy8gZXJhc2UgdHJhaWxpbmcgY29tbWEgYWZ0ZXIgbGFzdCBhcnJheSBlbGVtZW50IGlmIG5vdCBhbiBhcnJheSBob2xlXG4gICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3RoaXMuZWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdEVsZW1lbnQgJiYgL1xccyosLy50ZXN0KGNvZGUub3JpZ2luYWwuc2xpY2UobGFzdEVsZW1lbnQuZW5kLCB0aGlzLmVuZCkpKSB7XG4gICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKGxhc3RFbGVtZW50LmVuZCwgdGhpcy5lbmQgLSAxLCAnICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzWzBdO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09ICdTcHJlYWRFbGVtZW50Jykge1xuICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2Ug4oCTIFsgLi4uYXJndW1lbnRzIF1cbiAgICAgICAgICAgICAgaWYgKGlzQXJndW1lbnRzKGVsZW1lbnQuYXJndW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgdGhpcy5lbmQsIFwiW10uY29uY2F0KCBcIiArIHRoaXMuYXJndW1lbnRzQXJyYXlBbGlhcyArIFwiIClcIik7IC8vIFRPRE8gaWYgdGhpcyBpcyB0aGUgb25seSB1c2Ugb2YgYXJnc0FycmF5LCBkb24ndCBib3RoZXIgY29uY2F0aW5nXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgZWxlbWVudC5hcmd1bWVudC5zdGFydCwgJ1tdLmNvbmNhdCggJyk7XG4gICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUoZWxlbWVudC5lbmQsIHRoaXMuZW5kLCAnICknKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaGFzU3ByZWFkRWxlbWVudHMgPSBzcHJlYWQoY29kZSwgdGhpcy5lbGVtZW50cywgdGhpcy5zdGFydCwgdGhpcy5hcmd1bWVudHNBcnJheUFsaWFzKTtcblxuICAgICAgICAgICAgaWYgKGhhc1NwcmVhZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuZW5kIC0gMSwgdGhpcy5lbmQsICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgTm9kZS5wcm90b3R5cGUudHJhbnNwaWxlLmNhbGwodGhpcywgY29kZSwgdHJhbnNmb3Jtcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQXJyYXlFeHByZXNzaW9uO1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIEFycm93RnVuY3Rpb25FeHByZXNzaW9uLl9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG5cbiAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uLnByb3RvdHlwZS5pbml0aWFsaXNlID0gZnVuY3Rpb24gaW5pdGlhbGlzZSh0cmFuc2Zvcm1zKSB7XG4gICAgICAgIHRoaXMuYm9keS5jcmVhdGVTY29wZSgpO1xuICAgICAgICBOb2RlLnByb3RvdHlwZS5pbml0aWFsaXNlLmNhbGwodGhpcywgdHJhbnNmb3Jtcyk7XG4gICAgICB9O1xuXG4gICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbi5wcm90b3R5cGUudHJhbnNwaWxlID0gZnVuY3Rpb24gdHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybXMuYXJyb3cpIHtcbiAgICAgICAgICAvLyByZW1vdmUgYXJyb3dcbiAgICAgICAgICB2YXIgY2hhckluZGV4ID0gdGhpcy5ib2R5LnN0YXJ0O1xuICAgICAgICAgIHdoaWxlIChjb2RlLm9yaWdpbmFsW2NoYXJJbmRleF0gIT09ICc9Jykge1xuICAgICAgICAgICAgY2hhckluZGV4IC09IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZGUucmVtb3ZlKGNoYXJJbmRleCwgdGhpcy5ib2R5LnN0YXJ0KTtcblxuICAgICAgICAgIC8vIHdyYXAgbmFrZWQgcGFyYW1ldGVyXG4gICAgICAgICAgaWYgKHRoaXMucGFyYW1zLmxlbmd0aCA9PT0gMSAmJiB0aGlzLnN0YXJ0ID09PSB0aGlzLnBhcmFtc1swXS5zdGFydCkge1xuICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodCh0aGlzLnBhcmFtc1swXS5zdGFydCwgJygnKTtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLnBhcmFtc1swXS5lbmQsICcpJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIGZ1bmN0aW9uXG4gICAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50Jykge1xuICAgICAgICAgICAgLy8gc3RhbmRhbG9uZSBleHByZXNzaW9uIHN0YXRlbWVudFxuICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodCh0aGlzLnN0YXJ0LCAnKGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KHRoaXMuZW5kLCAnKScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KHRoaXMuc3RhcnQsICdmdW5jdGlvbiAnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBOb2RlLnByb3RvdHlwZS50cmFuc3BpbGUuY2FsbCh0aGlzLCBjb2RlLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcbiAgICB9KE5vZGUpO1xuXG4gICAgZnVuY3Rpb24gbG9jYXRlKHNvdXJjZSwgaW5kZXgpIHtcbiAgICAgIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgbGVuID0gbGluZXMubGVuZ3RoO1xuXG4gICAgICB2YXIgbGluZVN0YXJ0ID0gMDtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgdmFyIGxpbmVFbmQgPSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aCArIDE7IC8vICsxIGZvciBuZXdsaW5lXG5cbiAgICAgICAgaWYgKGxpbmVFbmQgPiBpbmRleCkge1xuICAgICAgICAgIHJldHVybiB7IGxpbmU6IGkgKyAxLCBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0LCBjaGFyOiBpIH07XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lU3RhcnQgPSBsaW5lRW5kO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgbG9jYXRpb24gb2YgY2hhcmFjdGVyJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFkKG51bSwgbGVuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gU3RyaW5nKG51bSk7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgcmVwZWF0KCcgJywgbGVuIC0gcmVzdWx0Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwZWF0KHN0ciwgdGltZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHdoaWxlICh0aW1lcy0tKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHI7XG4gICAgICB9cmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTbmlwcGV0KHNvdXJjZSwgbG9jLCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkgbGVuZ3RoID0gMTtcblxuICAgICAgdmFyIGZpcnN0ID0gTWF0aC5tYXgobG9jLmxpbmUgLSA1LCAwKTtcbiAgICAgIHZhciBsYXN0ID0gbG9jLmxpbmU7XG5cbiAgICAgIHZhciBudW1EaWdpdHMgPSBTdHJpbmcobGFzdCkubGVuZ3RoO1xuXG4gICAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpLnNsaWNlKGZpcnN0LCBsYXN0KTtcblxuICAgICAgdmFyIGxhc3RMaW5lID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgb2Zmc2V0ID0gbGFzdExpbmUuc2xpY2UoMCwgbG9jLmNvbHVtbikucmVwbGFjZSgvXFx0L2csICcgICcpLmxlbmd0aDtcblxuICAgICAgdmFyIHNuaXBwZXQgPSBsaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgcmV0dXJuIHBhZChpICsgZmlyc3QgKyAxLCBudW1EaWdpdHMpICsgXCIgOiBcIiArIGxpbmUucmVwbGFjZSgvXFx0L2csICcgICcpO1xuICAgICAgfSkuam9pbignXFxuJyk7XG5cbiAgICAgIHNuaXBwZXQgKz0gJ1xcbicgKyByZXBlYXQoJyAnLCBudW1EaWdpdHMgKyAzICsgb2Zmc2V0KSArIHJlcGVhdCgnXicsIGxlbmd0aCk7XG5cbiAgICAgIHJldHVybiBzbmlwcGV0O1xuICAgIH1cblxuICAgIHZhciBDb21waWxlRXJyb3IgPSBmdW5jdGlvbiAoRXJyb3IpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVFcnJvcihub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIEVycm9yLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IG5vZGUucHJvZ3JhbS5tYWdpY1N0cmluZy5vcmlnaW5hbDtcbiAgICAgICAgdmFyIGxvYyA9IGxvY2F0ZShzb3VyY2UsIG5vZGUuc3RhcnQpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdDb21waWxlRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlICsgXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcblxuICAgICAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2sucmVwbGFjZShuZXcgUmVnRXhwKFwiLituZXcgXCIgKyB0aGlzLm5hbWUgKyBcIi4rXFxcXG5cIiwgJ20nKSwgJycpO1xuXG4gICAgICAgIHRoaXMubG9jID0gbG9jO1xuICAgICAgICB0aGlzLnNuaXBwZXQgPSBnZXRTbmlwcGV0KHNvdXJjZSwgbG9jLCBub2RlLmVuZCAtIG5vZGUuc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoRXJyb3IpIENvbXBpbGVFcnJvci5fX3Byb3RvX18gPSBFcnJvcjtcbiAgICAgIENvbXBpbGVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yICYmIEVycm9yLnByb3RvdHlwZSk7XG4gICAgICBDb21waWxlRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tcGlsZUVycm9yO1xuXG4gICAgICBDb21waWxlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgKyBcIlxcblwiICsgdGhpcy5zbmlwcGV0O1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbXBpbGVFcnJvcjtcbiAgICB9KEVycm9yKTtcblxuICAgIHZhciBBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcbiAgICAgICAgTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTm9kZSkgQXNzaWdubWVudEV4cHJlc3Npb24uX19wcm90b19fID0gTm9kZTtcbiAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NpZ25tZW50RXhwcmVzc2lvbjtcblxuICAgICAgQXNzaWdubWVudEV4cHJlc3Npb24ucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKHRyYW5zZm9ybXMpIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLmZpbmRTY29wZShmYWxzZSkuZmluZERlY2xhcmF0aW9uKHRoaXMubGVmdC5uYW1lKTtcbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb24gJiYgZGVjbGFyYXRpb24ua2luZCA9PT0gJ2NvbnN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih0aGlzLmxlZnQsIHRoaXMubGVmdC5uYW1lICsgXCIgaXMgcmVhZC1vbmx5XCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSDigJMgaHR0cHM6Ly9naXRsYWIuY29tL1JpY2gtSGFycmlzL2J1YmxlL2lzc3Vlcy8xMVxuICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSBkZWNsYXJhdGlvbiAmJiBkZWNsYXJhdGlvbi5ub2RlLmFuY2VzdG9yKDMpO1xuICAgICAgICAgIGlmIChzdGF0ZW1lbnQgJiYgc3RhdGVtZW50LnR5cGUgPT09ICdGb3JTdGF0ZW1lbnQnICYmIHN0YXRlbWVudC5ib2R5LmNvbnRhaW5zKHRoaXMpKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnQucmVhc3NpZ25lZFt0aGlzLmxlZnQubmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmluaXRpYWxpc2UuY2FsbCh0aGlzLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uLnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJyoqPScgJiYgdHJhbnNmb3Jtcy5leHBvbmVudGlhdGlvbikge1xuICAgICAgICAgIHRoaXMudHJhbnNwaWxlRXhwb25lbnRpYXRpb24oY29kZSwgdHJhbnNmb3Jtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoL1BhdHRlcm4vLnRlc3QodGhpcy5sZWZ0LnR5cGUpICYmIHRyYW5zZm9ybXMuZGVzdHJ1Y3R1cmluZykge1xuICAgICAgICAgIHRoaXMudHJhbnNwaWxlRGVzdHJ1Y3R1cmluZyhjb2RlLCB0cmFuc2Zvcm1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE5vZGUucHJvdG90eXBlLnRyYW5zcGlsZS5jYWxsKHRoaXMsIGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgQXNzaWdubWVudEV4cHJlc3Npb24ucHJvdG90eXBlLnRyYW5zcGlsZURlc3RydWN0dXJpbmcgPSBmdW5jdGlvbiB0cmFuc3BpbGVEZXN0cnVjdHVyaW5nKGNvZGUpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5maW5kU2NvcGUodHJ1ZSk7XG4gICAgICAgIHZhciBhc3NpZ24gPSBzY29wZS5jcmVhdGVJZGVudGlmaWVyKCdhc3NpZ24nKTtcbiAgICAgICAgdmFyIHRlbXBvcmFyaWVzID0gW2Fzc2lnbl07XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHBpY2sgb3V0IHNvbWUgZWxlbWVudHMgZnJvbSB0aGUgb3JpZ2luYWwgY29kZSxcbiAgICAgICAgLy8gaW50ZXJsZWF2ZWQgd2l0aCBnZW5lcmF0ZWQgY29kZS4gVGhlc2UgaGVscGVycyBhcmUgdXNlZCB0b1xuICAgICAgICAvLyBlYXNpbHkgZG8gdGhhdCB3aGlsZSBrZWVwaW5nIHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0XG4gICAgICAgIC8vIHByZWRpY3RhYmxlLlxuICAgICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgICBmdW5jdGlvbiB1c2Uobm9kZSkge1xuICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQobm9kZS5zdGFydCwgdGV4dCk7XG4gICAgICAgICAgY29kZS5tb3ZlKG5vZGUuc3RhcnQsIG5vZGUuZW5kLCBzdGFydCk7XG4gICAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlKHN0cmluZykge1xuICAgICAgICAgIHRleHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgd3JpdGUoXCIoXCIgKyBhc3NpZ24gKyBcIiA9IFwiKTtcbiAgICAgICAgdXNlKHRoaXMucmlnaHQpO1xuXG4gICAgICAgIC8vIFdhbGsgYHBhdHRlcm5gLCBnZW5lcmF0aW5nIGNvZGUgdGhhdCBhc3NpZ25zIHRoZSB2YWx1ZSBpblxuICAgICAgICAvLyBgcmVmYCB0byBpdC4gV2hlbiBgbWF5RHVwbGljYXRlYCBpcyBmYWxzZSwgdGhlIGZ1bmN0aW9uXG4gICAgICAgIC8vIG11c3QgdGFrZSBjYXJlIHRvIG9ubHkgb3V0cHV0IGByZWZgIG9uY2UuXG4gICAgICAgIGZ1bmN0aW9uIGRlc3RydWN0dXJlKHBhdHRlcm4sIHJlZiwgbWF5RHVwbGljYXRlKSB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4udHlwZSA9PT0gJ0lkZW50aWZpZXInIHx8IHBhdHRlcm4udHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICB3cml0ZSgnLCAnKTtcbiAgICAgICAgICAgIHVzZShwYXR0ZXJuKTtcbiAgICAgICAgICAgIHdyaXRlKFwiID0gXCIgKyByZWYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGF0dGVybi50eXBlID09PSAnQXNzaWdubWVudFBhdHRlcm4nKSB7XG4gICAgICAgICAgICBpZiAocGF0dGVybi5sZWZ0LnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gcGF0dGVybi5sZWZ0Lm5hbWU7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2UgPSByZWY7XG4gICAgICAgICAgICAgIGlmICghbWF5RHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgd3JpdGUoXCIsIFwiICsgdGFyZ2V0ICsgXCIgPSBcIiArIHJlZik7XG4gICAgICAgICAgICAgICAgc291cmNlID0gdGFyZ2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKFwiLCBcIiArIHRhcmdldCArIFwiID0gXCIgKyBzb3VyY2UgKyBcIiA9PT0gdm9pZCAwID8gXCIpO1xuICAgICAgICAgICAgICB1c2UocGF0dGVybi5yaWdodCk7XG4gICAgICAgICAgICAgIHdyaXRlKFwiIDogXCIgKyBzb3VyY2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHRhcmdldCQxID0gc2NvcGUuY3JlYXRlSWRlbnRpZmllcigndGVtcCcpO1xuICAgICAgICAgICAgICB2YXIgc291cmNlJDEgPSByZWY7XG4gICAgICAgICAgICAgIHRlbXBvcmFyaWVzLnB1c2godGFyZ2V0JDEpO1xuICAgICAgICAgICAgICBpZiAoIW1heUR1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgIHdyaXRlKFwiLCBcIiArIHRhcmdldCQxICsgXCIgPSBcIiArIHJlZik7XG4gICAgICAgICAgICAgICAgc291cmNlJDEgPSB0YXJnZXQkMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZShcIiwgXCIgKyB0YXJnZXQkMSArIFwiID0gXCIgKyBzb3VyY2UkMSArIFwiID09PSB2b2lkIDAgPyBcIik7XG4gICAgICAgICAgICAgIHVzZShwYXR0ZXJuLnJpZ2h0KTtcbiAgICAgICAgICAgICAgd3JpdGUoXCIgOiBcIiArIHNvdXJjZSQxKTtcbiAgICAgICAgICAgICAgZGVzdHJ1Y3R1cmUocGF0dGVybi5sZWZ0LCB0YXJnZXQkMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXR0ZXJuLnR5cGUgPT09ICdBcnJheVBhdHRlcm4nKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBwYXR0ZXJuLmVsZW1lbnRzO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICBkZXN0cnVjdHVyZShlbGVtZW50c1swXSwgcmVmICsgXCJbMF1cIiwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFtYXlEdXBsaWNhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHNjb3BlLmNyZWF0ZUlkZW50aWZpZXIoJ2FycmF5Jyk7XG4gICAgICAgICAgICAgICAgdGVtcG9yYXJpZXMucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgICAgICB3cml0ZShcIiwgXCIgKyB0ZW1wICsgXCIgPSBcIiArIHJlZik7XG4gICAgICAgICAgICAgICAgcmVmID0gdGVtcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICdSZXN0RWxlbWVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3R1cmUoZWxlbWVudC5hcmd1bWVudCwgcmVmICsgXCIuc2xpY2UoXCIgKyBpICsgXCIpXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RydWN0dXJlKGVsZW1lbnQsIHJlZiArIFwiW1wiICsgaSArIFwiXVwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHBhdHRlcm4udHlwZSA9PT0gJ09iamVjdFBhdHRlcm4nKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBwYXR0ZXJuLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1swXTtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvcC5jb21wdXRlZCB8fCBwcm9wLmtleS50eXBlICE9PSAnSWRlbnRpZmllcicgPyByZWYgKyBcIltcIiArIGNvZGUuc2xpY2UocHJvcC5rZXkuc3RhcnQsIHByb3Aua2V5LmVuZCkgKyBcIl1cIiA6IHJlZiArIFwiLlwiICsgcHJvcC5rZXkubmFtZTtcbiAgICAgICAgICAgICAgZGVzdHJ1Y3R1cmUocHJvcC52YWx1ZSwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghbWF5RHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAkMSA9IHNjb3BlLmNyZWF0ZUlkZW50aWZpZXIoJ29iaicpO1xuICAgICAgICAgICAgICAgIHRlbXBvcmFyaWVzLnB1c2godGVtcCQxKTtcbiAgICAgICAgICAgICAgICB3cml0ZShcIiwgXCIgKyB0ZW1wJDEgKyBcIiA9IFwiICsgcmVmKTtcbiAgICAgICAgICAgICAgICByZWYgPSB0ZW1wJDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3AuY29tcHV0ZWQgfHwgcHJvcC5rZXkudHlwZSAhPT0gJ0lkZW50aWZpZXInID8gcmVmICsgXCJbXCIgKyBjb2RlLnNsaWNlKHByb3Aua2V5LnN0YXJ0LCBwcm9wLmtleS5lbmQpICsgXCJdXCIgOiByZWYgKyBcIi5cIiArIHByb3Aua2V5Lm5hbWU7XG4gICAgICAgICAgICAgICAgZGVzdHJ1Y3R1cmUocHJvcC52YWx1ZSwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbm9kZSB0eXBlIGluIGRlc3RydWN0dXJpbmcgYXNzaWdubWVudCAoXCIgKyBwYXR0ZXJuLnR5cGUgKyBcIilcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlc3RydWN0dXJlKHRoaXMubGVmdCwgYXNzaWduLCB0cnVlKTtcblxuICAgICAgICBpZiAodGhpcy51bnBhcmVudGhlc2l6ZWRQYXJlbnQoKS50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcpIHtcbiAgICAgICAgICAvLyBubyBydmFsdWUgbmVlZGVkIGZvciBleHByZXNzaW9uIHN0YXRlbWVudFxuICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQoc3RhcnQsIHRleHQgKyBcIilcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVzdHJ1Y3R1cmluZyBpcyBwYXJ0IG9mIGFuIGV4cHJlc3Npb24gLSBuZWVkIGFuIHJ2YWx1ZVxuICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQoc3RhcnQsIHRleHQgKyBcIiwgXCIgKyBhc3NpZ24gKyBcIilcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlLnJlbW92ZShzdGFydCwgdGhpcy5yaWdodC5zdGFydCk7XG5cbiAgICAgICAgdmFyIHN0YXRlbWVudCA9IHRoaXMuZmluZE5lYXJlc3QoLyg/OlN0YXRlbWVudHxEZWNsYXJhdGlvbikkLyk7XG4gICAgICAgIGNvZGUuaW5zZXJ0TGVmdChzdGF0ZW1lbnQuc3RhcnQsIFwidmFyIFwiICsgdGVtcG9yYXJpZXMuam9pbignLCAnKSArIFwiO1xcblwiICsgc3RhdGVtZW50LmdldEluZGVudGF0aW9uKCkpO1xuICAgICAgfTtcblxuICAgICAgQXNzaWdubWVudEV4cHJlc3Npb24ucHJvdG90eXBlLnRyYW5zcGlsZUV4cG9uZW50aWF0aW9uID0gZnVuY3Rpb24gdHJhbnNwaWxlRXhwb25lbnRpYXRpb24oY29kZSkge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLmZpbmRTY29wZShmYWxzZSk7XG4gICAgICAgIHZhciBnZXRBbGlhcyA9IGZ1bmN0aW9uIGdldEFsaWFzKG5hbWUpIHtcbiAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSBzY29wZS5maW5kRGVjbGFyYXRpb24obmFtZSk7XG4gICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uID8gZGVjbGFyYXRpb24ubmFtZSA6IG5hbWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZmlyc3QsIHRoZSBlYXN5IHBhcnQg4oCTIGAqKj1gIC0+IGA9YFxuICAgICAgICB2YXIgY2hhckluZGV4ID0gdGhpcy5sZWZ0LmVuZDtcbiAgICAgICAgd2hpbGUgKGNvZGUub3JpZ2luYWxbY2hhckluZGV4XSAhPT0gJyonKSB7XG4gICAgICAgICAgY2hhckluZGV4ICs9IDE7XG4gICAgICAgIH1jb2RlLnJlbW92ZShjaGFySW5kZXgsIGNoYXJJbmRleCArIDIpO1xuXG4gICAgICAgIC8vIGhvdyB3ZSBkbyB0aGUgbmV4dCBwYXJ0IGRlcGVuZHMgb24gYSBudW1iZXIgb2YgZmFjdG9ycyDigJMgd2hldGhlclxuICAgICAgICAvLyB0aGlzIGlzIGEgdG9wLWxldmVsIHN0YXRlbWVudCwgYW5kIHdoZXRoZXIgd2UncmUgdXBkYXRpbmcgYVxuICAgICAgICAvLyBzaW1wbGUgb3IgY29tcGxleCByZWZlcmVuY2VcbiAgICAgICAgdmFyIGJhc2U7XG5cbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQudW5wYXJlbnRoZXNpemUoKTtcblxuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICBiYXNlID0gZ2V0QWxpYXMobGVmdC5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZWZ0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICAgIHZhciBvYmplY3Q7XG4gICAgICAgICAgdmFyIG5lZWRzT2JqZWN0VmFyID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHByb3BlcnR5O1xuICAgICAgICAgIHZhciBuZWVkc1Byb3BlcnR5VmFyID0gZmFsc2U7XG5cbiAgICAgICAgICB2YXIgc3RhdGVtZW50ID0gdGhpcy5maW5kTmVhcmVzdCgvKD86U3RhdGVtZW50fERlY2xhcmF0aW9uKSQvKTtcbiAgICAgICAgICB2YXIgaTAgPSBzdGF0ZW1lbnQuZ2V0SW5kZW50YXRpb24oKTtcblxuICAgICAgICAgIGlmIChsZWZ0LnByb3BlcnR5LnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBsZWZ0LmNvbXB1dGVkID8gZ2V0QWxpYXMobGVmdC5wcm9wZXJ0eS5uYW1lKSA6IGxlZnQucHJvcGVydHkubmFtZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBzY29wZS5jcmVhdGVJZGVudGlmaWVyKCdwcm9wZXJ0eScpO1xuICAgICAgICAgICAgbmVlZHNQcm9wZXJ0eVZhciA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlZnQub2JqZWN0LnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgb2JqZWN0ID0gZ2V0QWxpYXMobGVmdC5vYmplY3QubmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iamVjdCA9IHNjb3BlLmNyZWF0ZUlkZW50aWZpZXIoJ29iamVjdCcpO1xuICAgICAgICAgICAgbmVlZHNPYmplY3RWYXIgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZWZ0LnN0YXJ0ID09PSBzdGF0ZW1lbnQuc3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChuZWVkc09iamVjdFZhciAmJiBuZWVkc1Byb3BlcnR5VmFyKSB7XG4gICAgICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQoc3RhdGVtZW50LnN0YXJ0LCBcInZhciBcIiArIG9iamVjdCArIFwiID0gXCIpO1xuICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShsZWZ0Lm9iamVjdC5lbmQsIGxlZnQucHJvcGVydHkuc3RhcnQsIFwiO1xcblwiICsgaTAgKyBcInZhciBcIiArIHByb3BlcnR5ICsgXCIgPSBcIik7XG4gICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKGxlZnQucHJvcGVydHkuZW5kLCBsZWZ0LmVuZCwgXCI7XFxuXCIgKyBpMCArIG9iamVjdCArIFwiW1wiICsgcHJvcGVydHkgKyBcIl1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5lZWRzT2JqZWN0VmFyKSB7XG4gICAgICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQoc3RhdGVtZW50LnN0YXJ0LCBcInZhciBcIiArIG9iamVjdCArIFwiID0gXCIpO1xuICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQobGVmdC5vYmplY3QuZW5kLCBcIjtcXG5cIiArIGkwKTtcbiAgICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KGxlZnQub2JqZWN0LmVuZCwgb2JqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmVlZHNQcm9wZXJ0eVZhcikge1xuICAgICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KGxlZnQucHJvcGVydHkuc3RhcnQsIFwidmFyIFwiICsgcHJvcGVydHkgKyBcIiA9IFwiKTtcbiAgICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KGxlZnQucHJvcGVydHkuZW5kLCBcIjtcXG5cIiArIGkwKTtcbiAgICAgICAgICAgICAgY29kZS5tb3ZlKGxlZnQucHJvcGVydHkuc3RhcnQsIGxlZnQucHJvcGVydHkuZW5kLCB0aGlzLnN0YXJ0KTtcblxuICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQobGVmdC5vYmplY3QuZW5kLCBcIltcIiArIHByb3BlcnR5ICsgXCJdXCIpO1xuICAgICAgICAgICAgICBjb2RlLnJlbW92ZShsZWZ0Lm9iamVjdC5lbmQsIGxlZnQucHJvcGVydHkuc3RhcnQpO1xuICAgICAgICAgICAgICBjb2RlLnJlbW92ZShsZWZ0LnByb3BlcnR5LmVuZCwgbGVmdC5lbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGVjbGFyYXRvcnMgPSBbXTtcbiAgICAgICAgICAgIGlmIChuZWVkc09iamVjdFZhcikgZGVjbGFyYXRvcnMucHVzaChvYmplY3QpO1xuICAgICAgICAgICAgaWYgKG5lZWRzUHJvcGVydHlWYXIpIGRlY2xhcmF0b3JzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgICAgICAgICBpZiAoZGVjbGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQoc3RhdGVtZW50LnN0YXJ0LCBcInZhciBcIiArIGRlY2xhcmF0b3JzLmpvaW4oJywgJykgKyBcIjtcXG5cIiArIGkwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5lZWRzT2JqZWN0VmFyICYmIG5lZWRzUHJvcGVydHlWYXIpIHtcbiAgICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodChsZWZ0LnN0YXJ0LCBcIiggXCIgKyBvYmplY3QgKyBcIiA9IFwiKTtcbiAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUobGVmdC5vYmplY3QuZW5kLCBsZWZ0LnByb3BlcnR5LnN0YXJ0LCBcIiwgXCIgKyBwcm9wZXJ0eSArIFwiID0gXCIpO1xuICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShsZWZ0LnByb3BlcnR5LmVuZCwgbGVmdC5lbmQsIFwiLCBcIiArIG9iamVjdCArIFwiW1wiICsgcHJvcGVydHkgKyBcIl1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5lZWRzT2JqZWN0VmFyKSB7XG4gICAgICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQobGVmdC5zdGFydCwgXCIoIFwiICsgb2JqZWN0ICsgXCIgPSBcIik7XG4gICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChsZWZ0Lm9iamVjdC5lbmQsIFwiLCBcIiArIG9iamVjdCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5lZWRzUHJvcGVydHlWYXIpIHtcbiAgICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodChsZWZ0LnByb3BlcnR5LnN0YXJ0LCBcIiggXCIgKyBwcm9wZXJ0eSArIFwiID0gXCIpO1xuICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQobGVmdC5wcm9wZXJ0eS5lbmQsIFwiLCBcIik7XG4gICAgICAgICAgICAgIGNvZGUubW92ZShsZWZ0LnByb3BlcnR5LnN0YXJ0LCBsZWZ0LnByb3BlcnR5LmVuZCwgbGVmdC5zdGFydCk7XG5cbiAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUobGVmdC5vYmplY3QuZW5kLCBsZWZ0LnByb3BlcnR5LnN0YXJ0LCBcIltcIiArIHByb3BlcnR5ICsgXCJdXCIpO1xuICAgICAgICAgICAgICBjb2RlLnJlbW92ZShsZWZ0LnByb3BlcnR5LmVuZCwgbGVmdC5lbmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmVlZHNQcm9wZXJ0eVZhcikge1xuICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQodGhpcy5lbmQsIFwiIClcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmFzZSA9IG9iamVjdCArIChsZWZ0LmNvbXB1dGVkIHx8IG5lZWRzUHJvcGVydHlWYXIgPyBcIltcIiArIHByb3BlcnR5ICsgXCJdXCIgOiBcIi5cIiArIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQodGhpcy5yaWdodC5zdGFydCwgXCJNYXRoLnBvdyggXCIgKyBiYXNlICsgXCIsIFwiKTtcbiAgICAgICAgY29kZS5pbnNlcnRMZWZ0KHRoaXMucmlnaHQuZW5kLCBcIiApXCIpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEFzc2lnbm1lbnRFeHByZXNzaW9uO1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgQmluYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBCaW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBCaW5hcnlFeHByZXNzaW9uLl9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBCaW5hcnlFeHByZXNzaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBCaW5hcnlFeHByZXNzaW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJpbmFyeUV4cHJlc3Npb247XG5cbiAgICAgIEJpbmFyeUV4cHJlc3Npb24ucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnKionICYmIHRyYW5zZm9ybXMuZXhwb25lbnRpYXRpb24pIHtcbiAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KHRoaXMuc3RhcnQsIFwiTWF0aC5wb3coIFwiKTtcbiAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLmxlZnQuZW5kLCB0aGlzLnJpZ2h0LnN0YXJ0LCBcIiwgXCIpO1xuICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLmVuZCwgXCIgKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBOb2RlLnByb3RvdHlwZS50cmFuc3BpbGUuY2FsbCh0aGlzLCBjb2RlLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBCaW5hcnlFeHByZXNzaW9uO1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgbG9vcFN0YXRlbWVudCA9IC8oPzpGb3IoPzpJbnxPZik/fFdoaWxlKVN0YXRlbWVudC87XG5cbiAgICB2YXIgQnJlYWtTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gQnJlYWtTdGF0ZW1lbnQoKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIEJyZWFrU3RhdGVtZW50Ll9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBCcmVha1N0YXRlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgQnJlYWtTdGF0ZW1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQnJlYWtTdGF0ZW1lbnQ7XG5cbiAgICAgIEJyZWFrU3RhdGVtZW50LnByb3RvdHlwZS5pbml0aWFsaXNlID0gZnVuY3Rpb24gaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgdmFyIGxvb3AgPSB0aGlzLmZpbmROZWFyZXN0KGxvb3BTdGF0ZW1lbnQpO1xuICAgICAgICB2YXIgc3dpdGNoQ2FzZSA9IHRoaXMuZmluZE5lYXJlc3QoJ1N3aXRjaENhc2UnKTtcblxuICAgICAgICBpZiAobG9vcCAmJiAoIXN3aXRjaENhc2UgfHwgbG9vcC5kZXB0aCA+IHN3aXRjaENhc2UuZGVwdGgpKSB7XG4gICAgICAgICAgbG9vcC5jYW5CcmVhayA9IHRydWU7XG4gICAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQnJlYWtTdGF0ZW1lbnQucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmxvb3AgJiYgdGhpcy5sb29wLnNob3VsZFJld3JpdGVBc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgaWYgKHRoaXMubGFiZWwpIHRocm93IG5ldyBDb21waWxlRXJyb3IodGhpcywgJ0xhYmVscyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgaW4gYSBsb29wIHdpdGggbG9jYWxseS1zY29wZWQgdmFyaWFibGVzJyk7XG4gICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgdGhpcy5zdGFydCArIDUsIFwicmV0dXJuICdicmVhaydcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBCcmVha1N0YXRlbWVudDtcbiAgICB9KE5vZGUpO1xuXG4gICAgdmFyIENhbGxFeHByZXNzaW9uID0gZnVuY3Rpb24gKE5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIENhbGxFeHByZXNzaW9uKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBDYWxsRXhwcmVzc2lvbi5fX3Byb3RvX18gPSBOb2RlO1xuICAgICAgQ2FsbEV4cHJlc3Npb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlICYmIE5vZGUucHJvdG90eXBlKTtcbiAgICAgIENhbGxFeHByZXNzaW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbGxFeHByZXNzaW9uO1xuXG4gICAgICBDYWxsRXhwcmVzc2lvbi5wcm90b3R5cGUuaW5pdGlhbGlzZSA9IGZ1bmN0aW9uIGluaXRpYWxpc2UodHJhbnNmb3Jtcykge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICBpZiAodHJhbnNmb3Jtcy5zcHJlYWRSZXN0ICYmIHRoaXMuYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB2YXIgbGV4aWNhbEJvdW5kYXJ5ID0gdGhpcy5maW5kTGV4aWNhbEJvdW5kYXJ5KCk7XG5cbiAgICAgICAgICB2YXIgaSA9IHRoaXMuYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gdGhpcyQxLmFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChhcmcudHlwZSA9PT0gJ1NwcmVhZEVsZW1lbnQnICYmIGlzQXJndW1lbnRzKGFyZy5hcmd1bWVudCkpIHtcbiAgICAgICAgICAgICAgdGhpcyQxLmFyZ3VtZW50c0FycmF5QWxpYXMgPSBsZXhpY2FsQm91bmRhcnkuZ2V0QXJndW1lbnRzQXJyYXlBbGlhcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmluaXRpYWxpc2UuY2FsbCh0aGlzLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIENhbGxFeHByZXNzaW9uLnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAodHJhbnNmb3Jtcy5zcHJlYWRSZXN0ICYmIHRoaXMuYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBoYXNTcHJlYWRFbGVtZW50cyA9IGZhbHNlO1xuICAgICAgICAgIHZhciBjb250ZXh0O1xuXG4gICAgICAgICAgdmFyIGZpcnN0QXJndW1lbnQgPSB0aGlzLmFyZ3VtZW50c1swXTtcblxuICAgICAgICAgIGlmICh0aGlzLmFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdEFyZ3VtZW50LnR5cGUgPT09ICdTcHJlYWRFbGVtZW50Jykge1xuICAgICAgICAgICAgICBjb2RlLnJlbW92ZShmaXJzdEFyZ3VtZW50LnN0YXJ0LCBmaXJzdEFyZ3VtZW50LmFyZ3VtZW50LnN0YXJ0KTtcbiAgICAgICAgICAgICAgaGFzU3ByZWFkRWxlbWVudHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYXNTcHJlYWRFbGVtZW50cyA9IHNwcmVhZChjb2RlLCB0aGlzLmFyZ3VtZW50cywgZmlyc3RBcmd1bWVudC5zdGFydCwgdGhpcy5hcmd1bWVudHNBcnJheUFsaWFzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzU3ByZWFkRWxlbWVudHMpIHtcblxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBoYW5kbGUgc3VwZXIoKSBhbmQgc3VwZXIubWV0aG9kKCkgZGlmZmVyZW50bHlcbiAgICAgICAgICAgIC8vIGR1ZSB0byBpdHMgaW5zdGFuY2VcbiAgICAgICAgICAgIHZhciBfc3VwZXIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGVlLnR5cGUgPT09ICdTdXBlcicpIHtcbiAgICAgICAgICAgICAgX3N1cGVyID0gdGhpcy5jYWxsZWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2FsbGVlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJiB0aGlzLmNhbGxlZS5vYmplY3QudHlwZSA9PT0gJ1N1cGVyJykge1xuICAgICAgICAgICAgICBfc3VwZXIgPSB0aGlzLmNhbGxlZS5vYmplY3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghX3N1cGVyICYmIHRoaXMuY2FsbGVlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNhbGxlZS5vYmplY3QubmFtZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5maW5kU2NvcGUodHJ1ZSkuY3JlYXRlSWRlbnRpZmllcigncmVmJyk7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxFeHByZXNzaW9uID0gdGhpcy5jYWxsZWUub2JqZWN0O1xuICAgICAgICAgICAgICAgIHZhciBlbmNsb3N1cmUgPSBjYWxsRXhwcmVzc2lvbi5maW5kTmVhcmVzdCgvRnVuY3Rpb24vKTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBlbmNsb3N1cmUgPyBlbmNsb3N1cmUuYm9keS5ib2R5IDogY2FsbEV4cHJlc3Npb24uZmluZE5lYXJlc3QoL15Qcm9ncmFtJC8pLmJvZHk7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RTdGF0ZW1lbnRJbkJsb2NrID0gYmxvY2tbYmxvY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIGkwID0gbGFzdFN0YXRlbWVudEluQmxvY2suZ2V0SW5kZW50YXRpb24oKTtcbiAgICAgICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KGNhbGxFeHByZXNzaW9uLnN0YXJ0LCBcIihcIiArIGNvbnRleHQgKyBcIiA9IFwiKTtcbiAgICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQoY2FsbEV4cHJlc3Npb24uZW5kLCBcIilcIik7XG4gICAgICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KGxhc3RTdGF0ZW1lbnRJbkJsb2NrLmVuZCwgXCJcXG5cIiArIGkwICsgXCJ2YXIgXCIgKyBjb250ZXh0ICsgXCI7XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb250ZXh0ID0gJ3ZvaWQgMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLmNhbGxlZS5lbmQsICcuYXBwbHknKTtcblxuICAgICAgICAgICAgaWYgKF9zdXBlcikge1xuICAgICAgICAgICAgICBfc3VwZXIubm9DYWxsID0gdHJ1ZTsgLy8gYml0IGhhY2t5Li4uXG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RBcmd1bWVudC50eXBlICE9PSAnU3ByZWFkRWxlbWVudCcpIHtcbiAgICAgICAgICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQoZmlyc3RBcmd1bWVudC5zdGFydCwgXCJbIFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQodGhpcy5hcmd1bWVudHNbdGhpcy5hcmd1bWVudHMubGVuZ3RoIC0gMV0uZW5kLCAnICknKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodChmaXJzdEFyZ3VtZW50LnN0YXJ0LCBjb250ZXh0ICsgXCIsIFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChmaXJzdEFyZ3VtZW50LnR5cGUgPT09ICdTcHJlYWRFbGVtZW50Jykge1xuICAgICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChmaXJzdEFyZ3VtZW50LnN0YXJ0LCBjb250ZXh0ICsgXCIsIFwiKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQoZmlyc3RBcmd1bWVudC5zdGFydCwgY29udGV4dCArIFwiLCBbIFwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLmFyZ3VtZW50c1t0aGlzLmFyZ3VtZW50cy5sZW5ndGggLSAxXS5lbmQsICcgKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE5vZGUucHJvdG90eXBlLnRyYW5zcGlsZS5jYWxsKHRoaXMsIGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENhbGxFeHByZXNzaW9uO1xuICAgIH0oTm9kZSk7XG5cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGZuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChmbihhcnJheVtpXSwgaSkpIHJldHVybiBpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIHJlc2VydmVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAnZG8gaWYgaW4gZm9yIGxldCBuZXcgdHJ5IHZhciBjYXNlIGVsc2UgZW51bSBldmFsIG51bGwgdGhpcyB0cnVlIHZvaWQgd2l0aCBhd2FpdCBicmVhayBjYXRjaCBjbGFzcyBjb25zdCBmYWxzZSBzdXBlciB0aHJvdyB3aGlsZSB5aWVsZCBkZWxldGUgZXhwb3J0IGltcG9ydCBwdWJsaWMgcmV0dXJuIHN0YXRpYyBzd2l0Y2ggdHlwZW9mIGRlZmF1bHQgZXh0ZW5kcyBmaW5hbGx5IHBhY2thZ2UgcHJpdmF0ZSBjb250aW51ZSBkZWJ1Z2dlciBmdW5jdGlvbiBhcmd1bWVudHMgaW50ZXJmYWNlIHByb3RlY3RlZCBpbXBsZW1lbnRzIGluc3RhbmNlb2YnLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAod29yZCkge1xuICAgICAgcmV0dXJuIHJlc2VydmVkW3dvcmRdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIFRPRE8gdGhpcyBjb2RlIGlzIHByZXR0eSB3aWxkLCB0aWR5IGl0IHVwXG4gICAgdmFyIENsYXNzQm9keSA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBDbGFzc0JvZHkoKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIENsYXNzQm9keS5fX3Byb3RvX18gPSBOb2RlO1xuICAgICAgQ2xhc3NCb2R5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBDbGFzc0JvZHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3NCb2R5O1xuXG4gICAgICBDbGFzc0JvZHkucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlLCB0cmFuc2Zvcm1zLCBpbkZ1bmN0aW9uRXhwcmVzc2lvbiwgc3VwZXJOYW1lKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLmNsYXNzZXMpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyZW50Lm5hbWU7XG5cbiAgICAgICAgICB2YXIgaW5kZW50U3RyID0gY29kZS5nZXRJbmRlbnRTdHJpbmcoKTtcbiAgICAgICAgICB2YXIgaTAgPSB0aGlzLmdldEluZGVudGF0aW9uKCkgKyAoaW5GdW5jdGlvbkV4cHJlc3Npb24gPyBpbmRlbnRTdHIgOiAnJyk7XG4gICAgICAgICAgdmFyIGkxID0gaTAgKyBpbmRlbnRTdHI7XG5cbiAgICAgICAgICB2YXIgY29uc3RydWN0b3JJbmRleCA9IGZpbmRJbmRleCh0aGlzLmJvZHksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5raW5kID09PSAnY29uc3RydWN0b3InO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuYm9keVtjb25zdHJ1Y3RvckluZGV4XTtcblxuICAgICAgICAgIHZhciBpbnRyb0Jsb2NrID0gJyc7XG4gICAgICAgICAgdmFyIG91dHJvQmxvY2sgPSAnJztcblxuICAgICAgICAgIGlmICh0aGlzLmJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLnN0YXJ0LCB0aGlzLmJvZHlbMF0uc3RhcnQpO1xuICAgICAgICAgICAgY29kZS5yZW1vdmUodGhpcy5ib2R5W3RoaXMuYm9keS5sZW5ndGggLSAxXS5lbmQsIHRoaXMuZW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZS5yZW1vdmUodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY29uc3RydWN0b3IudmFsdWUuYm9keS5pc0NvbnN0cnVjdG9yQm9keSA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciBwcmV2aW91c01ldGhvZCA9IHRoaXMuYm9keVtjb25zdHJ1Y3RvckluZGV4IC0gMV07XG4gICAgICAgICAgICB2YXIgbmV4dE1ldGhvZCA9IHRoaXMuYm9keVtjb25zdHJ1Y3RvckluZGV4ICsgMV07XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSBjb25zdHJ1Y3RvciBpcyBmaXJzdFxuICAgICAgICAgICAgaWYgKGNvbnN0cnVjdG9ySW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgIGNvZGUucmVtb3ZlKHByZXZpb3VzTWV0aG9kLmVuZCwgY29uc3RydWN0b3Iuc3RhcnQpO1xuICAgICAgICAgICAgICBjb2RlLm1vdmUoY29uc3RydWN0b3Iuc3RhcnQsIG5leHRNZXRob2QgPyBuZXh0TWV0aG9kLnN0YXJ0IDogdGhpcy5lbmQgLSAxLCB0aGlzLmJvZHlbMF0uc3RhcnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWluRnVuY3Rpb25FeHByZXNzaW9uKSBjb2RlLmluc2VydExlZnQoY29uc3RydWN0b3IuZW5kLCAnOycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuYW1lZEZ1bmN0aW9ucyA9IHRoaXMucHJvZ3JhbS5vcHRpb25zLm5hbWVkRnVuY3Rpb25FeHByZXNzaW9ucyAhPT0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWVkQ29uc3RydWN0b3IgPSBuYW1lZEZ1bmN0aW9ucyB8fCB0aGlzLnBhcmVudC5zdXBlckNsYXNzIHx8IHRoaXMucGFyZW50LnR5cGUgIT09ICdDbGFzc0RlY2xhcmF0aW9uJztcbiAgICAgICAgICBpZiAodGhpcy5wYXJlbnQuc3VwZXJDbGFzcykge1xuICAgICAgICAgICAgdmFyIGluaGVyaXRhbmNlQmxvY2sgPSBcImlmICggXCIgKyBzdXBlck5hbWUgKyBcIiApIFwiICsgbmFtZSArIFwiLl9fcHJvdG9fXyA9IFwiICsgc3VwZXJOYW1lICsgXCI7XFxuXCIgKyBpMCArIG5hbWUgKyBcIi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBcIiArIHN1cGVyTmFtZSArIFwiICYmIFwiICsgc3VwZXJOYW1lICsgXCIucHJvdG90eXBlICk7XFxuXCIgKyBpMCArIG5hbWUgKyBcIi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBcIiArIG5hbWUgKyBcIjtcIjtcblxuICAgICAgICAgICAgaWYgKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgIGludHJvQmxvY2sgKz0gXCJcXG5cXG5cIiArIGkwICsgaW5oZXJpdGFuY2VCbG9jaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBmbiA9IFwiZnVuY3Rpb24gXCIgKyBuYW1lICsgXCIgKCkge1wiICsgKHN1cGVyTmFtZSA/IFwiXFxuXCIgKyBpMSArIHN1cGVyTmFtZSArIFwiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXCIgKyBpMCArIFwifVwiIDogXCJ9XCIpICsgKGluRnVuY3Rpb25FeHByZXNzaW9uID8gJycgOiAnOycpICsgKHRoaXMuYm9keS5sZW5ndGggPyBcIlxcblxcblwiICsgaTAgOiAnJyk7XG5cbiAgICAgICAgICAgICAgaW5oZXJpdGFuY2VCbG9jayA9IGZuICsgaW5oZXJpdGFuY2VCbG9jaztcbiAgICAgICAgICAgICAgaW50cm9CbG9jayArPSBpbmhlcml0YW5jZUJsb2NrICsgXCJcXG5cXG5cIiArIGkwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgZm4kMSA9ICdmdW5jdGlvbiAnICsgKG5hbWVkQ29uc3RydWN0b3IgPyBuYW1lICsgJyAnIDogJycpICsgJygpIHt9JztcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSAnQ2xhc3NEZWNsYXJhdGlvbicpIGZuJDEgKz0gJzsnO1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5sZW5ndGgpIGZuJDEgKz0gXCJcXG5cXG5cIiArIGkwO1xuXG4gICAgICAgICAgICBpbnRyb0Jsb2NrICs9IGZuJDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5maW5kU2NvcGUoZmFsc2UpO1xuXG4gICAgICAgICAgdmFyIHByb3RvdHlwZUdldHRlcnNBbmRTZXR0ZXJzID0gW107XG4gICAgICAgICAgdmFyIHN0YXRpY0dldHRlcnNBbmRTZXR0ZXJzID0gW107XG4gICAgICAgICAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycztcbiAgICAgICAgICB2YXIgc3RhdGljQWNjZXNzb3JzO1xuXG4gICAgICAgICAgdGhpcy5ib2R5LmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCwgaSkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZC5raW5kID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgICAgIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBuYW1lZENvbnN0cnVjdG9yID8gJyAnICsgbmFtZSA6ICcnO1xuICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShtZXRob2Qua2V5LnN0YXJ0LCBtZXRob2Qua2V5LmVuZCwgXCJmdW5jdGlvblwiICsgY29uc3RydWN0b3JOYW1lKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kLnN0YXRpYykge1xuICAgICAgICAgICAgICB2YXIgbGVuID0gY29kZS5vcmlnaW5hbFttZXRob2Quc3RhcnQgKyA2XSA9PSAnICcgPyA3IDogNjtcbiAgICAgICAgICAgICAgY29kZS5yZW1vdmUobWV0aG9kLnN0YXJ0LCBtZXRob2Quc3RhcnQgKyBsZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXNBY2Nlc3NvciA9IG1ldGhvZC5raW5kICE9PSAnbWV0aG9kJztcbiAgICAgICAgICAgIHZhciBsaHM7XG5cbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbWV0aG9kLmtleS5uYW1lO1xuICAgICAgICAgICAgaWYgKHJlc2VydmVkW21ldGhvZE5hbWVdIHx8IG1ldGhvZC52YWx1ZS5ib2R5LnNjb3BlLnJlZmVyZW5jZXNbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICAgICAgbWV0aG9kTmFtZSA9IHNjb3BlLmNyZWF0ZUlkZW50aWZpZXIobWV0aG9kTmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdoZW4gbWV0aG9kIG5hbWUgaXMgYSBzdHJpbmcgb3IgYSBudW1iZXIgbGV0J3MgcHJldGVuZCBpdCdzIGEgY29tcHV0ZWQgbWV0aG9kXG5cbiAgICAgICAgICAgIHZhciBmYWtlX2NvbXB1dGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIW1ldGhvZC5jb21wdXRlZCAmJiBtZXRob2Qua2V5LnR5cGUgPT09ICdMaXRlcmFsJykge1xuICAgICAgICAgICAgICBmYWtlX2NvbXB1dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbWV0aG9kLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgaWYgKG1ldGhvZC5jb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcHV0ZWQgYWNjZXNzb3IgcHJvcGVydGllcyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvZGUucmVtb3ZlKG1ldGhvZC5zdGFydCwgbWV0aG9kLmtleS5zdGFydCk7XG5cbiAgICAgICAgICAgICAgaWYgKG1ldGhvZC5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIX5zdGF0aWNHZXR0ZXJzQW5kU2V0dGVycy5pbmRleE9mKG1ldGhvZC5rZXkubmFtZSkpIHN0YXRpY0dldHRlcnNBbmRTZXR0ZXJzLnB1c2gobWV0aG9kLmtleS5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRpY0FjY2Vzc29ycykgc3RhdGljQWNjZXNzb3JzID0gc2NvcGUuY3JlYXRlSWRlbnRpZmllcignc3RhdGljQWNjZXNzb3JzJyk7XG5cbiAgICAgICAgICAgICAgICBsaHMgPSBcIlwiICsgc3RhdGljQWNjZXNzb3JzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghfnByb3RvdHlwZUdldHRlcnNBbmRTZXR0ZXJzLmluZGV4T2YobWV0aG9kLmtleS5uYW1lKSkgcHJvdG90eXBlR2V0dGVyc0FuZFNldHRlcnMucHVzaChtZXRob2Qua2V5Lm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghcHJvdG90eXBlQWNjZXNzb3JzKSBwcm90b3R5cGVBY2Nlc3NvcnMgPSBzY29wZS5jcmVhdGVJZGVudGlmaWVyKCdwcm90b3R5cGVBY2Nlc3NvcnMnKTtcblxuICAgICAgICAgICAgICAgIGxocyA9IFwiXCIgKyBwcm90b3R5cGVBY2Nlc3NvcnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxocyA9IG1ldGhvZC5zdGF0aWMgPyBcIlwiICsgbmFtZSA6IG5hbWUgKyBcIi5wcm90b3R5cGVcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFtZXRob2QuY29tcHV0ZWQpIGxocyArPSAnLic7XG5cbiAgICAgICAgICAgIHZhciBpbnNlcnROZXdsaW5lcyA9IGNvbnN0cnVjdG9ySW5kZXggPiAwICYmIGkgPT09IGNvbnN0cnVjdG9ySW5kZXggKyAxIHx8IGkgPT09IDAgJiYgY29uc3RydWN0b3JJbmRleCA9PT0gdGhpcyQxLmJvZHkubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgaWYgKGluc2VydE5ld2xpbmVzKSBsaHMgPSBcIlxcblxcblwiICsgaTAgKyBsaHM7XG5cbiAgICAgICAgICAgIHZhciBjID0gbWV0aG9kLmtleS5lbmQ7XG4gICAgICAgICAgICBpZiAobWV0aG9kLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGlmIChmYWtlX2NvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodChtZXRob2Qua2V5LnN0YXJ0LCAnWycpO1xuICAgICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChtZXRob2Qua2V5LmVuZCwgJ10nKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29kZS5vcmlnaW5hbFtjXSAhPT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICBjICs9IDE7XG4gICAgICAgICAgICAgICAgfWMgKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KG1ldGhvZC5zdGFydCwgbGhzKTtcblxuICAgICAgICAgICAgdmFyIGZ1bmNOYW1lID0gbWV0aG9kLmNvbXB1dGVkIHx8IGlzQWNjZXNzb3IgfHwgIW5hbWVkRnVuY3Rpb25zID8gJycgOiBtZXRob2ROYW1lICsgXCIgXCI7XG4gICAgICAgICAgICB2YXIgcmhzID0gKGlzQWNjZXNzb3IgPyBcIi5cIiArIG1ldGhvZC5raW5kIDogJycpICsgXCIgPSBmdW5jdGlvblwiICsgKG1ldGhvZC52YWx1ZS5nZW5lcmF0b3IgPyAnKiAnIDogJyAnKSArIGZ1bmNOYW1lO1xuICAgICAgICAgICAgY29kZS5yZW1vdmUoYywgbWV0aG9kLnZhbHVlLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQobWV0aG9kLnZhbHVlLnN0YXJ0LCByaHMpO1xuICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KG1ldGhvZC5lbmQsICc7Jyk7XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QudmFsdWUuZ2VuZXJhdG9yKSBjb2RlLnJlbW92ZShtZXRob2Quc3RhcnQsIG1ldGhvZC5rZXkuc3RhcnQpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHByb3RvdHlwZUdldHRlcnNBbmRTZXR0ZXJzLmxlbmd0aCB8fCBzdGF0aWNHZXR0ZXJzQW5kU2V0dGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBpbnRybyA9IFtdO1xuICAgICAgICAgICAgdmFyIG91dHJvID0gW107XG5cbiAgICAgICAgICAgIGlmIChwcm90b3R5cGVHZXR0ZXJzQW5kU2V0dGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaW50cm8ucHVzaChcInZhciBcIiArIHByb3RvdHlwZUFjY2Vzc29ycyArIFwiID0geyBcIiArIHByb3RvdHlwZUdldHRlcnNBbmRTZXR0ZXJzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lICsgXCI6IHt9XCI7XG4gICAgICAgICAgICAgIH0pLmpvaW4oJywnKSArIFwiIH07XCIpO1xuICAgICAgICAgICAgICBvdXRyby5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFwiICsgbmFtZSArIFwiLnByb3RvdHlwZSwgXCIgKyBwcm90b3R5cGVBY2Nlc3NvcnMgKyBcIiApO1wiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YXRpY0dldHRlcnNBbmRTZXR0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpbnRyby5wdXNoKFwidmFyIFwiICsgc3RhdGljQWNjZXNzb3JzICsgXCIgPSB7IFwiICsgc3RhdGljR2V0dGVyc0FuZFNldHRlcnMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgKyBcIjoge31cIjtcbiAgICAgICAgICAgICAgfSkuam9pbignLCcpICsgXCIgfTtcIik7XG4gICAgICAgICAgICAgIG91dHJvLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydGllcyggXCIgKyBuYW1lICsgXCIsIFwiICsgc3RhdGljQWNjZXNzb3JzICsgXCIgKTtcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb25zdHJ1Y3RvcikgaW50cm9CbG9jayArPSBcIlxcblxcblwiICsgaTA7XG4gICAgICAgICAgICBpbnRyb0Jsb2NrICs9IGludHJvLmpvaW4oXCJcXG5cIiArIGkwKTtcbiAgICAgICAgICAgIGlmICghY29uc3RydWN0b3IpIGludHJvQmxvY2sgKz0gXCJcXG5cXG5cIiArIGkwO1xuXG4gICAgICAgICAgICBvdXRyb0Jsb2NrICs9IFwiXFxuXFxuXCIgKyBpMCArIG91dHJvLmpvaW4oXCJcXG5cIiArIGkwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChjb25zdHJ1Y3Rvci5lbmQsIGludHJvQmxvY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KHRoaXMuc3RhcnQsIGludHJvQmxvY2spO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLmVuZCwgb3V0cm9CbG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICBOb2RlLnByb3RvdHlwZS50cmFuc3BpbGUuY2FsbCh0aGlzLCBjb2RlLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDbGFzc0JvZHk7XG4gICAgfShOb2RlKTtcblxuICAgIC8vIFRPRE8gdGhpcyBmdW5jdGlvbiBpcyBzbGlnaHRseSBmbGF3ZWQg4oCTIGl0IHdvcmtzIG9uIHRoZSBvcmlnaW5hbCBzdHJpbmcsXG4gICAgLy8gbm90IGl0cyBjdXJyZW50IGVkaXRlZCBzdGF0ZS5cbiAgICAvLyBUaGF0J3Mgbm90IGEgcHJvYmxlbSBmb3IgdGhlIHdheSB0aGF0IGl0J3MgY3VycmVudGx5IHVzZWQsIGJ1dCBpdCBjb3VsZFxuICAgIC8vIGJlIGluIGZ1dHVyZS4uLlxuICAgIGZ1bmN0aW9uIGRlaW5kZW50KG5vZGUsIGNvZGUpIHtcbiAgICAgIHZhciBzdGFydCA9IG5vZGUuc3RhcnQ7XG4gICAgICB2YXIgZW5kID0gbm9kZS5lbmQ7XG5cbiAgICAgIHZhciBpbmRlbnRTdHIgPSBjb2RlLmdldEluZGVudFN0cmluZygpO1xuICAgICAgdmFyIGluZGVudFN0ckxlbiA9IGluZGVudFN0ci5sZW5ndGg7XG4gICAgICB2YXIgaW5kZW50U3RhcnQgPSBzdGFydCAtIGluZGVudFN0ckxlbjtcblxuICAgICAgaWYgKCFub2RlLnByb2dyYW0uaW5kZW50RXhjbHVzaW9uc1tpbmRlbnRTdGFydF0gJiYgY29kZS5vcmlnaW5hbC5zbGljZShpbmRlbnRTdGFydCwgc3RhcnQpID09PSBpbmRlbnRTdHIpIHtcbiAgICAgICAgY29kZS5yZW1vdmUoaW5kZW50U3RhcnQsIHN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKGluZGVudFN0ciArICdcXFxcUycsICdnJyk7XG4gICAgICB2YXIgc2xpY2UgPSBjb2RlLm9yaWdpbmFsLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgdmFyIG1hdGNoO1xuXG4gICAgICB3aGlsZSAobWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2xpY2UpKSB7XG4gICAgICAgIHZhciByZW1vdmVTdGFydCA9IHN0YXJ0ICsgbWF0Y2guaW5kZXg7XG4gICAgICAgIGlmICghbm9kZS5wcm9ncmFtLmluZGVudEV4Y2x1c2lvbnNbcmVtb3ZlU3RhcnRdKSB7XG4gICAgICAgICAgY29kZS5yZW1vdmUocmVtb3ZlU3RhcnQsIHJlbW92ZVN0YXJ0ICsgaW5kZW50U3RyTGVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBDbGFzc0RlY2xhcmF0aW9uID0gZnVuY3Rpb24gKE5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIENsYXNzRGVjbGFyYXRpb24oKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIENsYXNzRGVjbGFyYXRpb24uX19wcm90b19fID0gTm9kZTtcbiAgICAgIENsYXNzRGVjbGFyYXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlICYmIE5vZGUucHJvdG90eXBlKTtcbiAgICAgIENsYXNzRGVjbGFyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3NEZWNsYXJhdGlvbjtcblxuICAgICAgQ2xhc3NEZWNsYXJhdGlvbi5wcm90b3R5cGUuaW5pdGlhbGlzZSA9IGZ1bmN0aW9uIGluaXRpYWxpc2UodHJhbnNmb3Jtcykge1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmlkLm5hbWU7XG4gICAgICAgIHRoaXMuZmluZFNjb3BlKHRydWUpLmFkZERlY2xhcmF0aW9uKHRoaXMuaWQsICdjbGFzcycpO1xuXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmluaXRpYWxpc2UuY2FsbCh0aGlzLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIENsYXNzRGVjbGFyYXRpb24ucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLmNsYXNzZXMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuc3VwZXJDbGFzcykgZGVpbmRlbnQodGhpcy5ib2R5LCBjb2RlKTtcblxuICAgICAgICAgIHZhciBzdXBlck5hbWUgPSB0aGlzLnN1cGVyQ2xhc3MgJiYgKHRoaXMuc3VwZXJDbGFzcy5uYW1lIHx8ICdzdXBlcmNsYXNzJyk7XG5cbiAgICAgICAgICB2YXIgaTAgPSB0aGlzLmdldEluZGVudGF0aW9uKCk7XG4gICAgICAgICAgdmFyIGkxID0gaTAgKyBjb2RlLmdldEluZGVudFN0cmluZygpO1xuXG4gICAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBleHBvcnQgZGVmYXVsdCBzdGF0ZW1lbnQsIHdlIGhhdmUgdG8gbW92ZSB0aGUgZXhwb3J0IHRvXG4gICAgICAgICAgLy8gYWZ0ZXIgdGhlIGRlY2xhcmF0aW9uLCBiZWNhdXNlIGBleHBvcnQgZGVmYXVsdCB2YXIgRm9vID0gLi4uYCBpcyBpbGxlZ2FsXG4gICAgICAgICAgdmFyIHN5bnRoZXRpY0RlZmF1bHRFeHBvcnQgPSB0aGlzLnBhcmVudC50eXBlID09PSAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJyA/IFwiXFxuXFxuXCIgKyBpMCArIFwiZXhwb3J0IGRlZmF1bHQgXCIgKyB0aGlzLmlkLm5hbWUgKyBcIjtcIiA6ICcnO1xuXG4gICAgICAgICAgaWYgKHN5bnRoZXRpY0RlZmF1bHRFeHBvcnQpIGNvZGUucmVtb3ZlKHRoaXMucGFyZW50LnN0YXJ0LCB0aGlzLnN0YXJ0KTtcblxuICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3RhcnQsIHRoaXMuaWQuc3RhcnQsICd2YXIgJyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdXBlckNsYXNzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdXBlckNsYXNzLmVuZCA9PT0gdGhpcy5ib2R5LnN0YXJ0KSB7XG4gICAgICAgICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuaWQuZW5kLCB0aGlzLnN1cGVyQ2xhc3Muc3RhcnQpO1xuICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQodGhpcy5pZC5lbmQsIFwiID0gKGZ1bmN0aW9uIChcIiArIHN1cGVyTmFtZSArIFwiKSB7XFxuXCIgKyBpMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLmlkLmVuZCwgdGhpcy5zdXBlckNsYXNzLnN0YXJ0LCAnID0gJyk7XG4gICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3VwZXJDbGFzcy5lbmQsIHRoaXMuYm9keS5zdGFydCwgXCIoZnVuY3Rpb24gKFwiICsgc3VwZXJOYW1lICsgXCIpIHtcXG5cIiArIGkxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWQuZW5kID09PSB0aGlzLmJvZHkuc3RhcnQpIHtcbiAgICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KHRoaXMuaWQuZW5kLCAnID0gJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLmlkLmVuZCwgdGhpcy5ib2R5LnN0YXJ0LCAnID0gJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ib2R5LnRyYW5zcGlsZShjb2RlLCB0cmFuc2Zvcm1zLCAhIXRoaXMuc3VwZXJDbGFzcywgc3VwZXJOYW1lKTtcblxuICAgICAgICAgIGlmICh0aGlzLnN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLmVuZCwgXCJcXG5cXG5cIiArIGkxICsgXCJyZXR1cm4gXCIgKyB0aGlzLm5hbWUgKyBcIjtcXG5cIiArIGkwICsgXCJ9KFwiKTtcbiAgICAgICAgICAgIGNvZGUubW92ZSh0aGlzLnN1cGVyQ2xhc3Muc3RhcnQsIHRoaXMuc3VwZXJDbGFzcy5lbmQsIHRoaXMuZW5kKTtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQodGhpcy5lbmQsIFwiKSk7XCIgKyBzeW50aGV0aWNEZWZhdWx0RXhwb3J0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN5bnRoZXRpY0RlZmF1bHRFeHBvcnQpIHtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQodGhpcy5lbmQsIHN5bnRoZXRpY0RlZmF1bHRFeHBvcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJvZHkudHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENsYXNzRGVjbGFyYXRpb247XG4gICAgfShOb2RlKTtcblxuICAgIHZhciBDbGFzc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gQ2xhc3NFeHByZXNzaW9uKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBDbGFzc0V4cHJlc3Npb24uX19wcm90b19fID0gTm9kZTtcbiAgICAgIENsYXNzRXhwcmVzc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgQ2xhc3NFeHByZXNzaW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzRXhwcmVzc2lvbjtcblxuICAgICAgQ2xhc3NFeHByZXNzaW9uLnByb3RvdHlwZS5pbml0aWFsaXNlID0gZnVuY3Rpb24gaW5pdGlhbGlzZSh0cmFuc2Zvcm1zKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuaWQgPyB0aGlzLmlkLm5hbWUgOiB0aGlzLnBhcmVudC50eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdG9yJyA/IHRoaXMucGFyZW50LmlkLm5hbWUgOiB0aGlzLnBhcmVudC50eXBlID09PSAnQXNzaWdubWVudEV4cHJlc3Npb24nID8gdGhpcy5wYXJlbnQubGVmdC5uYW1lIDogdGhpcy5maW5kU2NvcGUodHJ1ZSkuY3JlYXRlSWRlbnRpZmllcignYW5vbnltb3VzJyk7XG5cbiAgICAgICAgTm9kZS5wcm90b3R5cGUuaW5pdGlhbGlzZS5jYWxsKHRoaXMsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgQ2xhc3NFeHByZXNzaW9uLnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAodHJhbnNmb3Jtcy5jbGFzc2VzKSB7XG4gICAgICAgICAgdmFyIHN1cGVyTmFtZSA9IHRoaXMuc3VwZXJDbGFzcyAmJiAodGhpcy5zdXBlckNsYXNzLm5hbWUgfHwgJ3N1cGVyY2xhc3MnKTtcblxuICAgICAgICAgIHZhciBpMCA9IHRoaXMuZ2V0SW5kZW50YXRpb24oKTtcbiAgICAgICAgICB2YXIgaTEgPSBpMCArIGNvZGUuZ2V0SW5kZW50U3RyaW5nKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdXBlckNsYXNzKSB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLnN0YXJ0LCB0aGlzLnN1cGVyQ2xhc3Muc3RhcnQpO1xuICAgICAgICAgICAgY29kZS5yZW1vdmUodGhpcy5zdXBlckNsYXNzLmVuZCwgdGhpcy5ib2R5LnN0YXJ0KTtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLnN0YXJ0LCBcIihmdW5jdGlvbiAoXCIgKyBzdXBlck5hbWUgKyBcIikge1xcblwiICsgaTEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LCB0aGlzLmJvZHkuc3RhcnQsIFwiKGZ1bmN0aW9uICgpIHtcXG5cIiArIGkxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJvZHkudHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMsIHRydWUsIHN1cGVyTmFtZSk7XG5cbiAgICAgICAgICB2YXIgb3V0cm8gPSBcIlxcblxcblwiICsgaTEgKyBcInJldHVybiBcIiArIHRoaXMubmFtZSArIFwiO1xcblwiICsgaTAgKyBcIn0oXCI7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdXBlckNsYXNzKSB7XG4gICAgICAgICAgICBjb2RlLmluc2VydExlZnQodGhpcy5lbmQsIG91dHJvKTtcbiAgICAgICAgICAgIGNvZGUubW92ZSh0aGlzLnN1cGVyQ2xhc3Muc3RhcnQsIHRoaXMuc3VwZXJDbGFzcy5lbmQsIHRoaXMuZW5kKTtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQodGhpcy5lbmQsICcpKScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlLmluc2VydExlZnQodGhpcy5lbmQsIFwiXFxuXFxuXCIgKyBpMSArIFwicmV0dXJuIFwiICsgdGhpcy5uYW1lICsgXCI7XFxuXCIgKyBpMCArIFwifSgpKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ib2R5LnRyYW5zcGlsZShjb2RlLCB0cmFuc2Zvcm1zLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDbGFzc0V4cHJlc3Npb247XG4gICAgfShOb2RlKTtcblxuICAgIHZhciBDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBDb250aW51ZVN0YXRlbWVudCgpIHtcbiAgICAgICAgTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTm9kZSkgQ29udGludWVTdGF0ZW1lbnQuX19wcm90b19fID0gTm9kZTtcbiAgICAgIENvbnRpbnVlU3RhdGVtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBDb250aW51ZVN0YXRlbWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250aW51ZVN0YXRlbWVudDtcblxuICAgICAgQ29udGludWVTdGF0ZW1lbnQucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlKSB7XG4gICAgICAgIHZhciBsb29wID0gdGhpcy5maW5kTmVhcmVzdChsb29wU3RhdGVtZW50KTtcbiAgICAgICAgaWYgKGxvb3Auc2hvdWxkUmV3cml0ZUFzRnVuY3Rpb24pIHtcbiAgICAgICAgICBpZiAodGhpcy5sYWJlbCkgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih0aGlzLCAnTGFiZWxzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBpbiBhIGxvb3Agd2l0aCBsb2NhbGx5LXNjb3BlZCB2YXJpYWJsZXMnKTtcbiAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0ICsgOCwgJ3JldHVybicpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTdGF0ZW1lbnQ7XG4gICAgfShOb2RlKTtcblxuICAgIHZhciBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24uX19wcm90b19fID0gTm9kZTtcbiAgICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcblxuICAgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uLnByb3RvdHlwZS5pbml0aWFsaXNlID0gZnVuY3Rpb24gaW5pdGlhbGlzZSh0cmFuc2Zvcm1zKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLm1vZHVsZUV4cG9ydCkgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih0aGlzLCAnZXhwb3J0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuaW5pdGlhbGlzZS5jYWxsKHRoaXMsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcbiAgICB9KE5vZGUpO1xuXG4gICAgdmFyIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gRXhwb3J0TmFtZWREZWNsYXJhdGlvbigpIHtcbiAgICAgICAgTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTm9kZSkgRXhwb3J0TmFtZWREZWNsYXJhdGlvbi5fX3Byb3RvX18gPSBOb2RlO1xuICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHBvcnROYW1lZERlY2xhcmF0aW9uO1xuXG4gICAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uLnByb3RvdHlwZS5pbml0aWFsaXNlID0gZnVuY3Rpb24gaW5pdGlhbGlzZSh0cmFuc2Zvcm1zKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLm1vZHVsZUV4cG9ydCkgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih0aGlzLCAnZXhwb3J0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuaW5pdGlhbGlzZS5jYWxsKHRoaXMsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEV4cG9ydE5hbWVkRGVjbGFyYXRpb247XG4gICAgfShOb2RlKTtcblxuICAgIHZhciBMb29wU3RhdGVtZW50ID0gZnVuY3Rpb24gKE5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIExvb3BTdGF0ZW1lbnQoKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIExvb3BTdGF0ZW1lbnQuX19wcm90b19fID0gTm9kZTtcbiAgICAgIExvb3BTdGF0ZW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlICYmIE5vZGUucHJvdG90eXBlKTtcbiAgICAgIExvb3BTdGF0ZW1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9vcFN0YXRlbWVudDtcblxuICAgICAgTG9vcFN0YXRlbWVudC5wcm90b3R5cGUuZmluZFNjb3BlID0gZnVuY3Rpb24gZmluZFNjb3BlKGZ1bmN0aW9uU2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uU2NvcGUgfHwgIXRoaXMuY3JlYXRlZFNjb3BlID8gdGhpcy5wYXJlbnQuZmluZFNjb3BlKGZ1bmN0aW9uU2NvcGUpIDogdGhpcy5ib2R5LnNjb3BlO1xuICAgICAgfTtcblxuICAgICAgTG9vcFN0YXRlbWVudC5wcm90b3R5cGUuaW5pdGlhbGlzZSA9IGZ1bmN0aW9uIGluaXRpYWxpc2UodHJhbnNmb3Jtcykge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICB0aGlzLmJvZHkuY3JlYXRlU2NvcGUoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVkU2NvcGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIHRoaXMgaXMgcG9wdWxhdGVkIGFzIGFuZCB3aGVuIHJlYXNzaWdubWVudHMgb2NjdXJcbiAgICAgICAgdGhpcy5yZWFzc2lnbmVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5hbGlhc2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBOb2RlLnByb3RvdHlwZS5pbml0aWFsaXNlLmNhbGwodGhpcywgdHJhbnNmb3Jtcyk7XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybXMubGV0Q29uc3QpIHtcbiAgICAgICAgICAvLyBzZWUgaWYgYW55IGJsb2NrLXNjb3BlZCBkZWNsYXJhdGlvbnMgYXJlIHJlZmVyZW5jZWRcbiAgICAgICAgICAvLyBpbnNpZGUgZnVuY3Rpb24gZXhwcmVzc2lvbnNcbiAgICAgICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmJvZHkuc2NvcGUuZGVjbGFyYXRpb25zKTtcblxuICAgICAgICAgIHZhciBpID0gbmFtZXMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzJDEuYm9keS5zY29wZS5kZWNsYXJhdGlvbnNbbmFtZV07XG5cbiAgICAgICAgICAgIHZhciBqID0gZGVjbGFyYXRpb24uaW5zdGFuY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZGVjbGFyYXRpb24uaW5zdGFuY2VzW2pdO1xuICAgICAgICAgICAgICB2YXIgbmVhcmVzdEZ1bmN0aW9uRXhwcmVzc2lvbiA9IGluc3RhbmNlLmZpbmROZWFyZXN0KC9GdW5jdGlvbi8pO1xuXG4gICAgICAgICAgICAgIGlmIChuZWFyZXN0RnVuY3Rpb25FeHByZXNzaW9uICYmIG5lYXJlc3RGdW5jdGlvbkV4cHJlc3Npb24uZGVwdGggPiB0aGlzJDEuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzJDEuc2hvdWxkUmV3cml0ZUFzRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzJDEuc2hvdWxkUmV3cml0ZUFzRnVuY3Rpb24pIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgTG9vcFN0YXRlbWVudC5wcm90b3R5cGUudHJhbnNwaWxlID0gZnVuY3Rpb24gdHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgdmFyIG5lZWRzQmxvY2sgPSB0aGlzLnR5cGUgIT0gJ0Zvck9mU3RhdGVtZW50JyAmJiAodGhpcy5ib2R5LnR5cGUgIT09ICdCbG9ja1N0YXRlbWVudCcgfHwgdGhpcy5ib2R5LnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcgJiYgdGhpcy5ib2R5LnN5bnRoZXRpYyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmV3cml0ZUFzRnVuY3Rpb24pIHtcbiAgICAgICAgICB2YXIgaTAgPSB0aGlzLmdldEluZGVudGF0aW9uKCk7XG4gICAgICAgICAgdmFyIGkxID0gaTAgKyBjb2RlLmdldEluZGVudFN0cmluZygpO1xuXG4gICAgICAgICAgdmFyIGFyZ1N0cmluZyA9IHRoaXMuYXJncyA/IFwiIFwiICsgdGhpcy5hcmdzLmpvaW4oJywgJykgKyBcIiBcIiA6ICcnO1xuICAgICAgICAgIHZhciBwYXJhbVN0cmluZyA9IHRoaXMucGFyYW1zID8gXCIgXCIgKyB0aGlzLnBhcmFtcy5qb2luKCcsICcpICsgXCIgXCIgOiAnJztcblxuICAgICAgICAgIHZhciBmdW5jdGlvblNjb3BlID0gdGhpcy5maW5kU2NvcGUodHJ1ZSk7XG4gICAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvblNjb3BlLmNyZWF0ZUlkZW50aWZpZXIoJ2xvb3AnKTtcblxuICAgICAgICAgIHZhciBiZWZvcmUgPSBcInZhciBcIiArIGxvb3AgKyBcIiA9IGZ1bmN0aW9uIChcIiArIHBhcmFtU3RyaW5nICsgXCIpIFwiICsgKHRoaXMuYm9keS5zeW50aGV0aWMgPyBcIntcXG5cIiArIGkwICsgY29kZS5nZXRJbmRlbnRTdHJpbmcoKSA6ICcnKTtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSAodGhpcy5ib2R5LnN5bnRoZXRpYyA/IFwiXFxuXCIgKyBpMCArIFwifVwiIDogJycpICsgXCI7XFxuXFxuXCIgKyBpMDtcblxuICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQodGhpcy5ib2R5LnN0YXJ0LCBiZWZvcmUpO1xuICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLmJvZHkuZW5kLCBhZnRlcik7XG4gICAgICAgICAgY29kZS5tb3ZlKHRoaXMuc3RhcnQsIHRoaXMuYm9keS5zdGFydCwgdGhpcy5ib2R5LmVuZCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5jYW5CcmVhayB8fCB0aGlzLmNhblJldHVybikge1xuICAgICAgICAgICAgdmFyIHJldHVybmVkID0gZnVuY3Rpb25TY29wZS5jcmVhdGVJZGVudGlmaWVyKCdyZXR1cm5lZCcpO1xuXG4gICAgICAgICAgICB2YXIgaW5zZXJ0ID0gXCJ7XFxuXCIgKyBpMSArIFwidmFyIFwiICsgcmV0dXJuZWQgKyBcIiA9IFwiICsgbG9vcCArIFwiKFwiICsgYXJnU3RyaW5nICsgXCIpO1xcblwiO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuQnJlYWspIGluc2VydCArPSBcIlxcblwiICsgaTEgKyBcImlmICggXCIgKyByZXR1cm5lZCArIFwiID09PSAnYnJlYWsnICkgYnJlYWs7XCI7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5SZXR1cm4pIGluc2VydCArPSBcIlxcblwiICsgaTEgKyBcImlmICggXCIgKyByZXR1cm5lZCArIFwiICkgcmV0dXJuIFwiICsgcmV0dXJuZWQgKyBcIi52O1wiO1xuICAgICAgICAgICAgaW5zZXJ0ICs9IFwiXFxuXCIgKyBpMCArIFwifVwiO1xuXG4gICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KHRoaXMuYm9keS5lbmQsIGluc2VydCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYWxsRXhwcmVzc2lvbiA9IGxvb3AgKyBcIihcIiArIGFyZ1N0cmluZyArIFwiKTtcIjtcblxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ0RvV2hpbGVTdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3RhcnQsIHRoaXMuYm9keS5zdGFydCwgXCJkbyB7XFxuXCIgKyBpMSArIGNhbGxFeHByZXNzaW9uICsgXCJcXG5cIiArIGkwICsgXCJ9XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodCh0aGlzLmJvZHkuZW5kLCBjYWxsRXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5lZWRzQmxvY2spIHtcbiAgICAgICAgICBjb2RlLmluc2VydExlZnQodGhpcy5ib2R5LnN0YXJ0LCAneyAnKTtcbiAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KHRoaXMuYm9keS5lbmQsICcgfScpO1xuICAgICAgICB9XG5cbiAgICAgICAgTm9kZS5wcm90b3R5cGUudHJhbnNwaWxlLmNhbGwodGhpcywgY29kZSwgdHJhbnNmb3Jtcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gTG9vcFN0YXRlbWVudDtcbiAgICB9KE5vZGUpO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdE5hbWVzKG5vZGUpIHtcbiAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgZXh0cmFjdG9yc1tub2RlLnR5cGVdKG5hbWVzLCBub2RlKTtcbiAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG5cbiAgICB2YXIgZXh0cmFjdG9ycyA9IHtcbiAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uIElkZW50aWZpZXIobmFtZXMsIG5vZGUpIHtcbiAgICAgICAgbmFtZXMucHVzaChub2RlKTtcbiAgICAgIH0sXG5cbiAgICAgIE9iamVjdFBhdHRlcm46IGZ1bmN0aW9uIE9iamVjdFBhdHRlcm4obmFtZXMsIG5vZGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgZXh0cmFjdG9yc1twcm9wLnZhbHVlLnR5cGVdKG5hbWVzLCBwcm9wLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgQXJyYXlQYXR0ZXJuOiBmdW5jdGlvbiBBcnJheVBhdHRlcm4obmFtZXMsIG5vZGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLmVsZW1lbnRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gbGlzdFtpXTtcblxuICAgICAgICAgIGlmIChlbGVtZW50KSBleHRyYWN0b3JzW2VsZW1lbnQudHlwZV0obmFtZXMsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBSZXN0RWxlbWVudDogZnVuY3Rpb24gUmVzdEVsZW1lbnQobmFtZXMsIG5vZGUpIHtcbiAgICAgICAgZXh0cmFjdG9yc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5hbWVzLCBub2RlLmFyZ3VtZW50KTtcbiAgICAgIH0sXG5cbiAgICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiBmdW5jdGlvbiBBc3NpZ25tZW50UGF0dGVybihuYW1lcywgbm9kZSkge1xuICAgICAgICBleHRyYWN0b3JzW25vZGUubGVmdC50eXBlXShuYW1lcywgbm9kZS5sZWZ0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIEZvclN0YXRlbWVudCA9IGZ1bmN0aW9uIChMb29wU3RhdGVtZW50KSB7XG4gICAgICBmdW5jdGlvbiBGb3JTdGF0ZW1lbnQoKSB7XG4gICAgICAgIExvb3BTdGF0ZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKExvb3BTdGF0ZW1lbnQpIEZvclN0YXRlbWVudC5fX3Byb3RvX18gPSBMb29wU3RhdGVtZW50O1xuICAgICAgRm9yU3RhdGVtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTG9vcFN0YXRlbWVudCAmJiBMb29wU3RhdGVtZW50LnByb3RvdHlwZSk7XG4gICAgICBGb3JTdGF0ZW1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRm9yU3RhdGVtZW50O1xuXG4gICAgICBGb3JTdGF0ZW1lbnQucHJvdG90eXBlLmZpbmRTY29wZSA9IGZ1bmN0aW9uIGZpbmRTY29wZShmdW5jdGlvblNjb3BlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvblNjb3BlIHx8ICF0aGlzLmNyZWF0ZWRTY29wZSA/IHRoaXMucGFyZW50LmZpbmRTY29wZShmdW5jdGlvblNjb3BlKSA6IHRoaXMuYm9keS5zY29wZTtcbiAgICAgIH07XG5cbiAgICAgIEZvclN0YXRlbWVudC5wcm90b3R5cGUudHJhbnNwaWxlID0gZnVuY3Rpb24gdHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGkxID0gdGhpcy5nZXRJbmRlbnRhdGlvbigpICsgY29kZS5nZXRJbmRlbnRTdHJpbmcoKTtcblxuICAgICAgICBpZiAodGhpcy5zaG91bGRSZXdyaXRlQXNGdW5jdGlvbikge1xuICAgICAgICAgIC8vIHdoaWNoIHZhcmlhYmxlcyBhcmUgZGVjbGFyZWQgaW4gdGhlIGluaXQgc3RhdGVtZW50P1xuICAgICAgICAgIHZhciBuYW1lcyA9IHRoaXMuaW5pdC50eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdGlvbicgPyBbXS5jb25jYXQuYXBwbHkoW10sIHRoaXMuaW5pdC5kZWNsYXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkZWNsYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0cmFjdE5hbWVzKGRlY2xhcmF0b3IuaWQpO1xuICAgICAgICAgIH0pKSA6IFtdO1xuXG4gICAgICAgICAgdmFyIGFsaWFzZXMgPSB0aGlzLmFsaWFzZXM7XG5cbiAgICAgICAgICB0aGlzLmFyZ3MgPSBuYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lIGluIHRoaXMkMS5hbGlhc2VzID8gdGhpcyQxLmFsaWFzZXNbbmFtZV0ub3V0ZXIgOiBuYW1lO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucGFyYW1zID0gbmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZSBpbiB0aGlzJDEuYWxpYXNlcyA/IHRoaXMkMS5hbGlhc2VzW25hbWVdLmlubmVyIDogbmFtZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciB1cGRhdGVzID0gT2JqZWN0LmtleXModGhpcy5yZWFzc2lnbmVkKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhbGlhc2VzW25hbWVdLm91dGVyICsgXCIgPSBcIiArIGFsaWFzZXNbbmFtZV0uaW5uZXIgKyBcIjtcIjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh1cGRhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5zeW50aGV0aWMpIHtcbiAgICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KHRoaXMuYm9keS5ib2R5WzBdLmVuZCwgXCI7IFwiICsgdXBkYXRlcy5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgbGFzdFN0YXRlbWVudCA9IHRoaXMuYm9keS5ib2R5W3RoaXMuYm9keS5ib2R5Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQobGFzdFN0YXRlbWVudC5lbmQsIFwiXFxuXFxuXCIgKyBpMSArIHVwZGF0ZXMuam9pbihcIlxcblwiICsgaTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBMb29wU3RhdGVtZW50LnByb3RvdHlwZS50cmFuc3BpbGUuY2FsbCh0aGlzLCBjb2RlLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBGb3JTdGF0ZW1lbnQ7XG4gICAgfShMb29wU3RhdGVtZW50KTtcblxuICAgIHZhciBGb3JJblN0YXRlbWVudCA9IGZ1bmN0aW9uIChMb29wU3RhdGVtZW50KSB7XG4gICAgICBmdW5jdGlvbiBGb3JJblN0YXRlbWVudCgpIHtcbiAgICAgICAgTG9vcFN0YXRlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTG9vcFN0YXRlbWVudCkgRm9ySW5TdGF0ZW1lbnQuX19wcm90b19fID0gTG9vcFN0YXRlbWVudDtcbiAgICAgIEZvckluU3RhdGVtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTG9vcFN0YXRlbWVudCAmJiBMb29wU3RhdGVtZW50LnByb3RvdHlwZSk7XG4gICAgICBGb3JJblN0YXRlbWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGb3JJblN0YXRlbWVudDtcblxuICAgICAgRm9ySW5TdGF0ZW1lbnQucHJvdG90eXBlLmZpbmRTY29wZSA9IGZ1bmN0aW9uIGZpbmRTY29wZShmdW5jdGlvblNjb3BlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvblNjb3BlIHx8ICF0aGlzLmNyZWF0ZWRTY29wZSA/IHRoaXMucGFyZW50LmZpbmRTY29wZShmdW5jdGlvblNjb3BlKSA6IHRoaXMuYm9keS5zY29wZTtcbiAgICAgIH07XG5cbiAgICAgIEZvckluU3RhdGVtZW50LnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5zaG91bGRSZXdyaXRlQXNGdW5jdGlvbikge1xuICAgICAgICAgIC8vIHdoaWNoIHZhcmlhYmxlcyBhcmUgZGVjbGFyZWQgaW4gdGhlIGluaXQgc3RhdGVtZW50P1xuICAgICAgICAgIHZhciBuYW1lcyA9IHRoaXMubGVmdC50eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdGlvbicgPyBbXS5jb25jYXQuYXBwbHkoW10sIHRoaXMubGVmdC5kZWNsYXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkZWNsYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0cmFjdE5hbWVzKGRlY2xhcmF0b3IuaWQpO1xuICAgICAgICAgIH0pKSA6IFtdO1xuXG4gICAgICAgICAgdGhpcy5hcmdzID0gbmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZSBpbiB0aGlzJDEuYWxpYXNlcyA/IHRoaXMkMS5hbGlhc2VzW25hbWVdLm91dGVyIDogbmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnBhcmFtcyA9IG5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgaW4gdGhpcyQxLmFsaWFzZXMgPyB0aGlzJDEuYWxpYXNlc1tuYW1lXS5pbm5lciA6IG5hbWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBMb29wU3RhdGVtZW50LnByb3RvdHlwZS50cmFuc3BpbGUuY2FsbCh0aGlzLCBjb2RlLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBGb3JJblN0YXRlbWVudDtcbiAgICB9KExvb3BTdGF0ZW1lbnQpO1xuXG4gICAgdmFyIGhhbmRsZXJzID0ge1xuICAgICAgSWRlbnRpZmllcjogZGVzdHJ1Y3R1cmVJZGVudGlmaWVyLFxuICAgICAgQXNzaWdubWVudFBhdHRlcm46IGRlc3RydWN0dXJlQXNzaWdubWVudFBhdHRlcm4sXG4gICAgICBBcnJheVBhdHRlcm46IGRlc3RydWN0dXJlQXJyYXlQYXR0ZXJuLFxuICAgICAgT2JqZWN0UGF0dGVybjogZGVzdHJ1Y3R1cmVPYmplY3RQYXR0ZXJuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRlc3RydWN0dXJlKGNvZGUsIHNjb3BlLCBub2RlLCByZWYsIGlubGluZSwgc3RhdGVtZW50R2VuZXJhdG9ycykge1xuICAgICAgaGFuZGxlcnNbbm9kZS50eXBlXShjb2RlLCBzY29wZSwgbm9kZSwgcmVmLCBpbmxpbmUsIHN0YXRlbWVudEdlbmVyYXRvcnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3RydWN0dXJlSWRlbnRpZmllcihjb2RlLCBzY29wZSwgbm9kZSwgcmVmLCBpbmxpbmUsIHN0YXRlbWVudEdlbmVyYXRvcnMpIHtcbiAgICAgIHN0YXRlbWVudEdlbmVyYXRvcnMucHVzaChmdW5jdGlvbiAoc3RhcnQsIHByZWZpeCwgc3VmZml4KSB7XG4gICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQobm9kZS5zdGFydCwgaW5saW5lID8gcHJlZml4IDogcHJlZml4ICsgXCJ2YXIgXCIpO1xuICAgICAgICBjb2RlLmluc2VydExlZnQobm9kZS5lbmQsIFwiID0gXCIgKyByZWYgKyBzdWZmaXgpO1xuICAgICAgICBjb2RlLm1vdmUobm9kZS5zdGFydCwgbm9kZS5lbmQsIHN0YXJ0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3RydWN0dXJlQXNzaWdubWVudFBhdHRlcm4oY29kZSwgc2NvcGUsIG5vZGUsIHJlZiwgaW5saW5lLCBzdGF0ZW1lbnRHZW5lcmF0b3JzKSB7XG4gICAgICB2YXIgaXNJZGVudGlmaWVyID0gbm9kZS5sZWZ0LnR5cGUgPT09ICdJZGVudGlmaWVyJztcbiAgICAgIHZhciBuYW1lID0gaXNJZGVudGlmaWVyID8gbm9kZS5sZWZ0Lm5hbWUgOiByZWY7XG5cbiAgICAgIGlmICghaW5saW5lKSB7XG4gICAgICAgIHN0YXRlbWVudEdlbmVyYXRvcnMucHVzaChmdW5jdGlvbiAoc3RhcnQsIHByZWZpeCwgc3VmZml4KSB7XG4gICAgICAgICAgY29kZS5pbnNlcnRSaWdodChub2RlLmxlZnQuZW5kLCBwcmVmaXggKyBcImlmICggXCIgKyBuYW1lICsgXCIgPT09IHZvaWQgMCApIFwiICsgbmFtZSk7XG4gICAgICAgICAgY29kZS5tb3ZlKG5vZGUubGVmdC5lbmQsIG5vZGUucmlnaHQuZW5kLCBzdGFydCk7XG4gICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KG5vZGUucmlnaHQuZW5kLCBzdWZmaXgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0lkZW50aWZpZXIpIHtcbiAgICAgICAgZGVzdHJ1Y3R1cmUoY29kZSwgc2NvcGUsIG5vZGUubGVmdCwgcmVmLCBpbmxpbmUsIHN0YXRlbWVudEdlbmVyYXRvcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3RydWN0dXJlQXJyYXlQYXR0ZXJuKGNvZGUsIHNjb3BlLCBub2RlLCByZWYsIGlubGluZSwgc3RhdGVtZW50R2VuZXJhdG9ycykge1xuICAgICAgdmFyIGMgPSBub2RlLnN0YXJ0O1xuXG4gICAgICBub2RlLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGkpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG5cbiAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ1Jlc3RFbGVtZW50Jykge1xuICAgICAgICAgIGhhbmRsZVByb3BlcnR5KGNvZGUsIHNjb3BlLCBjLCBlbGVtZW50LmFyZ3VtZW50LCByZWYgKyBcIi5zbGljZShcIiArIGkgKyBcIilcIiwgaW5saW5lLCBzdGF0ZW1lbnRHZW5lcmF0b3JzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVQcm9wZXJ0eShjb2RlLCBzY29wZSwgYywgZWxlbWVudCwgcmVmICsgXCJbXCIgKyBpICsgXCJdXCIsIGlubGluZSwgc3RhdGVtZW50R2VuZXJhdG9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgYyA9IGVsZW1lbnQuZW5kO1xuICAgICAgfSk7XG5cbiAgICAgIGNvZGUucmVtb3ZlKGMsIG5vZGUuZW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cnVjdHVyZU9iamVjdFBhdHRlcm4oY29kZSwgc2NvcGUsIG5vZGUsIHJlZiwgaW5saW5lLCBzdGF0ZW1lbnRHZW5lcmF0b3JzKSB7XG4gICAgICB2YXIgYyA9IG5vZGUuc3RhcnQ7XG5cbiAgICAgIG5vZGUucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3AuY29tcHV0ZWQgfHwgcHJvcC5rZXkudHlwZSAhPT0gJ0lkZW50aWZpZXInID8gcmVmICsgXCJbXCIgKyBjb2RlLnNsaWNlKHByb3Aua2V5LnN0YXJ0LCBwcm9wLmtleS5lbmQpICsgXCJdXCIgOiByZWYgKyBcIi5cIiArIHByb3Aua2V5Lm5hbWU7XG4gICAgICAgIGhhbmRsZVByb3BlcnR5KGNvZGUsIHNjb3BlLCBjLCBwcm9wLnZhbHVlLCB2YWx1ZSwgaW5saW5lLCBzdGF0ZW1lbnRHZW5lcmF0b3JzKTtcbiAgICAgICAgYyA9IHByb3AuZW5kO1xuICAgICAgfSk7XG5cbiAgICAgIGNvZGUucmVtb3ZlKGMsIG5vZGUuZW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eShjb2RlLCBzY29wZSwgYywgbm9kZSwgdmFsdWUsIGlubGluZSwgc3RhdGVtZW50R2VuZXJhdG9ycykge1xuICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29kZS5yZW1vdmUoYywgbm9kZS5zdGFydCk7XG4gICAgICAgICAgICBkZXN0cnVjdHVyZUlkZW50aWZpZXIoY29kZSwgc2NvcGUsIG5vZGUsIHZhbHVlLCBpbmxpbmUsIHN0YXRlbWVudEdlbmVyYXRvcnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRQYXR0ZXJuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbmFtZTtcblxuICAgICAgICAgICAgdmFyIGlzSWRlbnRpZmllciA9IG5vZGUubGVmdC50eXBlID09PSAnSWRlbnRpZmllcic7XG5cbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IG5vZGUubGVmdC5uYW1lO1xuICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSBzY29wZS5maW5kRGVjbGFyYXRpb24obmFtZSk7XG4gICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbikgbmFtZSA9IGRlY2xhcmF0aW9uLm5hbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lID0gc2NvcGUuY3JlYXRlSWRlbnRpZmllcih2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlbWVudEdlbmVyYXRvcnMucHVzaChmdW5jdGlvbiAoc3RhcnQsIHByZWZpeCwgc3VmZml4KSB7XG4gICAgICAgICAgICAgIGlmIChpbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KG5vZGUucmlnaHQuc3RhcnQsIG5hbWUgKyBcIiA9IFwiICsgdmFsdWUgKyBcIiA9PT0gdW5kZWZpbmVkID8gXCIpO1xuICAgICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChub2RlLnJpZ2h0LmVuZCwgXCIgOiBcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KG5vZGUucmlnaHQuc3RhcnQsIHByZWZpeCArIFwidmFyIFwiICsgbmFtZSArIFwiID0gXCIgKyB2YWx1ZSArIFwiOyBpZiAoIFwiICsgbmFtZSArIFwiID09PSB2b2lkIDAgKSBcIiArIG5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQobm9kZS5yaWdodC5lbmQsIHN1ZmZpeCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb2RlLm1vdmUobm9kZS5yaWdodC5zdGFydCwgbm9kZS5yaWdodC5lbmQsIHN0YXJ0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIGNvZGUucmVtb3ZlKGMsIG5vZGUucmlnaHQuc3RhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZS5yZW1vdmUoYywgbm9kZS5sZWZ0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgY29kZS5yZW1vdmUobm9kZS5sZWZ0LmVuZCwgbm9kZS5yaWdodC5zdGFydCk7XG4gICAgICAgICAgICAgIGhhbmRsZVByb3BlcnR5KGNvZGUsIHNjb3BlLCBjLCBub2RlLmxlZnQsIG5hbWUsIGlubGluZSwgc3RhdGVtZW50R2VuZXJhdG9ycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdPYmplY3RQYXR0ZXJuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZShjLCBjID0gbm9kZS5zdGFydCk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLnByb3BlcnRpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB2YXIgcmVmID0gc2NvcGUuY3JlYXRlSWRlbnRpZmllcih2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgc3RhdGVtZW50R2VuZXJhdG9ycy5wdXNoKGZ1bmN0aW9uIChzdGFydCwgcHJlZml4LCBzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGZlZWxzIGEgdGlueSBiaXQgaGFja3ksIGJ1dCB3ZSBjYW4ndCBkbyBhXG4gICAgICAgICAgICAgICAgLy8gc3RyYWlnaHRmb3J3YXJkIGluc2VydExlZnQgYW5kIGtlZXAgY29ycmVjdCBvcmRlci4uLlxuICAgICAgICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQobm9kZS5zdGFydCwgcHJlZml4ICsgXCJ2YXIgXCIgKyByZWYgKyBcIiA9IFwiKTtcbiAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShub2RlLnN0YXJ0LCBjID0gbm9kZS5zdGFydCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQoYywgc3VmZml4KTtcblxuICAgICAgICAgICAgICAgIGNvZGUubW92ZShub2RlLnN0YXJ0LCBjLCBzdGFydCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvcC5jb21wdXRlZCB8fCBwcm9wLmtleS50eXBlICE9PSAnSWRlbnRpZmllcicgPyByZWYgKyBcIltcIiArIGNvZGUuc2xpY2UocHJvcC5rZXkuc3RhcnQsIHByb3Aua2V5LmVuZCkgKyBcIl1cIiA6IHJlZiArIFwiLlwiICsgcHJvcC5rZXkubmFtZTtcbiAgICAgICAgICAgICAgICBoYW5kbGVQcm9wZXJ0eShjb2RlLCBzY29wZSwgYywgcHJvcC52YWx1ZSwgdmFsdWUsIGlubGluZSwgc3RhdGVtZW50R2VuZXJhdG9ycyk7XG4gICAgICAgICAgICAgICAgYyA9IHByb3AuZW5kO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wID0gbm9kZS5wcm9wZXJ0aWVzWzBdO1xuICAgICAgICAgICAgICB2YXIgdmFsdWVfc3VmZml4ID0gcHJvcC5jb21wdXRlZCB8fCBwcm9wLmtleS50eXBlICE9PSAnSWRlbnRpZmllcicgPyBcIltcIiArIGNvZGUuc2xpY2UocHJvcC5rZXkuc3RhcnQsIHByb3Aua2V5LmVuZCkgKyBcIl1cIiA6IFwiLlwiICsgcHJvcC5rZXkubmFtZTtcbiAgICAgICAgICAgICAgaGFuZGxlUHJvcGVydHkoY29kZSwgc2NvcGUsIGMsIHByb3AudmFsdWUsIFwiXCIgKyB2YWx1ZSArIHZhbHVlX3N1ZmZpeCwgaW5saW5lLCBzdGF0ZW1lbnRHZW5lcmF0b3JzKTtcbiAgICAgICAgICAgICAgYyA9IHByb3AuZW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2RlLnJlbW92ZShjLCBub2RlLmVuZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnQXJyYXlQYXR0ZXJuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZShjLCBjID0gbm9kZS5zdGFydCk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmVsZW1lbnRzLmZpbHRlcihCb29sZWFuKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHZhciByZWYkMSA9IHNjb3BlLmNyZWF0ZUlkZW50aWZpZXIodmFsdWUpO1xuXG4gICAgICAgICAgICAgIHN0YXRlbWVudEdlbmVyYXRvcnMucHVzaChmdW5jdGlvbiAoc3RhcnQsIHByZWZpeCwgc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodChub2RlLnN0YXJ0LCBwcmVmaXggKyBcInZhciBcIiArIHJlZiQxICsgXCIgPSBcIik7XG4gICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUobm9kZS5zdGFydCwgYyA9IG5vZGUuc3RhcnQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KGMsIHN1ZmZpeCk7XG5cbiAgICAgICAgICAgICAgICBjb2RlLm1vdmUobm9kZS5zdGFydCwgYywgc3RhcnQpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBub2RlLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICdSZXN0RWxlbWVudCcpIHtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZVByb3BlcnR5KGNvZGUsIHNjb3BlLCBjLCBlbGVtZW50LmFyZ3VtZW50LCByZWYkMSArIFwiLnNsaWNlKFwiICsgaSArIFwiKVwiLCBpbmxpbmUsIHN0YXRlbWVudEdlbmVyYXRvcnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVQcm9wZXJ0eShjb2RlLCBzY29wZSwgYywgZWxlbWVudCwgcmVmJDEgKyBcIltcIiArIGkgKyBcIl1cIiwgaW5saW5lLCBzdGF0ZW1lbnRHZW5lcmF0b3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYyA9IGVsZW1lbnQuZW5kO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleChub2RlLmVsZW1lbnRzLCBCb29sZWFuKTtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBub2RlLmVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ1Jlc3RFbGVtZW50Jykge1xuICAgICAgICAgICAgICAgIGhhbmRsZVByb3BlcnR5KGNvZGUsIHNjb3BlLCBjLCBlbGVtZW50LmFyZ3VtZW50LCB2YWx1ZSArIFwiLnNsaWNlKFwiICsgaW5kZXggKyBcIilcIiwgaW5saW5lLCBzdGF0ZW1lbnRHZW5lcmF0b3JzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVQcm9wZXJ0eShjb2RlLCBzY29wZSwgYywgZWxlbWVudCwgdmFsdWUgKyBcIltcIiArIGluZGV4ICsgXCJdXCIsIGlubGluZSwgc3RhdGVtZW50R2VuZXJhdG9ycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYyA9IGVsZW1lbnQuZW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2RlLnJlbW92ZShjLCBub2RlLmVuZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUgdHlwZSBpbiBkZXN0cnVjdHVyaW5nIChcIiArIG5vZGUudHlwZSArIFwiKVwiKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIEZvck9mU3RhdGVtZW50ID0gZnVuY3Rpb24gKExvb3BTdGF0ZW1lbnQpIHtcbiAgICAgIGZ1bmN0aW9uIEZvck9mU3RhdGVtZW50KCkge1xuICAgICAgICBMb29wU3RhdGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChMb29wU3RhdGVtZW50KSBGb3JPZlN0YXRlbWVudC5fX3Byb3RvX18gPSBMb29wU3RhdGVtZW50O1xuICAgICAgRm9yT2ZTdGF0ZW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMb29wU3RhdGVtZW50ICYmIExvb3BTdGF0ZW1lbnQucHJvdG90eXBlKTtcbiAgICAgIEZvck9mU3RhdGVtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZvck9mU3RhdGVtZW50O1xuXG4gICAgICBGb3JPZlN0YXRlbWVudC5wcm90b3R5cGUuaW5pdGlhbGlzZSA9IGZ1bmN0aW9uIGluaXRpYWxpc2UodHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAodHJhbnNmb3Jtcy5mb3JPZiAmJiAhdHJhbnNmb3Jtcy5kYW5nZXJvdXNGb3JPZikgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih0aGlzLCAnZm9yLi4ub2Ygc3RhdGVtZW50cyBhcmUgbm90IHN1cHBvcnRlZC4gVXNlIGB0cmFuc2Zvcm1zOiB7IGZvck9mOiBmYWxzZSB9YCB0byBza2lwIHRyYW5zZm9ybWF0aW9uIGFuZCBkaXNhYmxlIHRoaXMgZXJyb3IsIG9yIGB0cmFuc2Zvcm1zOiB7IGRhbmdlcm91c0Zvck9mOiB0cnVlIH1gIGlmIHlvdSBrbm93IHdoYXQgeW91XFwncmUgZG9pbmcnKTtcbiAgICAgICAgTG9vcFN0YXRlbWVudC5wcm90b3R5cGUuaW5pdGlhbGlzZS5jYWxsKHRoaXMsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgRm9yT2ZTdGF0ZW1lbnQucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIGlmICghdHJhbnNmb3Jtcy5kYW5nZXJvdXNGb3JPZikge1xuICAgICAgICAgIExvb3BTdGF0ZW1lbnQucHJvdG90eXBlLnRyYW5zcGlsZS5jYWxsKHRoaXMsIGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVkZ2UgY2FzZSAoIzgwKVxuICAgICAgICBpZiAoIXRoaXMuYm9keS5ib2R5WzBdKSB7XG4gICAgICAgICAgaWYgKHRoaXMubGVmdC50eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdGlvbicgJiYgdGhpcy5sZWZ0LmtpbmQgPT09ICd2YXInKSB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLnN0YXJ0LCB0aGlzLmxlZnQuc3RhcnQpO1xuICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KHRoaXMubGVmdC5lbmQsICc7Jyk7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLmxlZnQuZW5kLCB0aGlzLmVuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLmZpbmRTY29wZSh0cnVlKTtcbiAgICAgICAgdmFyIGkwID0gdGhpcy5nZXRJbmRlbnRhdGlvbigpO1xuICAgICAgICB2YXIgaTEgPSBpMCArIGNvZGUuZ2V0SW5kZW50U3RyaW5nKCk7XG5cbiAgICAgICAgdmFyIGtleSA9IHNjb3BlLmNyZWF0ZUlkZW50aWZpZXIoJ2knKTtcbiAgICAgICAgdmFyIGxpc3QgPSBzY29wZS5jcmVhdGVJZGVudGlmaWVyKCdsaXN0Jyk7XG5cbiAgICAgICAgaWYgKHRoaXMuYm9keS5zeW50aGV0aWMpIHtcbiAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KHRoaXMubGVmdC5zdGFydCwgXCJ7XFxuXCIgKyBpMSk7XG4gICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KHRoaXMuYm9keS5ib2R5WzBdLmVuZCwgXCJcXG5cIiArIGkwICsgXCJ9XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvZHlTdGFydCA9IHRoaXMuYm9keS5ib2R5WzBdLnN0YXJ0O1xuXG4gICAgICAgIGNvZGUucmVtb3ZlKHRoaXMubGVmdC5lbmQsIHRoaXMucmlnaHQuc3RhcnQpO1xuICAgICAgICBjb2RlLm1vdmUodGhpcy5sZWZ0LnN0YXJ0LCB0aGlzLmxlZnQuZW5kLCBib2R5U3RhcnQpO1xuXG4gICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQodGhpcy5yaWdodC5zdGFydCwgXCJ2YXIgXCIgKyBrZXkgKyBcIiA9IDAsIFwiICsgbGlzdCArIFwiID0gXCIpO1xuICAgICAgICBjb2RlLmluc2VydExlZnQodGhpcy5yaWdodC5lbmQsIFwiOyBcIiArIGtleSArIFwiIDwgXCIgKyBsaXN0ICsgXCIubGVuZ3RoOyBcIiArIGtleSArIFwiICs9IDFcIik7XG5cbiAgICAgICAgLy8gZGVzdHJ1Y3R1cmluZy4gVE9ETyBub24gZGVjbGFyYXRpb24gZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgZGVjbGFyYXRvciA9IHRoaXMubGVmdC50eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdGlvbicgJiYgdGhpcy5sZWZ0LmRlY2xhcmF0aW9uc1swXTtcbiAgICAgICAgaWYgKGRlY2xhcmF0b3IgJiYgZGVjbGFyYXRvci5pZC50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICB2YXIgc3RhdGVtZW50R2VuZXJhdG9ycyA9IFtdO1xuICAgICAgICAgIHZhciByZWYgPSBzY29wZS5jcmVhdGVJZGVudGlmaWVyKCdyZWYnKTtcbiAgICAgICAgICBkZXN0cnVjdHVyZShjb2RlLCBzY29wZSwgZGVjbGFyYXRvci5pZCwgcmVmLCBmYWxzZSwgc3RhdGVtZW50R2VuZXJhdG9ycyk7XG5cbiAgICAgICAgICB2YXIgc3VmZml4ID0gXCI7XFxuXCIgKyBpMTtcbiAgICAgICAgICBzdGF0ZW1lbnRHZW5lcmF0b3JzLmZvckVhY2goZnVuY3Rpb24gKGZuLCBpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gc3RhdGVtZW50R2VuZXJhdG9ycy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIHN1ZmZpeCA9IFwiO1xcblxcblwiICsgaTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZuKGJvZHlTdGFydCwgJycsIHN1ZmZpeCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb2RlLmluc2VydExlZnQodGhpcy5sZWZ0LnN0YXJ0ICsgdGhpcy5sZWZ0LmtpbmQubGVuZ3RoICsgMSwgcmVmKTtcbiAgICAgICAgICBjb2RlLmluc2VydExlZnQodGhpcy5sZWZ0LmVuZCwgXCIgPSBcIiArIGxpc3QgKyBcIltcIiArIGtleSArIFwiXTtcXG5cIiArIGkxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlLmluc2VydExlZnQodGhpcy5sZWZ0LmVuZCwgXCIgPSBcIiArIGxpc3QgKyBcIltcIiArIGtleSArIFwiXTtcXG5cXG5cIiArIGkxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIExvb3BTdGF0ZW1lbnQucHJvdG90eXBlLnRyYW5zcGlsZS5jYWxsKHRoaXMsIGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEZvck9mU3RhdGVtZW50O1xuICAgIH0oTG9vcFN0YXRlbWVudCk7XG5cbiAgICB2YXIgRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBGdW5jdGlvbkRlY2xhcmF0aW9uKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBGdW5jdGlvbkRlY2xhcmF0aW9uLl9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZ1bmN0aW9uRGVjbGFyYXRpb247XG5cbiAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb24ucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKHRyYW5zZm9ybXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdG9yICYmIHRyYW5zZm9ybXMuZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih0aGlzLCAnR2VuZXJhdG9ycyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2R5LmNyZWF0ZVNjb3BlKCk7XG5cbiAgICAgICAgdGhpcy5maW5kU2NvcGUodHJ1ZSkuYWRkRGVjbGFyYXRpb24odGhpcy5pZCwgJ2Z1bmN0aW9uJyk7XG4gICAgICAgIE5vZGUucHJvdG90eXBlLmluaXRpYWxpc2UuY2FsbCh0aGlzLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBGdW5jdGlvbkRlY2xhcmF0aW9uO1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKE5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRXhwcmVzc2lvbigpIHtcbiAgICAgICAgTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTm9kZSkgRnVuY3Rpb25FeHByZXNzaW9uLl9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBGdW5jdGlvbkV4cHJlc3Npb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlICYmIE5vZGUucHJvdG90eXBlKTtcbiAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGdW5jdGlvbkV4cHJlc3Npb247XG5cbiAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbi5wcm90b3R5cGUuaW5pdGlhbGlzZSA9IGZ1bmN0aW9uIGluaXRpYWxpc2UodHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAodGhpcy5nZW5lcmF0b3IgJiYgdHJhbnNmb3Jtcy5nZW5lcmF0b3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQ29tcGlsZUVycm9yKHRoaXMsICdHZW5lcmF0b3JzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHkuY3JlYXRlU2NvcGUoKTtcblxuICAgICAgICBpZiAodGhpcy5pZCkge1xuICAgICAgICAgIC8vIGZ1bmN0aW9uIGV4cHJlc3Npb24gSURzIGJlbG9uZyB0byB0aGUgY2hpbGQgc2NvcGUuLi5cbiAgICAgICAgICB0aGlzLmJvZHkuc2NvcGUuYWRkRGVjbGFyYXRpb24odGhpcy5pZCwgJ2Z1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBOb2RlLnByb3RvdHlwZS5pbml0aWFsaXNlLmNhbGwodGhpcywgdHJhbnNmb3Jtcyk7XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgbWV0aG9kTmFtZTtcblxuICAgICAgICBpZiAodHJhbnNmb3Jtcy5jb25jaXNlTWV0aG9kUHJvcGVydHkgJiYgcGFyZW50LnR5cGUgPT09ICdQcm9wZXJ0eScgJiYgcGFyZW50LmtpbmQgPT09ICdpbml0JyAmJiBwYXJlbnQubWV0aG9kICYmIHBhcmVudC5rZXkudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgLy8gb2JqZWN0IGxpdGVyYWwgY29uY2lzZSBtZXRob2RcbiAgICAgICAgICBtZXRob2ROYW1lID0gcGFyZW50LmtleS5uYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybXMuY2xhc3NlcyAmJiBwYXJlbnQudHlwZSA9PT0gJ01ldGhvZERlZmluaXRpb24nICYmIHBhcmVudC5raW5kID09PSAnbWV0aG9kJyAmJiBwYXJlbnQua2V5LnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgIC8vIG1ldGhvZCBkZWZpbml0aW9uIGluIGEgY2xhc3NcbiAgICAgICAgICBtZXRob2ROYW1lID0gcGFyZW50LmtleS5uYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaWQgJiYgdGhpcy5pZC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAvLyBuYWtlZCBmdW5jdGlvbiBleHByZXNzaW9uXG4gICAgICAgICAgbWV0aG9kTmFtZSA9IHRoaXMuaWQuYWxpYXMgfHwgdGhpcy5pZC5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHRoaXMucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJiBtZXRob2ROYW1lID09PSBwYXJhbS5uYW1lKSB7XG4gICAgICAgICAgICAgIC8vIHdvcmthcm91bmQgZm9yIFNhZmFyaSA5L1dlYktpdCBidWc6XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0bGFiLmNvbS9SaWNoLUhhcnJpcy9idWJsZS9pc3N1ZXMvMTU0XG4gICAgICAgICAgICAgIC8vIGNoYW5nZSBwYXJhbWV0ZXIgbmFtZSB3aGVuIHNhbWUgYXMgbWV0aG9kIG5hbWVcblxuICAgICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLmJvZHkuc2NvcGU7XG4gICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHNjb3BlLmRlY2xhcmF0aW9uc1ttZXRob2ROYW1lXTtcblxuICAgICAgICAgICAgICB2YXIgYWxpYXMgPSBzY29wZS5jcmVhdGVJZGVudGlmaWVyKG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgICBwYXJhbS5hbGlhcyA9IGFsaWFzO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IGRlY2xhcmF0aW9uLmluc3RhbmNlczsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllci5hbGlhcyA9IGFsaWFzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gRnVuY3Rpb25FeHByZXNzaW9uO1xuICAgIH0oTm9kZSk7XG5cbiAgICBmdW5jdGlvbiBpc1JlZmVyZW5jZShub2RlLCBwYXJlbnQpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICByZXR1cm4gIW5vZGUuY29tcHV0ZWQgJiYgaXNSZWZlcmVuY2Uobm9kZS5vYmplY3QsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgLy8gdGhlIG9ubHkgdGltZSB3ZSBjb3VsZCBoYXZlIGFuIGlkZW50aWZpZXIgbm9kZSB3aXRob3V0IGEgcGFyZW50IGlzXG4gICAgICAgIC8vIGlmIGl0J3MgdGhlIGVudGlyZSBib2R5IG9mIGEgZnVuY3Rpb24gd2l0aG91dCBhIGJsb2NrIHN0YXRlbWVudCDigJNcbiAgICAgICAgLy8gaS5lLiBhbiBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uIGxpa2UgYGEgPT4gYWBcbiAgICAgICAgaWYgKCFwYXJlbnQpIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGlmICgvKEZ1bmN0aW9ufENsYXNzKUV4cHJlc3Npb24vLnRlc3QocGFyZW50LnR5cGUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdG9yJykgcmV0dXJuIG5vZGUgPT09IHBhcmVudC5pbml0O1xuXG4gICAgICAgIC8vIFRPRE8gaXMgdGhpcyByaWdodD9cbiAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgfHwgcGFyZW50LnR5cGUgPT09ICdNZXRob2REZWZpbml0aW9uJykge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQuY29tcHV0ZWQgfHwgbm9kZSA9PT0gcGFyZW50Lm9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ0FycmF5UGF0dGVybicpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBkaXNyZWdhcmQgdGhlIGBiYXJgIGluIGB7IGJhcjogZm9vIH1gLCBidXQga2VlcCBpdCBpbiBgeyBbYmFyXTogZm9vIH1gXG4gICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ1Byb3BlcnR5Jykge1xuICAgICAgICAgIGlmIChwYXJlbnQucGFyZW50LnR5cGUgPT09ICdPYmplY3RQYXR0ZXJuJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHJldHVybiBwYXJlbnQuY29tcHV0ZWQgfHwgbm9kZSA9PT0gcGFyZW50LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGlzcmVnYXJkIHRoZSBgYmFyYCBpbiBgY2xhc3MgRm9vIHsgYmFyICgpIHsuLi59IH1gXG4gICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ01ldGhvZERlZmluaXRpb24nKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8gZGlzcmVnYXJkIHRoZSBgYmFyYCBpbiBgZXhwb3J0IHsgZm9vIGFzIGJhciB9YFxuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09ICdFeHBvcnRTcGVjaWZpZXInICYmIG5vZGUgIT09IHBhcmVudC5sb2NhbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBJZGVudGlmaWVyID0gZnVuY3Rpb24gKE5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIElkZW50aWZpZXIoKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIElkZW50aWZpZXIuX19wcm90b19fID0gTm9kZTtcbiAgICAgIElkZW50aWZpZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlICYmIE5vZGUucHJvdG90eXBlKTtcbiAgICAgIElkZW50aWZpZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWRlbnRpZmllcjtcblxuICAgICAgSWRlbnRpZmllci5wcm90b3R5cGUuZmluZFNjb3BlID0gZnVuY3Rpb24gZmluZFNjb3BlKGZ1bmN0aW9uU2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnBhcmFtcyAmJiB+dGhpcy5wYXJlbnQucGFyYW1zLmluZGV4T2YodGhpcykpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYm9keS5zY29wZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC50eXBlID09PSAnRnVuY3Rpb25FeHByZXNzaW9uJyAmJiB0aGlzID09PSB0aGlzLnBhcmVudC5pZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5ib2R5LnNjb3BlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmZpbmRTY29wZShmdW5jdGlvblNjb3BlKTtcbiAgICAgIH07XG5cbiAgICAgIElkZW50aWZpZXIucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKHRyYW5zZm9ybXMpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybXMuYXJyb3cgJiYgaXNSZWZlcmVuY2UodGhpcywgdGhpcy5wYXJlbnQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMubmFtZSA9PT0gJ2FyZ3VtZW50cycgJiYgIXRoaXMuZmluZFNjb3BlKGZhbHNlKS5jb250YWlucyh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgbGV4aWNhbEJvdW5kYXJ5ID0gdGhpcy5maW5kTGV4aWNhbEJvdW5kYXJ5KCk7XG4gICAgICAgICAgICB2YXIgYXJyb3dGdW5jdGlvbiA9IHRoaXMuZmluZE5lYXJlc3QoJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyk7XG4gICAgICAgICAgICB2YXIgbG9vcCA9IHRoaXMuZmluZE5lYXJlc3QobG9vcFN0YXRlbWVudCk7XG5cbiAgICAgICAgICAgIGlmIChhcnJvd0Z1bmN0aW9uICYmIGFycm93RnVuY3Rpb24uZGVwdGggPiBsZXhpY2FsQm91bmRhcnkuZGVwdGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5hbGlhcyA9IGxleGljYWxCb3VuZGFyeS5nZXRBcmd1bWVudHNBbGlhcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9vcCAmJiBsb29wLmJvZHkuY29udGFpbnModGhpcykgJiYgbG9vcC5kZXB0aCA+IGxleGljYWxCb3VuZGFyeS5kZXB0aCkge1xuICAgICAgICAgICAgICB0aGlzLmFsaWFzID0gbGV4aWNhbEJvdW5kYXJ5LmdldEFyZ3VtZW50c0FsaWFzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5maW5kU2NvcGUoZmFsc2UpLmFkZFJlZmVyZW5jZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgSWRlbnRpZmllci5wcm90b3R5cGUudHJhbnNwaWxlID0gZnVuY3Rpb24gdHJhbnNwaWxlKGNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxpYXMpIHtcbiAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgdGhpcy5hbGlhcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBJZGVudGlmaWVyO1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gSWZTdGF0ZW1lbnQoKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIElmU3RhdGVtZW50Ll9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBJZlN0YXRlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgSWZTdGF0ZW1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWZTdGF0ZW1lbnQ7XG5cbiAgICAgIElmU3RhdGVtZW50LnByb3RvdHlwZS5pbml0aWFsaXNlID0gZnVuY3Rpb24gaW5pdGlhbGlzZSh0cmFuc2Zvcm1zKSB7XG4gICAgICAgIE5vZGUucHJvdG90eXBlLmluaXRpYWxpc2UuY2FsbCh0aGlzLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIElmU3RhdGVtZW50LnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAodGhpcy5jb25zZXF1ZW50LnR5cGUgIT09ICdCbG9ja1N0YXRlbWVudCcgfHwgdGhpcy5jb25zZXF1ZW50LnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcgJiYgdGhpcy5jb25zZXF1ZW50LnN5bnRoZXRpYykge1xuICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLmNvbnNlcXVlbnQuc3RhcnQsICd7ICcpO1xuICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQodGhpcy5jb25zZXF1ZW50LmVuZCwgJyB9Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbHRlcm5hdGUgJiYgdGhpcy5hbHRlcm5hdGUudHlwZSAhPT0gJ0lmU3RhdGVtZW50JyAmJiAodGhpcy5hbHRlcm5hdGUudHlwZSAhPT0gJ0Jsb2NrU3RhdGVtZW50JyB8fCB0aGlzLmFsdGVybmF0ZS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnICYmIHRoaXMuYWx0ZXJuYXRlLnN5bnRoZXRpYykpIHtcbiAgICAgICAgICBjb2RlLmluc2VydExlZnQodGhpcy5hbHRlcm5hdGUuc3RhcnQsICd7ICcpO1xuICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQodGhpcy5hbHRlcm5hdGUuZW5kLCAnIH0nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE5vZGUucHJvdG90eXBlLnRyYW5zcGlsZS5jYWxsKHRoaXMsIGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIElmU3RhdGVtZW50O1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgSW1wb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gSW1wb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIEltcG9ydERlY2xhcmF0aW9uLl9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBJbXBvcnREZWNsYXJhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgSW1wb3J0RGVjbGFyYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1wb3J0RGVjbGFyYXRpb247XG5cbiAgICAgIEltcG9ydERlY2xhcmF0aW9uLnByb3RvdHlwZS5pbml0aWFsaXNlID0gZnVuY3Rpb24gaW5pdGlhbGlzZSh0cmFuc2Zvcm1zKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLm1vZHVsZUltcG9ydCkgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih0aGlzLCAnaW1wb3J0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuaW5pdGlhbGlzZS5jYWxsKHRoaXMsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEltcG9ydERlY2xhcmF0aW9uO1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBJbXBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBJbXBvcnREZWZhdWx0U3BlY2lmaWVyLl9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEltcG9ydERlZmF1bHRTcGVjaWZpZXI7XG5cbiAgICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXIucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKHRyYW5zZm9ybXMpIHtcbiAgICAgICAgdGhpcy5maW5kU2NvcGUodHJ1ZSkuYWRkRGVjbGFyYXRpb24odGhpcy5sb2NhbCwgJ2ltcG9ydCcpO1xuICAgICAgICBOb2RlLnByb3RvdHlwZS5pbml0aWFsaXNlLmNhbGwodGhpcywgdHJhbnNmb3Jtcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcbiAgICB9KE5vZGUpO1xuXG4gICAgdmFyIEltcG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBJbXBvcnRTcGVjaWZpZXIoKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIEltcG9ydFNwZWNpZmllci5fX3Byb3RvX18gPSBOb2RlO1xuICAgICAgSW1wb3J0U3BlY2lmaWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBJbXBvcnRTcGVjaWZpZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1wb3J0U3BlY2lmaWVyO1xuXG4gICAgICBJbXBvcnRTcGVjaWZpZXIucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKHRyYW5zZm9ybXMpIHtcbiAgICAgICAgdGhpcy5maW5kU2NvcGUodHJ1ZSkuYWRkRGVjbGFyYXRpb24odGhpcy5sb2NhbCwgJ2ltcG9ydCcpO1xuICAgICAgICBOb2RlLnByb3RvdHlwZS5pbml0aWFsaXNlLmNhbGwodGhpcywgdHJhbnNmb3Jtcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gSW1wb3J0U3BlY2lmaWVyO1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgSVNfREFUQV9BVFRSSUJVVEUgPSAvLS87XG5cbiAgICB2YXIgSlNYQXR0cmlidXRlID0gZnVuY3Rpb24gKE5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIEpTWEF0dHJpYnV0ZSgpIHtcbiAgICAgICAgTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTm9kZSkgSlNYQXR0cmlidXRlLl9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBKU1hBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlICYmIE5vZGUucHJvdG90eXBlKTtcbiAgICAgIEpTWEF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKU1hBdHRyaWJ1dGU7XG5cbiAgICAgIEpTWEF0dHJpYnV0ZS5wcm90b3R5cGUudHJhbnNwaWxlID0gZnVuY3Rpb24gdHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLm5hbWUuZW5kLCB0aGlzLnZhbHVlLnN0YXJ0LCAnOiAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0YWcgd2l0aG91dCB2YWx1ZVxuICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMubmFtZS5zdGFydCwgdGhpcy5uYW1lLmVuZCwgdGhpcy5uYW1lLm5hbWUgKyBcIjogdHJ1ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChJU19EQVRBX0FUVFJJQlVURS50ZXN0KHRoaXMubmFtZS5uYW1lKSkge1xuICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMubmFtZS5zdGFydCwgdGhpcy5uYW1lLmVuZCwgXCInXCIgKyB0aGlzLm5hbWUubmFtZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE5vZGUucHJvdG90eXBlLnRyYW5zcGlsZS5jYWxsKHRoaXMsIGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEpTWEF0dHJpYnV0ZTtcbiAgICB9KE5vZGUpO1xuXG4gICAgZnVuY3Rpb24gY29udGFpbnNOZXdMaW5lKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdMaXRlcmFsJyAmJiAhL1xcUy8udGVzdChub2RlLnZhbHVlKSAmJiAvXFxuLy50ZXN0KG5vZGUudmFsdWUpO1xuICAgIH1cblxuICAgIHZhciBKU1hDbG9zaW5nRWxlbWVudCA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBKU1hDbG9zaW5nRWxlbWVudCgpIHtcbiAgICAgICAgTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTm9kZSkgSlNYQ2xvc2luZ0VsZW1lbnQuX19wcm90b19fID0gTm9kZTtcbiAgICAgIEpTWENsb3NpbmdFbGVtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBKU1hDbG9zaW5nRWxlbWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKU1hDbG9zaW5nRWxlbWVudDtcblxuICAgICAgSlNYQ2xvc2luZ0VsZW1lbnQucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlKSB7XG4gICAgICAgIHZhciBzcGFjZUJlZm9yZVBhcmVuID0gdHJ1ZTtcblxuICAgICAgICB2YXIgbGFzdENoaWxkID0gdGhpcy5wYXJlbnQuY2hpbGRyZW5bdGhpcy5wYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgLy8gb21pdCBzcGFjZSBiZWZvcmUgY2xvc2luZyBwYXJlbiBpZlxuICAgICAgICAvLyAgIGEpIHRoaXMgaXMgb24gYSBzZXBhcmF0ZSBsaW5lLCBvclxuICAgICAgICAvLyAgIGIpIHRoZXJlIGFyZSBubyBjaGlsZHJlbiBidXQgdGhlcmUgYXJlIGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKGxhc3RDaGlsZCAmJiBjb250YWluc05ld0xpbmUobGFzdENoaWxkKSB8fCB0aGlzLnBhcmVudC5vcGVuaW5nRWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNwYWNlQmVmb3JlUGFyZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCBzcGFjZUJlZm9yZVBhcmVuID8gJyApJyA6ICcpJyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gSlNYQ2xvc2luZ0VsZW1lbnQ7XG4gICAgfShOb2RlKTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZShzdHIsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSkge1xuICAgICAgaWYgKHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSAmJiAvXFxuLy50ZXN0KHN0cikpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgfVxuXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXlxcblxccj9cXHMrLywgJycpIC8vIHJlbW92ZSBsZWFkaW5nIG5ld2xpbmUgKyBzcGFjZVxuICAgICAgLnJlcGxhY2UoL1xccypcXG5cXHI/XFxzKi9nbSwgJyAnKTsgLy8gcmVwbGFjZSBuZXdsaW5lcyB3aXRoIHNwYWNlc1xuXG4gICAgICAvLyBUT0RPIHByZWZlciBzaW5nbGUgcXVvdGVzP1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cik7XG4gICAgfVxuXG4gICAgdmFyIEpTWEVsZW1lbnQgPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gSlNYRWxlbWVudCgpIHtcbiAgICAgICAgTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTm9kZSkgSlNYRWxlbWVudC5fX3Byb3RvX18gPSBOb2RlO1xuICAgICAgSlNYRWxlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgSlNYRWxlbWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKU1hFbGVtZW50O1xuXG4gICAgICBKU1hFbGVtZW50LnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICBOb2RlLnByb3RvdHlwZS50cmFuc3BpbGUuY2FsbCh0aGlzLCBjb2RlLCB0cmFuc2Zvcm1zKTtcblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ0xpdGVyYWwnKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgIC8vIHJlbW92ZSB3aGl0ZXNwYWNlLW9ubHkgbGl0ZXJhbHMsIHVubGVzcyBvbiBhIHNpbmdsZSBsaW5lXG4gICAgICAgICAgcmV0dXJuICgvXFxTLy50ZXN0KGNoaWxkLnZhbHVlKSB8fCAhL1xcbi8udGVzdChjaGlsZC52YWx1ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGMgPSB0aGlzLm9wZW5pbmdFbGVtZW50LmVuZDtcblxuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnSlNYRXhwcmVzc2lvbkNvbnRhaW5lcicgJiYgY2hpbGQuZXhwcmVzc2lvbi50eXBlID09PSAnSlNYRW1wdHlFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAvLyBlbXB0eSBibG9jayBpcyBhIG5vIG9wXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdGFpbCA9IGNvZGUub3JpZ2luYWxbY10gPT09ICdcXG4nICYmIGNoaWxkLnR5cGUgIT09ICdMaXRlcmFsJyA/ICcnIDogJyAnO1xuICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQoYywgXCIsXCIgKyB0YWlsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdMaXRlcmFsJykge1xuICAgICAgICAgICAgICB2YXIgc3RyID0gbm9ybWFsaXNlKGNoaWxkLnZhbHVlLCBpID09PSBjaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUoY2hpbGQuc3RhcnQsIGNoaWxkLmVuZCwgc3RyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYyA9IGNoaWxkLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBKU1hFbGVtZW50O1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgSlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBKU1hFeHByZXNzaW9uQ29udGFpbmVyKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBKU1hFeHByZXNzaW9uQ29udGFpbmVyLl9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBKU1hFeHByZXNzaW9uQ29udGFpbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBKU1hFeHByZXNzaW9uQ29udGFpbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpTWEV4cHJlc3Npb25Db250YWluZXI7XG5cbiAgICAgIEpTWEV4cHJlc3Npb25Db250YWluZXIucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuc3RhcnQsIHRoaXMuZXhwcmVzc2lvbi5zdGFydCk7XG4gICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuZXhwcmVzc2lvbi5lbmQsIHRoaXMuZW5kKTtcblxuICAgICAgICBOb2RlLnByb3RvdHlwZS50cmFuc3BpbGUuY2FsbCh0aGlzLCBjb2RlLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgSlNYT3BlbmluZ0VsZW1lbnQgPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gSlNYT3BlbmluZ0VsZW1lbnQoKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIEpTWE9wZW5pbmdFbGVtZW50Ll9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBKU1hPcGVuaW5nRWxlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgSlNYT3BlbmluZ0VsZW1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSlNYT3BlbmluZ0VsZW1lbnQ7XG5cbiAgICAgIEpTWE9wZW5pbmdFbGVtZW50LnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LCB0aGlzLm5hbWUuc3RhcnQsIHRoaXMucHJvZ3JhbS5qc3ggKyBcIiggXCIpO1xuXG4gICAgICAgIHZhciBodG1sID0gdGhpcy5uYW1lLnR5cGUgPT09ICdKU1hJZGVudGlmaWVyJyAmJiB0aGlzLm5hbWUubmFtZVswXSA9PT0gdGhpcy5uYW1lLm5hbWVbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGh0bWwpIGNvZGUuaW5zZXJ0UmlnaHQodGhpcy5uYW1lLnN0YXJ0LCBcIidcIik7XG5cbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgIHZhciBjID0gdGhpcy5uYW1lLmVuZDtcblxuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICB2YXIgaGFzU3ByZWFkID0gZmFsc2U7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcyQxLmF0dHJpYnV0ZXNbaV0udHlwZSA9PT0gJ0pTWFNwcmVhZEF0dHJpYnV0ZScpIHtcbiAgICAgICAgICAgICAgaGFzU3ByZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYyA9IHRoaXMuYXR0cmlidXRlc1swXS5lbmQ7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBhdHRyID0gdGhpcyQxLmF0dHJpYnV0ZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShjLCBhdHRyLnN0YXJ0LCAnLCAnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc1NwcmVhZCAmJiBhdHRyLnR5cGUgIT09ICdKU1hTcHJlYWRBdHRyaWJ1dGUnKSB7XG4gICAgICAgICAgICAgIHZhciBsYXN0QXR0ciA9IHRoaXMkMS5hdHRyaWJ1dGVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgdmFyIG5leHRBdHRyID0gdGhpcyQxLmF0dHJpYnV0ZXNbaSArIDFdO1xuXG4gICAgICAgICAgICAgIGlmICghbGFzdEF0dHIgfHwgbGFzdEF0dHIudHlwZSA9PT0gJ0pTWFNwcmVhZEF0dHJpYnV0ZScpIHtcbiAgICAgICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KGF0dHIuc3RhcnQsICd7ICcpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFuZXh0QXR0ciB8fCBuZXh0QXR0ci50eXBlID09PSAnSlNYU3ByZWFkQXR0cmlidXRlJykge1xuICAgICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChhdHRyLmVuZCwgJyB9Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYyA9IGF0dHIuZW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhZnRlcjtcbiAgICAgICAgICB2YXIgYmVmb3JlO1xuICAgICAgICAgIGlmIChoYXNTcHJlYWQpIHtcbiAgICAgICAgICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgICAgICAgYmVmb3JlID0gaHRtbCA/IFwiJyxcIiA6ICcsJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5wcm9ncmFtLm9wdGlvbnMub2JqZWN0QXNzaWduKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih0aGlzLCAnTWl4ZWQgSlNYIGF0dHJpYnV0ZXMgZW5kaW5nIGluIHNwcmVhZCByZXF1aXJlcyBzcGVjaWZpZWQgb2JqZWN0QXNzaWduIG9wdGlvbiB3aXRoIFxcJ09iamVjdC5hc3NpZ25cXCcgb3IgcG9seWZpbGwgaGVscGVyLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJlZm9yZSA9IGh0bWwgPyBcIicsIFwiICsgdGhpcy5wcm9ncmFtLm9wdGlvbnMub2JqZWN0QXNzaWduICsgXCIoe30sXCIgOiBcIiwgXCIgKyB0aGlzLnByb2dyYW0ub3B0aW9ucy5vYmplY3RBc3NpZ24gKyBcIih7fSxcIjtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZSA9IGh0bWwgPyBcIicsIHtcIiA6ICcsIHsnO1xuICAgICAgICAgICAgYWZ0ZXIgPSAnIH0nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQodGhpcy5uYW1lLmVuZCwgYmVmb3JlKTtcblxuICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KHRoaXMuYXR0cmlidXRlc1tsZW4gLSAxXS5lbmQsIGFmdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KHRoaXMubmFtZS5lbmQsIGh0bWwgPyBcIicsIG51bGxcIiA6IFwiLCBudWxsXCIpO1xuICAgICAgICAgIGMgPSB0aGlzLm5hbWUuZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgTm9kZS5wcm90b3R5cGUudHJhbnNwaWxlLmNhbGwodGhpcywgY29kZSwgdHJhbnNmb3Jtcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShjLCB0aGlzLmVuZCwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aCA/IFwiKVwiIDogXCIgKVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlLnJlbW92ZShjLCB0aGlzLmVuZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBKU1hPcGVuaW5nRWxlbWVudDtcbiAgICB9KE5vZGUpO1xuXG4gICAgdmFyIEpTWFNwcmVhZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBKU1hTcHJlYWRBdHRyaWJ1dGUoKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIEpTWFNwcmVhZEF0dHJpYnV0ZS5fX3Byb3RvX18gPSBOb2RlO1xuICAgICAgSlNYU3ByZWFkQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBKU1hTcHJlYWRBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSlNYU3ByZWFkQXR0cmlidXRlO1xuXG4gICAgICBKU1hTcHJlYWRBdHRyaWJ1dGUucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuc3RhcnQsIHRoaXMuYXJndW1lbnQuc3RhcnQpO1xuICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLmFyZ3VtZW50LmVuZCwgdGhpcy5lbmQpO1xuXG4gICAgICAgIE5vZGUucHJvdG90eXBlLnRyYW5zcGlsZS5jYWxsKHRoaXMsIGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIEpTWFNwcmVhZEF0dHJpYnV0ZTtcbiAgICB9KE5vZGUpO1xuXG4gICAgdmFyIHJlZ2VuZXJhdGUgPSBfX2NvbW1vbmpzKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMsIGdsb2JhbCkge1xuICAgICAgLyohIGh0dHBzOi8vbXRocy5iZS9yZWdlbmVyYXRlIHYxLjMuMSBieSBAbWF0aGlhcyB8IE1JVCBsaWNlbnNlICovXG4gICAgICAoZnVuY3Rpb24gKHJvb3QpIHtcblxuICAgICAgICAvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgLlxuICAgICAgICB2YXIgZnJlZUV4cG9ydHMgPSAodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGV4cG9ydHMpKSA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG4gICAgICAgIC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLlxuICAgICAgICB2YXIgZnJlZU1vZHVsZSA9ICh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihtb2R1bGUpKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG4gICAgICAgIC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMvaW8uanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG4gICAgICAgIC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgLlxuICAgICAgICB2YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihnbG9iYWwpKSA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gICAgICAgIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuICAgICAgICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgdmFyIEVSUk9SUyA9IHtcbiAgICAgICAgICAncmFuZ2VPcmRlcic6ICdBIHJhbmdlXFx1MjAxOXMgYHN0b3BgIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsICcgKyAndG8gdGhlIGBzdGFydGAgdmFsdWUuJyxcbiAgICAgICAgICAnY29kZVBvaW50UmFuZ2UnOiAnSW52YWxpZCBjb2RlIHBvaW50IHZhbHVlLiBDb2RlIHBvaW50cyByYW5nZSBmcm9tICcgKyAnVSswMDAwMDAgdG8gVSsxMEZGRkYuJ1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1wYWlyc1xuICAgICAgICB2YXIgSElHSF9TVVJST0dBVEVfTUlOID0gMHhEODAwO1xuICAgICAgICB2YXIgSElHSF9TVVJST0dBVEVfTUFYID0gMHhEQkZGO1xuICAgICAgICB2YXIgTE9XX1NVUlJPR0FURV9NSU4gPSAweERDMDA7XG4gICAgICAgIHZhciBMT1dfU1VSUk9HQVRFX01BWCA9IDB4REZGRjtcblxuICAgICAgICAvLyBJbiBSZWdlbmVyYXRlIG91dHB1dCwgYFxcMGAgaXMgbmV2ZXIgcHJlY2VkZWQgYnkgYFxcYCBiZWNhdXNlIHdlIHNvcnQgYnlcbiAgICAgICAgLy8gY29kZSBwb2ludCB2YWx1ZSwgc28gbGV04oCZcyBrZWVwIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHNpbXBsZS5cbiAgICAgICAgdmFyIHJlZ2V4TnVsbCA9IC9cXFxceDAwKFteMDEyMzQ1Njc4OV18JCkvZztcblxuICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goYXJyYXksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0b1N0cmluZyA9IG9iamVjdC50b1N0cmluZztcbiAgICAgICAgdmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpc051bWJlciA9IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCBgbnVtYmVyYCBpcyBhIHBvc2l0aXZlIGludGVnZXIgdGhhdCBgdG9TdHJpbmcoKWBzIG5pY2VseVxuICAgICAgICAvLyAod2hpY2ggaXMgdGhlIGNhc2UgZm9yIGFsbCBjb2RlIHBvaW50IHZhbHVlcykuXG4gICAgICAgIHZhciB6ZXJvZXMgPSAnMDAwMCc7XG4gICAgICAgIHZhciBwYWQgPSBmdW5jdGlvbiBwYWQobnVtYmVyLCB0b3RhbENoYXJhY3RlcnMpIHtcbiAgICAgICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKG51bWJlcik7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGggPCB0b3RhbENoYXJhY3RlcnMgPyAoemVyb2VzICsgc3RyaW5nKS5zbGljZSgtdG90YWxDaGFyYWN0ZXJzKSA6IHN0cmluZztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGV4ID0gZnVuY3Rpb24gaGV4KG51bWJlcikge1xuICAgICAgICAgIHJldHVybiBOdW1iZXIobnVtYmVyKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICB2YXIgZGF0YUZyb21Db2RlUG9pbnRzID0gZnVuY3Rpb24gZGF0YUZyb21Db2RlUG9pbnRzKGNvZGVQb2ludHMpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgdmFyIG1heCA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIHZhciBpc1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgdG1wO1xuICAgICAgICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRtcCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG1wKTtcbiAgICAgICAgICAgICAgcHJldmlvdXMgPSB0bXA7XG4gICAgICAgICAgICAgIGlzU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0bXAgPT0gcHJldmlvdXMgKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9IG1heCkge1xuICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSB0bXA7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNTdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0bXAgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRW5kIHRoZSBwcmV2aW91cyByYW5nZSBhbmQgc3RhcnQgYSBuZXcgb25lLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByZXZpb3VzICsgMSwgdG1wKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IHRtcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU3RhcnQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkYXRhUmVtb3ZlID0gZnVuY3Rpb24gZGF0YVJlbW92ZShkYXRhLCBjb2RlUG9pbnQpIHtcbiAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGRhdGEgcGVyIGAoc3RhcnQsIGVuZClgIHBhaXIuXG4gICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgZW5kID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+PSBzdGFydCAmJiBjb2RlUG9pbnQgPCBlbmQpIHtcbiAgICAgICAgICAgICAgLy8gTW9kaWZ5IHRoaXMgcGFpci5cbiAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA9PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gc3RhcnQgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAvLyBKdXN0IHJlbW92ZSBgc3RhcnRgIGFuZCBgZW5kYC5cbiAgICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGluZGV4LCAyKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBKdXN0IHJlcGxhY2UgYHN0YXJ0YCB3aXRoIGEgbmV3IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSBjb2RlUG9pbnQgKyAxO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA9PSBlbmQgLSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSnVzdCByZXBsYWNlIGBlbmRgIHdpdGggYSBuZXcgdmFsdWUuXG4gICAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDFdID0gY29kZVBvaW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgYFtzdGFydCwgZW5kXWAgd2l0aCBgW3N0YXJ0QSwgZW5kQSwgc3RhcnRCLCBlbmRCXWAuXG4gICAgICAgICAgICAgICAgZGF0YS5zcGxpY2UoaW5kZXgsIDIsIHN0YXJ0LCBjb2RlUG9pbnQsIGNvZGVQb2ludCArIDEsIGVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkYXRhUmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbiBkYXRhUmVtb3ZlUmFuZ2UoZGF0YSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpIHtcbiAgICAgICAgICBpZiAocmFuZ2VFbmQgPCByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihFUlJPUlMucmFuZ2VPcmRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBwZXIgYChzdGFydCwgZW5kKWAgcGFpci5cbiAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgICB2YXIgZW5kO1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgZW5kID0gZGF0YVtpbmRleCArIDFdIC0gMTsgLy8gTm90ZTogdGhlIGAtIDFgIG1ha2VzIGBlbmRgIGluY2x1c2l2ZS5cblxuICAgICAgICAgICAgLy8gRXhpdCBhcyBzb29uIGFzIG5vIG1vcmUgbWF0Y2hpbmcgcGFpcnMgY2FuIGJlIGZvdW5kLlxuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcmFuZ2VFbmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgcmFuZ2UgcGFpciBpcyBlcXVhbCB0bywgb3IgZm9ybXMgYSBzdWJzZXQgb2YsIHRoZSByYW5nZVxuICAgICAgICAgICAgLy8gdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAgICAgIC8vIEUuZy4gd2UgaGF2ZSBgWzAsIDExLCA0MCwgNTFdYCBhbmQgd2FudCB0byByZW1vdmUgMC0xMCDihpIgYFs0MCwgNTFdYC5cbiAgICAgICAgICAgIC8vIEUuZy4gd2UgaGF2ZSBgWzQwLCA1MV1gIGFuZCB3YW50IHRvIHJlbW92ZSAwLTEwMCDihpIgYFtdYC5cbiAgICAgICAgICAgIGlmIChyYW5nZVN0YXJ0IDw9IHN0YXJ0ICYmIHJhbmdlRW5kID49IGVuZCkge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBwYWlyLlxuICAgICAgICAgICAgICBkYXRhLnNwbGljZShpbmRleCwgMik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBib3RoIGByYW5nZVN0YXJ0YCBhbmQgYHJhbmdlRW5kYCBhcmUgd2l0aGluIHRoZSBib3VuZHMgb2ZcbiAgICAgICAgICAgIC8vIHRoaXMgcGFpci5cbiAgICAgICAgICAgIC8vIEUuZy4gd2UgaGF2ZSBgWzAsIDExXWAgYW5kIHdhbnQgdG8gcmVtb3ZlIDQtNiDihpIgYFswLCA0LCA3LCAxMV1gLlxuICAgICAgICAgICAgaWYgKHJhbmdlU3RhcnQgPj0gc3RhcnQgJiYgcmFuZ2VFbmQgPCBlbmQpIHtcbiAgICAgICAgICAgICAgaWYgKHJhbmdlU3RhcnQgPT0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGBbc3RhcnQsIGVuZF1gIHdpdGggYFtzdGFydEIsIGVuZEJdYC5cbiAgICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHJhbmdlRW5kICsgMTtcbiAgICAgICAgICAgICAgICBkYXRhW2luZGV4ICsgMV0gPSBlbmQgKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFJlcGxhY2UgYFtzdGFydCwgZW5kXWAgd2l0aCBgW3N0YXJ0QSwgZW5kQSwgc3RhcnRCLCBlbmRCXWAuXG4gICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGluZGV4LCAyLCBzdGFydCwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQgKyAxLCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIG9ubHkgYHJhbmdlU3RhcnRgIGlzIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoaXMgcGFpci5cbiAgICAgICAgICAgIC8vIEUuZy4gd2UgaGF2ZSBgWzAsIDExXWAgYW5kIHdhbnQgdG8gcmVtb3ZlIDQtMjAg4oaSIGBbMCwgNF1gLlxuICAgICAgICAgICAgaWYgKHJhbmdlU3RhcnQgPj0gc3RhcnQgJiYgcmFuZ2VTdGFydCA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgLy8gUmVwbGFjZSBgZW5kYCB3aXRoIGByYW5nZVN0YXJ0YC5cbiAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDFdID0gcmFuZ2VTdGFydDtcbiAgICAgICAgICAgICAgLy8gTm90ZTogd2UgY2Fubm90IGByZXR1cm5gIGp1c3QgeWV0LCBpbiBjYXNlIGFueSBmb2xsb3dpbmcgcGFpcnMgc3RpbGxcbiAgICAgICAgICAgICAgLy8gY29udGFpbiBtYXRjaGluZyBjb2RlIHBvaW50cy5cbiAgICAgICAgICAgICAgLy8gRS5nLiB3ZSBoYXZlIGBbMCwgMTEsIDE0LCAzMV1gIGFuZCB3YW50IHRvIHJlbW92ZSA0LTIwXG4gICAgICAgICAgICAgIC8vIOKGkiBgWzAsIDQsIDIxLCAzMV1gLlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBvbmx5IGByYW5nZUVuZGAgaXMgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhpcyBwYWlyLlxuICAgICAgICAgICAgLy8gRS5nLiB3ZSBoYXZlIGBbMTQsIDMxXWAgYW5kIHdhbnQgdG8gcmVtb3ZlIDQtMjAg4oaSIGBbMjEsIDMxXWAuXG4gICAgICAgICAgICBlbHNlIGlmIChyYW5nZUVuZCA+PSBzdGFydCAmJiByYW5nZUVuZCA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBKdXN0IHJlcGxhY2UgYHN0YXJ0YC5cbiAgICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHJhbmdlRW5kICsgMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGF0YUFkZCA9IGZ1bmN0aW9uIGRhdGFBZGQoZGF0YSwgY29kZVBvaW50KSB7XG4gICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIHBlciBgKHN0YXJ0LCBlbmQpYCBwYWlyLlxuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICAgIHZhciBlbmQ7XG4gICAgICAgICAgdmFyIGxhc3RJbmRleCA9IG51bGw7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDAgfHwgY29kZVBvaW50ID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoRVJST1JTLmNvZGVQb2ludFJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgZW5kID0gZGF0YVtpbmRleCArIDFdO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29kZSBwb2ludCBpcyBhbHJlYWR5IGluIHRoZSBzZXQuXG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID49IHN0YXJ0ICYmIGNvZGVQb2ludCA8IGVuZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA9PSBzdGFydCAtIDEpIHtcbiAgICAgICAgICAgICAgLy8gSnVzdCByZXBsYWNlIGBzdGFydGAgd2l0aCBhIG5ldyB2YWx1ZS5cbiAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSBjb2RlUG9pbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBpZiBgc3RhcnRgIGlzIGBncmVhdGVyYCB0aGFuIGBjb2RlUG9pbnRgLCBpbnNlcnQgYSBuZXdcbiAgICAgICAgICAgIC8vIGBbc3RhcnQsIGVuZF1gIHBhaXIgYmVmb3JlIHRoZSBjdXJyZW50IHBhaXIsIG9yIGFmdGVyIHRoZSBjdXJyZW50IHBhaXJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEga25vd24gYGxhc3RJbmRleGAuXG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBjb2RlUG9pbnQpIHtcbiAgICAgICAgICAgICAgZGF0YS5zcGxpY2UobGFzdEluZGV4ICE9IG51bGwgPyBsYXN0SW5kZXggKyAyIDogMCwgMCwgY29kZVBvaW50LCBjb2RlUG9pbnQgKyAxKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT0gZW5kKSB7XG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIGFkZGluZyB0aGlzIGNvZGUgcG9pbnQgY2F1c2VzIHR3byBzZXBhcmF0ZSByYW5nZXMgdG8gYmVjb21lXG4gICAgICAgICAgICAgIC8vIGEgc2luZ2xlIHJhbmdlLCBlLmcuIGBkYXRhQWRkKFswLCA0LCA1LCAxMF0sIDQpYCDihpIgYFswLCAxMF1gLlxuICAgICAgICAgICAgICBpZiAoY29kZVBvaW50ICsgMSA9PSBkYXRhW2luZGV4ICsgMl0pIHtcbiAgICAgICAgICAgICAgICBkYXRhLnNwbGljZShpbmRleCwgNCwgc3RhcnQsIGRhdGFbaW5kZXggKyAzXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRWxzZSwganVzdCByZXBsYWNlIGBlbmRgIHdpdGggYSBuZXcgdmFsdWUuXG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IGNvZGVQb2ludCArIDE7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgbG9vcCBoYXMgZmluaXNoZWQ7IGFkZCB0aGUgbmV3IHBhaXIgdG8gdGhlIGVuZCBvZiB0aGUgZGF0YSBzZXQuXG4gICAgICAgICAgZGF0YS5wdXNoKGNvZGVQb2ludCwgY29kZVBvaW50ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRhdGFBZGREYXRhID0gZnVuY3Rpb24gZGF0YUFkZERhdGEoZGF0YUEsIGRhdGFCKSB7XG4gICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIHBlciBgKHN0YXJ0LCBlbmQpYCBwYWlyLlxuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICAgIHZhciBlbmQ7XG4gICAgICAgICAgdmFyIGRhdGEgPSBkYXRhQS5zbGljZSgpO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBkYXRhQi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGFCW2luZGV4XTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGFCW2luZGV4ICsgMV0gLSAxO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZCkge1xuICAgICAgICAgICAgICBkYXRhID0gZGF0YUFkZChkYXRhLCBzdGFydCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhID0gZGF0YUFkZFJhbmdlKGRhdGEsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRhdGFSZW1vdmVEYXRhID0gZnVuY3Rpb24gZGF0YVJlbW92ZURhdGEoZGF0YUEsIGRhdGFCKSB7XG4gICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIHBlciBgKHN0YXJ0LCBlbmQpYCBwYWlyLlxuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICAgIHZhciBlbmQ7XG4gICAgICAgICAgdmFyIGRhdGEgPSBkYXRhQS5zbGljZSgpO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBkYXRhQi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGFCW2luZGV4XTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGFCW2luZGV4ICsgMV0gLSAxO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZCkge1xuICAgICAgICAgICAgICBkYXRhID0gZGF0YVJlbW92ZShkYXRhLCBzdGFydCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhID0gZGF0YVJlbW92ZVJhbmdlKGRhdGEsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRhdGFBZGRSYW5nZSA9IGZ1bmN0aW9uIGRhdGFBZGRSYW5nZShkYXRhLCByYW5nZVN0YXJ0LCByYW5nZUVuZCkge1xuICAgICAgICAgIGlmIChyYW5nZUVuZCA8IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKEVSUk9SUy5yYW5nZU9yZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJhbmdlU3RhcnQgPCAweDAgfHwgcmFuZ2VTdGFydCA+IDB4MTBGRkZGIHx8IHJhbmdlRW5kIDwgMHgwIHx8IHJhbmdlRW5kID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoRVJST1JTLmNvZGVQb2ludFJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIHBlciBgKHN0YXJ0LCBlbmQpYCBwYWlyLlxuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICAgIHZhciBlbmQ7XG4gICAgICAgICAgdmFyIGFkZGVkID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRhW2luZGV4XTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGFbaW5kZXggKyAxXTtcblxuICAgICAgICAgICAgaWYgKGFkZGVkKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSByYW5nZSBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSBzZXQ7IGF0IHRoaXMgcG9pbnQsIHdlIGp1c3RcbiAgICAgICAgICAgICAgLy8gbmVlZCB0byBnZXQgcmlkIG9mIHRoZSBmb2xsb3dpbmcgcmFuZ2VzIGluIGNhc2UgdGhleSBvdmVybGFwLlxuXG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgcmFuZ2UgY2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIHByZXZpb3VzIHJhbmdlLlxuICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gcmFuZ2VFbmQgKyAxKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zcGxpY2UoaW5kZXggLSAxLCAyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEV4aXQgYXMgc29vbiBhcyBubyBtb3JlIHBvc3NpYmx5IG92ZXJsYXBwaW5nIHBhaXJzIGNhbiBiZSBmb3VuZC5cbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcmFuZ2VFbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEUuZy4gYFswLCAxMSwgMTIsIDE2XWAgYW5kIHdl4oCZdmUgYWRkZWQgNS0xNSwgc28gd2Ugbm93IGhhdmVcbiAgICAgICAgICAgICAgLy8gYFswLCAxNiwgMTIsIDE2XWAuIFJlbW92ZSB0aGUgYDEyLDE2YCBwYXJ0LCBhcyBpdCBsaWVzIHdpdGhpbiB0aGVcbiAgICAgICAgICAgICAgLy8gYDAsMTZgIHJhbmdlIHRoYXQgd2FzIHByZXZpb3VzbHkgYWRkZWQuXG4gICAgICAgICAgICAgIGlmIChzdGFydCA+PSByYW5nZVN0YXJ0ICYmIHN0YXJ0IDw9IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gYHN0YXJ0YCBsaWVzIHdpdGhpbiB0aGUgcmFuZ2UgdGhhdCB3YXMgcHJldmlvdXNseSBhZGRlZC5cblxuICAgICAgICAgICAgICAgIGlmIChlbmQgPiByYW5nZVN0YXJ0ICYmIGVuZCAtIDEgPD0gcmFuZ2VFbmQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGBlbmRgIGxpZXMgd2l0aGluIHRoZSByYW5nZSB0aGF0IHdhcyBwcmV2aW91c2x5IGFkZGVkIGFzIHdlbGwsXG4gICAgICAgICAgICAgICAgICAvLyBzbyByZW1vdmUgdGhpcyBwYWlyLlxuICAgICAgICAgICAgICAgICAgZGF0YS5zcGxpY2UoaW5kZXgsIDIpO1xuICAgICAgICAgICAgICAgICAgaW5kZXggLT0gMjtcbiAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHdlIGNhbm5vdCBgcmV0dXJuYCBqdXN0IHlldCwgYXMgdGhlcmUgbWF5IHN0aWxsIGJlIG90aGVyXG4gICAgICAgICAgICAgICAgICAvLyBvdmVybGFwcGluZyBwYWlycy5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gYHN0YXJ0YCBsaWVzIHdpdGhpbiB0aGUgcmFuZ2UgdGhhdCB3YXMgcHJldmlvdXNseSBhZGRlZCwgYnV0XG4gICAgICAgICAgICAgICAgICAvLyBgZW5kYCBkb2VzbuKAmXQuIEUuZy4gYFswLCAxMSwgMTIsIDMxXWAgYW5kIHdl4oCZdmUgYWRkZWQgNS0xNSwgc29cbiAgICAgICAgICAgICAgICAgIC8vIG5vdyB3ZSBoYXZlIGBbMCwgMTYsIDEyLCAzMV1gLiBUaGlzIG11c3QgYmUgd3JpdHRlbiBhcyBgWzAsIDMxXWAuXG4gICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHByZXZpb3VzbHkgYWRkZWQgYGVuZGAgYW5kIHRoZSBjdXJyZW50IGBzdGFydGAuXG4gICAgICAgICAgICAgICAgICBkYXRhLnNwbGljZShpbmRleCAtIDEsIDIpO1xuICAgICAgICAgICAgICAgICAgaW5kZXggLT0gMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB3ZSBjYW5ub3QgcmV0dXJuIHlldC5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydCA9PSByYW5nZUVuZCArIDEpIHtcbiAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSByYW5nZVN0YXJ0O1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYSBuZXcgcGFpciBtdXN0IGJlIGluc2VydGVkICpiZWZvcmUqIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0ID4gcmFuZ2VFbmQpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnNwbGljZShpbmRleCwgMCwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQgKyAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5nZVN0YXJ0ID49IHN0YXJ0ICYmIHJhbmdlU3RhcnQgPCBlbmQgJiYgcmFuZ2VFbmQgKyAxIDw9IGVuZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBuZXcgcmFuZ2UgbGllcyBlbnRpcmVseSB3aXRoaW4gYW4gZXhpc3RpbmcgcmFuZ2UgcGFpci4gTm8gYWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gbmVlZGVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAvLyBFLmcuIGBbMCwgMTFdYCBhbmQgeW91IGFkZCA1LTE1IOKGkiBgWzAsIDE2XWAuXG4gICAgICAgICAgICAgIHJhbmdlU3RhcnQgPj0gc3RhcnQgJiYgcmFuZ2VTdGFydCA8IGVuZCB8fFxuICAgICAgICAgICAgICAvLyBFLmcuIGBbMCwgM11gIGFuZCB5b3UgYWRkIDMtNiDihpIgYFswLCA3XWAuXG4gICAgICAgICAgICAgIGVuZCA9PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBgZW5kYCB3aXRoIHRoZSBuZXcgdmFsdWUuXG4gICAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDFdID0gcmFuZ2VFbmQgKyAxO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmV4dCByYW5nZSBwYWlyIGRvZXNu4oCZdCBvdmVybGFwLCBlLmcuIGBbMCwgMTEsIDEyLCAxNF1gXG4gICAgICAgICAgICAgICAgLy8gYW5kIHlvdSBhZGQgNS0xNSDihpIgYFswLCAxNl1gLCBpLmUuIHJlbW92ZSB0aGUgYDEyLDE0YCBwYXJ0LlxuICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB3ZSBjYW5ub3QgYHJldHVybmAganVzdCB5ZXQuXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2VTdGFydCA8PSBzdGFydCAmJiByYW5nZUVuZCArIDEgPj0gZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG5ldyByYW5nZSBpcyBhIHN1cGVyc2V0IG9mIHRoZSBvbGQgcmFuZ2UuXG4gICAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSByYW5nZVN0YXJ0O1xuICAgICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IHJhbmdlRW5kICsgMTtcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhlIGxvb3AgaGFzIGZpbmlzaGVkIHdpdGhvdXQgZG9pbmcgYW55dGhpbmc7IGFkZCB0aGUgbmV3IHBhaXIgdG8gdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBkYXRhIHNldC5cbiAgICAgICAgICBpZiAoIWFkZGVkKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2gocmFuZ2VTdGFydCwgcmFuZ2VFbmQgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRhdGFDb250YWlucyA9IGZ1bmN0aW9uIGRhdGFDb250YWlucyhkYXRhLCBjb2RlUG9pbnQpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIGBjb2RlUG9pbnRgIGlzIG5vdCB3aXRoaW4gYGRhdGFg4oCZcyBvdmVyYWxsIHJhbmdlLlxuICAgICAgICAgIHZhciBzdGFydCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgIHZhciBlbmQgPSBkYXRhW2xlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsZW5ndGggPj0gMikge1xuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IHN0YXJ0IHx8IGNvZGVQb2ludCA+IGVuZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBwZXIgYChzdGFydCwgZW5kKWAgcGFpci5cbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0YVtpbmRleF07XG4gICAgICAgICAgICBlbmQgPSBkYXRhW2luZGV4ICsgMV07XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID49IHN0YXJ0ICYmIGNvZGVQb2ludCA8IGVuZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGF0YUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGRhdGFJbnRlcnNlY3Rpb24oZGF0YSwgY29kZVBvaW50cykge1xuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICAgICAgICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoZGF0YUNvbnRhaW5zKGRhdGEsIGNvZGVQb2ludCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhRnJvbUNvZGVQb2ludHMocmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGF0YUlzRW1wdHkgPSBmdW5jdGlvbiBkYXRhSXNFbXB0eShkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuICFkYXRhLmxlbmd0aDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGF0YUlzU2luZ2xldG9uID0gZnVuY3Rpb24gZGF0YUlzU2luZ2xldG9uKGRhdGEpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2V0IG9ubHkgcmVwcmVzZW50cyBhIHNpbmdsZSBjb2RlIHBvaW50LlxuICAgICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA9PSAyICYmIGRhdGFbMF0gKyAxID09IGRhdGFbMV07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRhdGFUb0FycmF5ID0gZnVuY3Rpb24gZGF0YVRvQXJyYXkoZGF0YSkge1xuICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBwZXIgYChzdGFydCwgZW5kKWAgcGFpci5cbiAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgICB2YXIgZW5kO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgZW5kID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgKytzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIHZhciBoaWdoU3Vycm9nYXRlID0gZnVuY3Rpb24gaGlnaFN1cnJvZ2F0ZShjb2RlUG9pbnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZmxvb3IoKGNvZGVQb2ludCAtIDB4MTAwMDApIC8gMHg0MDApICsgSElHSF9TVVJST0dBVEVfTUlOLCAxMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxvd1N1cnJvZ2F0ZSA9IGZ1bmN0aW9uIGxvd1N1cnJvZ2F0ZShjb2RlUG9pbnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoKGNvZGVQb2ludCAtIDB4MTAwMDApICUgMHg0MDAgKyBMT1dfU1VSUk9HQVRFX01JTiwgMTApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgICAgICB2YXIgY29kZVBvaW50VG9TdHJpbmcgPSBmdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyhjb2RlUG9pbnQpIHtcbiAgICAgICAgICB2YXIgc3RyaW5nO1xuICAgICAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVzY2FwZXMjc2luZ2xlXG4gICAgICAgICAgLy8gTm90ZTogdGhlIGBcXGJgIGVzY2FwZSBzZXF1ZW5jZSBmb3IgVSswMDA4IEJBQ0tTUEFDRSBpbiBzdHJpbmdzIGhhcyBhXG4gICAgICAgICAgLy8gZGlmZmVyZW50IG1lYW5pbmcgaW4gcmVndWxhciBleHByZXNzaW9ucyAod29yZCBib3VuZGFyeSksIHNvIGl0IGNhbm5vdFxuICAgICAgICAgIC8vIGJlIHVzZWQgaGVyZS5cbiAgICAgICAgICBpZiAoY29kZVBvaW50ID09IDB4MDkpIHtcbiAgICAgICAgICAgIHN0cmluZyA9ICdcXFxcdCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdGU6IElFIDwgOSB0cmVhdHMgYCdcXHYnYCBhcyBgJ3YnYCwgc28gYXZvaWQgdXNpbmcgaXQuXG4gICAgICAgICAgLy8gZWxzZSBpZiAoY29kZVBvaW50ID09IDB4MEIpIHtcbiAgICAgICAgICAvLyBcdHN0cmluZyA9ICdcXFxcdic7XG4gICAgICAgICAgLy8gfVxuICAgICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA9PSAweDBBKSB7XG4gICAgICAgICAgICAgIHN0cmluZyA9ICdcXFxcbic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA9PSAweDBDKSB7XG4gICAgICAgICAgICAgIHN0cmluZyA9ICdcXFxcZic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA9PSAweDBEKSB7XG4gICAgICAgICAgICAgIHN0cmluZyA9ICdcXFxccic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA9PSAweDVDKSB7XG4gICAgICAgICAgICAgIHN0cmluZyA9ICdcXFxcXFxcXCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA9PSAweDI0IHx8IGNvZGVQb2ludCA+PSAweDI4ICYmIGNvZGVQb2ludCA8PSAweDJCIHx8IGNvZGVQb2ludCA9PSAweDJEIHx8IGNvZGVQb2ludCA9PSAweDJFIHx8IGNvZGVQb2ludCA9PSAweDNGIHx8IGNvZGVQb2ludCA+PSAweDVCICYmIGNvZGVQb2ludCA8PSAweDVFIHx8IGNvZGVQb2ludCA+PSAweDdCICYmIGNvZGVQb2ludCA8PSAweDdEKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSBjb2RlIHBvaW50IG1hcHMgdG8gYW4gdW5zYWZlIHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXI7XG4gICAgICAgICAgICAgIC8vIGJhY2tzbGFzaC1lc2NhcGUgaXQuIEhlcmXigJlzIHRoZSBsaXN0IG9mIHRob3NlIHN5bWJvbHM6XG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vICAgICAkKCkqKy0uP1tcXF1ee3x9XG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIFNlZSAjNyBmb3IgbW9yZSBpbmZvLlxuICAgICAgICAgICAgICBzdHJpbmcgPSAnXFxcXCcgKyBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID49IDB4MjAgJiYgY29kZVBvaW50IDw9IDB4N0UpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIGNvZGUgcG9pbnQgbWFwcyB0byBvbmUgb2YgdGhlc2UgcHJpbnRhYmxlIEFTQ0lJIHN5bWJvbHNcbiAgICAgICAgICAgICAgLy8gKGluY2x1ZGluZyB0aGUgc3BhY2UgY2hhcmFjdGVyKTpcbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gICAgICAhXCIjJSYnLC8wMTIzNDU2Nzg5Ojs8PT5AQUJDREVGR0hJSktMTU5PXG4gICAgICAgICAgICAgIC8vICAgICBQUVJTVFVWV1hZWl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp+XG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIFRoZXNlIGNhbiBzYWZlbHkgYmUgdXNlZCBkaXJlY3RseS5cbiAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweEZGKSB7XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVzY2FwZXMjaGV4YWRlY2ltYWxcbiAgICAgICAgICAgICAgc3RyaW5nID0gJ1xcXFx4JyArIHBhZChoZXgoY29kZVBvaW50KSwgMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBgY29kZVBvaW50IDw9IDB4RkZGRmAgaG9sZHMgdHJ1ZS5cbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZXNjYXBlcyN1bmljb2RlXG4gICAgICAgICAgICAgIHN0cmluZyA9ICdcXFxcdScgKyBwYWQoaGV4KGNvZGVQb2ludCksIDQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhlcmXigJlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgYXN0cmFsIHN5bWJvbHMgLyBzdXJyb2dhdGUgcGFpcnMgaGVyZSxcbiAgICAgICAgICAvLyBzaW5jZSBgY29kZVBvaW50VG9TdHJpbmdgIGlzIHByaXZhdGUgYW5kIG9ubHkgdXNlZCBmb3IgQk1QIGNvZGUgcG9pbnRzLlxuICAgICAgICAgIC8vIEJ1dCBpZiB0aGF04oCZcyB3aGF0IHlvdSBuZWVkLCBqdXN0IGFkZCBhbiBgZWxzZWAgYmxvY2sgd2l0aCB0aGlzIGNvZGU6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAgc3RyaW5nID0gJ1xcXFx1JyArIHBhZChoZXgoaGlnaFN1cnJvZ2F0ZShjb2RlUG9pbnQpKSwgNClcbiAgICAgICAgICAvLyAgICAgXHQrICdcXFxcdScgKyBwYWQoaGV4KGxvd1N1cnJvZ2F0ZShjb2RlUG9pbnQpKSwgNCk7XG5cbiAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjb2RlUG9pbnRUb1N0cmluZ1VuaWNvZGUgPSBmdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZ1VuaWNvZGUoY29kZVBvaW50KSB7XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnRUb1N0cmluZyhjb2RlUG9pbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJ1xcXFx1eycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnfSc7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN5bWJvbFRvQ29kZVBvaW50ID0gZnVuY3Rpb24gc3ltYm9sVG9Db2RlUG9pbnQoc3ltYm9sKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IHN5bWJvbC5sZW5ndGg7XG4gICAgICAgICAgdmFyIGZpcnN0ID0gc3ltYm9sLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgdmFyIHNlY29uZDtcbiAgICAgICAgICBpZiAoZmlyc3QgPj0gSElHSF9TVVJST0dBVEVfTUlOICYmIGZpcnN0IDw9IEhJR0hfU1VSUk9HQVRFX01BWCAmJiBsZW5ndGggPiAxIC8vIFRoZXJlIGlzIGEgbmV4dCBjb2RlIHVuaXQuXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIGBmaXJzdGAgaXMgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuIEFzc3VtZVxuICAgICAgICAgICAgICAvLyBpdOKAmXMgYSBsb3cgc3Vycm9nYXRlIChlbHNlIGl04oCZcyBpbnZhbGlkIHVzYWdlIG9mIFJlZ2VuZXJhdGUgYW55d2F5KS5cbiAgICAgICAgICAgICAgc2Vjb25kID0gc3ltYm9sLmNoYXJDb2RlQXQoMSk7XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICAgICAgICByZXR1cm4gKGZpcnN0IC0gSElHSF9TVVJST0dBVEVfTUlOKSAqIDB4NDAwICsgc2Vjb25kIC0gTE9XX1NVUlJPR0FURV9NSU4gKyAweDEwMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY3JlYXRlQk1QQ2hhcmFjdGVyQ2xhc3NlcyA9IGZ1bmN0aW9uIGNyZWF0ZUJNUENoYXJhY3RlckNsYXNzZXMoZGF0YSkge1xuICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBwZXIgYChzdGFydCwgZW5kKWAgcGFpci5cbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGRhdGFJc1NpbmdsZXRvbihkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nKGRhdGFbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0YVtpbmRleF07XG4gICAgICAgICAgICBlbmQgPSBkYXRhW2luZGV4ICsgMV0gLSAxOyAvLyBOb3RlOiB0aGUgYC0gMWAgbWFrZXMgYGVuZGAgaW5jbHVzaXZlLlxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZCkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydCArIDEgPT0gZW5kKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGFydCkgKyBjb2RlUG9pbnRUb1N0cmluZyhlbmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXJ0KSArICctJyArIGNvZGVQb2ludFRvU3RyaW5nKGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJ1snICsgcmVzdWx0ICsgJ10nO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjcmVhdGVVbmljb2RlQ2hhcmFjdGVyQ2xhc3NlcyA9IGZ1bmN0aW9uIGNyZWF0ZVVuaWNvZGVDaGFyYWN0ZXJDbGFzc2VzKGRhdGEpIHtcbiAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGRhdGEgcGVyIGAoc3RhcnQsIGVuZClgIHBhaXIuXG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICAgIHZhciBlbmQ7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgIGlmIChkYXRhSXNTaW5nbGV0b24oZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnRUb1N0cmluZ1VuaWNvZGUoZGF0YVswXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRhW2luZGV4XTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGFbaW5kZXggKyAxXSAtIDE7IC8vIE5vdGU6IHRoZSBgLSAxYCBtYWtlcyBgZW5kYCBpbmNsdXNpdmUuXG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBjb2RlUG9pbnRUb1N0cmluZ1VuaWNvZGUoc3RhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydCArIDEgPT0gZW5kKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBjb2RlUG9pbnRUb1N0cmluZ1VuaWNvZGUoc3RhcnQpICsgY29kZVBvaW50VG9TdHJpbmdVbmljb2RlKGVuZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gY29kZVBvaW50VG9TdHJpbmdVbmljb2RlKHN0YXJ0KSArICctJyArIGNvZGVQb2ludFRvU3RyaW5nVW5pY29kZShlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICdbJyArIHJlc3VsdCArICddJztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3BsaXRBdEJNUCA9IGZ1bmN0aW9uIHNwbGl0QXRCTVAoZGF0YSkge1xuICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBwZXIgYChzdGFydCwgZW5kKWAgcGFpci5cbiAgICAgICAgICB2YXIgbG9uZUhpZ2hTdXJyb2dhdGVzID0gW107XG4gICAgICAgICAgdmFyIGxvbmVMb3dTdXJyb2dhdGVzID0gW107XG4gICAgICAgICAgdmFyIGJtcCA9IFtdO1xuICAgICAgICAgIHZhciBhc3RyYWwgPSBbXTtcbiAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgICB2YXIgZW5kO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0YVtpbmRleF07XG4gICAgICAgICAgICBlbmQgPSBkYXRhW2luZGV4ICsgMV0gLSAxOyAvLyBOb3RlOiB0aGUgYC0gMWAgbWFrZXMgYGVuZGAgaW5jbHVzaXZlLlxuXG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBISUdIX1NVUlJPR0FURV9NSU4pIHtcblxuICAgICAgICAgICAgICAvLyBUaGUgcmFuZ2Ugc3RhcnRzIGFuZCBlbmRzIGJlZm9yZSB0aGUgaGlnaCBzdXJyb2dhdGUgcmFuZ2UuXG4gICAgICAgICAgICAgIC8vIEUuZy4gKDAsIDB4MTApLlxuICAgICAgICAgICAgICBpZiAoZW5kIDwgSElHSF9TVVJST0dBVEVfTUlOKSB7XG4gICAgICAgICAgICAgICAgYm1wLnB1c2goc3RhcnQsIGVuZCArIDEpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gVGhlIHJhbmdlIHN0YXJ0cyBiZWZvcmUgdGhlIGhpZ2ggc3Vycm9nYXRlIHJhbmdlIGFuZCBlbmRzIHdpdGhpbiBpdC5cbiAgICAgICAgICAgICAgLy8gRS5nLiAoMCwgMHhEODU1KS5cbiAgICAgICAgICAgICAgaWYgKGVuZCA+PSBISUdIX1NVUlJPR0FURV9NSU4gJiYgZW5kIDw9IEhJR0hfU1VSUk9HQVRFX01BWCkge1xuICAgICAgICAgICAgICAgIGJtcC5wdXNoKHN0YXJ0LCBISUdIX1NVUlJPR0FURV9NSU4pO1xuICAgICAgICAgICAgICAgIGxvbmVIaWdoU3Vycm9nYXRlcy5wdXNoKEhJR0hfU1VSUk9HQVRFX01JTiwgZW5kICsgMSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBUaGUgcmFuZ2Ugc3RhcnRzIGJlZm9yZSB0aGUgaGlnaCBzdXJyb2dhdGUgcmFuZ2UgYW5kIGVuZHMgaW4gdGhlIGxvd1xuICAgICAgICAgICAgICAvLyBzdXJyb2dhdGUgcmFuZ2UuIEUuZy4gKDAsIDB4RENGRikuXG4gICAgICAgICAgICAgIGlmIChlbmQgPj0gTE9XX1NVUlJPR0FURV9NSU4gJiYgZW5kIDw9IExPV19TVVJST0dBVEVfTUFYKSB7XG4gICAgICAgICAgICAgICAgYm1wLnB1c2goc3RhcnQsIEhJR0hfU1VSUk9HQVRFX01JTik7XG4gICAgICAgICAgICAgICAgbG9uZUhpZ2hTdXJyb2dhdGVzLnB1c2goSElHSF9TVVJST0dBVEVfTUlOLCBISUdIX1NVUlJPR0FURV9NQVggKyAxKTtcbiAgICAgICAgICAgICAgICBsb25lTG93U3Vycm9nYXRlcy5wdXNoKExPV19TVVJST0dBVEVfTUlOLCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFRoZSByYW5nZSBzdGFydHMgYmVmb3JlIHRoZSBoaWdoIHN1cnJvZ2F0ZSByYW5nZSBhbmQgZW5kcyBhZnRlciB0aGVcbiAgICAgICAgICAgICAgLy8gbG93IHN1cnJvZ2F0ZSByYW5nZS4gRS5nLiAoMCwgMHgxMEZGRkYpLlxuICAgICAgICAgICAgICBpZiAoZW5kID4gTE9XX1NVUlJPR0FURV9NQVgpIHtcbiAgICAgICAgICAgICAgICBibXAucHVzaChzdGFydCwgSElHSF9TVVJST0dBVEVfTUlOKTtcbiAgICAgICAgICAgICAgICBsb25lSGlnaFN1cnJvZ2F0ZXMucHVzaChISUdIX1NVUlJPR0FURV9NSU4sIEhJR0hfU1VSUk9HQVRFX01BWCArIDEpO1xuICAgICAgICAgICAgICAgIGxvbmVMb3dTdXJyb2dhdGVzLnB1c2goTE9XX1NVUlJPR0FURV9NSU4sIExPV19TVVJST0dBVEVfTUFYICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgIGJtcC5wdXNoKExPV19TVVJST0dBVEVfTUFYICsgMSwgZW5kICsgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGJtcC5wdXNoKExPV19TVVJST0dBVEVfTUFYICsgMSwgMHhGRkZGICsgMSk7XG4gICAgICAgICAgICAgICAgICBhc3RyYWwucHVzaCgweEZGRkYgKyAxLCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPj0gSElHSF9TVVJST0dBVEVfTUlOICYmIHN0YXJ0IDw9IEhJR0hfU1VSUk9HQVRFX01BWCkge1xuXG4gICAgICAgICAgICAgIC8vIFRoZSByYW5nZSBzdGFydHMgYW5kIGVuZHMgaW4gdGhlIGhpZ2ggc3Vycm9nYXRlIHJhbmdlLlxuICAgICAgICAgICAgICAvLyBFLmcuICgweEQ4NTUsIDB4RDg2NikuXG4gICAgICAgICAgICAgIGlmIChlbmQgPj0gSElHSF9TVVJST0dBVEVfTUlOICYmIGVuZCA8PSBISUdIX1NVUlJPR0FURV9NQVgpIHtcbiAgICAgICAgICAgICAgICBsb25lSGlnaFN1cnJvZ2F0ZXMucHVzaChzdGFydCwgZW5kICsgMSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBUaGUgcmFuZ2Ugc3RhcnRzIGluIHRoZSBoaWdoIHN1cnJvZ2F0ZSByYW5nZSBhbmQgZW5kcyBpbiB0aGUgbG93XG4gICAgICAgICAgICAgIC8vIHN1cnJvZ2F0ZSByYW5nZS4gRS5nLiAoMHhEODU1LCAweERDRkYpLlxuICAgICAgICAgICAgICBpZiAoZW5kID49IExPV19TVVJST0dBVEVfTUlOICYmIGVuZCA8PSBMT1dfU1VSUk9HQVRFX01BWCkge1xuICAgICAgICAgICAgICAgIGxvbmVIaWdoU3Vycm9nYXRlcy5wdXNoKHN0YXJ0LCBISUdIX1NVUlJPR0FURV9NQVggKyAxKTtcbiAgICAgICAgICAgICAgICBsb25lTG93U3Vycm9nYXRlcy5wdXNoKExPV19TVVJST0dBVEVfTUlOLCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFRoZSByYW5nZSBzdGFydHMgaW4gdGhlIGhpZ2ggc3Vycm9nYXRlIHJhbmdlIGFuZCBlbmRzIGFmdGVyIHRoZSBsb3dcbiAgICAgICAgICAgICAgLy8gc3Vycm9nYXRlIHJhbmdlLiBFLmcuICgweEQ4NTUsIDB4MTBGRkZGKS5cbiAgICAgICAgICAgICAgaWYgKGVuZCA+IExPV19TVVJST0dBVEVfTUFYKSB7XG4gICAgICAgICAgICAgICAgbG9uZUhpZ2hTdXJyb2dhdGVzLnB1c2goc3RhcnQsIEhJR0hfU1VSUk9HQVRFX01BWCArIDEpO1xuICAgICAgICAgICAgICAgIGxvbmVMb3dTdXJyb2dhdGVzLnB1c2goTE9XX1NVUlJPR0FURV9NSU4sIExPV19TVVJST0dBVEVfTUFYICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgIGJtcC5wdXNoKExPV19TVVJST0dBVEVfTUFYICsgMSwgZW5kICsgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGJtcC5wdXNoKExPV19TVVJST0dBVEVfTUFYICsgMSwgMHhGRkZGICsgMSk7XG4gICAgICAgICAgICAgICAgICBhc3RyYWwucHVzaCgweEZGRkYgKyAxLCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPj0gTE9XX1NVUlJPR0FURV9NSU4gJiYgc3RhcnQgPD0gTE9XX1NVUlJPR0FURV9NQVgpIHtcblxuICAgICAgICAgICAgICAvLyBUaGUgcmFuZ2Ugc3RhcnRzIGFuZCBlbmRzIGluIHRoZSBsb3cgc3Vycm9nYXRlIHJhbmdlLlxuICAgICAgICAgICAgICAvLyBFLmcuICgweERDRkYsIDB4RERGRikuXG4gICAgICAgICAgICAgIGlmIChlbmQgPj0gTE9XX1NVUlJPR0FURV9NSU4gJiYgZW5kIDw9IExPV19TVVJST0dBVEVfTUFYKSB7XG4gICAgICAgICAgICAgICAgbG9uZUxvd1N1cnJvZ2F0ZXMucHVzaChzdGFydCwgZW5kICsgMSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBUaGUgcmFuZ2Ugc3RhcnRzIGluIHRoZSBsb3cgc3Vycm9nYXRlIHJhbmdlIGFuZCBlbmRzIGFmdGVyIHRoZSBsb3dcbiAgICAgICAgICAgICAgLy8gc3Vycm9nYXRlIHJhbmdlLiBFLmcuICgweERDRkYsIDB4MTBGRkZGKS5cbiAgICAgICAgICAgICAgaWYgKGVuZCA+IExPV19TVVJST0dBVEVfTUFYKSB7XG4gICAgICAgICAgICAgICAgbG9uZUxvd1N1cnJvZ2F0ZXMucHVzaChzdGFydCwgTE9XX1NVUlJPR0FURV9NQVggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kIDw9IDB4RkZGRikge1xuICAgICAgICAgICAgICAgICAgYm1wLnB1c2goTE9XX1NVUlJPR0FURV9NQVggKyAxLCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYm1wLnB1c2goTE9XX1NVUlJPR0FURV9NQVggKyAxLCAweEZGRkYgKyAxKTtcbiAgICAgICAgICAgICAgICAgIGFzdHJhbC5wdXNoKDB4RkZGRiArIDEsIGVuZCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydCA+IExPV19TVVJST0dBVEVfTUFYICYmIHN0YXJ0IDw9IDB4RkZGRikge1xuXG4gICAgICAgICAgICAgIC8vIFRoZSByYW5nZSBzdGFydHMgYW5kIGVuZHMgYWZ0ZXIgdGhlIGxvdyBzdXJyb2dhdGUgcmFuZ2UuXG4gICAgICAgICAgICAgIC8vIEUuZy4gKDB4RkZBQSwgMHgxMEZGRkYpLlxuICAgICAgICAgICAgICBpZiAoZW5kIDw9IDB4RkZGRikge1xuICAgICAgICAgICAgICAgIGJtcC5wdXNoKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBibXAucHVzaChzdGFydCwgMHhGRkZGICsgMSk7XG4gICAgICAgICAgICAgICAgYXN0cmFsLnB1c2goMHhGRkZGICsgMSwgZW5kICsgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgLy8gVGhlIHJhbmdlIHN0YXJ0cyBhbmQgZW5kcyBpbiB0aGUgYXN0cmFsIHJhbmdlLlxuICAgICAgICAgICAgICBhc3RyYWwucHVzaChzdGFydCwgZW5kICsgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnbG9uZUhpZ2hTdXJyb2dhdGVzJzogbG9uZUhpZ2hTdXJyb2dhdGVzLFxuICAgICAgICAgICAgJ2xvbmVMb3dTdXJyb2dhdGVzJzogbG9uZUxvd1N1cnJvZ2F0ZXMsXG4gICAgICAgICAgICAnYm1wJzogYm1wLFxuICAgICAgICAgICAgJ2FzdHJhbCc6IGFzdHJhbFxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9wdGltaXplU3Vycm9nYXRlTWFwcGluZ3MgPSBmdW5jdGlvbiBvcHRpbWl6ZVN1cnJvZ2F0ZU1hcHBpbmdzKHN1cnJvZ2F0ZU1hcHBpbmdzKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIHZhciB0bXBMb3cgPSBbXTtcbiAgICAgICAgICB2YXIgYWRkTG93ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG1hcHBpbmc7XG4gICAgICAgICAgdmFyIG5leHRNYXBwaW5nO1xuICAgICAgICAgIHZhciBoaWdoU3Vycm9nYXRlcztcbiAgICAgICAgICB2YXIgbG93U3Vycm9nYXRlcztcbiAgICAgICAgICB2YXIgbmV4dEhpZ2hTdXJyb2dhdGVzO1xuICAgICAgICAgIHZhciBuZXh0TG93U3Vycm9nYXRlcztcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gc3Vycm9nYXRlTWFwcGluZ3MubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBtYXBwaW5nID0gc3Vycm9nYXRlTWFwcGluZ3NbaW5kZXhdO1xuICAgICAgICAgICAgbmV4dE1hcHBpbmcgPSBzdXJyb2dhdGVNYXBwaW5nc1tpbmRleCArIDFdO1xuICAgICAgICAgICAgaWYgKCFuZXh0TWFwcGluZykge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoaWdoU3Vycm9nYXRlcyA9IG1hcHBpbmdbMF07XG4gICAgICAgICAgICBsb3dTdXJyb2dhdGVzID0gbWFwcGluZ1sxXTtcbiAgICAgICAgICAgIG5leHRIaWdoU3Vycm9nYXRlcyA9IG5leHRNYXBwaW5nWzBdO1xuICAgICAgICAgICAgbmV4dExvd1N1cnJvZ2F0ZXMgPSBuZXh0TWFwcGluZ1sxXTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGlkZW50aWNhbCBoaWdoIHN1cnJvZ2F0ZSByYW5nZXMuXG4gICAgICAgICAgICB0bXBMb3cgPSBsb3dTdXJyb2dhdGVzO1xuICAgICAgICAgICAgd2hpbGUgKG5leHRIaWdoU3Vycm9nYXRlcyAmJiBoaWdoU3Vycm9nYXRlc1swXSA9PSBuZXh0SGlnaFN1cnJvZ2F0ZXNbMF0gJiYgaGlnaFN1cnJvZ2F0ZXNbMV0gPT0gbmV4dEhpZ2hTdXJyb2dhdGVzWzFdKSB7XG4gICAgICAgICAgICAgIC8vIE1lcmdlIHdpdGggdGhlIG5leHQgaXRlbS5cbiAgICAgICAgICAgICAgaWYgKGRhdGFJc1NpbmdsZXRvbihuZXh0TG93U3Vycm9nYXRlcykpIHtcbiAgICAgICAgICAgICAgICB0bXBMb3cgPSBkYXRhQWRkKHRtcExvdywgbmV4dExvd1N1cnJvZ2F0ZXNbMF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRtcExvdyA9IGRhdGFBZGRSYW5nZSh0bXBMb3csIG5leHRMb3dTdXJyb2dhdGVzWzBdLCBuZXh0TG93U3Vycm9nYXRlc1sxXSAtIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIG1hcHBpbmcgPSBzdXJyb2dhdGVNYXBwaW5nc1tpbmRleF07XG4gICAgICAgICAgICAgIGhpZ2hTdXJyb2dhdGVzID0gbWFwcGluZ1swXTtcbiAgICAgICAgICAgICAgbG93U3Vycm9nYXRlcyA9IG1hcHBpbmdbMV07XG4gICAgICAgICAgICAgIG5leHRNYXBwaW5nID0gc3Vycm9nYXRlTWFwcGluZ3NbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgbmV4dEhpZ2hTdXJyb2dhdGVzID0gbmV4dE1hcHBpbmcgJiYgbmV4dE1hcHBpbmdbMF07XG4gICAgICAgICAgICAgIG5leHRMb3dTdXJyb2dhdGVzID0gbmV4dE1hcHBpbmcgJiYgbmV4dE1hcHBpbmdbMV07XG4gICAgICAgICAgICAgIGFkZExvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChbaGlnaFN1cnJvZ2F0ZXMsIGFkZExvdyA/IHRtcExvdyA6IGxvd1N1cnJvZ2F0ZXNdKTtcbiAgICAgICAgICAgIGFkZExvdyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3B0aW1pemVCeUxvd1N1cnJvZ2F0ZXMocmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb3B0aW1pemVCeUxvd1N1cnJvZ2F0ZXMgPSBmdW5jdGlvbiBvcHRpbWl6ZUJ5TG93U3Vycm9nYXRlcyhzdXJyb2dhdGVNYXBwaW5ncykge1xuICAgICAgICAgIGlmIChzdXJyb2dhdGVNYXBwaW5ncy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cnJvZ2F0ZU1hcHBpbmdzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICB2YXIgaW5uZXJJbmRleCA9IC0xO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3Vycm9nYXRlTWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbWFwcGluZyA9IHN1cnJvZ2F0ZU1hcHBpbmdzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBsb3dTdXJyb2dhdGVzID0gbWFwcGluZ1sxXTtcbiAgICAgICAgICAgIHZhciBsb3dTdXJyb2dhdGVTdGFydCA9IGxvd1N1cnJvZ2F0ZXNbMF07XG4gICAgICAgICAgICB2YXIgbG93U3Vycm9nYXRlRW5kID0gbG93U3Vycm9nYXRlc1sxXTtcbiAgICAgICAgICAgIGlubmVySW5kZXggPSBpbmRleDsgLy8gTm90ZTogdGhlIGxvb3Agc3RhcnRzIGF0IHRoZSBuZXh0IGluZGV4LlxuICAgICAgICAgICAgd2hpbGUgKCsraW5uZXJJbmRleCA8IHN1cnJvZ2F0ZU1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgb3RoZXJNYXBwaW5nID0gc3Vycm9nYXRlTWFwcGluZ3NbaW5uZXJJbmRleF07XG4gICAgICAgICAgICAgIHZhciBvdGhlckxvd1N1cnJvZ2F0ZXMgPSBvdGhlck1hcHBpbmdbMV07XG4gICAgICAgICAgICAgIHZhciBvdGhlckxvd1N1cnJvZ2F0ZVN0YXJ0ID0gb3RoZXJMb3dTdXJyb2dhdGVzWzBdO1xuICAgICAgICAgICAgICB2YXIgb3RoZXJMb3dTdXJyb2dhdGVFbmQgPSBvdGhlckxvd1N1cnJvZ2F0ZXNbMV07XG4gICAgICAgICAgICAgIGlmIChsb3dTdXJyb2dhdGVTdGFydCA9PSBvdGhlckxvd1N1cnJvZ2F0ZVN0YXJ0ICYmIGxvd1N1cnJvZ2F0ZUVuZCA9PSBvdGhlckxvd1N1cnJvZ2F0ZUVuZCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29kZSBwb2ludHMgaW4gdGhlIG90aGVyIGl0ZW0gdG8gdGhpcyBvbmUuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFJc1NpbmdsZXRvbihvdGhlck1hcHBpbmdbMF0pKSB7XG4gICAgICAgICAgICAgICAgICBtYXBwaW5nWzBdID0gZGF0YUFkZChtYXBwaW5nWzBdLCBvdGhlck1hcHBpbmdbMF1bMF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtYXBwaW5nWzBdID0gZGF0YUFkZFJhbmdlKG1hcHBpbmdbMF0sIG90aGVyTWFwcGluZ1swXVswXSwgb3RoZXJNYXBwaW5nWzBdWzFdIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb3RoZXIsIG5vdyByZWR1bmRhbnQsIGl0ZW0uXG4gICAgICAgICAgICAgICAgc3Vycm9nYXRlTWFwcGluZ3Muc3BsaWNlKGlubmVySW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIC0taW5uZXJJbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3Vycm9nYXRlTWFwcGluZ3M7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN1cnJvZ2F0ZVNldCA9IGZ1bmN0aW9uIHN1cnJvZ2F0ZVNldChkYXRhKSB7XG4gICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiBgZGF0YWAgaXMgYW4gZW1wdHkgc2V0LlxuICAgICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGRhdGEgcGVyIGAoc3RhcnQsIGVuZClgIHBhaXIuXG4gICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgICB2YXIgc3RhcnRIaWdoO1xuICAgICAgICAgIHZhciBzdGFydExvdztcbiAgICAgICAgICB2YXIgcHJldlN0YXJ0SGlnaCA9IDA7XG4gICAgICAgICAgdmFyIHByZXZFbmRIaWdoID0gMDtcbiAgICAgICAgICB2YXIgdG1wTG93ID0gW107XG4gICAgICAgICAgdmFyIGVuZEhpZ2g7XG4gICAgICAgICAgdmFyIGVuZExvdztcbiAgICAgICAgICB2YXIgc3Vycm9nYXRlTWFwcGluZ3MgPSBbXTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgdmFyIGRhdGFIaWdoID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgZW5kID0gZGF0YVtpbmRleCArIDFdIC0gMTtcblxuICAgICAgICAgICAgc3RhcnRIaWdoID0gaGlnaFN1cnJvZ2F0ZShzdGFydCk7XG4gICAgICAgICAgICBzdGFydExvdyA9IGxvd1N1cnJvZ2F0ZShzdGFydCk7XG4gICAgICAgICAgICBlbmRIaWdoID0gaGlnaFN1cnJvZ2F0ZShlbmQpO1xuICAgICAgICAgICAgZW5kTG93ID0gbG93U3Vycm9nYXRlKGVuZCk7XG5cbiAgICAgICAgICAgIHZhciBzdGFydHNXaXRoTG93ZXN0TG93U3Vycm9nYXRlID0gc3RhcnRMb3cgPT0gTE9XX1NVUlJPR0FURV9NSU47XG4gICAgICAgICAgICB2YXIgZW5kc1dpdGhIaWdoZXN0TG93U3Vycm9nYXRlID0gZW5kTG93ID09IExPV19TVVJST0dBVEVfTUFYO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcHJldmlvdXMgaGlnaC1zdXJyb2dhdGUtdG8tbG93LXN1cnJvZ2F0ZSBtYXBwaW5ncy5cbiAgICAgICAgICAgIC8vIFN0ZXAgMTogYChzdGFydEhpZ2gsIHN0YXJ0TG93KWAgdG8gYChzdGFydEhpZ2gsIExPV19TVVJST0dBVEVfTUFYKWAuXG4gICAgICAgICAgICBpZiAoc3RhcnRIaWdoID09IGVuZEhpZ2ggfHwgc3RhcnRzV2l0aExvd2VzdExvd1N1cnJvZ2F0ZSAmJiBlbmRzV2l0aEhpZ2hlc3RMb3dTdXJyb2dhdGUpIHtcbiAgICAgICAgICAgICAgc3Vycm9nYXRlTWFwcGluZ3MucHVzaChbW3N0YXJ0SGlnaCwgZW5kSGlnaCArIDFdLCBbc3RhcnRMb3csIGVuZExvdyArIDFdXSk7XG4gICAgICAgICAgICAgIGNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1cnJvZ2F0ZU1hcHBpbmdzLnB1c2goW1tzdGFydEhpZ2gsIHN0YXJ0SGlnaCArIDFdLCBbc3RhcnRMb3csIExPV19TVVJST0dBVEVfTUFYICsgMV1dKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RlcCAyOiBgKHN0YXJ0SGlnaCArIDEsIExPV19TVVJST0dBVEVfTUlOKWAgdG9cbiAgICAgICAgICAgIC8vIGAoZW5kSGlnaCAtIDEsIExPV19TVVJST0dBVEVfTUFYKWAuXG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRlICYmIHN0YXJ0SGlnaCArIDEgPCBlbmRIaWdoKSB7XG4gICAgICAgICAgICAgIGlmIChlbmRzV2l0aEhpZ2hlc3RMb3dTdXJyb2dhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21iaW5lIHN0ZXAgMiBhbmQgc3RlcCAzLlxuICAgICAgICAgICAgICAgIHN1cnJvZ2F0ZU1hcHBpbmdzLnB1c2goW1tzdGFydEhpZ2ggKyAxLCBlbmRIaWdoICsgMV0sIFtMT1dfU1VSUk9HQVRFX01JTiwgZW5kTG93ICsgMV1dKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Vycm9nYXRlTWFwcGluZ3MucHVzaChbW3N0YXJ0SGlnaCArIDEsIGVuZEhpZ2hdLCBbTE9XX1NVUlJPR0FURV9NSU4sIExPV19TVVJST0dBVEVfTUFYICsgMV1dKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGVwIDMuIGAoZW5kSGlnaCwgTE9XX1NVUlJPR0FURV9NSU4pYCB0byBgKGVuZEhpZ2gsIGVuZExvdylgLlxuICAgICAgICAgICAgaWYgKCFjb21wbGV0ZSkge1xuICAgICAgICAgICAgICBzdXJyb2dhdGVNYXBwaW5ncy5wdXNoKFtbZW5kSGlnaCwgZW5kSGlnaCArIDFdLCBbTE9XX1NVUlJPR0FURV9NSU4sIGVuZExvdyArIDFdXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZTdGFydEhpZ2ggPSBzdGFydEhpZ2g7XG4gICAgICAgICAgICBwcmV2RW5kSGlnaCA9IGVuZEhpZ2g7XG5cbiAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhlIGZvcm1hdCBvZiBgc3Vycm9nYXRlTWFwcGluZ3NgIGlzIGFzIGZvbGxvd3M6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAgWyBzdXJyb2dhdGVNYXBwaW5nMSwgc3Vycm9nYXRlTWFwcGluZzIgXVxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gaS5lLjpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICAgICBbXG4gICAgICAgICAgLy8gICAgICAgWyBoaWdoU3Vycm9nYXRlczEsIGxvd1N1cnJvZ2F0ZXMxIF0sXG4gICAgICAgICAgLy8gICAgICAgWyBoaWdoU3Vycm9nYXRlczIsIGxvd1N1cnJvZ2F0ZXMyIF1cbiAgICAgICAgICAvLyAgICAgXVxuICAgICAgICAgIHJldHVybiBvcHRpbWl6ZVN1cnJvZ2F0ZU1hcHBpbmdzKHN1cnJvZ2F0ZU1hcHBpbmdzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY3JlYXRlU3Vycm9nYXRlQ2hhcmFjdGVyQ2xhc3NlcyA9IGZ1bmN0aW9uIGNyZWF0ZVN1cnJvZ2F0ZUNoYXJhY3RlckNsYXNzZXMoc3Vycm9nYXRlTWFwcGluZ3MpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgZm9yRWFjaChzdXJyb2dhdGVNYXBwaW5ncywgZnVuY3Rpb24gKHN1cnJvZ2F0ZU1hcHBpbmcpIHtcbiAgICAgICAgICAgIHZhciBoaWdoU3Vycm9nYXRlcyA9IHN1cnJvZ2F0ZU1hcHBpbmdbMF07XG4gICAgICAgICAgICB2YXIgbG93U3Vycm9nYXRlcyA9IHN1cnJvZ2F0ZU1hcHBpbmdbMV07XG4gICAgICAgICAgICByZXN1bHQucHVzaChjcmVhdGVCTVBDaGFyYWN0ZXJDbGFzc2VzKGhpZ2hTdXJyb2dhdGVzKSArIGNyZWF0ZUJNUENoYXJhY3RlckNsYXNzZXMobG93U3Vycm9nYXRlcykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignfCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjcmVhdGVDaGFyYWN0ZXJDbGFzc2VzRnJvbURhdGEgPSBmdW5jdGlvbiBjcmVhdGVDaGFyYWN0ZXJDbGFzc2VzRnJvbURhdGEoZGF0YSwgYm1wT25seSwgaGFzVW5pY29kZUZsYWcpIHtcbiAgICAgICAgICBpZiAoaGFzVW5pY29kZUZsYWcpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVVbmljb2RlQ2hhcmFjdGVyQ2xhc3NlcyhkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgdmFyIHBhcnRzID0gc3BsaXRBdEJNUChkYXRhKTtcbiAgICAgICAgICB2YXIgbG9uZUhpZ2hTdXJyb2dhdGVzID0gcGFydHMubG9uZUhpZ2hTdXJyb2dhdGVzO1xuICAgICAgICAgIHZhciBsb25lTG93U3Vycm9nYXRlcyA9IHBhcnRzLmxvbmVMb3dTdXJyb2dhdGVzO1xuICAgICAgICAgIHZhciBibXAgPSBwYXJ0cy5ibXA7XG4gICAgICAgICAgdmFyIGFzdHJhbCA9IHBhcnRzLmFzdHJhbDtcbiAgICAgICAgICB2YXIgaGFzQXN0cmFsID0gIWRhdGFJc0VtcHR5KHBhcnRzLmFzdHJhbCk7XG4gICAgICAgICAgdmFyIGhhc0xvbmVIaWdoU3Vycm9nYXRlcyA9ICFkYXRhSXNFbXB0eShsb25lSGlnaFN1cnJvZ2F0ZXMpO1xuICAgICAgICAgIHZhciBoYXNMb25lTG93U3Vycm9nYXRlcyA9ICFkYXRhSXNFbXB0eShsb25lTG93U3Vycm9nYXRlcyk7XG5cbiAgICAgICAgICB2YXIgc3Vycm9nYXRlTWFwcGluZ3MgPSBzdXJyb2dhdGVTZXQoYXN0cmFsKTtcblxuICAgICAgICAgIGlmIChibXBPbmx5KSB7XG4gICAgICAgICAgICBibXAgPSBkYXRhQWRkRGF0YShibXAsIGxvbmVIaWdoU3Vycm9nYXRlcyk7XG4gICAgICAgICAgICBoYXNMb25lSGlnaFN1cnJvZ2F0ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGJtcCA9IGRhdGFBZGREYXRhKGJtcCwgbG9uZUxvd1N1cnJvZ2F0ZXMpO1xuICAgICAgICAgICAgaGFzTG9uZUxvd1N1cnJvZ2F0ZXMgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWRhdGFJc0VtcHR5KGJtcCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBkYXRhIHNldCBjb250YWlucyBCTVAgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IGhpZ2ggc3Vycm9nYXRlc1xuICAgICAgICAgICAgLy8gbmVlZGVkIGZvciBhc3RyYWwgY29kZSBwb2ludHMgaW4gdGhlIHNldC5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNyZWF0ZUJNUENoYXJhY3RlckNsYXNzZXMoYm1wKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdXJyb2dhdGVNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBkYXRhIHNldCBjb250YWlucyBhc3RyYWwgY29kZSBwb2ludHM7IGFwcGVuZCBjaGFyYWN0ZXIgY2xhc3Nlc1xuICAgICAgICAgICAgLy8gYmFzZWQgb24gdGhlaXIgc3Vycm9nYXRlIHBhaXJzLlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3JlYXRlU3Vycm9nYXRlQ2hhcmFjdGVyQ2xhc3NlcyhzdXJyb2dhdGVNYXBwaW5ncykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL2JiZTdmODcwMjA4YWJjZmVjODYwXG4gICAgICAgICAgaWYgKGhhc0xvbmVIaWdoU3Vycm9nYXRlcykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3JlYXRlQk1QQ2hhcmFjdGVyQ2xhc3Nlcyhsb25lSGlnaFN1cnJvZ2F0ZXMpICtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgaGlnaCBzdXJyb2dhdGVzIGFyZW7igJl0IHBhcnQgb2YgYSBzdXJyb2dhdGUgcGFpci5cbiAgICAgICAgICAgICcoPyFbXFxcXHVEQzAwLVxcXFx1REZGRl0pJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNMb25lTG93U3Vycm9nYXRlcykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gYWNjdXJhdGVseSBhc3NlcnQgdGhlIGxvdyBzdXJyb2dhdGVzIGFyZW7igJl0XG4gICAgICAgICAgICAvLyBwYXJ0IG9mIGEgc3Vycm9nYXRlIHBhaXIsIHNpbmNlIEphdmFTY3JpcHQgcmVndWxhciBleHByZXNzaW9ucyBkb1xuICAgICAgICAgICAgLy8gbm90IHN1cHBvcnQgbG9va2JlaGluZC5cbiAgICAgICAgICAgICcoPzpbXlxcXFx1RDgwMC1cXFxcdURCRkZdfF4pJyArIGNyZWF0ZUJNUENoYXJhY3RlckNsYXNzZXMobG9uZUxvd1N1cnJvZ2F0ZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCd8Jyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgLy8gYHJlZ2VuZXJhdGVgIGNhbiBiZSB1c2VkIGFzIGEgY29uc3RydWN0b3IgKGFuZCBuZXcgbWV0aG9kcyBjYW4gYmUgYWRkZWQgdG9cbiAgICAgICAgLy8gaXRzIHByb3RvdHlwZSkgYnV0IGFsc28gYXMgYSByZWd1bGFyIGZ1bmN0aW9uLCB0aGUgbGF0dGVyIG9mIHdoaWNoIGlzIHRoZVxuICAgICAgICAvLyBkb2N1bWVudGVkIGFuZCBtb3N0IGNvbW1vbiB1c2FnZS4gRm9yIHRoYXQgcmVhc29uLCBpdOKAmXMgbm90IGNhcGl0YWxpemVkLlxuICAgICAgICB2YXIgcmVnZW5lcmF0ZSA9IGZ1bmN0aW9uIHJlZ2VuZXJhdGUodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIHJlZ2VuZXJhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdGhpcy5hZGQodmFsdWUpIDogdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyByZWdlbmVyYXRlKCkuYWRkKHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdlbmVyYXRlLnZlcnNpb24gPSAnMS4zLjEnO1xuXG4gICAgICAgIHZhciBwcm90byA9IHJlZ2VuZXJhdGUucHJvdG90eXBlO1xuICAgICAgICBleHRlbmQocHJvdG8sIHtcbiAgICAgICAgICAnYWRkJzogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICR0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgcmVnZW5lcmF0ZSkge1xuICAgICAgICAgICAgICAvLyBBbGxvdyBwYXNzaW5nIG90aGVyIFJlZ2VuZXJhdGUgaW5zdGFuY2VzLlxuICAgICAgICAgICAgICAkdGhpcy5kYXRhID0gZGF0YUFkZERhdGEoJHRoaXMuZGF0YSwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmFkZChpdGVtKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR0aGlzLmRhdGEgPSBkYXRhQWRkKCR0aGlzLmRhdGEsIGlzTnVtYmVyKHZhbHVlKSA/IHZhbHVlIDogc3ltYm9sVG9Db2RlUG9pbnQodmFsdWUpKTtcbiAgICAgICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgICAgICB9LFxuICAgICAgICAgICdyZW1vdmUnOiBmdW5jdGlvbiByZW1vdmUodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gJHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiByZWdlbmVyYXRlKSB7XG4gICAgICAgICAgICAgIC8vIEFsbG93IHBhc3Npbmcgb3RoZXIgUmVnZW5lcmF0ZSBpbnN0YW5jZXMuXG4gICAgICAgICAgICAgICR0aGlzLmRhdGEgPSBkYXRhUmVtb3ZlRGF0YSgkdGhpcy5kYXRhLCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgICAgcmV0dXJuICR0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMucmVtb3ZlKGl0ZW0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHRoaXMuZGF0YSA9IGRhdGFSZW1vdmUoJHRoaXMuZGF0YSwgaXNOdW1iZXIodmFsdWUpID8gdmFsdWUgOiBzeW1ib2xUb0NvZGVQb2ludCh2YWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuICR0aGlzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2FkZFJhbmdlJzogZnVuY3Rpb24gYWRkUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgICAgICR0aGlzLmRhdGEgPSBkYXRhQWRkUmFuZ2UoJHRoaXMuZGF0YSwgaXNOdW1iZXIoc3RhcnQpID8gc3RhcnQgOiBzeW1ib2xUb0NvZGVQb2ludChzdGFydCksIGlzTnVtYmVyKGVuZCkgPyBlbmQgOiBzeW1ib2xUb0NvZGVQb2ludChlbmQpKTtcbiAgICAgICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgICAgICB9LFxuICAgICAgICAgICdyZW1vdmVSYW5nZSc6IGZ1bmN0aW9uIHJlbW92ZVJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc3RhcnRDb2RlUG9pbnQgPSBpc051bWJlcihzdGFydCkgPyBzdGFydCA6IHN5bWJvbFRvQ29kZVBvaW50KHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmRDb2RlUG9pbnQgPSBpc051bWJlcihlbmQpID8gZW5kIDogc3ltYm9sVG9Db2RlUG9pbnQoZW5kKTtcbiAgICAgICAgICAgICR0aGlzLmRhdGEgPSBkYXRhUmVtb3ZlUmFuZ2UoJHRoaXMuZGF0YSwgc3RhcnRDb2RlUG9pbnQsIGVuZENvZGVQb2ludCk7XG4gICAgICAgICAgICByZXR1cm4gJHRoaXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnaW50ZXJzZWN0aW9uJzogZnVuY3Rpb24gaW50ZXJzZWN0aW9uKGFyZ3VtZW50KSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gQWxsb3cgcGFzc2luZyBvdGhlciBSZWdlbmVyYXRlIGluc3RhbmNlcy5cbiAgICAgICAgICAgIC8vIFRPRE86IE9wdGltaXplIHRoaXMgYnkgd3JpdGluZyBhbmQgdXNpbmcgYGRhdGFJbnRlcnNlY3Rpb25EYXRhKClgLlxuICAgICAgICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnQgaW5zdGFuY2VvZiByZWdlbmVyYXRlID8gZGF0YVRvQXJyYXkoYXJndW1lbnQuZGF0YSkgOiBhcmd1bWVudDtcbiAgICAgICAgICAgICR0aGlzLmRhdGEgPSBkYXRhSW50ZXJzZWN0aW9uKCR0aGlzLmRhdGEsIGFycmF5KTtcbiAgICAgICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgICAgICB9LFxuICAgICAgICAgICdjb250YWlucyc6IGZ1bmN0aW9uIGNvbnRhaW5zKGNvZGVQb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFDb250YWlucyh0aGlzLmRhdGEsIGlzTnVtYmVyKGNvZGVQb2ludCkgPyBjb2RlUG9pbnQgOiBzeW1ib2xUb0NvZGVQb2ludChjb2RlUG9pbnQpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICdjbG9uZSc6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgdmFyIHNldCQkMSA9IG5ldyByZWdlbmVyYXRlKCk7XG4gICAgICAgICAgICBzZXQkJDEuZGF0YSA9IHRoaXMuZGF0YS5zbGljZSgwKTtcbiAgICAgICAgICAgIHJldHVybiBzZXQkJDE7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAndG9TdHJpbmcnOiBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQ2hhcmFjdGVyQ2xhc3Nlc0Zyb21EYXRhKHRoaXMuZGF0YSwgb3B0aW9ucyA/IG9wdGlvbnMuYm1wT25seSA6IGZhbHNlLCBvcHRpb25zID8gb3B0aW9ucy5oYXNVbmljb2RlRmxhZyA6IGZhbHNlKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIC8vIEZvciBhbiBlbXB0eSBzZXQsIHJldHVybiBzb21ldGhpbmcgdGhhdCBjYW4gYmUgaW5zZXJ0ZWQgYC9oZXJlL2AgdG9cbiAgICAgICAgICAgICAgLy8gZm9ybSBhIHZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbi4gQXZvaWQgYCg/OilgIHNpbmNlIHRoYXQgbWF0Y2hlcyB0aGVcbiAgICAgICAgICAgICAgLy8gZW1wdHkgc3RyaW5nLlxuICAgICAgICAgICAgICByZXR1cm4gJ1tdJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzZSBgXFwwYCBpbnN0ZWFkIG9mIGBcXHgwMGAgd2hlcmUgcG9zc2libGUuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UocmVnZXhOdWxsLCAnXFxcXDAkMScpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJ3RvUmVnRXhwJzogZnVuY3Rpb24gdG9SZWdFeHAoZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy50b1N0cmluZyhmbGFncyAmJiBmbGFncy5pbmRleE9mKCd1JykgIT0gLTEgPyB7ICdoYXNVbmljb2RlRmxhZyc6IHRydWUgfSA6IG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZ0V4cChwYXR0ZXJuLCBmbGFncyB8fCAnJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAndmFsdWVPZic6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBgdmFsdWVPZmAgaXMgYWxpYXNlZCBhcyBgdG9BcnJheWAuXG4gICAgICAgICAgICByZXR1cm4gZGF0YVRvQXJyYXkodGhpcy5kYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3RvLnRvQXJyYXkgPSBwcm90by52YWx1ZU9mO1xuXG4gICAgICAgIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuICAgICAgICAvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgIGlmICh0eXBlb2YgdW5kZWZpbmVkID09ICdmdW5jdGlvbicgJiYgX3R5cGVvZih1bmRlZmluZWQuYW1kKSA9PSAnb2JqZWN0JyAmJiB1bmRlZmluZWQuYW1kKSB7XG4gICAgICAgICAgdW5kZWZpbmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuICAgICAgICAgIGlmIChmcmVlTW9kdWxlKSB7XG4gICAgICAgICAgICAvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG4gICAgICAgICAgICBmcmVlTW9kdWxlLmV4cG9ydHMgPSByZWdlbmVyYXRlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuICAgICAgICAgICAgZnJlZUV4cG9ydHMucmVnZW5lcmF0ZSA9IHJlZ2VuZXJhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcbiAgICAgICAgICByb290LnJlZ2VuZXJhdGUgPSByZWdlbmVyYXRlO1xuICAgICAgICB9XG4gICAgICB9KShfX2NvbW1vbmpzX2dsb2JhbCk7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVxdWlyZSQkMCQyID0gcmVnZW5lcmF0ZSAmJiAodHlwZW9mIHJlZ2VuZXJhdGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHJlZ2VuZXJhdGUpKSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIHJlZ2VuZXJhdGUgPyByZWdlbmVyYXRlWydkZWZhdWx0J10gOiByZWdlbmVyYXRlO1xuXG4gICAgdmFyIGNoYXJhY3RlckNsYXNzRXNjYXBlU2V0cyA9IF9fY29tbW9uanMoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgLy8gR2VuZXJhdGVkIGJ5IGAvc2NyaXB0cy9jaGFyYWN0ZXItY2xhc3MtZXNjYXBlLXNldHMuanNgLiBEbyBub3QgZWRpdC5cbiAgICAgIHZhciByZWdlbmVyYXRlID0gcmVxdWlyZSQkMCQyO1xuXG4gICAgICBleHBvcnRzLlJFR1VMQVIgPSB7XG4gICAgICAgICdkJzogcmVnZW5lcmF0ZSgpLmFkZFJhbmdlKDB4MzAsIDB4MzkpLFxuICAgICAgICAnRCc6IHJlZ2VuZXJhdGUoKS5hZGRSYW5nZSgweDAsIDB4MkYpLmFkZFJhbmdlKDB4M0EsIDB4RkZGRiksXG4gICAgICAgICdzJzogcmVnZW5lcmF0ZSgweDIwLCAweEEwLCAweDE2ODAsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRikuYWRkUmFuZ2UoMHg5LCAweEQpLmFkZFJhbmdlKDB4MjAwMCwgMHgyMDBBKS5hZGRSYW5nZSgweDIwMjgsIDB4MjAyOSksXG4gICAgICAgICdTJzogcmVnZW5lcmF0ZSgpLmFkZFJhbmdlKDB4MCwgMHg4KS5hZGRSYW5nZSgweEUsIDB4MUYpLmFkZFJhbmdlKDB4MjEsIDB4OUYpLmFkZFJhbmdlKDB4QTEsIDB4MTY3RikuYWRkUmFuZ2UoMHgxNjgxLCAweDFGRkYpLmFkZFJhbmdlKDB4MjAwQiwgMHgyMDI3KS5hZGRSYW5nZSgweDIwMkEsIDB4MjAyRSkuYWRkUmFuZ2UoMHgyMDMwLCAweDIwNUUpLmFkZFJhbmdlKDB4MjA2MCwgMHgyRkZGKS5hZGRSYW5nZSgweDMwMDEsIDB4RkVGRSkuYWRkUmFuZ2UoMHhGRjAwLCAweEZGRkYpLFxuICAgICAgICAndyc6IHJlZ2VuZXJhdGUoMHg1RikuYWRkUmFuZ2UoMHgzMCwgMHgzOSkuYWRkUmFuZ2UoMHg0MSwgMHg1QSkuYWRkUmFuZ2UoMHg2MSwgMHg3QSksXG4gICAgICAgICdXJzogcmVnZW5lcmF0ZSgweDYwKS5hZGRSYW5nZSgweDAsIDB4MkYpLmFkZFJhbmdlKDB4M0EsIDB4NDApLmFkZFJhbmdlKDB4NUIsIDB4NUUpLmFkZFJhbmdlKDB4N0IsIDB4RkZGRilcbiAgICAgIH07XG5cbiAgICAgIGV4cG9ydHMuVU5JQ09ERSA9IHtcbiAgICAgICAgJ2QnOiByZWdlbmVyYXRlKCkuYWRkUmFuZ2UoMHgzMCwgMHgzOSksXG4gICAgICAgICdEJzogcmVnZW5lcmF0ZSgpLmFkZFJhbmdlKDB4MCwgMHgyRikuYWRkUmFuZ2UoMHgzQSwgMHgxMEZGRkYpLFxuICAgICAgICAncyc6IHJlZ2VuZXJhdGUoMHgyMCwgMHhBMCwgMHgxNjgwLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkYpLmFkZFJhbmdlKDB4OSwgMHhEKS5hZGRSYW5nZSgweDIwMDAsIDB4MjAwQSkuYWRkUmFuZ2UoMHgyMDI4LCAweDIwMjkpLFxuICAgICAgICAnUyc6IHJlZ2VuZXJhdGUoKS5hZGRSYW5nZSgweDAsIDB4OCkuYWRkUmFuZ2UoMHhFLCAweDFGKS5hZGRSYW5nZSgweDIxLCAweDlGKS5hZGRSYW5nZSgweEExLCAweDE2N0YpLmFkZFJhbmdlKDB4MTY4MSwgMHgxRkZGKS5hZGRSYW5nZSgweDIwMEIsIDB4MjAyNykuYWRkUmFuZ2UoMHgyMDJBLCAweDIwMkUpLmFkZFJhbmdlKDB4MjAzMCwgMHgyMDVFKS5hZGRSYW5nZSgweDIwNjAsIDB4MkZGRikuYWRkUmFuZ2UoMHgzMDAxLCAweEZFRkUpLmFkZFJhbmdlKDB4RkYwMCwgMHgxMEZGRkYpLFxuICAgICAgICAndyc6IHJlZ2VuZXJhdGUoMHg1RikuYWRkUmFuZ2UoMHgzMCwgMHgzOSkuYWRkUmFuZ2UoMHg0MSwgMHg1QSkuYWRkUmFuZ2UoMHg2MSwgMHg3QSksXG4gICAgICAgICdXJzogcmVnZW5lcmF0ZSgweDYwKS5hZGRSYW5nZSgweDAsIDB4MkYpLmFkZFJhbmdlKDB4M0EsIDB4NDApLmFkZFJhbmdlKDB4NUIsIDB4NUUpLmFkZFJhbmdlKDB4N0IsIDB4MTBGRkZGKVxuICAgICAgfTtcblxuICAgICAgZXhwb3J0cy5VTklDT0RFX0lHTk9SRV9DQVNFID0ge1xuICAgICAgICAnZCc6IHJlZ2VuZXJhdGUoKS5hZGRSYW5nZSgweDMwLCAweDM5KSxcbiAgICAgICAgJ0QnOiByZWdlbmVyYXRlKCkuYWRkUmFuZ2UoMHgwLCAweDJGKS5hZGRSYW5nZSgweDNBLCAweDEwRkZGRiksXG4gICAgICAgICdzJzogcmVnZW5lcmF0ZSgweDIwLCAweEEwLCAweDE2ODAsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRikuYWRkUmFuZ2UoMHg5LCAweEQpLmFkZFJhbmdlKDB4MjAwMCwgMHgyMDBBKS5hZGRSYW5nZSgweDIwMjgsIDB4MjAyOSksXG4gICAgICAgICdTJzogcmVnZW5lcmF0ZSgpLmFkZFJhbmdlKDB4MCwgMHg4KS5hZGRSYW5nZSgweEUsIDB4MUYpLmFkZFJhbmdlKDB4MjEsIDB4OUYpLmFkZFJhbmdlKDB4QTEsIDB4MTY3RikuYWRkUmFuZ2UoMHgxNjgxLCAweDFGRkYpLmFkZFJhbmdlKDB4MjAwQiwgMHgyMDI3KS5hZGRSYW5nZSgweDIwMkEsIDB4MjAyRSkuYWRkUmFuZ2UoMHgyMDMwLCAweDIwNUUpLmFkZFJhbmdlKDB4MjA2MCwgMHgyRkZGKS5hZGRSYW5nZSgweDMwMDEsIDB4RkVGRSkuYWRkUmFuZ2UoMHhGRjAwLCAweDEwRkZGRiksXG4gICAgICAgICd3JzogcmVnZW5lcmF0ZSgweDVGLCAweDE3RiwgMHgyMTJBKS5hZGRSYW5nZSgweDMwLCAweDM5KS5hZGRSYW5nZSgweDQxLCAweDVBKS5hZGRSYW5nZSgweDYxLCAweDdBKSxcbiAgICAgICAgJ1cnOiByZWdlbmVyYXRlKDB4NEIsIDB4NTMsIDB4NjApLmFkZFJhbmdlKDB4MCwgMHgyRikuYWRkUmFuZ2UoMHgzQSwgMHg0MCkuYWRkUmFuZ2UoMHg1QiwgMHg1RSkuYWRkUmFuZ2UoMHg3QiwgMHgxMEZGRkYpXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIHJlcXVpcmUkJDAkMSA9IGNoYXJhY3RlckNsYXNzRXNjYXBlU2V0cyAmJiAodHlwZW9mIGNoYXJhY3RlckNsYXNzRXNjYXBlU2V0cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2hhcmFjdGVyQ2xhc3NFc2NhcGVTZXRzKSkgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBjaGFyYWN0ZXJDbGFzc0VzY2FwZVNldHMgPyBjaGFyYWN0ZXJDbGFzc0VzY2FwZVNldHNbJ2RlZmF1bHQnXSA6IGNoYXJhY3RlckNsYXNzRXNjYXBlU2V0cztcblxuICAgIHZhciByZXF1aXJlJCQxID0ge1xuICAgICAgXCI3NVwiOiA4NDkwLFxuICAgICAgXCI4M1wiOiAzODMsXG4gICAgICBcIjEwN1wiOiA4NDkwLFxuICAgICAgXCIxMTVcIjogMzgzLFxuICAgICAgXCIxODFcIjogOTI0LFxuICAgICAgXCIxOTdcIjogODQ5MSxcbiAgICAgIFwiMzgzXCI6IDgzLFxuICAgICAgXCI0NTJcIjogNDUzLFxuICAgICAgXCI0NTNcIjogNDUyLFxuICAgICAgXCI0NTVcIjogNDU2LFxuICAgICAgXCI0NTZcIjogNDU1LFxuICAgICAgXCI0NThcIjogNDU5LFxuICAgICAgXCI0NTlcIjogNDU4LFxuICAgICAgXCI0OTdcIjogNDk4LFxuICAgICAgXCI0OThcIjogNDk3LFxuICAgICAgXCI4MzdcIjogODEyNixcbiAgICAgIFwiOTE0XCI6IDk3NixcbiAgICAgIFwiOTE3XCI6IDEwMTMsXG4gICAgICBcIjkyMFwiOiAxMDEyLFxuICAgICAgXCI5MjFcIjogODEyNixcbiAgICAgIFwiOTIyXCI6IDEwMDgsXG4gICAgICBcIjkyNFwiOiAxODEsXG4gICAgICBcIjkyOFwiOiA5ODIsXG4gICAgICBcIjkyOVwiOiAxMDA5LFxuICAgICAgXCI5MzFcIjogOTYyLFxuICAgICAgXCI5MzRcIjogOTgxLFxuICAgICAgXCI5MzdcIjogODQ4NixcbiAgICAgIFwiOTYyXCI6IDkzMSxcbiAgICAgIFwiOTc2XCI6IDkxNCxcbiAgICAgIFwiOTc3XCI6IDEwMTIsXG4gICAgICBcIjk4MVwiOiA5MzQsXG4gICAgICBcIjk4MlwiOiA5MjgsXG4gICAgICBcIjEwMDhcIjogOTIyLFxuICAgICAgXCIxMDA5XCI6IDkyOSxcbiAgICAgIFwiMTAxMlwiOiBbOTIwLCA5NzddLFxuICAgICAgXCIxMDEzXCI6IDkxNyxcbiAgICAgIFwiNzc3NlwiOiA3ODM1LFxuICAgICAgXCI3ODM1XCI6IDc3NzYsXG4gICAgICBcIjgxMjZcIjogWzgzNywgOTIxXSxcbiAgICAgIFwiODQ4NlwiOiA5MzcsXG4gICAgICBcIjg0OTBcIjogNzUsXG4gICAgICBcIjg0OTFcIjogMTk3LFxuICAgICAgXCI2NjU2MFwiOiA2NjYwMCxcbiAgICAgIFwiNjY1NjFcIjogNjY2MDEsXG4gICAgICBcIjY2NTYyXCI6IDY2NjAyLFxuICAgICAgXCI2NjU2M1wiOiA2NjYwMyxcbiAgICAgIFwiNjY1NjRcIjogNjY2MDQsXG4gICAgICBcIjY2NTY1XCI6IDY2NjA1LFxuICAgICAgXCI2NjU2NlwiOiA2NjYwNixcbiAgICAgIFwiNjY1NjdcIjogNjY2MDcsXG4gICAgICBcIjY2NTY4XCI6IDY2NjA4LFxuICAgICAgXCI2NjU2OVwiOiA2NjYwOSxcbiAgICAgIFwiNjY1NzBcIjogNjY2MTAsXG4gICAgICBcIjY2NTcxXCI6IDY2NjExLFxuICAgICAgXCI2NjU3MlwiOiA2NjYxMixcbiAgICAgIFwiNjY1NzNcIjogNjY2MTMsXG4gICAgICBcIjY2NTc0XCI6IDY2NjE0LFxuICAgICAgXCI2NjU3NVwiOiA2NjYxNSxcbiAgICAgIFwiNjY1NzZcIjogNjY2MTYsXG4gICAgICBcIjY2NTc3XCI6IDY2NjE3LFxuICAgICAgXCI2NjU3OFwiOiA2NjYxOCxcbiAgICAgIFwiNjY1NzlcIjogNjY2MTksXG4gICAgICBcIjY2NTgwXCI6IDY2NjIwLFxuICAgICAgXCI2NjU4MVwiOiA2NjYyMSxcbiAgICAgIFwiNjY1ODJcIjogNjY2MjIsXG4gICAgICBcIjY2NTgzXCI6IDY2NjIzLFxuICAgICAgXCI2NjU4NFwiOiA2NjYyNCxcbiAgICAgIFwiNjY1ODVcIjogNjY2MjUsXG4gICAgICBcIjY2NTg2XCI6IDY2NjI2LFxuICAgICAgXCI2NjU4N1wiOiA2NjYyNyxcbiAgICAgIFwiNjY1ODhcIjogNjY2MjgsXG4gICAgICBcIjY2NTg5XCI6IDY2NjI5LFxuICAgICAgXCI2NjU5MFwiOiA2NjYzMCxcbiAgICAgIFwiNjY1OTFcIjogNjY2MzEsXG4gICAgICBcIjY2NTkyXCI6IDY2NjMyLFxuICAgICAgXCI2NjU5M1wiOiA2NjYzMyxcbiAgICAgIFwiNjY1OTRcIjogNjY2MzQsXG4gICAgICBcIjY2NTk1XCI6IDY2NjM1LFxuICAgICAgXCI2NjU5NlwiOiA2NjYzNixcbiAgICAgIFwiNjY1OTdcIjogNjY2MzcsXG4gICAgICBcIjY2NTk4XCI6IDY2NjM4LFxuICAgICAgXCI2NjU5OVwiOiA2NjYzOSxcbiAgICAgIFwiNjY2MDBcIjogNjY1NjAsXG4gICAgICBcIjY2NjAxXCI6IDY2NTYxLFxuICAgICAgXCI2NjYwMlwiOiA2NjU2MixcbiAgICAgIFwiNjY2MDNcIjogNjY1NjMsXG4gICAgICBcIjY2NjA0XCI6IDY2NTY0LFxuICAgICAgXCI2NjYwNVwiOiA2NjU2NSxcbiAgICAgIFwiNjY2MDZcIjogNjY1NjYsXG4gICAgICBcIjY2NjA3XCI6IDY2NTY3LFxuICAgICAgXCI2NjYwOFwiOiA2NjU2OCxcbiAgICAgIFwiNjY2MDlcIjogNjY1NjksXG4gICAgICBcIjY2NjEwXCI6IDY2NTcwLFxuICAgICAgXCI2NjYxMVwiOiA2NjU3MSxcbiAgICAgIFwiNjY2MTJcIjogNjY1NzIsXG4gICAgICBcIjY2NjEzXCI6IDY2NTczLFxuICAgICAgXCI2NjYxNFwiOiA2NjU3NCxcbiAgICAgIFwiNjY2MTVcIjogNjY1NzUsXG4gICAgICBcIjY2NjE2XCI6IDY2NTc2LFxuICAgICAgXCI2NjYxN1wiOiA2NjU3NyxcbiAgICAgIFwiNjY2MThcIjogNjY1NzgsXG4gICAgICBcIjY2NjE5XCI6IDY2NTc5LFxuICAgICAgXCI2NjYyMFwiOiA2NjU4MCxcbiAgICAgIFwiNjY2MjFcIjogNjY1ODEsXG4gICAgICBcIjY2NjIyXCI6IDY2NTgyLFxuICAgICAgXCI2NjYyM1wiOiA2NjU4MyxcbiAgICAgIFwiNjY2MjRcIjogNjY1ODQsXG4gICAgICBcIjY2NjI1XCI6IDY2NTg1LFxuICAgICAgXCI2NjYyNlwiOiA2NjU4NixcbiAgICAgIFwiNjY2MjdcIjogNjY1ODcsXG4gICAgICBcIjY2NjI4XCI6IDY2NTg4LFxuICAgICAgXCI2NjYyOVwiOiA2NjU4OSxcbiAgICAgIFwiNjY2MzBcIjogNjY1OTAsXG4gICAgICBcIjY2NjMxXCI6IDY2NTkxLFxuICAgICAgXCI2NjYzMlwiOiA2NjU5MixcbiAgICAgIFwiNjY2MzNcIjogNjY1OTMsXG4gICAgICBcIjY2NjM0XCI6IDY2NTk0LFxuICAgICAgXCI2NjYzNVwiOiA2NjU5NSxcbiAgICAgIFwiNjY2MzZcIjogNjY1OTYsXG4gICAgICBcIjY2NjM3XCI6IDY2NTk3LFxuICAgICAgXCI2NjYzOFwiOiA2NjU5OCxcbiAgICAgIFwiNjY2MzlcIjogNjY1OTksXG4gICAgICBcIjY4NzM2XCI6IDY4ODAwLFxuICAgICAgXCI2ODczN1wiOiA2ODgwMSxcbiAgICAgIFwiNjg3MzhcIjogNjg4MDIsXG4gICAgICBcIjY4NzM5XCI6IDY4ODAzLFxuICAgICAgXCI2ODc0MFwiOiA2ODgwNCxcbiAgICAgIFwiNjg3NDFcIjogNjg4MDUsXG4gICAgICBcIjY4NzQyXCI6IDY4ODA2LFxuICAgICAgXCI2ODc0M1wiOiA2ODgwNyxcbiAgICAgIFwiNjg3NDRcIjogNjg4MDgsXG4gICAgICBcIjY4NzQ1XCI6IDY4ODA5LFxuICAgICAgXCI2ODc0NlwiOiA2ODgxMCxcbiAgICAgIFwiNjg3NDdcIjogNjg4MTEsXG4gICAgICBcIjY4NzQ4XCI6IDY4ODEyLFxuICAgICAgXCI2ODc0OVwiOiA2ODgxMyxcbiAgICAgIFwiNjg3NTBcIjogNjg4MTQsXG4gICAgICBcIjY4NzUxXCI6IDY4ODE1LFxuICAgICAgXCI2ODc1MlwiOiA2ODgxNixcbiAgICAgIFwiNjg3NTNcIjogNjg4MTcsXG4gICAgICBcIjY4NzU0XCI6IDY4ODE4LFxuICAgICAgXCI2ODc1NVwiOiA2ODgxOSxcbiAgICAgIFwiNjg3NTZcIjogNjg4MjAsXG4gICAgICBcIjY4NzU3XCI6IDY4ODIxLFxuICAgICAgXCI2ODc1OFwiOiA2ODgyMixcbiAgICAgIFwiNjg3NTlcIjogNjg4MjMsXG4gICAgICBcIjY4NzYwXCI6IDY4ODI0LFxuICAgICAgXCI2ODc2MVwiOiA2ODgyNSxcbiAgICAgIFwiNjg3NjJcIjogNjg4MjYsXG4gICAgICBcIjY4NzYzXCI6IDY4ODI3LFxuICAgICAgXCI2ODc2NFwiOiA2ODgyOCxcbiAgICAgIFwiNjg3NjVcIjogNjg4MjksXG4gICAgICBcIjY4NzY2XCI6IDY4ODMwLFxuICAgICAgXCI2ODc2N1wiOiA2ODgzMSxcbiAgICAgIFwiNjg3NjhcIjogNjg4MzIsXG4gICAgICBcIjY4NzY5XCI6IDY4ODMzLFxuICAgICAgXCI2ODc3MFwiOiA2ODgzNCxcbiAgICAgIFwiNjg3NzFcIjogNjg4MzUsXG4gICAgICBcIjY4NzcyXCI6IDY4ODM2LFxuICAgICAgXCI2ODc3M1wiOiA2ODgzNyxcbiAgICAgIFwiNjg3NzRcIjogNjg4MzgsXG4gICAgICBcIjY4Nzc1XCI6IDY4ODM5LFxuICAgICAgXCI2ODc3NlwiOiA2ODg0MCxcbiAgICAgIFwiNjg3NzdcIjogNjg4NDEsXG4gICAgICBcIjY4Nzc4XCI6IDY4ODQyLFxuICAgICAgXCI2ODc3OVwiOiA2ODg0MyxcbiAgICAgIFwiNjg3ODBcIjogNjg4NDQsXG4gICAgICBcIjY4NzgxXCI6IDY4ODQ1LFxuICAgICAgXCI2ODc4MlwiOiA2ODg0NixcbiAgICAgIFwiNjg3ODNcIjogNjg4NDcsXG4gICAgICBcIjY4Nzg0XCI6IDY4ODQ4LFxuICAgICAgXCI2ODc4NVwiOiA2ODg0OSxcbiAgICAgIFwiNjg3ODZcIjogNjg4NTAsXG4gICAgICBcIjY4ODAwXCI6IDY4NzM2LFxuICAgICAgXCI2ODgwMVwiOiA2ODczNyxcbiAgICAgIFwiNjg4MDJcIjogNjg3MzgsXG4gICAgICBcIjY4ODAzXCI6IDY4NzM5LFxuICAgICAgXCI2ODgwNFwiOiA2ODc0MCxcbiAgICAgIFwiNjg4MDVcIjogNjg3NDEsXG4gICAgICBcIjY4ODA2XCI6IDY4NzQyLFxuICAgICAgXCI2ODgwN1wiOiA2ODc0MyxcbiAgICAgIFwiNjg4MDhcIjogNjg3NDQsXG4gICAgICBcIjY4ODA5XCI6IDY4NzQ1LFxuICAgICAgXCI2ODgxMFwiOiA2ODc0NixcbiAgICAgIFwiNjg4MTFcIjogNjg3NDcsXG4gICAgICBcIjY4ODEyXCI6IDY4NzQ4LFxuICAgICAgXCI2ODgxM1wiOiA2ODc0OSxcbiAgICAgIFwiNjg4MTRcIjogNjg3NTAsXG4gICAgICBcIjY4ODE1XCI6IDY4NzUxLFxuICAgICAgXCI2ODgxNlwiOiA2ODc1MixcbiAgICAgIFwiNjg4MTdcIjogNjg3NTMsXG4gICAgICBcIjY4ODE4XCI6IDY4NzU0LFxuICAgICAgXCI2ODgxOVwiOiA2ODc1NSxcbiAgICAgIFwiNjg4MjBcIjogNjg3NTYsXG4gICAgICBcIjY4ODIxXCI6IDY4NzU3LFxuICAgICAgXCI2ODgyMlwiOiA2ODc1OCxcbiAgICAgIFwiNjg4MjNcIjogNjg3NTksXG4gICAgICBcIjY4ODI0XCI6IDY4NzYwLFxuICAgICAgXCI2ODgyNVwiOiA2ODc2MSxcbiAgICAgIFwiNjg4MjZcIjogNjg3NjIsXG4gICAgICBcIjY4ODI3XCI6IDY4NzYzLFxuICAgICAgXCI2ODgyOFwiOiA2ODc2NCxcbiAgICAgIFwiNjg4MjlcIjogNjg3NjUsXG4gICAgICBcIjY4ODMwXCI6IDY4NzY2LFxuICAgICAgXCI2ODgzMVwiOiA2ODc2NyxcbiAgICAgIFwiNjg4MzJcIjogNjg3NjgsXG4gICAgICBcIjY4ODMzXCI6IDY4NzY5LFxuICAgICAgXCI2ODgzNFwiOiA2ODc3MCxcbiAgICAgIFwiNjg4MzVcIjogNjg3NzEsXG4gICAgICBcIjY4ODM2XCI6IDY4NzcyLFxuICAgICAgXCI2ODgzN1wiOiA2ODc3MyxcbiAgICAgIFwiNjg4MzhcIjogNjg3NzQsXG4gICAgICBcIjY4ODM5XCI6IDY4Nzc1LFxuICAgICAgXCI2ODg0MFwiOiA2ODc3NixcbiAgICAgIFwiNjg4NDFcIjogNjg3NzcsXG4gICAgICBcIjY4ODQyXCI6IDY4Nzc4LFxuICAgICAgXCI2ODg0M1wiOiA2ODc3OSxcbiAgICAgIFwiNjg4NDRcIjogNjg3ODAsXG4gICAgICBcIjY4ODQ1XCI6IDY4NzgxLFxuICAgICAgXCI2ODg0NlwiOiA2ODc4MixcbiAgICAgIFwiNjg4NDdcIjogNjg3ODMsXG4gICAgICBcIjY4ODQ4XCI6IDY4Nzg0LFxuICAgICAgXCI2ODg0OVwiOiA2ODc4NSxcbiAgICAgIFwiNjg4NTBcIjogNjg3ODYsXG4gICAgICBcIjcxODQwXCI6IDcxODcyLFxuICAgICAgXCI3MTg0MVwiOiA3MTg3MyxcbiAgICAgIFwiNzE4NDJcIjogNzE4NzQsXG4gICAgICBcIjcxODQzXCI6IDcxODc1LFxuICAgICAgXCI3MTg0NFwiOiA3MTg3NixcbiAgICAgIFwiNzE4NDVcIjogNzE4NzcsXG4gICAgICBcIjcxODQ2XCI6IDcxODc4LFxuICAgICAgXCI3MTg0N1wiOiA3MTg3OSxcbiAgICAgIFwiNzE4NDhcIjogNzE4ODAsXG4gICAgICBcIjcxODQ5XCI6IDcxODgxLFxuICAgICAgXCI3MTg1MFwiOiA3MTg4MixcbiAgICAgIFwiNzE4NTFcIjogNzE4ODMsXG4gICAgICBcIjcxODUyXCI6IDcxODg0LFxuICAgICAgXCI3MTg1M1wiOiA3MTg4NSxcbiAgICAgIFwiNzE4NTRcIjogNzE4ODYsXG4gICAgICBcIjcxODU1XCI6IDcxODg3LFxuICAgICAgXCI3MTg1NlwiOiA3MTg4OCxcbiAgICAgIFwiNzE4NTdcIjogNzE4ODksXG4gICAgICBcIjcxODU4XCI6IDcxODkwLFxuICAgICAgXCI3MTg1OVwiOiA3MTg5MSxcbiAgICAgIFwiNzE4NjBcIjogNzE4OTIsXG4gICAgICBcIjcxODYxXCI6IDcxODkzLFxuICAgICAgXCI3MTg2MlwiOiA3MTg5NCxcbiAgICAgIFwiNzE4NjNcIjogNzE4OTUsXG4gICAgICBcIjcxODY0XCI6IDcxODk2LFxuICAgICAgXCI3MTg2NVwiOiA3MTg5NyxcbiAgICAgIFwiNzE4NjZcIjogNzE4OTgsXG4gICAgICBcIjcxODY3XCI6IDcxODk5LFxuICAgICAgXCI3MTg2OFwiOiA3MTkwMCxcbiAgICAgIFwiNzE4NjlcIjogNzE5MDEsXG4gICAgICBcIjcxODcwXCI6IDcxOTAyLFxuICAgICAgXCI3MTg3MVwiOiA3MTkwMyxcbiAgICAgIFwiNzE4NzJcIjogNzE4NDAsXG4gICAgICBcIjcxODczXCI6IDcxODQxLFxuICAgICAgXCI3MTg3NFwiOiA3MTg0MixcbiAgICAgIFwiNzE4NzVcIjogNzE4NDMsXG4gICAgICBcIjcxODc2XCI6IDcxODQ0LFxuICAgICAgXCI3MTg3N1wiOiA3MTg0NSxcbiAgICAgIFwiNzE4NzhcIjogNzE4NDYsXG4gICAgICBcIjcxODc5XCI6IDcxODQ3LFxuICAgICAgXCI3MTg4MFwiOiA3MTg0OCxcbiAgICAgIFwiNzE4ODFcIjogNzE4NDksXG4gICAgICBcIjcxODgyXCI6IDcxODUwLFxuICAgICAgXCI3MTg4M1wiOiA3MTg1MSxcbiAgICAgIFwiNzE4ODRcIjogNzE4NTIsXG4gICAgICBcIjcxODg1XCI6IDcxODUzLFxuICAgICAgXCI3MTg4NlwiOiA3MTg1NCxcbiAgICAgIFwiNzE4ODdcIjogNzE4NTUsXG4gICAgICBcIjcxODg4XCI6IDcxODU2LFxuICAgICAgXCI3MTg4OVwiOiA3MTg1NyxcbiAgICAgIFwiNzE4OTBcIjogNzE4NTgsXG4gICAgICBcIjcxODkxXCI6IDcxODU5LFxuICAgICAgXCI3MTg5MlwiOiA3MTg2MCxcbiAgICAgIFwiNzE4OTNcIjogNzE4NjEsXG4gICAgICBcIjcxODk0XCI6IDcxODYyLFxuICAgICAgXCI3MTg5NVwiOiA3MTg2MyxcbiAgICAgIFwiNzE4OTZcIjogNzE4NjQsXG4gICAgICBcIjcxODk3XCI6IDcxODY1LFxuICAgICAgXCI3MTg5OFwiOiA3MTg2NixcbiAgICAgIFwiNzE4OTlcIjogNzE4NjcsXG4gICAgICBcIjcxOTAwXCI6IDcxODY4LFxuICAgICAgXCI3MTkwMVwiOiA3MTg2OSxcbiAgICAgIFwiNzE5MDJcIjogNzE4NzAsXG4gICAgICBcIjcxOTAzXCI6IDcxODcxXG4gICAgfTtcblxuICAgIHZhciBwYXJzZXIgPSBfX2NvbW1vbmpzKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgIC8vIHJlZ2pzcGFyc2VyXG4gICAgICAvL1xuICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAvL1xuICAgICAgLy8gU2VlIEVDTUEtMjYyIFN0YW5kYXJkOiAxNS4xMC4xXG4gICAgICAvL1xuICAgICAgLy8gTk9URTogVGhlIEVDTUEtMjYyIHN0YW5kYXJkIHVzZXMgdGhlIHRlcm0gXCJBc3NlcnRpb25cIiBmb3IgL14vLiBIZXJlIHRoZVxuICAgICAgLy8gICB0ZXJtIFwiQW5jaG9yXCIgaXMgdXNlZC5cbiAgICAgIC8vXG4gICAgICAvLyBQYXR0ZXJuIDo6XG4gICAgICAvLyAgICAgIERpc2p1bmN0aW9uXG4gICAgICAvL1xuICAgICAgLy8gRGlzanVuY3Rpb24gOjpcbiAgICAgIC8vICAgICAgQWx0ZXJuYXRpdmVcbiAgICAgIC8vICAgICAgQWx0ZXJuYXRpdmUgfCBEaXNqdW5jdGlvblxuICAgICAgLy9cbiAgICAgIC8vIEFsdGVybmF0aXZlIDo6XG4gICAgICAvLyAgICAgIFtlbXB0eV1cbiAgICAgIC8vICAgICAgQWx0ZXJuYXRpdmUgVGVybVxuICAgICAgLy9cbiAgICAgIC8vIFRlcm0gOjpcbiAgICAgIC8vICAgICAgQW5jaG9yXG4gICAgICAvLyAgICAgIEF0b21cbiAgICAgIC8vICAgICAgQXRvbSBRdWFudGlmaWVyXG4gICAgICAvL1xuICAgICAgLy8gQW5jaG9yIDo6XG4gICAgICAvLyAgICAgIF5cbiAgICAgIC8vICAgICAgJFxuICAgICAgLy8gICAgICBcXCBiXG4gICAgICAvLyAgICAgIFxcIEJcbiAgICAgIC8vICAgICAgKCA/ID0gRGlzanVuY3Rpb24gKVxuICAgICAgLy8gICAgICAoID8gISBEaXNqdW5jdGlvbiApXG4gICAgICAvL1xuICAgICAgLy8gUXVhbnRpZmllciA6OlxuICAgICAgLy8gICAgICBRdWFudGlmaWVyUHJlZml4XG4gICAgICAvLyAgICAgIFF1YW50aWZpZXJQcmVmaXggP1xuICAgICAgLy9cbiAgICAgIC8vIFF1YW50aWZpZXJQcmVmaXggOjpcbiAgICAgIC8vICAgICAgKlxuICAgICAgLy8gICAgICArXG4gICAgICAvLyAgICAgID9cbiAgICAgIC8vICAgICAgeyBEZWNpbWFsRGlnaXRzIH1cbiAgICAgIC8vICAgICAgeyBEZWNpbWFsRGlnaXRzICwgfVxuICAgICAgLy8gICAgICB7IERlY2ltYWxEaWdpdHMgLCBEZWNpbWFsRGlnaXRzIH1cbiAgICAgIC8vXG4gICAgICAvLyBBdG9tIDo6XG4gICAgICAvLyAgICAgIFBhdHRlcm5DaGFyYWN0ZXJcbiAgICAgIC8vICAgICAgLlxuICAgICAgLy8gICAgICBcXCBBdG9tRXNjYXBlXG4gICAgICAvLyAgICAgIENoYXJhY3RlckNsYXNzXG4gICAgICAvLyAgICAgICggRGlzanVuY3Rpb24gKVxuICAgICAgLy8gICAgICAoID8gOiBEaXNqdW5jdGlvbiApXG4gICAgICAvL1xuICAgICAgLy8gUGF0dGVybkNoYXJhY3RlciA6OlxuICAgICAgLy8gICAgICBTb3VyY2VDaGFyYWN0ZXIgYnV0IG5vdCBhbnkgb2Y6IF4gJCBcXCAuICogKyA/ICggKSBbIF0geyB9IHxcbiAgICAgIC8vXG4gICAgICAvLyBBdG9tRXNjYXBlIDo6XG4gICAgICAvLyAgICAgIERlY2ltYWxFc2NhcGVcbiAgICAgIC8vICAgICAgQ2hhcmFjdGVyRXNjYXBlXG4gICAgICAvLyAgICAgIENoYXJhY3RlckNsYXNzRXNjYXBlXG4gICAgICAvL1xuICAgICAgLy8gQ2hhcmFjdGVyRXNjYXBlW1VdIDo6XG4gICAgICAvLyAgICAgIENvbnRyb2xFc2NhcGVcbiAgICAgIC8vICAgICAgYyBDb250cm9sTGV0dGVyXG4gICAgICAvLyAgICAgIEhleEVzY2FwZVNlcXVlbmNlXG4gICAgICAvLyAgICAgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVs/VV0gKEVTNilcbiAgICAgIC8vICAgICAgSWRlbnRpdHlFc2NhcGVbP1VdXG4gICAgICAvL1xuICAgICAgLy8gQ29udHJvbEVzY2FwZSA6OlxuICAgICAgLy8gICAgICBvbmUgb2YgZiBuIHIgdCB2XG4gICAgICAvLyBDb250cm9sTGV0dGVyIDo6XG4gICAgICAvLyAgICAgIG9uZSBvZlxuICAgICAgLy8gICAgICAgICAgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgbSBuIG8gcCBxIHIgcyB0IHUgdiB3IHggeSB6XG4gICAgICAvLyAgICAgICAgICBBIEIgQyBEIEUgRiBHIEggSSBKIEsgTCBNIE4gTyBQIFEgUiBTIFQgVSBWIFcgWCBZIFpcbiAgICAgIC8vXG4gICAgICAvLyBJZGVudGl0eUVzY2FwZSA6OlxuICAgICAgLy8gICAgICBTb3VyY2VDaGFyYWN0ZXIgYnV0IG5vdCBJZGVudGlmaWVyUGFydFxuICAgICAgLy8gICAgICA8WldKPlxuICAgICAgLy8gICAgICA8WldOSj5cbiAgICAgIC8vXG4gICAgICAvLyBEZWNpbWFsRXNjYXBlIDo6XG4gICAgICAvLyAgICAgIERlY2ltYWxJbnRlZ2VyTGl0ZXJhbCBbbG9va2FoZWFkIOKIiSBEZWNpbWFsRGlnaXRdXG4gICAgICAvL1xuICAgICAgLy8gQ2hhcmFjdGVyQ2xhc3NFc2NhcGUgOjpcbiAgICAgIC8vICAgICAgb25lIG9mIGQgRCBzIFMgdyBXXG4gICAgICAvL1xuICAgICAgLy8gQ2hhcmFjdGVyQ2xhc3MgOjpcbiAgICAgIC8vICAgICAgWyBbbG9va2FoZWFkIOKIiSB7Xn1dIENsYXNzUmFuZ2VzIF1cbiAgICAgIC8vICAgICAgWyBeIENsYXNzUmFuZ2VzIF1cbiAgICAgIC8vXG4gICAgICAvLyBDbGFzc1JhbmdlcyA6OlxuICAgICAgLy8gICAgICBbZW1wdHldXG4gICAgICAvLyAgICAgIE5vbmVtcHR5Q2xhc3NSYW5nZXNcbiAgICAgIC8vXG4gICAgICAvLyBOb25lbXB0eUNsYXNzUmFuZ2VzIDo6XG4gICAgICAvLyAgICAgIENsYXNzQXRvbVxuICAgICAgLy8gICAgICBDbGFzc0F0b20gTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxuICAgICAgLy8gICAgICBDbGFzc0F0b20gLSBDbGFzc0F0b20gQ2xhc3NSYW5nZXNcbiAgICAgIC8vXG4gICAgICAvLyBOb25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoIDo6XG4gICAgICAvLyAgICAgIENsYXNzQXRvbVxuICAgICAgLy8gICAgICBDbGFzc0F0b21Ob0Rhc2ggTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxuICAgICAgLy8gICAgICBDbGFzc0F0b21Ob0Rhc2ggLSBDbGFzc0F0b20gQ2xhc3NSYW5nZXNcbiAgICAgIC8vXG4gICAgICAvLyBDbGFzc0F0b20gOjpcbiAgICAgIC8vICAgICAgLVxuICAgICAgLy8gICAgICBDbGFzc0F0b21Ob0Rhc2hcbiAgICAgIC8vXG4gICAgICAvLyBDbGFzc0F0b21Ob0Rhc2ggOjpcbiAgICAgIC8vICAgICAgU291cmNlQ2hhcmFjdGVyIGJ1dCBub3Qgb25lIG9mIFxcIG9yIF0gb3IgLVxuICAgICAgLy8gICAgICBcXCBDbGFzc0VzY2FwZVxuICAgICAgLy9cbiAgICAgIC8vIENsYXNzRXNjYXBlIDo6XG4gICAgICAvLyAgICAgIERlY2ltYWxFc2NhcGVcbiAgICAgIC8vICAgICAgYlxuICAgICAgLy8gICAgICBDaGFyYWN0ZXJFc2NhcGVcbiAgICAgIC8vICAgICAgQ2hhcmFjdGVyQ2xhc3NFc2NhcGVcblxuICAgICAgKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBmdW5jdGlvbiBwYXJzZShzdHIsIGZsYWdzKSB7XG4gICAgICAgICAgZnVuY3Rpb24gYWRkUmF3KG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucmF3ID0gc3RyLnN1YnN0cmluZyhub2RlLnJhbmdlWzBdLCBub2RlLnJhbmdlWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVJhd1N0YXJ0KG5vZGUsIHN0YXJ0KSB7XG4gICAgICAgICAgICBub2RlLnJhbmdlWzBdID0gc3RhcnQ7XG4gICAgICAgICAgICByZXR1cm4gYWRkUmF3KG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFuY2hvcihraW5kLCByYXdMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRSYXcoe1xuICAgICAgICAgICAgICB0eXBlOiAnYW5jaG9yJyxcbiAgICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgICAgcmFuZ2U6IFtwb3MgLSByYXdMZW5ndGgsIHBvc11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVZhbHVlKGtpbmQsIGNvZGVQb2ludCwgZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRSYXcoe1xuICAgICAgICAgICAgICB0eXBlOiAndmFsdWUnLFxuICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICBjb2RlUG9pbnQ6IGNvZGVQb2ludCxcbiAgICAgICAgICAgICAgcmFuZ2U6IFtmcm9tLCB0b11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUVzY2FwZWQoa2luZCwgY29kZVBvaW50LCB2YWx1ZSwgZnJvbU9mZnNldCkge1xuICAgICAgICAgICAgZnJvbU9mZnNldCA9IGZyb21PZmZzZXQgfHwgMDtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWYWx1ZShraW5kLCBjb2RlUG9pbnQsIHBvcyAtICh2YWx1ZS5sZW5ndGggKyBmcm9tT2Zmc2V0KSwgcG9zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVDaGFyYWN0ZXIobWF0Y2hlcykge1xuICAgICAgICAgICAgdmFyIF9jaGFyID0gbWF0Y2hlc1swXTtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IF9jaGFyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoaGFzVW5pY29kZUZsYWcpIHtcbiAgICAgICAgICAgICAgdmFyIHNlY29uZDtcbiAgICAgICAgICAgICAgaWYgKF9jaGFyLmxlbmd0aCA9PT0gMSAmJiBmaXJzdCA+PSAweEQ4MDAgJiYgZmlyc3QgPD0gMHhEQkZGKSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kID0gbG9va2FoZWFkKCkuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vjb25kID49IDB4REMwMCAmJiBzZWNvbmQgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgICAgICAvLyBVbmljb2RlIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWYWx1ZSgnc3ltYm9sJywgKGZpcnN0IC0gMHhEODAwKSAqIDB4NDAwICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMCwgcG9zIC0gMiwgcG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWYWx1ZSgnc3ltYm9sJywgZmlyc3QsIHBvcyAtIDEsIHBvcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlRGlzanVuY3Rpb24oYWx0ZXJuYXRpdmVzLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgICAgICAgIHR5cGU6ICdkaXNqdW5jdGlvbicsXG4gICAgICAgICAgICAgIGJvZHk6IGFsdGVybmF0aXZlcyxcbiAgICAgICAgICAgICAgcmFuZ2U6IFtmcm9tLCB0b11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURvdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRSYXcoe1xuICAgICAgICAgICAgICB0eXBlOiAnZG90JyxcbiAgICAgICAgICAgICAgcmFuZ2U6IFtwb3MgLSAxLCBwb3NdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVDaGFyYWN0ZXJDbGFzc0VzY2FwZSh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgICAgICAgIHR5cGU6ICdjaGFyYWN0ZXJDbGFzc0VzY2FwZScsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgcmFuZ2U6IFtwb3MgLSAyLCBwb3NdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVSZWZlcmVuY2UobWF0Y2hJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgICAgICAgIHR5cGU6ICdyZWZlcmVuY2UnLFxuICAgICAgICAgICAgICBtYXRjaEluZGV4OiBwYXJzZUludChtYXRjaEluZGV4LCAxMCksXG4gICAgICAgICAgICAgIHJhbmdlOiBbcG9zIC0gMSAtIG1hdGNoSW5kZXgubGVuZ3RoLCBwb3NdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVHcm91cChiZWhhdmlvciwgZGlzanVuY3Rpb24sIGZyb20sIHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkUmF3KHtcbiAgICAgICAgICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgICAgICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yLFxuICAgICAgICAgICAgICBib2R5OiBkaXNqdW5jdGlvbixcbiAgICAgICAgICAgICAgcmFuZ2U6IFtmcm9tLCB0b11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVF1YW50aWZpZXIobWluLCBtYXgsIGZyb20sIHRvKSB7XG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBmcm9tID0gcG9zIC0gMTtcbiAgICAgICAgICAgICAgdG8gPSBwb3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhZGRSYXcoe1xuICAgICAgICAgICAgICB0eXBlOiAncXVhbnRpZmllcicsXG4gICAgICAgICAgICAgIG1pbjogbWluLFxuICAgICAgICAgICAgICBtYXg6IG1heCxcbiAgICAgICAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICAgICAgICBib2R5OiBudWxsLCAvLyBzZXQgbGF0ZXIgb25cbiAgICAgICAgICAgICAgcmFuZ2U6IFtmcm9tLCB0b11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFsdGVybmF0aXZlKHRlcm1zLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgICAgICAgIHR5cGU6ICdhbHRlcm5hdGl2ZScsXG4gICAgICAgICAgICAgIGJvZHk6IHRlcm1zLFxuICAgICAgICAgICAgICByYW5nZTogW2Zyb20sIHRvXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ2hhcmFjdGVyQ2xhc3MoY2xhc3NSYW5nZXMsIG5lZ2F0aXZlLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgICAgICAgIHR5cGU6ICdjaGFyYWN0ZXJDbGFzcycsXG4gICAgICAgICAgICAgIGJvZHk6IGNsYXNzUmFuZ2VzLFxuICAgICAgICAgICAgICBuZWdhdGl2ZTogbmVnYXRpdmUsXG4gICAgICAgICAgICAgIHJhbmdlOiBbZnJvbSwgdG9dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVDbGFzc1JhbmdlKG1pbiwgbWF4LCBmcm9tLCB0bykge1xuICAgICAgICAgICAgLy8gU2VlIDE1LjEwLjIuMTU6XG4gICAgICAgICAgICBpZiAobWluLmNvZGVQb2ludCA+IG1heC5jb2RlUG9pbnQpIHtcbiAgICAgICAgICAgICAgYmFpbCgnaW52YWxpZCByYW5nZSBpbiBjaGFyYWN0ZXIgY2xhc3MnLCBtaW4ucmF3ICsgJy0nICsgbWF4LnJhdywgZnJvbSwgdG8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWRkUmF3KHtcbiAgICAgICAgICAgICAgdHlwZTogJ2NoYXJhY3RlckNsYXNzUmFuZ2UnLFxuICAgICAgICAgICAgICBtaW46IG1pbixcbiAgICAgICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgICAgIHJhbmdlOiBbZnJvbSwgdG9dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBmbGF0dGVuQm9keShib2R5KSB7XG4gICAgICAgICAgICBpZiAoYm9keS50eXBlID09PSAnYWx0ZXJuYXRpdmUnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBib2R5LmJvZHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gW2JvZHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGluY3IoYW1vdW50KSB7XG4gICAgICAgICAgICBhbW91bnQgPSBhbW91bnQgfHwgMTtcbiAgICAgICAgICAgIHZhciByZXMgPSBzdHIuc3Vic3RyaW5nKHBvcywgcG9zICsgYW1vdW50KTtcbiAgICAgICAgICAgIHBvcyArPSBhbW91bnQgfHwgMTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gc2tpcCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFtYXRjaCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgYmFpbCgnY2hhcmFjdGVyJywgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmluZGV4T2YodmFsdWUsIHBvcykgPT09IHBvcykge1xuICAgICAgICAgICAgICByZXR1cm4gaW5jcih2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGxvb2thaGVhZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJbcG9zXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjdXJyZW50KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YodmFsdWUsIHBvcykgPT09IHBvcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyW3BvcyArIDFdID09PSB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBtYXRjaFJlZyhyZWdFeHApIHtcbiAgICAgICAgICAgIHZhciBzdWJTdHIgPSBzdHIuc3Vic3RyaW5nKHBvcyk7XG4gICAgICAgICAgICB2YXIgcmVzID0gc3ViU3RyLm1hdGNoKHJlZ0V4cCk7XG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgIHJlcy5yYW5nZSA9IFtdO1xuICAgICAgICAgICAgICByZXMucmFuZ2VbMF0gPSBwb3M7XG4gICAgICAgICAgICAgIGluY3IocmVzWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgIHJlcy5yYW5nZVsxXSA9IHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcGFyc2VEaXNqdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIERpc2p1bmN0aW9uIDo6XG4gICAgICAgICAgICAvLyAgICAgIEFsdGVybmF0aXZlXG4gICAgICAgICAgICAvLyAgICAgIEFsdGVybmF0aXZlIHwgRGlzanVuY3Rpb25cbiAgICAgICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBmcm9tID0gcG9zO1xuICAgICAgICAgICAgcmVzLnB1c2gocGFyc2VBbHRlcm5hdGl2ZSgpKTtcblxuICAgICAgICAgICAgd2hpbGUgKG1hdGNoKCd8JykpIHtcbiAgICAgICAgICAgICAgcmVzLnB1c2gocGFyc2VBbHRlcm5hdGl2ZSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc1swXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZURpc2p1bmN0aW9uKHJlcywgZnJvbSwgcG9zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXJzZUFsdGVybmF0aXZlKCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGZyb20gPSBwb3M7XG4gICAgICAgICAgICB2YXIgdGVybTtcblxuICAgICAgICAgICAgLy8gQWx0ZXJuYXRpdmUgOjpcbiAgICAgICAgICAgIC8vICAgICAgW2VtcHR5XVxuICAgICAgICAgICAgLy8gICAgICBBbHRlcm5hdGl2ZSBUZXJtXG4gICAgICAgICAgICB3aGlsZSAodGVybSA9IHBhcnNlVGVybSgpKSB7XG4gICAgICAgICAgICAgIHJlcy5wdXNoKHRlcm0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQWx0ZXJuYXRpdmUocmVzLCBmcm9tLCBwb3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlVGVybSgpIHtcbiAgICAgICAgICAgIC8vIFRlcm0gOjpcbiAgICAgICAgICAgIC8vICAgICAgQW5jaG9yXG4gICAgICAgICAgICAvLyAgICAgIEF0b21cbiAgICAgICAgICAgIC8vICAgICAgQXRvbSBRdWFudGlmaWVyXG5cbiAgICAgICAgICAgIGlmIChwb3MgPj0gc3RyLmxlbmd0aCB8fCBjdXJyZW50KCd8JykgfHwgY3VycmVudCgnKScpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsOyAvKiBNZWFuczogVGhlIHRlcm0gaXMgZW1wdHkgKi9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFuY2hvciA9IHBhcnNlQW5jaG9yKCk7XG5cbiAgICAgICAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFuY2hvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF0b20gPSBwYXJzZUF0b20oKTtcbiAgICAgICAgICAgIGlmICghYXRvbSkge1xuICAgICAgICAgICAgICBiYWlsKCdFeHBlY3RlZCBhdG9tJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcXVhbnRpZmllciA9IHBhcnNlUXVhbnRpZmllcigpIHx8IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHF1YW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgcXVhbnRpZmllci5ib2R5ID0gZmxhdHRlbkJvZHkoYXRvbSk7XG4gICAgICAgICAgICAgIC8vIFRoZSBxdWFudGlmaWVyIGNvbnRhaW5zIHRoZSBhdG9tLiBUaGVyZWZvcmUsIHRoZSBiZWdpbm5pbmcgb2YgdGhlXG4gICAgICAgICAgICAgIC8vIHF1YW50aWZpZXIgcmFuZ2UgaXMgZ2l2ZW4gYnkgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXRvbS5cbiAgICAgICAgICAgICAgdXBkYXRlUmF3U3RhcnQocXVhbnRpZmllciwgYXRvbS5yYW5nZVswXSk7XG4gICAgICAgICAgICAgIHJldHVybiBxdWFudGlmaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF0b207XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcGFyc2VHcm91cChtYXRjaEEsIHR5cGVBLCBtYXRjaEIsIHR5cGVCKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IG51bGwsXG4gICAgICAgICAgICAgICAgZnJvbSA9IHBvcztcblxuICAgICAgICAgICAgaWYgKG1hdGNoKG1hdGNoQSkpIHtcbiAgICAgICAgICAgICAgdHlwZSA9IHR5cGVBO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaChtYXRjaEIpKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSB0eXBlQjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJvZHkgPSBwYXJzZURpc2p1bmN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgYmFpbCgnRXhwZWN0ZWQgZGlzanVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNraXAoJyknKTtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGNyZWF0ZUdyb3VwKHR5cGUsIGZsYXR0ZW5Cb2R5KGJvZHkpLCBmcm9tLCBwb3MpO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgY2xvc2VkIGdyb3Vwcy4gVGhpcyBpcyByZXF1aXJlZCBmb3JcbiAgICAgICAgICAgICAgLy8gcGFyc2VEZWNpbWFsRXNjYXBlKCkuIEluIGNhc2UgdGhlIHN0cmluZyBpcyBwYXJzZWQgYSBzZWNvbmQgdGltZSB0aGVcbiAgICAgICAgICAgICAgLy8gdmFsdWUgYWxyZWFkeSBob2xkcyB0aGUgdG90YWwgY291bnQgYW5kIG5vIGluY3JlbWVudGF0aW9uIGlzIHJlcXVpcmVkLlxuICAgICAgICAgICAgICBpZiAoZmlyc3RJdGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjbG9zZWRDYXB0dXJlQ291bnRlcisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcGFyc2VBbmNob3IoKSB7XG4gICAgICAgICAgICAvLyBBbmNob3IgOjpcbiAgICAgICAgICAgIC8vICAgICAgXlxuICAgICAgICAgICAgLy8gICAgICAkXG4gICAgICAgICAgICAvLyAgICAgIFxcIGJcbiAgICAgICAgICAgIC8vICAgICAgXFwgQlxuICAgICAgICAgICAgLy8gICAgICAoID8gPSBEaXNqdW5jdGlvbiApXG4gICAgICAgICAgICAvLyAgICAgICggPyAhIERpc2p1bmN0aW9uIClcbiAgICAgICAgICAgIHZhciByZXMsXG4gICAgICAgICAgICAgICAgZnJvbSA9IHBvcztcblxuICAgICAgICAgICAgaWYgKG1hdGNoKCdeJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFuY2hvcignc3RhcnQnLCAxIC8qIHJhd0xlbmd0aCAqLyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCckJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFuY2hvcignZW5kJywgMSAvKiByYXdMZW5ndGggKi8pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnXFxcXGInKSkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQW5jaG9yKCdib3VuZGFyeScsIDIgLyogcmF3TGVuZ3RoICovKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1xcXFxCJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFuY2hvcignbm90LWJvdW5kYXJ5JywgMiAvKiByYXdMZW5ndGggKi8pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlR3JvdXAoJyg/PScsICdsb29rYWhlYWQnLCAnKD8hJywgJ25lZ2F0aXZlTG9va2FoZWFkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcGFyc2VRdWFudGlmaWVyKCkge1xuICAgICAgICAgICAgLy8gUXVhbnRpZmllciA6OlxuICAgICAgICAgICAgLy8gICAgICBRdWFudGlmaWVyUHJlZml4XG4gICAgICAgICAgICAvLyAgICAgIFF1YW50aWZpZXJQcmVmaXggP1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFF1YW50aWZpZXJQcmVmaXggOjpcbiAgICAgICAgICAgIC8vICAgICAgKlxuICAgICAgICAgICAgLy8gICAgICArXG4gICAgICAgICAgICAvLyAgICAgID9cbiAgICAgICAgICAgIC8vICAgICAgeyBEZWNpbWFsRGlnaXRzIH1cbiAgICAgICAgICAgIC8vICAgICAgeyBEZWNpbWFsRGlnaXRzICwgfVxuICAgICAgICAgICAgLy8gICAgICB7IERlY2ltYWxEaWdpdHMgLCBEZWNpbWFsRGlnaXRzIH1cblxuICAgICAgICAgICAgdmFyIHJlcyxcbiAgICAgICAgICAgICAgICBmcm9tID0gcG9zO1xuICAgICAgICAgICAgdmFyIHF1YW50aWZpZXI7XG4gICAgICAgICAgICB2YXIgbWluLCBtYXg7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICAgIHF1YW50aWZpZXIgPSBjcmVhdGVRdWFudGlmaWVyKDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKycpKSB7XG4gICAgICAgICAgICAgIHF1YW50aWZpZXIgPSBjcmVhdGVRdWFudGlmaWVyKDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgICAgIHF1YW50aWZpZXIgPSBjcmVhdGVRdWFudGlmaWVyKDAsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXMgPSBtYXRjaFJlZygvXlxceyhbMC05XSspXFx9LykpIHtcbiAgICAgICAgICAgICAgbWluID0gcGFyc2VJbnQocmVzWzFdLCAxMCk7XG4gICAgICAgICAgICAgIHF1YW50aWZpZXIgPSBjcmVhdGVRdWFudGlmaWVyKG1pbiwgbWluLCByZXMucmFuZ2VbMF0sIHJlcy5yYW5nZVsxXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlcyA9IG1hdGNoUmVnKC9eXFx7KFswLTldKyksXFx9LykpIHtcbiAgICAgICAgICAgICAgbWluID0gcGFyc2VJbnQocmVzWzFdLCAxMCk7XG4gICAgICAgICAgICAgIHF1YW50aWZpZXIgPSBjcmVhdGVRdWFudGlmaWVyKG1pbiwgdW5kZWZpbmVkLCByZXMucmFuZ2VbMF0sIHJlcy5yYW5nZVsxXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlcyA9IG1hdGNoUmVnKC9eXFx7KFswLTldKyksKFswLTldKylcXH0vKSkge1xuICAgICAgICAgICAgICBtaW4gPSBwYXJzZUludChyZXNbMV0sIDEwKTtcbiAgICAgICAgICAgICAgbWF4ID0gcGFyc2VJbnQocmVzWzJdLCAxMCk7XG4gICAgICAgICAgICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBiYWlsKCdudW1iZXJzIG91dCBvZiBvcmRlciBpbiB7fSBxdWFudGlmaWVyJywgJycsIGZyb20sIHBvcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcXVhbnRpZmllciA9IGNyZWF0ZVF1YW50aWZpZXIobWluLCBtYXgsIHJlcy5yYW5nZVswXSwgcmVzLnJhbmdlWzFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHF1YW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKCc/JykpIHtcbiAgICAgICAgICAgICAgICBxdWFudGlmaWVyLmdyZWVkeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHF1YW50aWZpZXIucmFuZ2VbMV0gKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcXVhbnRpZmllcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXJzZUF0b20oKSB7XG4gICAgICAgICAgICAvLyBBdG9tIDo6XG4gICAgICAgICAgICAvLyAgICAgIFBhdHRlcm5DaGFyYWN0ZXJcbiAgICAgICAgICAgIC8vICAgICAgLlxuICAgICAgICAgICAgLy8gICAgICBcXCBBdG9tRXNjYXBlXG4gICAgICAgICAgICAvLyAgICAgIENoYXJhY3RlckNsYXNzXG4gICAgICAgICAgICAvLyAgICAgICggRGlzanVuY3Rpb24gKVxuICAgICAgICAgICAgLy8gICAgICAoID8gOiBEaXNqdW5jdGlvbiApXG5cbiAgICAgICAgICAgIHZhciByZXM7XG5cbiAgICAgICAgICAgIC8vIGp2aWVyZWNrOiBhbGxvdyAnXScsICd9JyBoZXJlIGFzIHdlbGwgdG8gYmUgY29tcGF0aWJsZSB3aXRoIGJyb3dzZXInc1xuICAgICAgICAgICAgLy8gICBpbXBsZW1lbnRhdGlvbnM6ICddJy5tYXRjaCgvXS8pO1xuICAgICAgICAgICAgLy8gaWYgKHJlcyA9IG1hdGNoUmVnKC9eW15eJFxcXFwuKis/KClbXFxde318XS8pKSB7XG4gICAgICAgICAgICBpZiAocmVzID0gbWF0Y2hSZWcoL15bXl4kXFxcXC4qKz8oKXtbfF0vKSkge1xuICAgICAgICAgICAgICAvLyAgICAgIFBhdHRlcm5DaGFyYWN0ZXJcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNoYXJhY3RlcihyZXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICAgIC8vICAgICAgLlxuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRG90KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdcXFxcJykpIHtcbiAgICAgICAgICAgICAgLy8gICAgICBcXCBBdG9tRXNjYXBlXG4gICAgICAgICAgICAgIHJlcyA9IHBhcnNlQXRvbUVzY2FwZSgpO1xuICAgICAgICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgICAgIGJhaWwoJ2F0b21Fc2NhcGUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXMgPSBwYXJzZUNoYXJhY3RlckNsYXNzKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vICAgICAgKCBEaXNqdW5jdGlvbiApXG4gICAgICAgICAgICAgIC8vICAgICAgKCA/IDogRGlzanVuY3Rpb24gKVxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VHcm91cCgnKD86JywgJ2lnbm9yZScsICcoJywgJ25vcm1hbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlVW5pY29kZVN1cnJvZ2F0ZVBhaXJFc2NhcGUoZmlyc3RFc2NhcGUpIHtcbiAgICAgICAgICAgIGlmIChoYXNVbmljb2RlRmxhZykge1xuICAgICAgICAgICAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICAgICAgICAgICAgaWYgKGZpcnN0RXNjYXBlLmtpbmQgPT0gJ3VuaWNvZGVFc2NhcGUnICYmIChmaXJzdCA9IGZpcnN0RXNjYXBlLmNvZGVQb2ludCkgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRiAmJiBjdXJyZW50KCdcXFxcJykgJiYgbmV4dCgndScpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZQb3MgPSBwb3M7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZEVzY2FwZSA9IHBhcnNlQ2xhc3NFc2NhcGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vjb25kRXNjYXBlLmtpbmQgPT0gJ3VuaWNvZGVFc2NhcGUnICYmIChzZWNvbmQgPSBzZWNvbmRFc2NhcGUuY29kZVBvaW50KSA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xuICAgICAgICAgICAgICAgICAgLy8gVW5pY29kZSBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgICAgICAgZmlyc3RFc2NhcGUucmFuZ2VbMV0gPSBzZWNvbmRFc2NhcGUucmFuZ2VbMV07XG4gICAgICAgICAgICAgICAgICBmaXJzdEVzY2FwZS5jb2RlUG9pbnQgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuICAgICAgICAgICAgICAgICAgZmlyc3RFc2NhcGUudHlwZSA9ICd2YWx1ZSc7XG4gICAgICAgICAgICAgICAgICBmaXJzdEVzY2FwZS5raW5kID0gJ3VuaWNvZGVDb2RlUG9pbnRFc2NhcGUnO1xuICAgICAgICAgICAgICAgICAgYWRkUmF3KGZpcnN0RXNjYXBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcG9zID0gcHJldlBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaXJzdEVzY2FwZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXJzZUNsYXNzRXNjYXBlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXRvbUVzY2FwZSh0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXJzZUF0b21Fc2NhcGUoaW5zaWRlQ2hhcmFjdGVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEF0b21Fc2NhcGUgOjpcbiAgICAgICAgICAgIC8vICAgICAgRGVjaW1hbEVzY2FwZVxuICAgICAgICAgICAgLy8gICAgICBDaGFyYWN0ZXJFc2NhcGVcbiAgICAgICAgICAgIC8vICAgICAgQ2hhcmFjdGVyQ2xhc3NFc2NhcGVcblxuICAgICAgICAgICAgdmFyIHJlcyxcbiAgICAgICAgICAgICAgICBmcm9tID0gcG9zO1xuXG4gICAgICAgICAgICByZXMgPSBwYXJzZURlY2ltYWxFc2NhcGUoKTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9yIENsYXNzRXNjYXBlXG4gICAgICAgICAgICBpZiAoaW5zaWRlQ2hhcmFjdGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKCdiJykpIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4xMC4yLjE5XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByb2R1Y3Rpb24gQ2xhc3NFc2NhcGUgOjogYiBldmFsdWF0ZXMgYnkgcmV0dXJuaW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIENoYXJTZXQgY29udGFpbmluZyB0aGUgb25lIGNoYXJhY3RlciA8QlM+IChVbmljb2RlIHZhbHVlIDAwMDgpLlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVFc2NhcGVkKCdzaW5nbGVFc2NhcGUnLCAweDAwMDgsICdcXFxcYicpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdCJykpIHtcbiAgICAgICAgICAgICAgICBiYWlsKCdcXFxcQiBub3QgcG9zc2libGUgaW5zaWRlIG9mIENoYXJhY3RlckNsYXNzJywgJycsIGZyb20pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcyA9IHBhcnNlQ2hhcmFjdGVyRXNjYXBlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcGFyc2VEZWNpbWFsRXNjYXBlKCkge1xuICAgICAgICAgICAgLy8gRGVjaW1hbEVzY2FwZSA6OlxuICAgICAgICAgICAgLy8gICAgICBEZWNpbWFsSW50ZWdlckxpdGVyYWwgW2xvb2thaGVhZCDiiIkgRGVjaW1hbERpZ2l0XVxuICAgICAgICAgICAgLy8gICAgICBDaGFyYWN0ZXJDbGFzc0VzY2FwZSA6OiBvbmUgb2YgZCBEIHMgUyB3IFdcblxuICAgICAgICAgICAgdmFyIHJlcywgbWF0Y2g7XG5cbiAgICAgICAgICAgIGlmIChyZXMgPSBtYXRjaFJlZygvXig/ITApXFxkKy8pKSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gcmVzWzBdO1xuICAgICAgICAgICAgICB2YXIgcmVmSWR4ID0gcGFyc2VJbnQocmVzWzBdLCAxMCk7XG4gICAgICAgICAgICAgIGlmIChyZWZJZHggPD0gY2xvc2VkQ2FwdHVyZUNvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbnVtYmVyIGlzIHNtYWxsZXIgdGhhbiB0aGUgbm9ybWFsLWdyb3VwcyBmb3VuZCBzb1xuICAgICAgICAgICAgICAgIC8vIGZhciwgdGhlbiBpdCBpcyBhIHJlZmVyZW5jZS4uLlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZWZlcmVuY2UocmVzWzBdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAuLi4gb3RoZXJ3aXNlIGl0IG5lZWRzIHRvIGJlIGludGVycHJldGVkIGFzIGEgb2N0YWwgKGlmIHRoZVxuICAgICAgICAgICAgICAgIC8vIG51bWJlciBpcyBpbiBhbiBvY3RhbCBmb3JtYXQpLiBJZiBpdCBpcyBOT1Qgb2N0YWwgZm9ybWF0LFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gdGhlIHNsYXNoIGlzIGlnbm9yZWQgYW5kIHRoZSBudW1iZXIgaXMgbWF0Y2hlZCBsYXRlclxuICAgICAgICAgICAgICAgIC8vIGFzIG5vcm1hbCBjaGFyYWN0ZXJzLlxuXG4gICAgICAgICAgICAgICAgLy8gUmVjYWxsIHRoZSBuZWdhdGl2ZSBkZWNpc2lvbiB0byBkZWNpZGUgaWYgdGhlIGlucHV0IG11c3QgYmUgcGFyc2VkXG4gICAgICAgICAgICAgICAgLy8gYSBzZWNvbmQgdGltZSB3aXRoIHRoZSB0b3RhbCBub3JtYWwtZ3JvdXBzLlxuICAgICAgICAgICAgICAgIGJhY2tyZWZEZW5pZWQucHVzaChyZWZJZHgpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHBvc2l0aW9uIGFnYWluLCBhcyBtYXliZSBvbmx5IHBhcnRzIG9mIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgIC8vIG1hdGNoZWQgbnVtYmVycyBhcmUgYWN0dWFsIG9jdGFsIG51bWJlcnMuIEUuZy4gaW4gJzAxOScgb25seVxuICAgICAgICAgICAgICAgIC8vIHRoZSAnMDEnIHNob3VsZCBiZSBtYXRjaGVkLlxuICAgICAgICAgICAgICAgIGluY3IoLXJlc1swXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMgPSBtYXRjaFJlZygvXlswLTddezEsM30vKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ29jdGFsJywgcGFyc2VJbnQocmVzWzBdLCA4KSwgcmVzWzBdLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZW5kIHVwIGhlcmUsIHdlIGhhdmUgYSBjYXNlIGxpa2UgL1xcOTEvLiBUaGVuIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gZmlyc3Qgc2xhc2ggaXMgdG8gYmUgaWdub3JlZCBhbmQgdGhlIDkgJiAxIHRvIGJlIHRyZWF0ZWRcbiAgICAgICAgICAgICAgICAgIC8vIGxpa2Ugb3JkaW5hcnkgY2hhcmFjdGVycy4gQ3JlYXRlIGEgY2hhcmFjdGVyIGZvciB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IG51bWJlciBvbmx5IGhlcmUgLSBvdGhlciBudW1iZXItY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgLy8gKGlmIGF2YWlsYWJsZSkgd2lsbCBiZSBtYXRjaGVkIGxhdGVyLlxuICAgICAgICAgICAgICAgICAgcmVzID0gY3JlYXRlQ2hhcmFjdGVyKG1hdGNoUmVnKC9eWzg5XS8pKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVSYXdTdGFydChyZXMsIHJlcy5yYW5nZVswXSAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBhbGxvdyBvY3RhbCBudW1iZXJzIGluIHRoZSBmb2xsb3dpbmcuIEFsbCBtYXRjaGVkIG51bWJlcnMgc3RhcnRcbiAgICAgICAgICAgIC8vIHdpdGggYSB6ZXJvIChpZiB0aGUgZG8gbm90LCB0aGUgcHJldmlvdXMgaWYtYnJhbmNoIGlzIGV4ZWN1dGVkKS5cbiAgICAgICAgICAgIC8vIElmIHRoZSBudW1iZXIgaXMgbm90IG9jdGFsIGZvcm1hdCBhbmQgc3RhcnRzIHdpdGggemVybyAoZS5nLiBgMDkxYClcbiAgICAgICAgICAgIC8vIHRoZW4gb25seSB0aGUgemVyb3MgYDBgIGlzIHRyZWF0ZWQgaGVyZSBhbmQgdGhlIGA5MWAgYXJlIG9yZGluYXJ5XG4gICAgICAgICAgICAvLyBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgLy8gRXhhbXBsZTpcbiAgICAgICAgICAgIC8vICAgL1xcMDkxLy5leGVjKCdcXDA5MScpWzBdLmxlbmd0aCA9PT0gM1xuICAgICAgICAgICAgZWxzZSBpZiAocmVzID0gbWF0Y2hSZWcoL15bMC03XXsxLDN9LykpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHJlc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoL14wezEsM30kLy50ZXN0KG1hdGNoKSkge1xuICAgICAgICAgICAgICAgICAgLy8gSWYgdGhleSBhcmUgYWxsIHplcm9zLCB0aGVuIG9ubHkgdGFrZSB0aGUgZmlyc3Qgb25lLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ251bGwnLCAweDAwMDAsICcwJywgbWF0Y2gubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVFc2NhcGVkKCdvY3RhbCcsIHBhcnNlSW50KG1hdGNoLCA4KSwgbWF0Y2gsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXMgPSBtYXRjaFJlZygvXltkRHNTd1ddLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hhcmFjdGVyQ2xhc3NFc2NhcGUocmVzWzBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlQ2hhcmFjdGVyRXNjYXBlKCkge1xuICAgICAgICAgICAgLy8gQ2hhcmFjdGVyRXNjYXBlIDo6XG4gICAgICAgICAgICAvLyAgICAgIENvbnRyb2xFc2NhcGVcbiAgICAgICAgICAgIC8vICAgICAgYyBDb250cm9sTGV0dGVyXG4gICAgICAgICAgICAvLyAgICAgIEhleEVzY2FwZVNlcXVlbmNlXG4gICAgICAgICAgICAvLyAgICAgIFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVxuICAgICAgICAgICAgLy8gICAgICBJZGVudGl0eUVzY2FwZVxuXG4gICAgICAgICAgICB2YXIgcmVzO1xuICAgICAgICAgICAgaWYgKHJlcyA9IG1hdGNoUmVnKC9eW2ZucnR2XS8pKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRyb2xFc2NhcGVcbiAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IDA7XG4gICAgICAgICAgICAgIHN3aXRjaCAocmVzWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAweDAwOTticmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IDB4MDBBO2JyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gMHgwMEI7YnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAweDAwQzticmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IDB4MDBEO2JyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVFc2NhcGVkKCdzaW5nbGVFc2NhcGUnLCBjb2RlUG9pbnQsICdcXFxcJyArIHJlc1swXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlcyA9IG1hdGNoUmVnKC9eYyhbYS16QS1aXSkvKSkge1xuICAgICAgICAgICAgICAvLyBjIENvbnRyb2xMZXR0ZXJcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ2NvbnRyb2xMZXR0ZXInLCByZXNbMV0uY2hhckNvZGVBdCgwKSAlIDMyLCByZXNbMV0sIDIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXMgPSBtYXRjaFJlZygvXngoWzAtOWEtZkEtRl17Mn0pLykpIHtcbiAgICAgICAgICAgICAgLy8gSGV4RXNjYXBlU2VxdWVuY2VcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ2hleGFkZWNpbWFsRXNjYXBlJywgcGFyc2VJbnQocmVzWzFdLCAxNiksIHJlc1sxXSwgMik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlcyA9IG1hdGNoUmVnKC9edShbMC05YS1mQS1GXXs0fSkvKSkge1xuICAgICAgICAgICAgICAvLyBVbmljb2RlRXNjYXBlU2VxdWVuY2VcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVW5pY29kZVN1cnJvZ2F0ZVBhaXJFc2NhcGUoY3JlYXRlRXNjYXBlZCgndW5pY29kZUVzY2FwZScsIHBhcnNlSW50KHJlc1sxXSwgMTYpLCByZXNbMV0sIDIpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzVW5pY29kZUZsYWcgJiYgKHJlcyA9IG1hdGNoUmVnKC9edVxceyhbMC05YS1mQS1GXSspXFx9LykpKSB7XG4gICAgICAgICAgICAgIC8vIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSAoRVM2IFVuaWNvZGUgY29kZSBwb2ludCBlc2NhcGUpXG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVFc2NhcGVkKCd1bmljb2RlQ29kZVBvaW50RXNjYXBlJywgcGFyc2VJbnQocmVzWzFdLCAxNiksIHJlc1sxXSwgNCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJZGVudGl0eUVzY2FwZVxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJZGVudGl0eUVzY2FwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRha2VuIGZyb20gdGhlIEVzcHJpbWEgcGFyc2VyLlxuICAgICAgICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlZCBieSBgdG9vbHMvZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG4gICAgICAgICAgICB2YXIgTm9uQXNjaWlJZGVudGlmaWVyUGFydCA9IG5ldyBSZWdFeHAoJ1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjJcXHUwOEU0LVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4XFx1MEM1OVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOUQ5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5QVxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTY5RFxcdUE2OUYtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRFxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNoID09PSAzNiB8fCBjaCA9PT0gOTUgfHwgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAgIGNoID49IDY1ICYmIGNoIDw9IDkwIHx8IC8vIEEuLlpcbiAgICAgICAgICAgIGNoID49IDk3ICYmIGNoIDw9IDEyMiB8fCAvLyBhLi56XG4gICAgICAgICAgICBjaCA+PSA0OCAmJiBjaCA8PSA1NyB8fCAvLyAwLi45XG4gICAgICAgICAgICBjaCA9PT0gOTIgfHwgLy8gXFwgKGJhY2tzbGFzaClcbiAgICAgICAgICAgIGNoID49IDB4ODAgJiYgTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXJzZUlkZW50aXR5RXNjYXBlKCkge1xuICAgICAgICAgICAgLy8gSWRlbnRpdHlFc2NhcGUgOjpcbiAgICAgICAgICAgIC8vICAgICAgU291cmNlQ2hhcmFjdGVyIGJ1dCBub3QgSWRlbnRpZmllclBhcnRcbiAgICAgICAgICAgIC8vICAgICAgPFpXSj5cbiAgICAgICAgICAgIC8vICAgICAgPFpXTko+XG5cbiAgICAgICAgICAgIHZhciBaV0ogPSAnXFx1MjAwQyc7XG4gICAgICAgICAgICB2YXIgWldOSiA9ICdcXHUyMDBEJztcblxuICAgICAgICAgICAgdmFyIHRtcDtcblxuICAgICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGxvb2thaGVhZCgpKSkge1xuICAgICAgICAgICAgICB0bXAgPSBpbmNyKCk7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVFc2NhcGVkKCdpZGVudGlmaWVyJywgdG1wLmNoYXJDb2RlQXQoMCksIHRtcCwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaChaV0opKSB7XG4gICAgICAgICAgICAgIC8vIDxaV0o+XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVFc2NhcGVkKCdpZGVudGlmaWVyJywgMHgyMDBDLCBaV0opO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaChaV05KKSkge1xuICAgICAgICAgICAgICAvLyA8WldOSj5cbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ2lkZW50aWZpZXInLCAweDIwMEQsIFpXTkopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXJzZUNoYXJhY3RlckNsYXNzKCkge1xuICAgICAgICAgICAgLy8gQ2hhcmFjdGVyQ2xhc3MgOjpcbiAgICAgICAgICAgIC8vICAgICAgWyBbbG9va2FoZWFkIOKIiSB7Xn1dIENsYXNzUmFuZ2VzIF1cbiAgICAgICAgICAgIC8vICAgICAgWyBeIENsYXNzUmFuZ2VzIF1cblxuICAgICAgICAgICAgdmFyIHJlcyxcbiAgICAgICAgICAgICAgICBmcm9tID0gcG9zO1xuICAgICAgICAgICAgaWYgKHJlcyA9IG1hdGNoUmVnKC9eXFxbXFxeLykpIHtcbiAgICAgICAgICAgICAgcmVzID0gcGFyc2VDbGFzc1JhbmdlcygpO1xuICAgICAgICAgICAgICBza2lwKCddJyk7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDaGFyYWN0ZXJDbGFzcyhyZXMsIHRydWUsIGZyb20sIHBvcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgcmVzID0gcGFyc2VDbGFzc1JhbmdlcygpO1xuICAgICAgICAgICAgICBza2lwKCddJyk7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDaGFyYWN0ZXJDbGFzcyhyZXMsIGZhbHNlLCBmcm9tLCBwb3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXJzZUNsYXNzUmFuZ2VzKCkge1xuICAgICAgICAgICAgLy8gQ2xhc3NSYW5nZXMgOjpcbiAgICAgICAgICAgIC8vICAgICAgW2VtcHR5XVxuICAgICAgICAgICAgLy8gICAgICBOb25lbXB0eUNsYXNzUmFuZ2VzXG5cbiAgICAgICAgICAgIHZhciByZXM7XG4gICAgICAgICAgICBpZiAoY3VycmVudCgnXScpKSB7XG4gICAgICAgICAgICAgIC8vIEVtcHR5IGFycmF5IG1lYW5zIG5vdGhpbmcgaW5zaW5kZSBvZiB0aGUgQ2xhc3NSYW5nZS5cbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzID0gcGFyc2VOb25lbXB0eUNsYXNzUmFuZ2VzKCk7XG4gICAgICAgICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICAgICAgYmFpbCgnbm9uRW1wdHlDbGFzc1JhbmdlcycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcGFyc2VIZWxwZXJDbGFzc1JhbmdlcyhhdG9tKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSwgdG8sIHJlcztcbiAgICAgICAgICAgIGlmIChjdXJyZW50KCctJykgJiYgIW5leHQoJ10nKSkge1xuICAgICAgICAgICAgICAvLyBDbGFzc0F0b20gLSBDbGFzc0F0b20gQ2xhc3NSYW5nZXNcbiAgICAgICAgICAgICAgc2tpcCgnLScpO1xuXG4gICAgICAgICAgICAgIHJlcyA9IHBhcnNlQ2xhc3NBdG9tKCk7XG4gICAgICAgICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICAgICAgYmFpbCgnY2xhc3NBdG9tJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG8gPSBwb3M7XG4gICAgICAgICAgICAgIHZhciBjbGFzc1JhbmdlcyA9IHBhcnNlQ2xhc3NSYW5nZXMoKTtcbiAgICAgICAgICAgICAgaWYgKCFjbGFzc1Jhbmdlcykge1xuICAgICAgICAgICAgICAgIGJhaWwoJ2NsYXNzUmFuZ2VzJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IGF0b20ucmFuZ2VbMF07XG4gICAgICAgICAgICAgIGlmIChjbGFzc1Jhbmdlcy50eXBlID09PSAnZW1wdHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDbGFzc1JhbmdlKGF0b20sIHJlcywgZnJvbSwgdG8pXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNsYXNzUmFuZ2UoYXRvbSwgcmVzLCBmcm9tLCB0byldLmNvbmNhdChjbGFzc1Jhbmdlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcyA9IHBhcnNlTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaCgpO1xuICAgICAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgICAgYmFpbCgnbm9uRW1wdHlDbGFzc1Jhbmdlc05vRGFzaCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2F0b21dLmNvbmNhdChyZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlTm9uZW1wdHlDbGFzc1JhbmdlcygpIHtcbiAgICAgICAgICAgIC8vIE5vbmVtcHR5Q2xhc3NSYW5nZXMgOjpcbiAgICAgICAgICAgIC8vICAgICAgQ2xhc3NBdG9tXG4gICAgICAgICAgICAvLyAgICAgIENsYXNzQXRvbSBOb25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoXG4gICAgICAgICAgICAvLyAgICAgIENsYXNzQXRvbSAtIENsYXNzQXRvbSBDbGFzc1Jhbmdlc1xuXG4gICAgICAgICAgICB2YXIgYXRvbSA9IHBhcnNlQ2xhc3NBdG9tKCk7XG4gICAgICAgICAgICBpZiAoIWF0b20pIHtcbiAgICAgICAgICAgICAgYmFpbCgnY2xhc3NBdG9tJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50KCddJykpIHtcbiAgICAgICAgICAgICAgLy8gQ2xhc3NBdG9tXG4gICAgICAgICAgICAgIHJldHVybiBbYXRvbV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsYXNzQXRvbSBOb25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoXG4gICAgICAgICAgICAvLyBDbGFzc0F0b20gLSBDbGFzc0F0b20gQ2xhc3NSYW5nZXNcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUhlbHBlckNsYXNzUmFuZ2VzKGF0b20pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaCgpIHtcbiAgICAgICAgICAgIC8vIE5vbmVtcHR5Q2xhc3NSYW5nZXNOb0Rhc2ggOjpcbiAgICAgICAgICAgIC8vICAgICAgQ2xhc3NBdG9tXG4gICAgICAgICAgICAvLyAgICAgIENsYXNzQXRvbU5vRGFzaCBOb25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoXG4gICAgICAgICAgICAvLyAgICAgIENsYXNzQXRvbU5vRGFzaCAtIENsYXNzQXRvbSBDbGFzc1Jhbmdlc1xuXG4gICAgICAgICAgICB2YXIgcmVzID0gcGFyc2VDbGFzc0F0b20oKTtcbiAgICAgICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICAgIGJhaWwoJ2NsYXNzQXRvbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnQoJ10nKSkge1xuICAgICAgICAgICAgICAvLyAgICAgIENsYXNzQXRvbVxuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbGFzc0F0b21Ob0Rhc2ggTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxuICAgICAgICAgICAgLy8gQ2xhc3NBdG9tTm9EYXNoIC0gQ2xhc3NBdG9tIENsYXNzUmFuZ2VzXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VIZWxwZXJDbGFzc1JhbmdlcyhyZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NBdG9tKCkge1xuICAgICAgICAgICAgLy8gQ2xhc3NBdG9tIDo6XG4gICAgICAgICAgICAvLyAgICAgIC1cbiAgICAgICAgICAgIC8vICAgICAgQ2xhc3NBdG9tTm9EYXNoXG4gICAgICAgICAgICBpZiAobWF0Y2goJy0nKSkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hhcmFjdGVyKCctJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDbGFzc0F0b21Ob0Rhc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXJzZUNsYXNzQXRvbU5vRGFzaCgpIHtcbiAgICAgICAgICAgIC8vIENsYXNzQXRvbU5vRGFzaCA6OlxuICAgICAgICAgICAgLy8gICAgICBTb3VyY2VDaGFyYWN0ZXIgYnV0IG5vdCBvbmUgb2YgXFwgb3IgXSBvciAtXG4gICAgICAgICAgICAvLyAgICAgIFxcIENsYXNzRXNjYXBlXG5cbiAgICAgICAgICAgIHZhciByZXM7XG4gICAgICAgICAgICBpZiAocmVzID0gbWF0Y2hSZWcoL15bXlxcXFxcXF0tXS8pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDaGFyYWN0ZXIocmVzWzBdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1xcXFwnKSkge1xuICAgICAgICAgICAgICByZXMgPSBwYXJzZUNsYXNzRXNjYXBlKCk7XG4gICAgICAgICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICAgICAgYmFpbCgnY2xhc3NFc2NhcGUnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVVuaWNvZGVTdXJyb2dhdGVQYWlyRXNjYXBlKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYmFpbChtZXNzYWdlLCBkZXRhaWxzLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgZnJvbSA9IGZyb20gPT0gbnVsbCA/IHBvcyA6IGZyb207XG4gICAgICAgICAgICB0byA9IHRvID09IG51bGwgPyBmcm9tIDogdG87XG5cbiAgICAgICAgICAgIHZhciBjb250ZXh0U3RhcnQgPSBNYXRoLm1heCgwLCBmcm9tIC0gMTApO1xuICAgICAgICAgICAgdmFyIGNvbnRleHRFbmQgPSBNYXRoLm1pbih0byArIDEwLCBzdHIubGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gT3V0cHV0IGEgYml0IG9mIGNvbnRleHQgYW5kIGEgbGluZSBwb2ludGluZyB0byB3aGVyZSBvdXIgZXJyb3IgaXMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gV2UgYXJlIGFzc3VtaW5nIHRoYXQgdGhlcmUgYXJlIG5vIGFjdHVhbCBuZXdsaW5lcyBpbiB0aGUgY29udGVudCBhcyB0aGlzIGlzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSAnICAgICcgKyBzdHIuc3Vic3RyaW5nKGNvbnRleHRTdGFydCwgY29udGV4dEVuZCk7XG4gICAgICAgICAgICB2YXIgcG9pbnRlciA9ICcgICAgJyArIG5ldyBBcnJheShmcm9tIC0gY29udGV4dFN0YXJ0ICsgMSkuam9pbignICcpICsgJ14nO1xuXG4gICAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcihtZXNzYWdlICsgJyBhdCBwb3NpdGlvbiAnICsgZnJvbSArIChkZXRhaWxzID8gJzogJyArIGRldGFpbHMgOiAnJykgKyAnXFxuJyArIGNvbnRleHQgKyAnXFxuJyArIHBvaW50ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBiYWNrcmVmRGVuaWVkID0gW107XG4gICAgICAgICAgdmFyIGNsb3NlZENhcHR1cmVDb3VudGVyID0gMDtcbiAgICAgICAgICB2YXIgZmlyc3RJdGVyYXRpb24gPSB0cnVlO1xuICAgICAgICAgIHZhciBoYXNVbmljb2RlRmxhZyA9IChmbGFncyB8fCBcIlwiKS5pbmRleE9mKFwidVwiKSAhPT0gLTE7XG4gICAgICAgICAgdmFyIHBvcyA9IDA7XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBpbnB1dCB0byBhIHN0cmluZyBhbmQgdHJlYXQgdGhlIGVtcHR5IHN0cmluZyBzcGVjaWFsLlxuICAgICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICAgIGlmIChzdHIgPT09ICcnKSB7XG4gICAgICAgICAgICBzdHIgPSAnKD86KSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRGlzanVuY3Rpb24oKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQucmFuZ2VbMV0gIT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJhaWwoJ0NvdWxkIG5vdCBwYXJzZSBlbnRpcmUgaW5wdXQgLSBnb3Qgc3R1Y2snLCAnJywgcmVzdWx0LnJhbmdlWzFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUaGUgc3BlYyByZXF1aXJlcyB0byBpbnRlcnByZXQgdGhlIGBcXDJgIGluIGAvXFwyKCkoKS9gIGFzIGJhY2tyZWZlcmVuY2UuXG4gICAgICAgICAgLy8gQXMgdGhlIHBhcnNlciBjb2xsZWN0cyB0aGUgbnVtYmVyIG9mIGNhcHR1cmUgZ3JvdXBzIGFzIHRoZSBzdHJpbmcgaXNcbiAgICAgICAgICAvLyBwYXJzZWQgaXQgaXMgaW1wb3NzaWJsZSB0byBtYWtlIHRoZXNlIGRlY2lzaW9ucyBhdCB0aGUgcG9pbnQgd2hlbiB0aGVcbiAgICAgICAgICAvLyBgXFwyYCBpcyBoYW5kbGVkLiBJbiBjYXNlIHRoZSBsb2NhbCBkZWNpc2lvbiB0dXJucyBvdXQgdG8gYmUgd3JvbmcgYWZ0ZXJcbiAgICAgICAgICAvLyB0aGUgcGFyc2luZyBoYXMgZmluaXNoZWQsIHRoZSBpbnB1dCBzdHJpbmcgaXMgcGFyc2VkIGEgc2Vjb25kIHRpbWUgd2l0aFxuICAgICAgICAgIC8vIHRoZSB0b3RhbCBudW1iZXIgb2YgY2FwdHVyZSBncm91cHMgc2V0LlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gU0VFOiBodHRwczovL2dpdGh1Yi5jb20vanZpZXJlY2svcmVnanNwYXJzZXIvaXNzdWVzLzcwXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYWNrcmVmRGVuaWVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYmFja3JlZkRlbmllZFtpXSA8PSBjbG9zZWRDYXB0dXJlQ291bnRlcikge1xuICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW5wdXQgYSBzZWNvbmQgdGltZS5cbiAgICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgICAgICAgZmlyc3RJdGVyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRGlzanVuY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZ2pzcGFyc2VyID0ge1xuICAgICAgICAgIHBhcnNlOiBwYXJzZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVnanNwYXJzZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LnJlZ2pzcGFyc2VyID0gcmVnanNwYXJzZXI7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVxdWlyZSQkMyA9IHBhcnNlciAmJiAodHlwZW9mIHBhcnNlciA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGFyc2VyKSkgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBwYXJzZXIgPyBwYXJzZXJbJ2RlZmF1bHQnXSA6IHBhcnNlcjtcblxuICAgIHZhciByZWdqc2dlbiA9IF9fY29tbW9uanMoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgZ2xvYmFsKSB7XG4gICAgICAvKiFcbiAgICAgICAqIFJlZ0pTR2VuXG4gICAgICAgKiBDb3B5cmlnaHQgMjAxNCBCZW5qYW1pbiBUYW4gPGh0dHBzOi8vZDEwLmdpdGh1Yi5pby8+XG4gICAgICAgKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHA6Ly9kMTAubWl0LWxpY2Vuc2Uub3JnLz5cbiAgICAgICAqL1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIC8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgICovXG5cbiAgICAgICAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICAgICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgICAgICAgJ29iamVjdCc6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCAqL1xuICAgICAgICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdyldICYmIHdpbmRvdyB8fCB0aGlzO1xuXG4gICAgICAgIC8qKiBCYWNrdXAgcG9zc2libGUgZ2xvYmFsIG9iamVjdCAqL1xuICAgICAgICB2YXIgb2xkUm9vdCA9IHJvb3Q7XG5cbiAgICAgICAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYCAqL1xuICAgICAgICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZXhwb3J0cyldICYmIGV4cG9ydHM7XG5cbiAgICAgICAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgICovXG4gICAgICAgIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobW9kdWxlKV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gICAgICAgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUgYW5kIHVzZSBpdCBhcyBgcm9vdGAgKi9cbiAgICAgICAgdmFyIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmICh0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihnbG9iYWwpKSA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gICAgICAgIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgICAgICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gICAgICAgIH1cblxuICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAvKiEgQmFzZWQgb24gaHR0cHM6Ly9tdGhzLmJlL2Zyb21jb2RlcG9pbnQgdjAuMi4wIGJ5IEBtYXRoaWFzICovXG5cbiAgICAgICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoKSB7XG4gICAgICAgICAgdmFyIE1BWF9TSVpFID0gMHg0MDAwO1xuICAgICAgICAgIHZhciBjb2RlVW5pdHMgPSBbXTtcbiAgICAgICAgICB2YXIgaGlnaFN1cnJvZ2F0ZTtcbiAgICAgICAgICB2YXIgbG93U3Vycm9nYXRlO1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IE51bWJlcihhcmd1bWVudHNbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUoY29kZVBvaW50KSB8fCAvLyBgTmFOYCwgYCtJbmZpbml0eWAsIG9yIGAtSW5maW5pdHlgXG4gICAgICAgICAgICBjb2RlUG9pbnQgPCAwIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgY29kZVBvaW50ID4gMHgxMEZGRkYgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICBmbG9vcihjb2RlUG9pbnQpICE9IGNvZGVQb2ludCAvLyBub3QgYW4gaW50ZWdlclxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCBjb2RlIHBvaW50OiAnICsgY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgICAgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEFzdHJhbCBjb2RlIHBvaW50OyBzcGxpdCBpbiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgICAgICAgIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICBoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDA7XG4gICAgICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IGNvZGVQb2ludCAlIDB4NDAwICsgMHhEQzAwO1xuICAgICAgICAgICAgICBjb2RlVW5pdHMucHVzaChoaWdoU3Vycm9nYXRlLCBsb3dTdXJyb2dhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA9PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IE1BWF9TSVpFKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVVuaXRzKTtcbiAgICAgICAgICAgICAgY29kZVVuaXRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhc3NlcnRUeXBlKHR5cGUsIGV4cGVjdGVkKSB7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkLmluZGV4T2YoJ3wnKSA9PSAtMSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBub2RlIHR5cGU6ICcgKyB0eXBlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBlY3RlZCA9IGFzc2VydFR5cGUuaGFzT3duUHJvcGVydHkoZXhwZWN0ZWQpID8gYXNzZXJ0VHlwZVtleHBlY3RlZF0gOiBhc3NlcnRUeXBlW2V4cGVjdGVkXSA9IFJlZ0V4cCgnXig/OicgKyBleHBlY3RlZCArICcpJCcpO1xuXG4gICAgICAgICAgaWYgKGV4cGVjdGVkLnRlc3QodHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBub2RlIHR5cGU6ICcgKyB0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IG5vZGUudHlwZTtcblxuICAgICAgICAgIGlmIChnZW5lcmF0ZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSAmJiB0eXBlb2YgZ2VuZXJhdGVbdHlwZV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlW3R5cGVdKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIG5vZGUgdHlwZTogJyArIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVBbHRlcm5hdGl2ZShub2RlKSB7XG4gICAgICAgICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdhbHRlcm5hdGl2ZScpO1xuXG4gICAgICAgICAgdmFyIHRlcm1zID0gbm9kZS5ib2R5LFxuICAgICAgICAgICAgICBsZW5ndGggPSB0ZXJtcyA/IHRlcm1zLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVRlcm0odGVybXNbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBnZW5lcmF0ZVRlcm0odGVybXNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlQW5jaG9yKG5vZGUpIHtcbiAgICAgICAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2FuY2hvcicpO1xuXG4gICAgICAgICAgc3dpdGNoIChub2RlLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgcmV0dXJuICdeJztcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiAnJCc7XG4gICAgICAgICAgICBjYXNlICdib3VuZGFyeSc6XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXGInO1xuICAgICAgICAgICAgY2FzZSAnbm90LWJvdW5kYXJ5JzpcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxcQic7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBhc3NlcnRpb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZUF0b20obm9kZSkge1xuICAgICAgICAgIGFzc2VydFR5cGUobm9kZS50eXBlLCAnYW5jaG9yfGNoYXJhY3RlckNsYXNzfGNoYXJhY3RlckNsYXNzRXNjYXBlfGRvdHxncm91cHxyZWZlcmVuY2V8dmFsdWUnKTtcblxuICAgICAgICAgIHJldHVybiBnZW5lcmF0ZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ2hhcmFjdGVyQ2xhc3Mobm9kZSkge1xuICAgICAgICAgIGFzc2VydFR5cGUobm9kZS50eXBlLCAnY2hhcmFjdGVyQ2xhc3MnKTtcblxuICAgICAgICAgIHZhciBjbGFzc1JhbmdlcyA9IG5vZGUuYm9keSxcbiAgICAgICAgICAgICAgbGVuZ3RoID0gY2xhc3NSYW5nZXMgPyBjbGFzc1Jhbmdlcy5sZW5ndGggOiAwO1xuXG4gICAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gJ1snO1xuXG4gICAgICAgICAgaWYgKG5vZGUubmVnYXRpdmUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGdlbmVyYXRlQ2xhc3NBdG9tKGNsYXNzUmFuZ2VzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgKz0gJ10nO1xuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ2hhcmFjdGVyQ2xhc3NFc2NhcGUobm9kZSkge1xuICAgICAgICAgIGFzc2VydFR5cGUobm9kZS50eXBlLCAnY2hhcmFjdGVyQ2xhc3NFc2NhcGUnKTtcblxuICAgICAgICAgIHJldHVybiAnXFxcXCcgKyBub2RlLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVDaGFyYWN0ZXJDbGFzc1JhbmdlKG5vZGUpIHtcbiAgICAgICAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2NoYXJhY3RlckNsYXNzUmFuZ2UnKTtcblxuICAgICAgICAgIHZhciBtaW4gPSBub2RlLm1pbixcbiAgICAgICAgICAgICAgbWF4ID0gbm9kZS5tYXg7XG5cbiAgICAgICAgICBpZiAobWluLnR5cGUgPT0gJ2NoYXJhY3RlckNsYXNzUmFuZ2UnIHx8IG1heC50eXBlID09ICdjaGFyYWN0ZXJDbGFzc1JhbmdlJykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGNsYXNzIHJhbmdlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRlQ2xhc3NBdG9tKG1pbikgKyAnLScgKyBnZW5lcmF0ZUNsYXNzQXRvbShtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVDbGFzc0F0b20obm9kZSkge1xuICAgICAgICAgIGFzc2VydFR5cGUobm9kZS50eXBlLCAnYW5jaG9yfGNoYXJhY3RlckNsYXNzRXNjYXBlfGNoYXJhY3RlckNsYXNzUmFuZ2V8ZG90fHZhbHVlJyk7XG5cbiAgICAgICAgICByZXR1cm4gZ2VuZXJhdGUobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZURpc2p1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2Rpc2p1bmN0aW9uJyk7XG5cbiAgICAgICAgICB2YXIgYm9keSA9IG5vZGUuYm9keSxcbiAgICAgICAgICAgICAgbGVuZ3RoID0gYm9keSA/IGJvZHkubGVuZ3RoIDogMDtcblxuICAgICAgICAgIGlmIChsZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ05vIGJvZHknKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGUoYm9keVswXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKGkgIT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnfCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ICs9IGdlbmVyYXRlKGJvZHlbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlRG90KG5vZGUpIHtcbiAgICAgICAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2RvdCcpO1xuXG4gICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlR3JvdXAobm9kZSkge1xuICAgICAgICAgIGFzc2VydFR5cGUobm9kZS50eXBlLCAnZ3JvdXAnKTtcblxuICAgICAgICAgIHZhciByZXN1bHQgPSAnKCc7XG5cbiAgICAgICAgICBzd2l0Y2ggKG5vZGUuYmVoYXZpb3IpIHtcbiAgICAgICAgICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgcmVzdWx0ICs9ICc/Oic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbG9va2FoZWFkJzpcbiAgICAgICAgICAgICAgcmVzdWx0ICs9ICc/PSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbmVnYXRpdmVMb29rYWhlYWQnOlxuICAgICAgICAgICAgICByZXN1bHQgKz0gJz8hJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBiZWhhdmlvdXI6ICcgKyBub2RlLmJlaGF2aW91cik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJvZHkgPSBub2RlLmJvZHksXG4gICAgICAgICAgICAgIGxlbmd0aCA9IGJvZHkgPyBib2R5Lmxlbmd0aCA6IDA7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBnZW5lcmF0ZShib2R5WzBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGkgPSAtMTtcblxuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gZ2VuZXJhdGUoYm9keVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ICs9ICcpJztcblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZVF1YW50aWZpZXIobm9kZSkge1xuICAgICAgICAgIGFzc2VydFR5cGUobm9kZS50eXBlLCAncXVhbnRpZmllcicpO1xuXG4gICAgICAgICAgdmFyIHF1YW50aWZpZXIgPSAnJyxcbiAgICAgICAgICAgICAgbWluID0gbm9kZS5taW4sXG4gICAgICAgICAgICAgIG1heCA9IG5vZGUubWF4O1xuXG4gICAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICBzd2l0Y2ggKG1pbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIHF1YW50aWZpZXIgPSAnKic7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICBxdWFudGlmaWVyID0gJysnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHF1YW50aWZpZXIgPSAneycgKyBtaW4gKyAnLH0nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAobWluID09IG1heCkge1xuICAgICAgICAgICAgICAgIHF1YW50aWZpZXIgPSAneycgKyBtaW4gKyAnfSc7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobWluID09IDAgJiYgbWF4ID09IDEpIHtcbiAgICAgICAgICAgICAgICBxdWFudGlmaWVyID0gJz8nO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1YW50aWZpZXIgPSAneycgKyBtaW4gKyAnLCcgKyBtYXggKyAnfSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFub2RlLmdyZWVkeSkge1xuICAgICAgICAgICAgcXVhbnRpZmllciArPSAnPyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRlQXRvbShub2RlLmJvZHlbMF0pICsgcXVhbnRpZmllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlUmVmZXJlbmNlKG5vZGUpIHtcbiAgICAgICAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ3JlZmVyZW5jZScpO1xuXG4gICAgICAgICAgcmV0dXJuICdcXFxcJyArIG5vZGUubWF0Y2hJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlVGVybShub2RlKSB7XG4gICAgICAgICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdhbmNob3J8Y2hhcmFjdGVyQ2xhc3N8Y2hhcmFjdGVyQ2xhc3NFc2NhcGV8ZW1wdHl8Z3JvdXB8cXVhbnRpZmllcnxyZWZlcmVuY2V8dmFsdWUnKTtcblxuICAgICAgICAgIHJldHVybiBnZW5lcmF0ZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlVmFsdWUobm9kZSkge1xuICAgICAgICAgIGFzc2VydFR5cGUobm9kZS50eXBlLCAndmFsdWUnKTtcblxuICAgICAgICAgIHZhciBraW5kID0gbm9kZS5raW5kLFxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSBub2RlLmNvZGVQb2ludDtcblxuICAgICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAnY29udHJvbExldHRlcic6XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXGMnICsgZnJvbUNvZGVQb2ludChjb2RlUG9pbnQgKyA2NCk7XG4gICAgICAgICAgICBjYXNlICdoZXhhZGVjaW1hbEVzY2FwZSc6XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXHgnICsgKCcwMCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbiAgICAgICAgICAgIGNhc2UgJ2lkZW50aWZpZXInOlxuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFwnICsgZnJvbUNvZGVQb2ludChjb2RlUG9pbnQpO1xuICAgICAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXCcgKyBjb2RlUG9pbnQ7XG4gICAgICAgICAgICBjYXNlICdvY3RhbCc6XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoOCk7XG4gICAgICAgICAgICBjYXNlICdzaW5nbGVFc2NhcGUnOlxuICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGVQb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMHgwMDA4OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcYic7XG4gICAgICAgICAgICAgICAgY2FzZSAweDAwOTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXHQnO1xuICAgICAgICAgICAgICAgIGNhc2UgMHgwMEE6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFxuJztcbiAgICAgICAgICAgICAgICBjYXNlIDB4MDBCOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdic7XG4gICAgICAgICAgICAgICAgY2FzZSAweDAwQzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXGYnO1xuICAgICAgICAgICAgICAgIGNhc2UgMHgwMEQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFxyJztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgY29kZXBvaW50OiAnICsgY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgICAgICAgIGNhc2UgJ3VuaWNvZGVFc2NhcGUnOlxuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArICgnMDAwMCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC00KTtcbiAgICAgICAgICAgIGNhc2UgJ3VuaWNvZGVDb2RlUG9pbnRFc2NhcGUnOlxuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1eycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnfSc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgbm9kZSBraW5kOiAnICsga2luZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgZ2VuZXJhdGUuYWx0ZXJuYXRpdmUgPSBnZW5lcmF0ZUFsdGVybmF0aXZlO1xuICAgICAgICBnZW5lcmF0ZS5hbmNob3IgPSBnZW5lcmF0ZUFuY2hvcjtcbiAgICAgICAgZ2VuZXJhdGUuY2hhcmFjdGVyQ2xhc3MgPSBnZW5lcmF0ZUNoYXJhY3RlckNsYXNzO1xuICAgICAgICBnZW5lcmF0ZS5jaGFyYWN0ZXJDbGFzc0VzY2FwZSA9IGdlbmVyYXRlQ2hhcmFjdGVyQ2xhc3NFc2NhcGU7XG4gICAgICAgIGdlbmVyYXRlLmNoYXJhY3RlckNsYXNzUmFuZ2UgPSBnZW5lcmF0ZUNoYXJhY3RlckNsYXNzUmFuZ2U7XG4gICAgICAgIGdlbmVyYXRlLmRpc2p1bmN0aW9uID0gZ2VuZXJhdGVEaXNqdW5jdGlvbjtcbiAgICAgICAgZ2VuZXJhdGUuZG90ID0gZ2VuZXJhdGVEb3Q7XG4gICAgICAgIGdlbmVyYXRlLmdyb3VwID0gZ2VuZXJhdGVHcm91cDtcbiAgICAgICAgZ2VuZXJhdGUucXVhbnRpZmllciA9IGdlbmVyYXRlUXVhbnRpZmllcjtcbiAgICAgICAgZ2VuZXJhdGUucmVmZXJlbmNlID0gZ2VuZXJhdGVSZWZlcmVuY2U7XG4gICAgICAgIGdlbmVyYXRlLnZhbHVlID0gZ2VuZXJhdGVWYWx1ZTtcblxuICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAvLyBleHBvcnQgcmVnanNnZW5cbiAgICAgICAgLy8gc29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgaWYgKHR5cGVvZiB1bmRlZmluZWQgPT0gJ2Z1bmN0aW9uJyAmJiBfdHlwZW9mKHVuZGVmaW5lZC5hbWQpID09ICdvYmplY3QnICYmIHVuZGVmaW5lZC5hbWQpIHtcbiAgICAgICAgICAvLyBkZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZSBhbGlhc2VkXG4gICAgICAgICAgdW5kZWZpbmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICdnZW5lcmF0ZSc6IGdlbmVyYXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3RcbiAgICAgICAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgICAgICAgICAgLy8gaW4gTmFyd2hhbCwgTm9kZS5qcywgUmhpbm8gLXJlcXVpcmUsIG9yIFJpbmdvSlNcbiAgICAgICAgICAgIGZyZWVFeHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGluIGEgYnJvd3NlciBvciBSaGlub1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByb290LnJlZ2pzZ2VuID0ge1xuICAgICAgICAgICAgICAgICdnZW5lcmF0ZSc6IGdlbmVyYXRlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICB9KS5jYWxsKF9fY29tbW9uanNfZ2xvYmFsKTtcbiAgICB9KTtcblxuICAgIHZhciByZXF1aXJlJCQ0ID0gcmVnanNnZW4gJiYgKHR5cGVvZiByZWdqc2dlbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocmVnanNnZW4pKSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIHJlZ2pzZ2VuID8gcmVnanNnZW5bJ2RlZmF1bHQnXSA6IHJlZ2pzZ2VuO1xuXG4gICAgdmFyIHJld3JpdGVQYXR0ZXJuID0gX19jb21tb25qcyhmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICB2YXIgZ2VuZXJhdGUgPSByZXF1aXJlJCQ0LmdlbmVyYXRlO1xuICAgICAgdmFyIHBhcnNlID0gcmVxdWlyZSQkMy5wYXJzZTtcbiAgICAgIHZhciByZWdlbmVyYXRlID0gcmVxdWlyZSQkMCQyO1xuICAgICAgdmFyIGl1TWFwcGluZ3MgPSByZXF1aXJlJCQxO1xuICAgICAgdmFyIEVTQ0FQRV9TRVRTID0gcmVxdWlyZSQkMCQxO1xuXG4gICAgICBmdW5jdGlvbiBnZXRDaGFyYWN0ZXJDbGFzc0VzY2FwZVNldChjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKHVuaWNvZGUpIHtcbiAgICAgICAgICBpZiAoaWdub3JlQ2FzZSkge1xuICAgICAgICAgICAgcmV0dXJuIEVTQ0FQRV9TRVRTLlVOSUNPREVfSUdOT1JFX0NBU0VbY2hhcmFjdGVyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEVTQ0FQRV9TRVRTLlVOSUNPREVbY2hhcmFjdGVyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRVNDQVBFX1NFVFMuUkVHVUxBUltjaGFyYWN0ZXJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG4gICAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSBhIFJlZ2VuZXJhdGUgc2V0IGNvbnRhaW5pbmcgYWxsIGNvZGUgcG9pbnRzLCB1c2VkIGZvciBuZWdhdGl2ZVxuICAgICAgLy8gY2hhcmFjdGVyIGNsYXNzZXMgKGlmIGFueSkuXG4gICAgICB2YXIgVU5JQ09ERV9TRVQgPSByZWdlbmVyYXRlKCkuYWRkUmFuZ2UoMHgwLCAweDEwRkZGRik7XG4gICAgICAvLyBXaXRob3V0IHRoZSBgdWAgZmxhZywgdGhlIHJhbmdlIHN0b3BzIGF0IDB4RkZGRi5cbiAgICAgIC8vIGh0dHBzOi8vbXRocy5iZS9lczYjc2VjLXBhdHRlcm4tc2VtYW50aWNzXG4gICAgICB2YXIgQk1QX1NFVCA9IHJlZ2VuZXJhdGUoKS5hZGRSYW5nZSgweDAsIDB4RkZGRik7XG5cbiAgICAgIC8vIFByZXBhcmUgYSBSZWdlbmVyYXRlIHNldCBjb250YWluaW5nIGFsbCBjb2RlIHBvaW50cyB0aGF0IGFyZSBzdXBwb3NlZCB0byBiZVxuICAgICAgLy8gbWF0Y2hlZCBieSBgLy4vdWAuIGh0dHBzOi8vbXRocy5iZS9lczYjc2VjLWF0b21cbiAgICAgIHZhciBET1RfU0VUX1VOSUNPREUgPSBVTklDT0RFX1NFVC5jbG9uZSgpIC8vIGFsbCBVbmljb2RlIGNvZGUgcG9pbnRzXG4gICAgICAucmVtb3ZlKFxuICAgICAgLy8gbWludXMgYExpbmVUZXJtaW5hdG9yYHMgKGh0dHBzOi8vbXRocy5iZS9lczYjc2VjLWxpbmUtdGVybWluYXRvcnMpOlxuICAgICAgMHgwMDBBLCAvLyBMaW5lIEZlZWQgPExGPlxuICAgICAgMHgwMDBELCAvLyBDYXJyaWFnZSBSZXR1cm4gPENSPlxuICAgICAgMHgyMDI4LCAvLyBMaW5lIFNlcGFyYXRvciA8TFM+XG4gICAgICAweDIwMjkgLy8gUGFyYWdyYXBoIFNlcGFyYXRvciA8UFM+XG4gICAgICApO1xuICAgICAgLy8gUHJlcGFyZSBhIFJlZ2VuZXJhdGUgc2V0IGNvbnRhaW5pbmcgYWxsIGNvZGUgcG9pbnRzIHRoYXQgYXJlIHN1cHBvc2VkIHRvIGJlXG4gICAgICAvLyBtYXRjaGVkIGJ5IGAvLi9gIChvbmx5IEJNUCBjb2RlIHBvaW50cykuXG4gICAgICB2YXIgRE9UX1NFVCA9IERPVF9TRVRfVU5JQ09ERS5jbG9uZSgpLmludGVyc2VjdGlvbihCTVBfU0VUKTtcblxuICAgICAgLy8gQWRkIGEgcmFuZ2Ugb2YgY29kZSBwb2ludHMgKyBhbnkgY2FzZS1mb2xkZWQgY29kZSBwb2ludHMgaW4gdGhhdCByYW5nZSB0byBhXG4gICAgICAvLyBzZXQuXG4gICAgICByZWdlbmVyYXRlLnByb3RvdHlwZS5pdUFkZFJhbmdlID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgZm9sZGVkID0gY2FzZUZvbGQobWluKTtcbiAgICAgICAgICBpZiAoZm9sZGVkKSB7XG4gICAgICAgICAgICAkdGhpcy5hZGQoZm9sZGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCsrbWluIDw9IG1heCk7XG4gICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgLy8gTm90ZTogYGhhc093blByb3BlcnR5YCBpcyBub3QgbmVlZGVkIGhlcmUuXG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGUoaXRlbSwgcGF0dGVybikge1xuICAgICAgICAvLyBUT0RPOiBUZXN0IGlmIG1lbW9pemluZyBgcGF0dGVybmAgaGVyZSBpcyB3b3J0aCB0aGUgZWZmb3J0LlxuICAgICAgICBpZiAoIXBhdHRlcm4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyZWUgPSBwYXJzZShwYXR0ZXJuLCAnJyk7XG4gICAgICAgIHN3aXRjaCAodHJlZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnY2hhcmFjdGVyQ2xhc3MnOlxuICAgICAgICAgIGNhc2UgJ2dyb3VwJzpcbiAgICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgICAvLyBObyB3cmFwcGluZyBuZWVkZWQuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gV3JhcCB0aGUgcGF0dGVybiBpbiBhIG5vbi1jYXB0dXJpbmcgZ3JvdXAuXG4gICAgICAgICAgICB0cmVlID0gd3JhcCh0cmVlLCBwYXR0ZXJuKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24oaXRlbSwgdHJlZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXAodHJlZSwgcGF0dGVybikge1xuICAgICAgICAvLyBXcmFwIHRoZSBwYXR0ZXJuIGluIGEgbm9uLWNhcHR1cmluZyBncm91cC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAndHlwZSc6ICdncm91cCcsXG4gICAgICAgICAgJ2JlaGF2aW9yJzogJ2lnbm9yZScsXG4gICAgICAgICAgJ2JvZHknOiBbdHJlZV0sXG4gICAgICAgICAgJ3Jhdyc6ICcoPzonICsgcGF0dGVybiArICcpJ1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYXNlRm9sZChjb2RlUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGhhcyhpdU1hcHBpbmdzLCBjb2RlUG9pbnQpID8gaXVNYXBwaW5nc1tjb2RlUG9pbnRdIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZ25vcmVDYXNlID0gZmFsc2U7XG4gICAgICB2YXIgdW5pY29kZSA9IGZhbHNlO1xuICAgICAgZnVuY3Rpb24gcHJvY2Vzc0NoYXJhY3RlckNsYXNzKGNoYXJhY3RlckNsYXNzSXRlbSkge1xuICAgICAgICB2YXIgc2V0JCQxID0gcmVnZW5lcmF0ZSgpO1xuICAgICAgICB2YXIgYm9keSA9IGNoYXJhY3RlckNsYXNzSXRlbS5ib2R5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgICAgICBzZXQkJDEuYWRkKGl0ZW0uY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgaWYgKGlnbm9yZUNhc2UgJiYgdW5pY29kZSkge1xuICAgICAgICAgICAgICAgIHZhciBmb2xkZWQgPSBjYXNlRm9sZChpdGVtLmNvZGVQb2ludCk7XG4gICAgICAgICAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgICAgICAgc2V0JCQxLmFkZChmb2xkZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NoYXJhY3RlckNsYXNzUmFuZ2UnOlxuICAgICAgICAgICAgICB2YXIgbWluID0gaXRlbS5taW4uY29kZVBvaW50O1xuICAgICAgICAgICAgICB2YXIgbWF4ID0gaXRlbS5tYXguY29kZVBvaW50O1xuICAgICAgICAgICAgICBzZXQkJDEuYWRkUmFuZ2UobWluLCBtYXgpO1xuICAgICAgICAgICAgICBpZiAoaWdub3JlQ2FzZSAmJiB1bmljb2RlKSB7XG4gICAgICAgICAgICAgICAgc2V0JCQxLml1QWRkUmFuZ2UobWluLCBtYXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2hhcmFjdGVyQ2xhc3NFc2NhcGUnOlxuICAgICAgICAgICAgICBzZXQkJDEuYWRkKGdldENoYXJhY3RlckNsYXNzRXNjYXBlU2V0KGl0ZW0udmFsdWUpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBUaGUgYGRlZmF1bHRgIGNsYXVzZSBpcyBvbmx5IGhlcmUgYXMgYSBzYWZlZ3VhcmQ7IGl0IHNob3VsZCBuZXZlciBiZVxuICAgICAgICAgICAgLy8gcmVhY2hlZC4gQ29kZSBjb3ZlcmFnZSB0b29scyBzaG91bGQgaWdub3JlIGl0LlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHRlcm0gdHlwZTogJyArIGl0ZW0udHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNoYXJhY3RlckNsYXNzSXRlbS5uZWdhdGl2ZSkge1xuICAgICAgICAgIHNldCQkMSA9ICh1bmljb2RlID8gVU5JQ09ERV9TRVQgOiBCTVBfU0VUKS5jbG9uZSgpLnJlbW92ZShzZXQkJDEpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZShjaGFyYWN0ZXJDbGFzc0l0ZW0sIHNldCQkMS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIGNoYXJhY3RlckNsYXNzSXRlbTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJvY2Vzc1Rlcm0oaXRlbSkge1xuICAgICAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2RvdCc6XG4gICAgICAgICAgICB1cGRhdGUoaXRlbSwgKHVuaWNvZGUgPyBET1RfU0VUX1VOSUNPREUgOiBET1RfU0VUKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NoYXJhY3RlckNsYXNzJzpcbiAgICAgICAgICAgIGl0ZW0gPSBwcm9jZXNzQ2hhcmFjdGVyQ2xhc3MoaXRlbSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjaGFyYWN0ZXJDbGFzc0VzY2FwZSc6XG4gICAgICAgICAgICB1cGRhdGUoaXRlbSwgZ2V0Q2hhcmFjdGVyQ2xhc3NFc2NhcGVTZXQoaXRlbS52YWx1ZSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhbHRlcm5hdGl2ZSc6XG4gICAgICAgICAgY2FzZSAnZGlzanVuY3Rpb24nOlxuICAgICAgICAgIGNhc2UgJ2dyb3VwJzpcbiAgICAgICAgICBjYXNlICdxdWFudGlmaWVyJzpcbiAgICAgICAgICAgIGl0ZW0uYm9keSA9IGl0ZW0uYm9keS5tYXAocHJvY2Vzc1Rlcm0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IGl0ZW0uY29kZVBvaW50O1xuICAgICAgICAgICAgdmFyIHNldCQkMSA9IHJlZ2VuZXJhdGUoY29kZVBvaW50KTtcbiAgICAgICAgICAgIGlmIChpZ25vcmVDYXNlICYmIHVuaWNvZGUpIHtcbiAgICAgICAgICAgICAgdmFyIGZvbGRlZCA9IGNhc2VGb2xkKGNvZGVQb2ludCk7XG4gICAgICAgICAgICAgIGlmIChmb2xkZWQpIHtcbiAgICAgICAgICAgICAgICBzZXQkJDEuYWRkKGZvbGRlZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZShpdGVtLCBzZXQkJDEudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgIGNhc2UgJ2VtcHR5JzpcbiAgICAgICAgICBjYXNlICdncm91cCc6XG4gICAgICAgICAgY2FzZSAncmVmZXJlbmNlJzpcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIFRoZSBgZGVmYXVsdGAgY2xhdXNlIGlzIG9ubHkgaGVyZSBhcyBhIHNhZmVndWFyZDsgaXQgc2hvdWxkIG5ldmVyIGJlXG4gICAgICAgICAgLy8gcmVhY2hlZC4gQ29kZSBjb3ZlcmFnZSB0b29scyBzaG91bGQgaWdub3JlIGl0LlxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHRlcm0gdHlwZTogJyArIGl0ZW0udHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgICAgIHZhciB0cmVlID0gcGFyc2UocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgICBpZ25vcmVDYXNlID0gZmxhZ3MgPyBmbGFncy5pbmRleE9mKCdpJykgPiAtMSA6IGZhbHNlO1xuICAgICAgICB1bmljb2RlID0gZmxhZ3MgPyBmbGFncy5pbmRleE9mKCd1JykgPiAtMSA6IGZhbHNlO1xuICAgICAgICBhc3NpZ24odHJlZSwgcHJvY2Vzc1Rlcm0odHJlZSkpO1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGUodHJlZSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIHJld3JpdGVQYXR0ZXJuJDEgPSByZXdyaXRlUGF0dGVybiAmJiAodHlwZW9mIHJld3JpdGVQYXR0ZXJuID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihyZXdyaXRlUGF0dGVybikpID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gcmV3cml0ZVBhdHRlcm4gPyByZXdyaXRlUGF0dGVyblsnZGVmYXVsdCddIDogcmV3cml0ZVBhdHRlcm47XG5cbiAgICB2YXIgTGl0ZXJhbCA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBMaXRlcmFsKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBMaXRlcmFsLl9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBMaXRlcmFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBMaXRlcmFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpdGVyYWw7XG5cbiAgICAgIExpdGVyYWwucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5wcm9ncmFtLmluZGVudEV4Y2x1c2lvbkVsZW1lbnRzLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIExpdGVyYWwucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLm51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmcgPSB0aGlzLnJhdy5zbGljZSgwLCAyKTtcbiAgICAgICAgICBpZiAobGVhZGluZyA9PT0gJzBiJyB8fCBsZWFkaW5nID09PSAnMG8nKSB7XG4gICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgU3RyaW5nKHRoaXMudmFsdWUpLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yZWdleCkge1xuICAgICAgICAgIHZhciByZWYgPSB0aGlzLnJlZ2V4O1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gcmVmLnBhdHRlcm47XG4gICAgICAgICAgdmFyIGZsYWdzID0gcmVmLmZsYWdzO1xuXG4gICAgICAgICAgaWYgKHRyYW5zZm9ybXMuc3RpY2t5UmVnRXhwICYmIC95Ly50ZXN0KGZsYWdzKSkgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih0aGlzLCAnUmVndWxhciBleHByZXNzaW9uIHN0aWNreSBmbGFnIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICBpZiAodHJhbnNmb3Jtcy51bmljb2RlUmVnRXhwICYmIC91Ly50ZXN0KGZsYWdzKSkge1xuICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgdGhpcy5lbmQsIFwiL1wiICsgcmV3cml0ZVBhdHRlcm4kMShwYXR0ZXJuLCBmbGFncykgKyBcIi9cIiArIGZsYWdzLnJlcGxhY2UoJ3UnLCAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIExpdGVyYWw7XG4gICAgfShOb2RlKTtcblxuICAgIHZhciBNZW1iZXJFeHByZXNzaW9uID0gZnVuY3Rpb24gKE5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIE1lbWJlckV4cHJlc3Npb24oKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIE1lbWJlckV4cHJlc3Npb24uX19wcm90b19fID0gTm9kZTtcbiAgICAgIE1lbWJlckV4cHJlc3Npb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlICYmIE5vZGUucHJvdG90eXBlKTtcbiAgICAgIE1lbWJlckV4cHJlc3Npb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVtYmVyRXhwcmVzc2lvbjtcblxuICAgICAgTWVtYmVyRXhwcmVzc2lvbi5wcm90b3R5cGUudHJhbnNwaWxlID0gZnVuY3Rpb24gdHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybXMucmVzZXJ2ZWRQcm9wZXJ0aWVzICYmIHJlc2VydmVkW3RoaXMucHJvcGVydHkubmFtZV0pIHtcbiAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLm9iamVjdC5lbmQsIHRoaXMucHJvcGVydHkuc3RhcnQsIFwiWydcIik7XG4gICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KHRoaXMucHJvcGVydHkuZW5kLCBcIiddXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgTm9kZS5wcm90b3R5cGUudHJhbnNwaWxlLmNhbGwodGhpcywgY29kZSwgdHJhbnNmb3Jtcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gTWVtYmVyRXhwcmVzc2lvbjtcbiAgICB9KE5vZGUpO1xuXG4gICAgdmFyIE5ld0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gTmV3RXhwcmVzc2lvbigpIHtcbiAgICAgICAgTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTm9kZSkgTmV3RXhwcmVzc2lvbi5fX3Byb3RvX18gPSBOb2RlO1xuICAgICAgTmV3RXhwcmVzc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgTmV3RXhwcmVzc2lvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOZXdFeHByZXNzaW9uO1xuXG4gICAgICBOZXdFeHByZXNzaW9uLnByb3RvdHlwZS5pbml0aWFsaXNlID0gZnVuY3Rpb24gaW5pdGlhbGlzZSh0cmFuc2Zvcm1zKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLnNwcmVhZFJlc3QgJiYgdGhpcy5hcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGxleGljYWxCb3VuZGFyeSA9IHRoaXMuZmluZExleGljYWxCb3VuZGFyeSgpO1xuXG4gICAgICAgICAgdmFyIGkgPSB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdmFyIGFyZyA9IHRoaXMkMS5hcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09ICdTcHJlYWRFbGVtZW50JyAmJiBpc0FyZ3VtZW50cyhhcmcuYXJndW1lbnQpKSB7XG4gICAgICAgICAgICAgIHRoaXMkMS5hcmd1bWVudHNBcnJheUFsaWFzID0gbGV4aWNhbEJvdW5kYXJ5LmdldEFyZ3VtZW50c0FycmF5QWxpYXMoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgTm9kZS5wcm90b3R5cGUuaW5pdGlhbGlzZS5jYWxsKHRoaXMsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgTmV3RXhwcmVzc2lvbi5wcm90b3R5cGUudHJhbnNwaWxlID0gZnVuY3Rpb24gdHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybXMuc3ByZWFkUmVzdCAmJiB0aGlzLmFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZmlyc3RBcmd1bWVudCA9IHRoaXMuYXJndW1lbnRzWzBdO1xuICAgICAgICAgIHZhciBpc05ldyA9IHRydWU7XG4gICAgICAgICAgdmFyIGhhc1NwcmVhZEVsZW1lbnRzID0gc3ByZWFkKGNvZGUsIHRoaXMuYXJndW1lbnRzLCBmaXJzdEFyZ3VtZW50LnN0YXJ0LCB0aGlzLmFyZ3VtZW50c0FycmF5QWxpYXMsIGlzTmV3KTtcblxuICAgICAgICAgIGlmIChoYXNTcHJlYWRFbGVtZW50cykge1xuICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodCh0aGlzLnN0YXJ0ICsgJ25ldycubGVuZ3RoLCAnIChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSgnKTtcbiAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuY2FsbGVlLmVuZCwgZmlyc3RBcmd1bWVudC5zdGFydCwgJywgWyBudWxsIF0uY29uY2F0KCAnKTtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLmVuZCwgJyApKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE5vZGUucHJvdG90eXBlLnRyYW5zcGlsZS5jYWxsKHRoaXMsIGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIE5ld0V4cHJlc3Npb247XG4gICAgfShOb2RlKTtcblxuICAgIHZhciBPYmplY3RFeHByZXNzaW9uID0gZnVuY3Rpb24gKE5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIE9iamVjdEV4cHJlc3Npb24oKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIE9iamVjdEV4cHJlc3Npb24uX19wcm90b19fID0gTm9kZTtcbiAgICAgIE9iamVjdEV4cHJlc3Npb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlICYmIE5vZGUucHJvdG90eXBlKTtcbiAgICAgIE9iamVjdEV4cHJlc3Npb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2JqZWN0RXhwcmVzc2lvbjtcblxuICAgICAgT2JqZWN0RXhwcmVzc2lvbi5wcm90b3R5cGUudHJhbnNwaWxlID0gZnVuY3Rpb24gdHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgTm9kZS5wcm90b3R5cGUudHJhbnNwaWxlLmNhbGwodGhpcywgY29kZSwgdHJhbnNmb3Jtcyk7XG5cbiAgICAgICAgdmFyIGZpcnN0UHJvcGVydHlTdGFydCA9IHRoaXMuc3RhcnQgKyAxO1xuICAgICAgICB2YXIgcmVndWxhclByb3BlcnR5Q291bnQgPSAwO1xuICAgICAgICB2YXIgc3ByZWFkUHJvcGVydHlDb3VudCA9IDA7XG4gICAgICAgIHZhciBjb21wdXRlZFByb3BlcnR5Q291bnQgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkkMiA9IDAsIGxpc3QgPSB0aGlzLnByb3BlcnRpZXM7IGkkMiA8IGxpc3QubGVuZ3RoOyBpJDIgKz0gMSkge1xuICAgICAgICAgIHZhciBwcm9wID0gbGlzdFtpJDJdO1xuXG4gICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gJ1NwcmVhZFByb3BlcnR5Jykge1xuICAgICAgICAgICAgc3ByZWFkUHJvcGVydHlDb3VudCArPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvcC5jb21wdXRlZCkge1xuICAgICAgICAgICAgY29tcHV0ZWRQcm9wZXJ0eUNvdW50ICs9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wLnR5cGUgPT09ICdQcm9wZXJ0eScpIHtcbiAgICAgICAgICAgIHJlZ3VsYXJQcm9wZXJ0eUNvdW50ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNwcmVhZFByb3BlcnR5Q291bnQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMucHJvZ3JhbS5vcHRpb25zLm9iamVjdEFzc2lnbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih0aGlzLCAnT2JqZWN0IHNwcmVhZCBvcGVyYXRvciByZXF1aXJlcyBzcGVjaWZpZWQgb2JqZWN0QXNzaWduIG9wdGlvbiB3aXRoIFxcJ09iamVjdC5hc3NpZ25cXCcgb3IgcG9seWZpbGwgaGVscGVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlbmNsb3NlIHJ1biBvZiBub24tc3ByZWFkIHByb3BlcnRpZXMgaW4gY3VybGllc1xuICAgICAgICAgIHZhciBpID0gdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgICAgICBpZiAocmVndWxhclByb3BlcnR5Q291bnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgdmFyIHByb3AkMSA9IHRoaXMkMS5wcm9wZXJ0aWVzW2ldO1xuXG4gICAgICAgICAgICAgIGlmIChwcm9wJDEudHlwZSA9PT0gJ1Byb3BlcnR5JyAmJiAhcHJvcCQxLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RQcm9wID0gdGhpcyQxLnByb3BlcnRpZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0UHJvcCA9IHRoaXMkMS5wcm9wZXJ0aWVzW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgIGlmICghbGFzdFByb3AgfHwgbGFzdFByb3AudHlwZSAhPT0gJ1Byb3BlcnR5JyB8fCBsYXN0UHJvcC5jb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodChwcm9wJDEuc3RhcnQsICd7Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0UHJvcCB8fCBuZXh0UHJvcC50eXBlICE9PSAnUHJvcGVydHknIHx8IG5leHRQcm9wLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQocHJvcCQxLmVuZCwgJ30nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB3cmFwIHRoZSB3aG9sZSB0aGluZyBpbiBPYmplY3QuYXNzaWduXG4gICAgICAgICAgZmlyc3RQcm9wZXJ0eVN0YXJ0ID0gdGhpcy5wcm9wZXJ0aWVzWzBdLnN0YXJ0O1xuICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3RhcnQsIGZpcnN0UHJvcGVydHlTdGFydCwgdGhpcy5wcm9ncmFtLm9wdGlvbnMub2JqZWN0QXNzaWduICsgXCIoe30sIFwiKTtcbiAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnByb3BlcnRpZXNbdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aCAtIDFdLmVuZCwgdGhpcy5lbmQsICcpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcHV0ZWRQcm9wZXJ0eUNvdW50ICYmIHRyYW5zZm9ybXMuY29tcHV0ZWRQcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBpMCA9IHRoaXMuZ2V0SW5kZW50YXRpb24oKTtcblxuICAgICAgICAgIHZhciBpc1NpbXBsZUFzc2lnbm1lbnQ7XG4gICAgICAgICAgdmFyIG5hbWU7XG5cbiAgICAgICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRvcicgJiYgdGhpcy5wYXJlbnQucGFyZW50LmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlzU2ltcGxlQXNzaWdubWVudCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5wYXJlbnQuaWQuYWxpYXMgfHwgdGhpcy5wYXJlbnQuaWQubmFtZTsgLy8gVE9ETyBpcyB0aGlzIHJpZ2h0P1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyAmJiB0aGlzLnBhcmVudC5wYXJlbnQudHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICYmIHRoaXMucGFyZW50LmxlZnQudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICBpc1NpbXBsZUFzc2lnbm1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMucGFyZW50LmxlZnQuYWxpYXMgfHwgdGhpcy5wYXJlbnQubGVmdC5uYW1lOyAvLyBUT0RPIGlzIHRoaXMgcmlnaHQ/XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudC50eXBlID09PSAnQXNzaWdubWVudFBhdHRlcm4nICYmIHRoaXMucGFyZW50LmxlZnQudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICBpc1NpbXBsZUFzc2lnbm1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMucGFyZW50LmxlZnQuYWxpYXMgfHwgdGhpcy5wYXJlbnQubGVmdC5uYW1lOyAvLyBUT0RPIGlzIHRoaXMgcmlnaHQ/XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaGFuZGxlIGJsb2NrIHNjb3BpbmdcbiAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLmZpbmRTY29wZShmYWxzZSkuZmluZERlY2xhcmF0aW9uKG5hbWUpO1xuICAgICAgICAgIGlmIChkZWNsYXJhdGlvbikgbmFtZSA9IGRlY2xhcmF0aW9uLm5hbWU7XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBmaXJzdFByb3BlcnR5U3RhcnQ7XG4gICAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICAgICAgaWYgKGlzU2ltcGxlQXNzaWdubWVudCkge1xuICAgICAgICAgICAgLy8gPz8/XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLmZpbmRTY29wZSh0cnVlKS5jcmVhdGVJZGVudGlmaWVyKCdvYmonKTtcblxuICAgICAgICAgICAgdmFyIHN0YXRlbWVudCA9IHRoaXMuZmluZE5lYXJlc3QoLyg/OlN0YXRlbWVudHxEZWNsYXJhdGlvbikkLyk7XG4gICAgICAgICAgICBjb2RlLmluc2VydExlZnQoc3RhdGVtZW50LmVuZCwgXCJcXG5cIiArIGkwICsgXCJ2YXIgXCIgKyBuYW1lICsgXCI7XCIpO1xuXG4gICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KHRoaXMuc3RhcnQsIFwiKCBcIiArIG5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGVuID0gdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgbGFzdENvbXB1dGVkUHJvcDtcbiAgICAgICAgICB2YXIgc2F3Tm9uQ29tcHV0ZWRQcm9wZXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGVuOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHByb3AkMiA9IHRoaXMkMS5wcm9wZXJ0aWVzW2kkMV07XG5cbiAgICAgICAgICAgIGlmIChwcm9wJDIuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgbGFzdENvbXB1dGVkUHJvcCA9IHByb3AkMjtcbiAgICAgICAgICAgICAgdmFyIG1vdmVTdGFydCA9IGkkMSA+IDAgPyB0aGlzJDEucHJvcGVydGllc1tpJDEgLSAxXS5lbmQgOiBzdGFydDtcblxuICAgICAgICAgICAgICB2YXIgcHJvcElkID0gaXNTaW1wbGVBc3NpZ25tZW50ID8gXCI7XFxuXCIgKyBpMCArIG5hbWUgOiBcIiwgXCIgKyBuYW1lO1xuXG4gICAgICAgICAgICAgIGlmIChtb3ZlU3RhcnQgPCBwcm9wJDIuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShtb3ZlU3RhcnQsIHByb3AkMi5zdGFydCwgcHJvcElkKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KHByb3AkMi5zdGFydCwgcHJvcElkKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBjID0gcHJvcCQyLmtleS5lbmQ7XG4gICAgICAgICAgICAgIHdoaWxlIChjb2RlLm9yaWdpbmFsW2NdICE9PSAnXScpIHtcbiAgICAgICAgICAgICAgICBjICs9IDE7XG4gICAgICAgICAgICAgIH1jICs9IDE7XG5cbiAgICAgICAgICAgICAgaWYgKHByb3AkMi52YWx1ZS5zdGFydCA+IGMpIGNvZGUucmVtb3ZlKGMsIHByb3AkMi52YWx1ZS5zdGFydCk7XG4gICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChjLCAnID0gJyk7XG4gICAgICAgICAgICAgIGNvZGUubW92ZShtb3ZlU3RhcnQsIHByb3AkMi5lbmQsIGVuZCk7XG5cbiAgICAgICAgICAgICAgaWYgKGkkMSA8IGxlbiAtIDEgJiYgIXNhd05vbkNvbXB1dGVkUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgY29tbWFcbiAgICAgICAgICAgICAgICBjID0gcHJvcCQyLmVuZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29kZS5vcmlnaW5hbFtjXSAhPT0gJywnKSB7XG4gICAgICAgICAgICAgICAgICBjICs9IDE7XG4gICAgICAgICAgICAgICAgfWNvZGUucmVtb3ZlKHByb3AkMi5lbmQsIGMgKyAxKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwcm9wJDIubWV0aG9kICYmIHRyYW5zZm9ybXMuY29uY2lzZU1ldGhvZFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodChwcm9wJDIudmFsdWUuc3RhcnQsICdmdW5jdGlvbiAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2F3Tm9uQ29tcHV0ZWRQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc3BlY2lhbCBjYXNlXG4gICAgICAgICAgaWYgKGNvbXB1dGVkUHJvcGVydHlDb3VudCA9PT0gbGVuKSB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLnByb3BlcnRpZXNbbGVuIC0gMV0uZW5kLCB0aGlzLmVuZCAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNTaW1wbGVBc3NpZ25tZW50KSB7XG4gICAgICAgICAgICBjb2RlLmluc2VydExlZnQobGFzdENvbXB1dGVkUHJvcC5lbmQsIFwiLCBcIiArIG5hbWUgKyBcIiApXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIE9iamVjdEV4cHJlc3Npb247XG4gICAgfShOb2RlKTtcblxuICAgIHZhciBQcm9wZXJ0eSA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBQcm9wZXJ0eSgpIHtcbiAgICAgICAgTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTm9kZSkgUHJvcGVydHkuX19wcm90b19fID0gTm9kZTtcbiAgICAgIFByb3BlcnR5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBQcm9wZXJ0eS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcm9wZXJ0eTtcblxuICAgICAgUHJvcGVydHkucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLmNvbmNpc2VNZXRob2RQcm9wZXJ0eSAmJiAhdGhpcy5jb21wdXRlZCAmJiB0aGlzLnBhcmVudC50eXBlICE9PSAnT2JqZWN0UGF0dGVybicpIHtcbiAgICAgICAgICBpZiAodGhpcy5zaG9ydGhhbmQpIHtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0UmlnaHQodGhpcy5zdGFydCwgdGhpcy5rZXkubmFtZSArIFwiOiBcIik7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1ldGhvZCkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2dyYW0ub3B0aW9ucy5uYW1lZEZ1bmN0aW9uRXhwcmVzc2lvbnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmtleS50eXBlID09PSAnTGl0ZXJhbCcgJiYgdHlwZW9mIHRoaXMua2V5LnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMua2V5LnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgICAgIGlmIChyZXNlcnZlZFt0aGlzLmtleS5uYW1lXSB8fCAhL15bYS16XyRdW2EtejAtOV8kXSokL2kudGVzdCh0aGlzLmtleS5uYW1lKSB8fCB0aGlzLnZhbHVlLmJvZHkuc2NvcGUucmVmZXJlbmNlc1t0aGlzLmtleS5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuZmluZFNjb3BlKHRydWUpLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5rZXkubmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLmtleS5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5maW5kU2NvcGUodHJ1ZSkuY3JlYXRlSWRlbnRpZmllcih0aGlzLmtleS52YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmFtZSA9ICcgJyArIG5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmdlbmVyYXRvcikgY29kZS5yZW1vdmUodGhpcy5zdGFydCwgdGhpcy5rZXkuc3RhcnQpO1xuICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KHRoaXMua2V5LmVuZCwgXCI6IGZ1bmN0aW9uXCIgKyAodGhpcy52YWx1ZS5nZW5lcmF0b3IgPyAnKicgOiAnJykgKyBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNmb3Jtcy5yZXNlcnZlZFByb3BlcnRpZXMgJiYgcmVzZXJ2ZWRbdGhpcy5rZXkubmFtZV0pIHtcbiAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KHRoaXMua2V5LnN0YXJ0LCBcIidcIik7XG4gICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KHRoaXMua2V5LmVuZCwgXCInXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgTm9kZS5wcm90b3R5cGUudHJhbnNwaWxlLmNhbGwodGhpcywgY29kZSwgdHJhbnNmb3Jtcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gUHJvcGVydHk7XG4gICAgfShOb2RlKTtcblxuICAgIHZhciBSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gUmV0dXJuU3RhdGVtZW50KCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBSZXR1cm5TdGF0ZW1lbnQuX19wcm90b19fID0gTm9kZTtcbiAgICAgIFJldHVyblN0YXRlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgUmV0dXJuU3RhdGVtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJldHVyblN0YXRlbWVudDtcblxuICAgICAgUmV0dXJuU3RhdGVtZW50LnByb3RvdHlwZS5pbml0aWFsaXNlID0gZnVuY3Rpb24gaW5pdGlhbGlzZSh0cmFuc2Zvcm1zKSB7XG4gICAgICAgIHRoaXMubG9vcCA9IHRoaXMuZmluZE5lYXJlc3QobG9vcFN0YXRlbWVudCk7XG4gICAgICAgIHRoaXMubmVhcmVzdEZ1bmN0aW9uID0gdGhpcy5maW5kTmVhcmVzdCgvRnVuY3Rpb24vKTtcblxuICAgICAgICBpZiAodGhpcy5sb29wICYmICghdGhpcy5uZWFyZXN0RnVuY3Rpb24gfHwgdGhpcy5sb29wLmRlcHRoID4gdGhpcy5uZWFyZXN0RnVuY3Rpb24uZGVwdGgpKSB7XG4gICAgICAgICAgdGhpcy5sb29wLmNhblJldHVybiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zaG91bGRXcmFwID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFyZ3VtZW50KSB0aGlzLmFyZ3VtZW50LmluaXRpYWxpc2UodHJhbnNmb3Jtcyk7XG4gICAgICB9O1xuXG4gICAgICBSZXR1cm5TdGF0ZW1lbnQucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIHZhciBzaG91bGRXcmFwID0gdGhpcy5zaG91bGRXcmFwICYmIHRoaXMubG9vcCAmJiB0aGlzLmxvb3Auc2hvdWxkUmV3cml0ZUFzRnVuY3Rpb247XG5cbiAgICAgICAgaWYgKHRoaXMuYXJndW1lbnQpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkV3JhcCkgY29kZS5pbnNlcnRSaWdodCh0aGlzLmFyZ3VtZW50LnN0YXJ0LCBcInsgdjogXCIpO1xuICAgICAgICAgIHRoaXMuYXJndW1lbnQudHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgICAgIGlmIChzaG91bGRXcmFwKSBjb2RlLmluc2VydExlZnQodGhpcy5hcmd1bWVudC5lbmQsIFwiIH1cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkV3JhcCkge1xuICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLnN0YXJ0ICsgNiwgJyB7fScpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gUmV0dXJuU3RhdGVtZW50O1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgU3ByZWFkUHJvcGVydHkgPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gU3ByZWFkUHJvcGVydHkoKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIFNwcmVhZFByb3BlcnR5Ll9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBTcHJlYWRQcm9wZXJ0eS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgU3ByZWFkUHJvcGVydHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ByZWFkUHJvcGVydHk7XG5cbiAgICAgIFNwcmVhZFByb3BlcnR5LnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLnN0YXJ0LCB0aGlzLmFyZ3VtZW50LnN0YXJ0KTtcbiAgICAgICAgY29kZS5yZW1vdmUodGhpcy5hcmd1bWVudC5lbmQsIHRoaXMuZW5kKTtcblxuICAgICAgICBOb2RlLnByb3RvdHlwZS50cmFuc3BpbGUuY2FsbCh0aGlzLCBjb2RlLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTcHJlYWRQcm9wZXJ0eTtcbiAgICB9KE5vZGUpO1xuXG4gICAgdmFyIFN1cGVyID0gZnVuY3Rpb24gKE5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIFN1cGVyKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBTdXBlci5fX3Byb3RvX18gPSBOb2RlO1xuICAgICAgU3VwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlICYmIE5vZGUucHJvdG90eXBlKTtcbiAgICAgIFN1cGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1cGVyO1xuXG4gICAgICBTdXBlci5wcm90b3R5cGUuaW5pdGlhbGlzZSA9IGZ1bmN0aW9uIGluaXRpYWxpc2UodHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAodHJhbnNmb3Jtcy5jbGFzc2VzKSB7XG4gICAgICAgICAgdGhpcy5tZXRob2QgPSB0aGlzLmZpbmROZWFyZXN0KCdNZXRob2REZWZpbml0aW9uJyk7XG4gICAgICAgICAgaWYgKCF0aGlzLm1ldGhvZCkgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih0aGlzLCAndXNlIG9mIHN1cGVyIG91dHNpZGUgY2xhc3MgbWV0aG9kJyk7XG5cbiAgICAgICAgICB2YXIgcGFyZW50Q2xhc3MgPSB0aGlzLmZpbmROZWFyZXN0KCdDbGFzc0JvZHknKS5wYXJlbnQ7XG4gICAgICAgICAgdGhpcy5zdXBlckNsYXNzTmFtZSA9IHBhcmVudENsYXNzLnN1cGVyQ2xhc3MgJiYgKHBhcmVudENsYXNzLnN1cGVyQ2xhc3MubmFtZSB8fCAnc3VwZXJjbGFzcycpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLnN1cGVyQ2xhc3NOYW1lKSB0aHJvdyBuZXcgQ29tcGlsZUVycm9yKHRoaXMsICdzdXBlciB1c2VkIGluIGJhc2UgY2xhc3MnKTtcblxuICAgICAgICAgIHRoaXMuaXNDYWxsZWQgPSB0aGlzLnBhcmVudC50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nICYmIHRoaXMgPT09IHRoaXMucGFyZW50LmNhbGxlZTtcblxuICAgICAgICAgIGlmICh0aGlzLm1ldGhvZC5raW5kICE9PSAnY29uc3RydWN0b3InICYmIHRoaXMuaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21waWxlRXJyb3IodGhpcywgJ3N1cGVyKCkgbm90IGFsbG93ZWQgb3V0c2lkZSBjbGFzcyBjb25zdHJ1Y3RvcicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuaXNNZW1iZXIgPSB0aGlzLnBhcmVudC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbic7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuaXNDYWxsZWQgJiYgIXRoaXMuaXNNZW1iZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21waWxlRXJyb3IodGhpcywgJ1VuZXhwZWN0ZWQgdXNlIG9mIGBzdXBlcmAgKGV4cGVjdGVkIGBzdXBlciguLi4pYCBvciBgc3VwZXIuKmApJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybXMuYXJyb3cpIHtcbiAgICAgICAgICB2YXIgbGV4aWNhbEJvdW5kYXJ5ID0gdGhpcy5maW5kTGV4aWNhbEJvdW5kYXJ5KCk7XG4gICAgICAgICAgdmFyIGFycm93RnVuY3Rpb24gPSB0aGlzLmZpbmROZWFyZXN0KCdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicpO1xuICAgICAgICAgIHZhciBsb29wID0gdGhpcy5maW5kTmVhcmVzdChsb29wU3RhdGVtZW50KTtcblxuICAgICAgICAgIGlmIChhcnJvd0Z1bmN0aW9uICYmIGFycm93RnVuY3Rpb24uZGVwdGggPiBsZXhpY2FsQm91bmRhcnkuZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMudGhpc0FsaWFzID0gbGV4aWNhbEJvdW5kYXJ5LmdldFRoaXNBbGlhcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsb29wICYmIGxvb3AuYm9keS5jb250YWlucyh0aGlzKSAmJiBsb29wLmRlcHRoID4gbGV4aWNhbEJvdW5kYXJ5LmRlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLnRoaXNBbGlhcyA9IGxleGljYWxCb3VuZGFyeS5nZXRUaGlzQWxpYXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFN1cGVyLnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAodHJhbnNmb3Jtcy5jbGFzc2VzKSB7XG4gICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmlzQ2FsbGVkIHx8IHRoaXMubWV0aG9kLnN0YXRpYyA/IHRoaXMuc3VwZXJDbGFzc05hbWUgOiB0aGlzLnN1cGVyQ2xhc3NOYW1lICsgXCIucHJvdG90eXBlXCI7XG5cbiAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgZXhwcmVzc2lvbiwgdHJ1ZSk7XG5cbiAgICAgICAgICB2YXIgY2FsbEV4cHJlc3Npb24gPSB0aGlzLmlzQ2FsbGVkID8gdGhpcy5wYXJlbnQgOiB0aGlzLnBhcmVudC5wYXJlbnQ7XG5cbiAgICAgICAgICBpZiAoY2FsbEV4cHJlc3Npb24gJiYgY2FsbEV4cHJlc3Npb24udHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQ2FsbCkge1xuICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2Ug4oCTIGBzdXBlciggLi4uYXJncyApYFxuICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQoY2FsbEV4cHJlc3Npb24uY2FsbGVlLmVuZCwgJy5jYWxsJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0aGlzQWxpYXMgPSB0aGlzLnRoaXNBbGlhcyB8fCAndGhpcyc7XG5cbiAgICAgICAgICAgIGlmIChjYWxsRXhwcmVzc2lvbi5hcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChjYWxsRXhwcmVzc2lvbi5hcmd1bWVudHNbMF0uc3RhcnQsIHRoaXNBbGlhcyArIFwiLCBcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQoY2FsbEV4cHJlc3Npb24uZW5kIC0gMSwgXCJcIiArIHRoaXNBbGlhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gU3VwZXI7XG4gICAgfShOb2RlKTtcblxuICAgIHZhciBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24uX19wcm90b19fID0gTm9kZTtcbiAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcblxuICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uLnByb3RvdHlwZS5pbml0aWFsaXNlID0gZnVuY3Rpb24gaW5pdGlhbGlzZSh0cmFuc2Zvcm1zKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLnRlbXBsYXRlU3RyaW5nICYmICF0cmFuc2Zvcm1zLmRhbmdlcm91c1RhZ2dlZFRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih0aGlzLCAnVGFnZ2VkIHRlbXBsYXRlIHN0cmluZ3MgYXJlIG5vdCBzdXBwb3J0ZWQuIFVzZSBgdHJhbnNmb3JtczogeyB0ZW1wbGF0ZVN0cmluZzogZmFsc2UgfWAgdG8gc2tpcCB0cmFuc2Zvcm1hdGlvbiBhbmQgZGlzYWJsZSB0aGlzIGVycm9yLCBvciBgdHJhbnNmb3JtczogeyBkYW5nZXJvdXNUYWdnZWRUZW1wbGF0ZVN0cmluZzogdHJ1ZSB9YCBpZiB5b3Uga25vdyB3aGF0IHlvdVxcJ3JlIGRvaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICBOb2RlLnByb3RvdHlwZS5pbml0aWFsaXNlLmNhbGwodGhpcywgdHJhbnNmb3Jtcyk7XG4gICAgICB9O1xuXG4gICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24ucHJvdG90eXBlLnRyYW5zcGlsZSA9IGZ1bmN0aW9uIHRyYW5zcGlsZShjb2RlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLnRlbXBsYXRlU3RyaW5nICYmIHRyYW5zZm9ybXMuZGFuZ2Vyb3VzVGFnZ2VkVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgICAgICB2YXIgb3JkZXJlZCA9IHRoaXMucXVhc2kuZXhwcmVzc2lvbnMuY29uY2F0KHRoaXMucXVhc2kucXVhc2lzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBpbnNlcnQgc3RyaW5ncyBhdCBzdGFydFxuICAgICAgICAgIHZhciB0ZW1wbGF0ZVN0cmluZ3MgPSB0aGlzLnF1YXNpLnF1YXNpcy5tYXAoZnVuY3Rpb24gKHF1YXNpKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocXVhc2kudmFsdWUuY29va2VkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnRhZy5lbmQsIG9yZGVyZWRbMF0uc3RhcnQsIFwiKFtcIiArIHRlbXBsYXRlU3RyaW5ncy5qb2luKCcsICcpICsgXCJdXCIpO1xuXG4gICAgICAgICAgdmFyIGxhc3RJbmRleCA9IG9yZGVyZWRbMF0uc3RhcnQ7XG4gICAgICAgICAgb3JkZXJlZC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnVGVtcGxhdGVFbGVtZW50Jykge1xuICAgICAgICAgICAgICBjb2RlLnJlbW92ZShsYXN0SW5kZXgsIG5vZGUuZW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKGxhc3RJbmRleCwgbm9kZS5zdGFydCwgJywgJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IG5vZGUuZW5kO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29kZS5vdmVyd3JpdGUobGFzdEluZGV4LCB0aGlzLmVuZCwgJyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE5vZGUucHJvdG90eXBlLnRyYW5zcGlsZS5jYWxsKHRoaXMsIGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcbiAgICB9KE5vZGUpO1xuXG4gICAgdmFyIFRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBUZW1wbGF0ZUVsZW1lbnQoKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIFRlbXBsYXRlRWxlbWVudC5fX3Byb3RvX18gPSBOb2RlO1xuICAgICAgVGVtcGxhdGVFbGVtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBUZW1wbGF0ZUVsZW1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGVtcGxhdGVFbGVtZW50O1xuXG4gICAgICBUZW1wbGF0ZUVsZW1lbnQucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKCkge1xuICAgICAgICB0aGlzLnByb2dyYW0uaW5kZW50RXhjbHVzaW9uRWxlbWVudHMucHVzaCh0aGlzKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBUZW1wbGF0ZUVsZW1lbnQ7XG4gICAgfShOb2RlKTtcblxuICAgIHZhciBUZW1wbGF0ZUxpdGVyYWwgPSBmdW5jdGlvbiAoTm9kZSkge1xuICAgICAgZnVuY3Rpb24gVGVtcGxhdGVMaXRlcmFsKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBUZW1wbGF0ZUxpdGVyYWwuX19wcm90b19fID0gTm9kZTtcbiAgICAgIFRlbXBsYXRlTGl0ZXJhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUgJiYgTm9kZS5wcm90b3R5cGUpO1xuICAgICAgVGVtcGxhdGVMaXRlcmFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRlbXBsYXRlTGl0ZXJhbDtcblxuICAgICAgVGVtcGxhdGVMaXRlcmFsLnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAodHJhbnNmb3Jtcy50ZW1wbGF0ZVN0cmluZyAmJiB0aGlzLnBhcmVudC50eXBlICE9PSAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJykge1xuICAgICAgICAgIHZhciBvcmRlcmVkID0gdGhpcy5leHByZXNzaW9ucy5jb25jYXQodGhpcy5xdWFzaXMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydCB8fCBhLmVuZCAtIGIuZW5kO1xuICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgICAgICAgLy8gaW5jbHVkZSBhbGwgZXhwcmVzc2lvbnNcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdUZW1wbGF0ZUVsZW1lbnQnKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gaW5jbHVkZSBhbGwgbm9uLWVtcHR5IHN0cmluZ3NcbiAgICAgICAgICAgIGlmIChub2RlLnZhbHVlLnJhdykgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIC8vIGV4Y2x1ZGUgYWxsIGVtcHR5IHN0cmluZ3Mgbm90IGF0IHRoZSBoZWFkXG4gICAgICAgICAgICByZXR1cm4gIWk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBzcGVjaWFsIGNhc2Ug4oCTIHdlIG1heSBiZSBhYmxlIHRvIHNraXAgdGhlIGZpcnN0IGVsZW1lbnQsXG4gICAgICAgICAgLy8gaWYgaXQncyB0aGUgZW1wdHkgc3RyaW5nLCBidXQgb25seSBpZiB0aGUgc2Vjb25kIGFuZFxuICAgICAgICAgIC8vIHRoaXJkIGVsZW1lbnRzIGFyZW4ndCBib3RoIGV4cHJlc3Npb25zIChzaW5jZSB0aGV5IG1heWJlXG4gICAgICAgICAgLy8gYmUgbnVtZXJpYywgYW5kIGAxICsgMiArICczJyA9PT0gJzMzJ2ApXG4gICAgICAgICAgaWYgKG9yZGVyZWQubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IG9yZGVyZWRbMF07XG4gICAgICAgICAgICB2YXIgdGhpcmQgPSBvcmRlcmVkWzJdO1xuICAgICAgICAgICAgaWYgKGZpcnN0LnR5cGUgPT09ICdUZW1wbGF0ZUVsZW1lbnQnICYmIGZpcnN0LnZhbHVlLnJhdyA9PT0gJycgJiYgdGhpcmQudHlwZSA9PT0gJ1RlbXBsYXRlRWxlbWVudCcpIHtcbiAgICAgICAgICAgICAgb3JkZXJlZC5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXJlbnRoZXNpc2UgPSAodGhpcy5xdWFzaXMubGVuZ3RoICE9PSAxIHx8IHRoaXMuZXhwcmVzc2lvbnMubGVuZ3RoICE9PSAwKSAmJiB0aGlzLnBhcmVudC50eXBlICE9PSAnQXNzaWdubWVudEV4cHJlc3Npb24nICYmIHRoaXMucGFyZW50LnR5cGUgIT09ICdBc3NpZ25tZW50UGF0dGVybicgJiYgdGhpcy5wYXJlbnQudHlwZSAhPT0gJ1ZhcmlhYmxlRGVjbGFyYXRvcicgJiYgKHRoaXMucGFyZW50LnR5cGUgIT09ICdCaW5hcnlFeHByZXNzaW9uJyB8fCB0aGlzLnBhcmVudC5vcGVyYXRvciAhPT0gJysnKTtcblxuICAgICAgICAgIGlmIChwYXJlbnRoZXNpc2UpIGNvZGUuaW5zZXJ0UmlnaHQodGhpcy5zdGFydCwgJygnKTtcblxuICAgICAgICAgIHZhciBsYXN0SW5kZXggPSB0aGlzLnN0YXJ0O1xuXG4gICAgICAgICAgb3JkZXJlZC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnVGVtcGxhdGVFbGVtZW50Jykge1xuICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSAnJztcbiAgICAgICAgICAgICAgaWYgKGkpIHJlcGxhY2VtZW50ICs9ICcgKyAnO1xuICAgICAgICAgICAgICByZXBsYWNlbWVudCArPSBKU09OLnN0cmluZ2lmeShub2RlLnZhbHVlLmNvb2tlZCk7XG5cbiAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUobGFzdEluZGV4LCBub2RlLmVuZCwgcmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudGhlc2lzZSA9IG5vZGUudHlwZSAhPT0gJ0lkZW50aWZpZXInOyAvLyBUT0RPIG90aGVyIGNhc2VzIHdoZXJlIGl0J3Mgc2FmZVxuXG4gICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCQxID0gJyc7XG4gICAgICAgICAgICAgIGlmIChpKSByZXBsYWNlbWVudCQxICs9ICcgKyAnO1xuICAgICAgICAgICAgICBpZiAocGFyZW50aGVzaXNlKSByZXBsYWNlbWVudCQxICs9ICcoJztcblxuICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShsYXN0SW5kZXgsIG5vZGUuc3RhcnQsIHJlcGxhY2VtZW50JDEpO1xuXG4gICAgICAgICAgICAgIGlmIChwYXJlbnRoZXNpc2UpIGNvZGUuaW5zZXJ0TGVmdChub2RlLmVuZCwgJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdEluZGV4ID0gbm9kZS5lbmQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgY2xvc2UgPSAnJztcbiAgICAgICAgICBpZiAocGFyZW50aGVzaXNlKSBjbG9zZSArPSAnKSc7XG5cbiAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShsYXN0SW5kZXgsIHRoaXMuZW5kLCBjbG9zZSk7XG4gICAgICAgIH1cblxuICAgICAgICBOb2RlLnByb3RvdHlwZS50cmFuc3BpbGUuY2FsbCh0aGlzLCBjb2RlLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBUZW1wbGF0ZUxpdGVyYWw7XG4gICAgfShOb2RlKTtcblxuICAgIHZhciBUaGlzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBUaGlzRXhwcmVzc2lvbigpIHtcbiAgICAgICAgTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTm9kZSkgVGhpc0V4cHJlc3Npb24uX19wcm90b19fID0gTm9kZTtcbiAgICAgIFRoaXNFeHByZXNzaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBUaGlzRXhwcmVzc2lvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaGlzRXhwcmVzc2lvbjtcblxuICAgICAgVGhpc0V4cHJlc3Npb24ucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKHRyYW5zZm9ybXMpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybXMuYXJyb3cpIHtcbiAgICAgICAgICB2YXIgbGV4aWNhbEJvdW5kYXJ5ID0gdGhpcy5maW5kTGV4aWNhbEJvdW5kYXJ5KCk7XG4gICAgICAgICAgdmFyIGFycm93RnVuY3Rpb24gPSB0aGlzLmZpbmROZWFyZXN0KCdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicpO1xuICAgICAgICAgIHZhciBsb29wID0gdGhpcy5maW5kTmVhcmVzdChsb29wU3RhdGVtZW50KTtcblxuICAgICAgICAgIGlmIChhcnJvd0Z1bmN0aW9uICYmIGFycm93RnVuY3Rpb24uZGVwdGggPiBsZXhpY2FsQm91bmRhcnkuZGVwdGggfHwgbG9vcCAmJiBsb29wLmJvZHkuY29udGFpbnModGhpcykgJiYgbG9vcC5kZXB0aCA+IGxleGljYWxCb3VuZGFyeS5kZXB0aCB8fCBsb29wICYmIGxvb3AucmlnaHQgJiYgbG9vcC5yaWdodC5jb250YWlucyh0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5hbGlhcyA9IGxleGljYWxCb3VuZGFyeS5nZXRUaGlzQWxpYXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFRoaXNFeHByZXNzaW9uLnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSkge1xuICAgICAgICBpZiAodGhpcy5hbGlhcykge1xuICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB0aGlzLmFsaWFzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFRoaXNFeHByZXNzaW9uO1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgVXBkYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBVcGRhdGVFeHByZXNzaW9uKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBVcGRhdGVFeHByZXNzaW9uLl9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBVcGRhdGVFeHByZXNzaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBVcGRhdGVFeHByZXNzaW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVwZGF0ZUV4cHJlc3Npb247XG5cbiAgICAgIFVwZGF0ZUV4cHJlc3Npb24ucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKHRyYW5zZm9ybXMpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJndW1lbnQudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5maW5kU2NvcGUoZmFsc2UpLmZpbmREZWNsYXJhdGlvbih0aGlzLmFyZ3VtZW50Lm5hbWUpO1xuICAgICAgICAgIGlmIChkZWNsYXJhdGlvbiAmJiBkZWNsYXJhdGlvbi5raW5kID09PSAnY29uc3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29tcGlsZUVycm9yKHRoaXMsIHRoaXMuYXJndW1lbnQubmFtZSArIFwiIGlzIHJlYWQtb25seVwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBzcGVjaWFsIGNhc2Ug4oCTIGh0dHBzOi8vZ2l0bGFiLmNvbS9SaWNoLUhhcnJpcy9idWJsZS9pc3N1ZXMvMTUwXG4gICAgICAgICAgdmFyIHN0YXRlbWVudCA9IGRlY2xhcmF0aW9uICYmIGRlY2xhcmF0aW9uLm5vZGUuYW5jZXN0b3IoMyk7XG4gICAgICAgICAgaWYgKHN0YXRlbWVudCAmJiBzdGF0ZW1lbnQudHlwZSA9PT0gJ0ZvclN0YXRlbWVudCcgJiYgc3RhdGVtZW50LmJvZHkuY29udGFpbnModGhpcykpIHtcbiAgICAgICAgICAgIHN0YXRlbWVudC5yZWFzc2lnbmVkW3RoaXMuYXJndW1lbnQubmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmluaXRpYWxpc2UuY2FsbCh0aGlzLCB0cmFuc2Zvcm1zKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBVcGRhdGVFeHByZXNzaW9uO1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgVmFyaWFibGVEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0aW9uKCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBWYXJpYWJsZURlY2xhcmF0aW9uLl9fcHJvdG9fXyA9IE5vZGU7XG4gICAgICBWYXJpYWJsZURlY2xhcmF0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBWYXJpYWJsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZhcmlhYmxlRGVjbGFyYXRpb247XG5cbiAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb24ucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKHRyYW5zZm9ybXMpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHRoaXMuZmluZFNjb3BlKHRoaXMua2luZCA9PT0gJ3ZhcicpO1xuICAgICAgICB0aGlzLmRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWNsYXJhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY2xhcmF0b3IuaW5pdGlhbGlzZSh0cmFuc2Zvcm1zKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBWYXJpYWJsZURlY2xhcmF0aW9uLnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICB2YXIgaTAgPSB0aGlzLmdldEluZGVudGF0aW9uKCk7XG4gICAgICAgIHZhciBraW5kID0gdGhpcy5raW5kO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLmxldENvbnN0ICYmIGtpbmQgIT09ICd2YXInKSB7XG4gICAgICAgICAga2luZCA9ICd2YXInO1xuICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3RhcnQsIHRoaXMuc3RhcnQgKyB0aGlzLmtpbmQubGVuZ3RoLCBraW5kLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1zLmRlc3RydWN0dXJpbmcgJiYgdGhpcy5wYXJlbnQudHlwZSAhPT0gJ0Zvck9mU3RhdGVtZW50Jykge1xuICAgICAgICAgIHZhciBjID0gdGhpcy5zdGFydDtcbiAgICAgICAgICB2YXIgbGFzdERlY2xhcmF0b3JJc1BhdHRlcm47XG5cbiAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWNsYXJhdG9yLCBpKSB7XG4gICAgICAgICAgICBpZiAoZGVjbGFyYXRvci5pZC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgICAgaWYgKGkgPiAwICYmIHRoaXMkMS5kZWNsYXJhdGlvbnNbaSAtIDFdLmlkLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKGMsIGRlY2xhcmF0b3IuaWQuc3RhcnQsIFwidmFyIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGlubGluZSA9IGxvb3BTdGF0ZW1lbnQudGVzdCh0aGlzJDEucGFyZW50LnR5cGUpO1xuXG4gICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29kZS5yZW1vdmUoYywgZGVjbGFyYXRvci5pZC5zdGFydCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUoYywgZGVjbGFyYXRvci5pZC5zdGFydCwgXCI7XFxuXCIgKyBpMCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgc2ltcGxlID0gZGVjbGFyYXRvci5pbml0LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJiAhZGVjbGFyYXRvci5pbml0LnJld3JpdHRlbjtcblxuICAgICAgICAgICAgICB2YXIgbmFtZSA9IHNpbXBsZSA/IGRlY2xhcmF0b3IuaW5pdC5uYW1lIDogZGVjbGFyYXRvci5maW5kU2NvcGUodHJ1ZSkuY3JlYXRlSWRlbnRpZmllcigncmVmJyk7XG5cbiAgICAgICAgICAgICAgdmFyIGMkMSA9IGRlY2xhcmF0b3Iuc3RhcnQ7XG5cbiAgICAgICAgICAgICAgdmFyIHN0YXRlbWVudEdlbmVyYXRvcnMgPSBbXTtcblxuICAgICAgICAgICAgICBpZiAoc2ltcGxlKSB7XG4gICAgICAgICAgICAgICAgY29kZS5yZW1vdmUoZGVjbGFyYXRvci5pZC5lbmQsIGRlY2xhcmF0b3IuZW5kKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRHZW5lcmF0b3JzLnB1c2goZnVuY3Rpb24gKHN0YXJ0LCBwcmVmaXgsIHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodChkZWNsYXJhdG9yLmlkLmVuZCwgXCJ2YXIgXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChkZWNsYXJhdG9yLmluaXQuZW5kLCBcIlwiICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICAgIGNvZGUubW92ZShkZWNsYXJhdG9yLmlkLmVuZCwgZGVjbGFyYXRvci5lbmQsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlc3RydWN0dXJlKGNvZGUsIGRlY2xhcmF0b3IuZmluZFNjb3BlKGZhbHNlKSwgZGVjbGFyYXRvci5pZCwgbmFtZSwgaW5saW5lLCBzdGF0ZW1lbnRHZW5lcmF0b3JzKTtcblxuICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gaW5saW5lID8gJ3ZhciAnIDogJyc7XG4gICAgICAgICAgICAgIHZhciBzdWZmaXggPSBpbmxpbmUgPyBcIiwgXCIgOiBcIjtcXG5cIiArIGkwO1xuICAgICAgICAgICAgICBzdGF0ZW1lbnRHZW5lcmF0b3JzLmZvckVhY2goZnVuY3Rpb24gKGZuLCBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMkMS5kZWNsYXJhdGlvbnMubGVuZ3RoIC0gMSAmJiBqID09PSBzdGF0ZW1lbnRHZW5lcmF0b3JzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IGlubGluZSA/ICcnIDogJzsnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZuKGRlY2xhcmF0b3Iuc3RhcnQsIGogPT09IDAgPyBwcmVmaXggOiAnJywgc3VmZml4KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlY2xhcmF0b3IudHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpO1xuXG4gICAgICAgICAgICBjID0gZGVjbGFyYXRvci5lbmQ7XG4gICAgICAgICAgICBsYXN0RGVjbGFyYXRvcklzUGF0dGVybiA9IGRlY2xhcmF0b3IuaWQudHlwZSAhPT0gJ0lkZW50aWZpZXInO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGxhc3REZWNsYXJhdG9ySXNQYXR0ZXJuKSB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZShjLCB0aGlzLmVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlY2xhcmF0b3IpIHtcbiAgICAgICAgICAgIGRlY2xhcmF0b3IudHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICB9KE5vZGUpO1xuXG4gICAgdmFyIFZhcmlhYmxlRGVjbGFyYXRvciA9IGZ1bmN0aW9uIChOb2RlKSB7XG4gICAgICBmdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0b3IoKSB7XG4gICAgICAgIE5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5vZGUpIFZhcmlhYmxlRGVjbGFyYXRvci5fX3Byb3RvX18gPSBOb2RlO1xuICAgICAgVmFyaWFibGVEZWNsYXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZSAmJiBOb2RlLnByb3RvdHlwZSk7XG4gICAgICBWYXJpYWJsZURlY2xhcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmFyaWFibGVEZWNsYXJhdG9yO1xuXG4gICAgICBWYXJpYWJsZURlY2xhcmF0b3IucHJvdG90eXBlLmluaXRpYWxpc2UgPSBmdW5jdGlvbiBpbml0aWFsaXNlKHRyYW5zZm9ybXMpIHtcbiAgICAgICAgdmFyIGtpbmQgPSB0aGlzLnBhcmVudC5raW5kO1xuICAgICAgICBpZiAoa2luZCA9PT0gJ2xldCcgJiYgdGhpcy5wYXJlbnQucGFyZW50LnR5cGUgPT09ICdGb3JTdGF0ZW1lbnQnKSB7XG4gICAgICAgICAga2luZCA9ICdmb3IubGV0JzsgLy8gc3BlY2lhbCBjYXNlLi4uXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhcmVudC5zY29wZS5hZGREZWNsYXJhdGlvbih0aGlzLmlkLCBraW5kKTtcbiAgICAgICAgTm9kZS5wcm90b3R5cGUuaW5pdGlhbGlzZS5jYWxsKHRoaXMsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgVmFyaWFibGVEZWNsYXJhdG9yLnByb3RvdHlwZS50cmFuc3BpbGUgPSBmdW5jdGlvbiB0cmFuc3BpbGUoY29kZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdCAmJiB0cmFuc2Zvcm1zLmxldENvbnN0ICYmIHRoaXMucGFyZW50LmtpbmQgIT09ICd2YXInKSB7XG4gICAgICAgICAgdmFyIGluTG9vcCA9IHRoaXMuZmluZE5lYXJlc3QoL0Z1bmN0aW9ufF5Gb3IoSW58T2YpP1N0YXRlbWVudHxeKD86RG8pP1doaWxlU3RhdGVtZW50Lyk7XG4gICAgICAgICAgaWYgKGluTG9vcCAmJiAhL0Z1bmN0aW9uLy50ZXN0KGluTG9vcC50eXBlKSAmJiAhdGhpcy5pc0xlZnREZWNsYXJhdG9yT2ZMb29wKCkpIHtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLmlkLmVuZCwgJyA9ICh2b2lkIDApJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaWQpIHRoaXMuaWQudHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgICBpZiAodGhpcy5pbml0KSB0aGlzLmluaXQudHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpO1xuICAgICAgfTtcblxuICAgICAgVmFyaWFibGVEZWNsYXJhdG9yLnByb3RvdHlwZS5pc0xlZnREZWNsYXJhdG9yT2ZMb29wID0gZnVuY3Rpb24gaXNMZWZ0RGVjbGFyYXRvck9mTG9vcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJyAmJiB0aGlzLnBhcmVudC5wYXJlbnQgJiYgKHRoaXMucGFyZW50LnBhcmVudC50eXBlID09PSAnRm9ySW5TdGF0ZW1lbnQnIHx8IHRoaXMucGFyZW50LnBhcmVudC50eXBlID09PSAnRm9yT2ZTdGF0ZW1lbnQnKSAmJiB0aGlzLnBhcmVudC5wYXJlbnQubGVmdCAmJiB0aGlzLnBhcmVudC5wYXJlbnQubGVmdC5kZWNsYXJhdGlvbnNbMF0gPT09IHRoaXM7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gVmFyaWFibGVEZWNsYXJhdG9yO1xuICAgIH0oTm9kZSk7XG5cbiAgICB2YXIgdHlwZXMgPSB7XG4gICAgICBBcnJheUV4cHJlc3Npb246IEFycmF5RXhwcmVzc2lvbixcbiAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbixcbiAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBBc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICAgIEJpbmFyeUV4cHJlc3Npb246IEJpbmFyeUV4cHJlc3Npb24sXG4gICAgICBCcmVha1N0YXRlbWVudDogQnJlYWtTdGF0ZW1lbnQsXG4gICAgICBDYWxsRXhwcmVzc2lvbjogQ2FsbEV4cHJlc3Npb24sXG4gICAgICBDbGFzc0JvZHk6IENsYXNzQm9keSxcbiAgICAgIENsYXNzRGVjbGFyYXRpb246IENsYXNzRGVjbGFyYXRpb24sXG4gICAgICBDbGFzc0V4cHJlc3Npb246IENsYXNzRXhwcmVzc2lvbixcbiAgICAgIENvbnRpbnVlU3RhdGVtZW50OiBDb250aW51ZVN0YXRlbWVudCxcbiAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6IExvb3BTdGF0ZW1lbnQsXG4gICAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiBFeHBvcnROYW1lZERlY2xhcmF0aW9uLFxuICAgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24sXG4gICAgICBGb3JTdGF0ZW1lbnQ6IEZvclN0YXRlbWVudCxcbiAgICAgIEZvckluU3RhdGVtZW50OiBGb3JJblN0YXRlbWVudCxcbiAgICAgIEZvck9mU3RhdGVtZW50OiBGb3JPZlN0YXRlbWVudCxcbiAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IEZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICBGdW5jdGlvbkV4cHJlc3Npb246IEZ1bmN0aW9uRXhwcmVzc2lvbixcbiAgICAgIElkZW50aWZpZXI6IElkZW50aWZpZXIsXG4gICAgICBJZlN0YXRlbWVudDogSWZTdGF0ZW1lbnQsXG4gICAgICBJbXBvcnREZWNsYXJhdGlvbjogSW1wb3J0RGVjbGFyYXRpb24sXG4gICAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBJbXBvcnREZWZhdWx0U3BlY2lmaWVyLFxuICAgICAgSW1wb3J0U3BlY2lmaWVyOiBJbXBvcnRTcGVjaWZpZXIsXG4gICAgICBKU1hBdHRyaWJ1dGU6IEpTWEF0dHJpYnV0ZSxcbiAgICAgIEpTWENsb3NpbmdFbGVtZW50OiBKU1hDbG9zaW5nRWxlbWVudCxcbiAgICAgIEpTWEVsZW1lbnQ6IEpTWEVsZW1lbnQsXG4gICAgICBKU1hFeHByZXNzaW9uQ29udGFpbmVyOiBKU1hFeHByZXNzaW9uQ29udGFpbmVyLFxuICAgICAgSlNYT3BlbmluZ0VsZW1lbnQ6IEpTWE9wZW5pbmdFbGVtZW50LFxuICAgICAgSlNYU3ByZWFkQXR0cmlidXRlOiBKU1hTcHJlYWRBdHRyaWJ1dGUsXG4gICAgICBMaXRlcmFsOiBMaXRlcmFsLFxuICAgICAgTWVtYmVyRXhwcmVzc2lvbjogTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgIE5ld0V4cHJlc3Npb246IE5ld0V4cHJlc3Npb24sXG4gICAgICBPYmplY3RFeHByZXNzaW9uOiBPYmplY3RFeHByZXNzaW9uLFxuICAgICAgUHJvcGVydHk6IFByb3BlcnR5LFxuICAgICAgUmV0dXJuU3RhdGVtZW50OiBSZXR1cm5TdGF0ZW1lbnQsXG4gICAgICBTcHJlYWRQcm9wZXJ0eTogU3ByZWFkUHJvcGVydHksXG4gICAgICBTdXBlcjogU3VwZXIsXG4gICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbixcbiAgICAgIFRlbXBsYXRlRWxlbWVudDogVGVtcGxhdGVFbGVtZW50LFxuICAgICAgVGVtcGxhdGVMaXRlcmFsOiBUZW1wbGF0ZUxpdGVyYWwsXG4gICAgICBUaGlzRXhwcmVzc2lvbjogVGhpc0V4cHJlc3Npb24sXG4gICAgICBVcGRhdGVFeHByZXNzaW9uOiBVcGRhdGVFeHByZXNzaW9uLFxuICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogVmFyaWFibGVEZWNsYXJhdG9yLFxuICAgICAgV2hpbGVTdGF0ZW1lbnQ6IExvb3BTdGF0ZW1lbnRcbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlbWVudHNXaXRoQmxvY2tzID0ge1xuICAgICAgSWZTdGF0ZW1lbnQ6ICdjb25zZXF1ZW50JyxcbiAgICAgIEZvclN0YXRlbWVudDogJ2JvZHknLFxuICAgICAgRm9ySW5TdGF0ZW1lbnQ6ICdib2R5JyxcbiAgICAgIEZvck9mU3RhdGVtZW50OiAnYm9keScsXG4gICAgICBXaGlsZVN0YXRlbWVudDogJ2JvZHknLFxuICAgICAgRG9XaGlsZVN0YXRlbWVudDogJ2JvZHknLFxuICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246ICdib2R5J1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB3cmFwKHJhdywgcGFyZW50KSB7XG4gICAgICBpZiAoIXJhdykgcmV0dXJuO1xuXG4gICAgICBpZiAoJ2xlbmd0aCcgaW4gcmF3KSB7XG4gICAgICAgIHZhciBpID0gcmF3Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHdyYXAocmF3W2ldLCBwYXJlbnQpO1xuICAgICAgICB9cmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB3aXRoIGUuZy4gc2hvcnRoYW5kIHByb3BlcnRpZXMsIGtleSBhbmQgdmFsdWUgYXJlXG4gICAgICAvLyB0aGUgc2FtZSBub2RlLiBXZSBkb24ndCB3YW50IHRvIHdyYXAgYW4gb2JqZWN0IHR3aWNlXG4gICAgICBpZiAocmF3Ll9fd3JhcHBlZCkgcmV0dXJuO1xuICAgICAgcmF3Ll9fd3JhcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmICgha2V5c1tyYXcudHlwZV0pIHtcbiAgICAgICAga2V5c1tyYXcudHlwZV0gPSBPYmplY3Qua2V5cyhyYXcpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF90eXBlb2YocmF3W2tleV0pID09PSAnb2JqZWN0JztcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNwZWNpYWwgY2FzZSDigJMgYm9keS1sZXNzIGlmL2Zvci93aGlsZSBzdGF0ZW1lbnRzLiBUT0RPIG90aGVycz9cbiAgICAgIHZhciBib2R5VHlwZSA9IHN0YXRlbWVudHNXaXRoQmxvY2tzW3Jhdy50eXBlXTtcbiAgICAgIGlmIChib2R5VHlwZSAmJiByYXdbYm9keVR5cGVdLnR5cGUgIT09ICdCbG9ja1N0YXRlbWVudCcpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSByYXdbYm9keVR5cGVdO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHN5bnRoZXRpYyBibG9jayBzdGF0ZW1lbnQsIG90aGVyd2lzZSBhbGwgaGVsbFxuICAgICAgICAvLyBicmVha3MgbG9vc2Ugd2hlbiBpdCBjb21lcyB0byBibG9jayBzY29waW5nXG4gICAgICAgIHJhd1tib2R5VHlwZV0gPSB7XG4gICAgICAgICAgc3RhcnQ6IGV4cHJlc3Npb24uc3RhcnQsXG4gICAgICAgICAgZW5kOiBleHByZXNzaW9uLmVuZCxcbiAgICAgICAgICB0eXBlOiAnQmxvY2tTdGF0ZW1lbnQnLFxuICAgICAgICAgIGJvZHk6IFtleHByZXNzaW9uXSxcbiAgICAgICAgICBzeW50aGV0aWM6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbmV3IE5vZGUocmF3LCBwYXJlbnQpO1xuXG4gICAgICB2YXIgdHlwZSA9IChyYXcudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50JyA/IEJsb2NrU3RhdGVtZW50IDogdHlwZXNbcmF3LnR5cGVdKSB8fCBOb2RlO1xuICAgICAgcmF3Ll9fcHJvdG9fXyA9IHR5cGUucHJvdG90eXBlO1xuICAgIH1cblxuICAgIHZhciBsZXRDb25zdCA9IC9eKD86bGV0fGNvbnN0KSQvO1xuXG4gICAgZnVuY3Rpb24gU2NvcGUob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIHRoaXMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgICB0aGlzLmlzQmxvY2tTY29wZSA9ICEhb3B0aW9ucy5ibG9jaztcblxuICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgIHdoaWxlIChzY29wZS5pc0Jsb2NrU2NvcGUpIHtcbiAgICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgICB9dGhpcy5mdW5jdGlvblNjb3BlID0gc2NvcGU7XG5cbiAgICAgIHRoaXMuaWRlbnRpZmllcnMgPSBbXTtcbiAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMucmVmZXJlbmNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmJsb2NrU2NvcGVkRGVjbGFyYXRpb25zID0gdGhpcy5pc0Jsb2NrU2NvcGUgPyBudWxsIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuYWxpYXNlcyA9IHRoaXMuaXNCbG9ja1Njb3BlID8gbnVsbCA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuXG4gICAgU2NvcGUucHJvdG90eXBlID0ge1xuICAgICAgYWRkRGVjbGFyYXRpb246IGZ1bmN0aW9uIGFkZERlY2xhcmF0aW9uKG5vZGUsIGtpbmQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHRyYWN0TmFtZXMobm9kZSk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdmFyIG5hbWUgPSBpZGVudGlmaWVyLm5hbWU7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nRGVjbGFyYXRpb24gPSB0aGlzLmRlY2xhcmF0aW9uc1tuYW1lXTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdEZWNsYXJhdGlvbiAmJiAobGV0Q29uc3QudGVzdChraW5kKSB8fCBsZXRDb25zdC50ZXN0KGV4aXN0aW5nRGVjbGFyYXRpb24ua2luZCkpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHdhcm4gYWJvdXQgZG91YmxlIHZhciBkZWNsYXJhdGlvbnM/XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29tcGlsZUVycm9yKGlkZW50aWZpZXIsIG5hbWUgKyBcIiBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHsgbmFtZTogbmFtZSwgbm9kZTogaWRlbnRpZmllciwga2luZDoga2luZCwgaW5zdGFuY2VzOiBbXSB9O1xuICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zW25hbWVdID0gZGVjbGFyYXRpb247XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0Jsb2NrU2NvcGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mdW5jdGlvblNjb3BlLmJsb2NrU2NvcGVkRGVjbGFyYXRpb25zW25hbWVdKSB0aGlzLmZ1bmN0aW9uU2NvcGUuYmxvY2tTY29wZWREZWNsYXJhdGlvbnNbbmFtZV0gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25TY29wZS5ibG9ja1Njb3BlZERlY2xhcmF0aW9uc1tuYW1lXS5wdXNoKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGFkZFJlZmVyZW5jZTogZnVuY3Rpb24gYWRkUmVmZXJlbmNlKGlkZW50aWZpZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uc29saWRhdGVkKSB7XG4gICAgICAgICAgdGhpcy5jb25zb2xpZGF0ZVJlZmVyZW5jZShpZGVudGlmaWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvbnNvbGlkYXRlOiBmdW5jdGlvbiBjb25zb2xpZGF0ZSgpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzJDEuaWRlbnRpZmllcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAvLyB3ZSBtaWdodCBwdXNoIHRvIHRoZSBhcnJheSBkdXJpbmcgY29uc29saWRhdGlvbiwgc28gZG9uJ3QgY2FjaGUgbGVuZ3RoXG4gICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSB0aGlzJDEuaWRlbnRpZmllcnNbaV07XG4gICAgICAgICAgdGhpcyQxLmNvbnNvbGlkYXRlUmVmZXJlbmNlKGlkZW50aWZpZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb25zb2xpZGF0ZWQgPSB0cnVlOyAvLyBUT0RPIHVuZGVyc3RhbmQgd2h5IHRoaXMgaXMgbmVjZXNzYXJ5Li4uIHNlZW1zIGJhZFxuICAgICAgfSxcblxuICAgICAgY29uc29saWRhdGVSZWZlcmVuY2U6IGZ1bmN0aW9uIGNvbnNvbGlkYXRlUmVmZXJlbmNlKGlkZW50aWZpZXIpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5kZWNsYXJhdGlvbnNbaWRlbnRpZmllci5uYW1lXTtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgZGVjbGFyYXRpb24uaW5zdGFuY2VzLnB1c2goaWRlbnRpZmllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZWZlcmVuY2VzW2lkZW50aWZpZXIubmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkgdGhpcy5wYXJlbnQuYWRkUmVmZXJlbmNlKGlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjb250YWluczogZnVuY3Rpb24gY29udGFpbnMobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbnNbbmFtZV0gfHwgKHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuY29udGFpbnMobmFtZSkgOiBmYWxzZSk7XG4gICAgICB9LFxuXG4gICAgICBjcmVhdGVJZGVudGlmaWVyOiBmdW5jdGlvbiBjcmVhdGVJZGVudGlmaWVyKGJhc2UpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSAnbnVtYmVyJykgYmFzZSA9IGJhc2UudG9TdHJpbmcoKTtcblxuICAgICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKC9cXHMvZywgJycpLnJlcGxhY2UoL1xcWyhbXlxcXV0rKVxcXS9nLCAnXyQxJykucmVwbGFjZSgvW15hLXpBLVowLTlfJF0vZywgJ18nKS5yZXBsYWNlKC9fezIsfS8sICdfJyk7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBiYXNlO1xuICAgICAgICB2YXIgY291bnRlciA9IDE7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMkMS5kZWNsYXJhdGlvbnNbbmFtZV0gfHwgdGhpcyQxLnJlZmVyZW5jZXNbbmFtZV0gfHwgdGhpcyQxLmFsaWFzZXNbbmFtZV0gfHwgbmFtZSBpbiByZXNlcnZlZCkge1xuICAgICAgICAgIG5hbWUgPSBiYXNlICsgXCIkXCIgKyBjb3VudGVyKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFsaWFzZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH0sXG5cbiAgICAgIGZpbmREZWNsYXJhdGlvbjogZnVuY3Rpb24gZmluZERlY2xhcmF0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyYXRpb25zW25hbWVdIHx8IHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmZpbmREZWNsYXJhdGlvbihuYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNVc2VTdHJpY3Qobm9kZSkge1xuICAgICAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAobm9kZS50eXBlICE9PSAnRXhwcmVzc2lvblN0YXRlbWVudCcpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChub2RlLmV4cHJlc3Npb24udHlwZSAhPT0gJ0xpdGVyYWwnKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uLnZhbHVlID09PSAndXNlIHN0cmljdCc7XG4gICAgfVxuXG4gICAgdmFyIEJsb2NrU3RhdGVtZW50ID0gZnVuY3Rpb24gKE5vZGUpIHtcbiAgICAgIGZ1bmN0aW9uIEJsb2NrU3RhdGVtZW50KCkge1xuICAgICAgICBOb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChOb2RlKSBCbG9ja1N0YXRlbWVudC5fX3Byb3RvX18gPSBOb2RlO1xuICAgICAgQmxvY2tTdGF0ZW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlICYmIE5vZGUucHJvdG90eXBlKTtcbiAgICAgIEJsb2NrU3RhdGVtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsb2NrU3RhdGVtZW50O1xuXG4gICAgICBCbG9ja1N0YXRlbWVudC5wcm90b3R5cGUuY3JlYXRlU2NvcGUgPSBmdW5jdGlvbiBjcmVhdGVTY29wZSgpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5wYXJlbnRJc0Z1bmN0aW9uID0gL0Z1bmN0aW9uLy50ZXN0KHRoaXMucGFyZW50LnR5cGUpO1xuICAgICAgICB0aGlzLmlzRnVuY3Rpb25CbG9jayA9IHRoaXMucGFyZW50SXNGdW5jdGlvbiB8fCB0aGlzLnBhcmVudC50eXBlID09PSAnUm9vdCc7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgU2NvcGUoe1xuICAgICAgICAgIGJsb2NrOiAhdGhpcy5pc0Z1bmN0aW9uQmxvY2ssXG4gICAgICAgICAgcGFyZW50OiB0aGlzLnBhcmVudC5maW5kU2NvcGUoZmFsc2UpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudElzRnVuY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcyQxLnNjb3BlLmFkZERlY2xhcmF0aW9uKG5vZGUsICdwYXJhbScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBCbG9ja1N0YXRlbWVudC5wcm90b3R5cGUuaW5pdGlhbGlzZSA9IGZ1bmN0aW9uIGluaXRpYWxpc2UodHJhbnNmb3Jtcykge1xuICAgICAgICB0aGlzLnRoaXNBbGlhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXJndW1lbnRzQWxpYXMgPSBudWxsO1xuICAgICAgICB0aGlzLmRlZmF1bHRQYXJhbWV0ZXJzID0gW107XG5cbiAgICAgICAgLy8gbm9ybWFsbHkgdGhlIHNjb3BlIGdldHMgY3JlYXRlZCBoZXJlLCBkdXJpbmcgaW5pdGlhbGlzYXRpb24sXG4gICAgICAgIC8vIGJ1dCBpbiBzb21lIGNhc2VzIChlLmcuIGBmb3JgIHN0YXRlbWVudHMpLCB3ZSBuZWVkIHRvIGNyZWF0ZVxuICAgICAgICAvLyB0aGUgc2NvcGUgZWFybHksIGFzIGl0IHBlcnRhaW5zIHRvIGJvdGggdGhlIGluaXQgYmxvY2sgYW5kXG4gICAgICAgIC8vIHRoZSBib2R5IG9mIHRoZSBzdGF0ZW1lbnRcbiAgICAgICAgaWYgKCF0aGlzLnNjb3BlKSB0aGlzLmNyZWF0ZVNjb3BlKCk7XG5cbiAgICAgICAgdGhpcy5ib2R5LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5pbml0aWFsaXNlKHRyYW5zZm9ybXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNjb3BlLmNvbnNvbGlkYXRlKCk7XG4gICAgICB9O1xuXG4gICAgICBCbG9ja1N0YXRlbWVudC5wcm90b3R5cGUuZmluZExleGljYWxCb3VuZGFyeSA9IGZ1bmN0aW9uIGZpbmRMZXhpY2FsQm91bmRhcnkoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdQcm9ncmFtJykgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICgvXkZ1bmN0aW9uLy50ZXN0KHRoaXMucGFyZW50LnR5cGUpKSByZXR1cm4gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZmluZExleGljYWxCb3VuZGFyeSgpO1xuICAgICAgfTtcblxuICAgICAgQmxvY2tTdGF0ZW1lbnQucHJvdG90eXBlLmZpbmRTY29wZSA9IGZ1bmN0aW9uIGZpbmRTY29wZShmdW5jdGlvblNjb3BlKSB7XG4gICAgICAgIGlmIChmdW5jdGlvblNjb3BlICYmICF0aGlzLmlzRnVuY3Rpb25CbG9jaykgcmV0dXJuIHRoaXMucGFyZW50LmZpbmRTY29wZShmdW5jdGlvblNjb3BlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGU7XG4gICAgICB9O1xuXG4gICAgICBCbG9ja1N0YXRlbWVudC5wcm90b3R5cGUuZ2V0QXJndW1lbnRzQWxpYXMgPSBmdW5jdGlvbiBnZXRBcmd1bWVudHNBbGlhcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFyZ3VtZW50c0FsaWFzKSB7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudHNBbGlhcyA9IHRoaXMuc2NvcGUuY3JlYXRlSWRlbnRpZmllcignYXJndW1lbnRzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hcmd1bWVudHNBbGlhcztcbiAgICAgIH07XG5cbiAgICAgIEJsb2NrU3RhdGVtZW50LnByb3RvdHlwZS5nZXRBcmd1bWVudHNBcnJheUFsaWFzID0gZnVuY3Rpb24gZ2V0QXJndW1lbnRzQXJyYXlBbGlhcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFyZ3VtZW50c0FycmF5QWxpYXMpIHtcbiAgICAgICAgICB0aGlzLmFyZ3VtZW50c0FycmF5QWxpYXMgPSB0aGlzLnNjb3BlLmNyZWF0ZUlkZW50aWZpZXIoJ2FyZ3NBcnJheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJndW1lbnRzQXJyYXlBbGlhcztcbiAgICAgIH07XG5cbiAgICAgIEJsb2NrU3RhdGVtZW50LnByb3RvdHlwZS5nZXRUaGlzQWxpYXMgPSBmdW5jdGlvbiBnZXRUaGlzQWxpYXMoKSB7XG4gICAgICAgIGlmICghdGhpcy50aGlzQWxpYXMpIHtcbiAgICAgICAgICB0aGlzLnRoaXNBbGlhcyA9IHRoaXMuc2NvcGUuY3JlYXRlSWRlbnRpZmllcigndGhpcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGhpc0FsaWFzO1xuICAgICAgfTtcblxuICAgICAgQmxvY2tTdGF0ZW1lbnQucHJvdG90eXBlLmdldEluZGVudGF0aW9uID0gZnVuY3Rpb24gZ2V0SW5kZW50YXRpb24oKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLmluZGVudGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5wcm9ncmFtLm1hZ2ljU3RyaW5nLm9yaWdpbmFsO1xuXG4gICAgICAgICAgdmFyIHVzZU91dGVyID0gdGhpcy5zeW50aGV0aWMgfHwgIXRoaXMuYm9keS5sZW5ndGg7XG4gICAgICAgICAgdmFyIGMgPSB1c2VPdXRlciA/IHRoaXMuc3RhcnQgOiB0aGlzLmJvZHlbMF0uc3RhcnQ7XG5cbiAgICAgICAgICB3aGlsZSAoYyAmJiBzb3VyY2VbY10gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjIC09IDE7XG4gICAgICAgICAgfXRoaXMuaW5kZW50YXRpb24gPSAnJztcblxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICAgICAgYyArPSAxO1xuICAgICAgICAgICAgdmFyIGNoYXIgPSBzb3VyY2VbY107XG5cbiAgICAgICAgICAgIGlmIChjaGFyICE9PSAnICcgJiYgY2hhciAhPT0gJ1xcdCcpIGJyZWFrO1xuXG4gICAgICAgICAgICB0aGlzJDEuaW5kZW50YXRpb24gKz0gY2hhcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5kZW50U3RyaW5nID0gdGhpcy5wcm9ncmFtLm1hZ2ljU3RyaW5nLmdldEluZGVudFN0cmluZygpO1xuXG4gICAgICAgICAgLy8gYWNjb3VudCBmb3IgZGVkZW50ZWQgY2xhc3MgY29uc3RydWN0b3JzXG4gICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQua2luZCA9PT0gJ2NvbnN0cnVjdG9yJyAmJiAhcGFyZW50LnBhcmVudC5wYXJlbnQuc3VwZXJDbGFzcykge1xuICAgICAgICAgICAgICB0aGlzJDEuaW5kZW50YXRpb24gPSB0aGlzJDEuaW5kZW50YXRpb24ucmVwbGFjZShpbmRlbnRTdHJpbmcsICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXNlT3V0ZXIpIHRoaXMuaW5kZW50YXRpb24gKz0gaW5kZW50U3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZW50YXRpb247XG4gICAgICB9O1xuXG4gICAgICBCbG9ja1N0YXRlbWVudC5wcm90b3R5cGUudHJhbnNwaWxlID0gZnVuY3Rpb24gdHJhbnNwaWxlKGNvZGUsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGluZGVudGF0aW9uID0gdGhpcy5nZXRJbmRlbnRhdGlvbigpO1xuXG4gICAgICAgIHZhciBpbnRyb1N0YXRlbWVudEdlbmVyYXRvcnMgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5hcmd1bWVudHNBbGlhcykge1xuICAgICAgICAgIGludHJvU3RhdGVtZW50R2VuZXJhdG9ycy5wdXNoKGZ1bmN0aW9uIChzdGFydCwgcHJlZml4LCBzdWZmaXgpIHtcbiAgICAgICAgICAgIHZhciBhc3NpZ25tZW50ID0gcHJlZml4ICsgXCJ2YXIgXCIgKyB0aGlzJDEuYXJndW1lbnRzQWxpYXMgKyBcIiA9IGFyZ3VtZW50c1wiICsgc3VmZml4O1xuICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KHN0YXJ0LCBhc3NpZ25tZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRoaXNBbGlhcykge1xuICAgICAgICAgIGludHJvU3RhdGVtZW50R2VuZXJhdG9ycy5wdXNoKGZ1bmN0aW9uIChzdGFydCwgcHJlZml4LCBzdWZmaXgpIHtcbiAgICAgICAgICAgIHZhciBhc3NpZ25tZW50ID0gcHJlZml4ICsgXCJ2YXIgXCIgKyB0aGlzJDEudGhpc0FsaWFzICsgXCIgPSB0aGlzXCIgKyBzdWZmaXg7XG4gICAgICAgICAgICBjb2RlLmluc2VydExlZnQoc3RhcnQsIGFzc2lnbm1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYXJndW1lbnRzQXJyYXlBbGlhcykge1xuICAgICAgICAgIGludHJvU3RhdGVtZW50R2VuZXJhdG9ycy5wdXNoKGZ1bmN0aW9uIChzdGFydCwgcHJlZml4LCBzdWZmaXgpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcyQxLnNjb3BlLmNyZWF0ZUlkZW50aWZpZXIoJ2knKTtcbiAgICAgICAgICAgIHZhciBhc3NpZ25tZW50ID0gcHJlZml4ICsgXCJ2YXIgXCIgKyBpICsgXCIgPSBhcmd1bWVudHMubGVuZ3RoLCBcIiArIHRoaXMkMS5hcmd1bWVudHNBcnJheUFsaWFzICsgXCIgPSBBcnJheShcIiArIGkgKyBcIik7XFxuXCIgKyBpbmRlbnRhdGlvbiArIFwid2hpbGUgKCBcIiArIGkgKyBcIi0tICkgXCIgKyB0aGlzJDEuYXJndW1lbnRzQXJyYXlBbGlhcyArIFwiW1wiICsgaSArIFwiXSA9IGFyZ3VtZW50c1tcIiArIGkgKyBcIl1cIiArIHN1ZmZpeDtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChzdGFydCwgYXNzaWdubWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL0Z1bmN0aW9uLy50ZXN0KHRoaXMucGFyZW50LnR5cGUpKSB7XG4gICAgICAgICAgdGhpcy50cmFuc3BpbGVQYXJhbWV0ZXJzKGNvZGUsIHRyYW5zZm9ybXMsIGluZGVudGF0aW9uLCBpbnRyb1N0YXRlbWVudEdlbmVyYXRvcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybXMubGV0Q29uc3QgJiYgdGhpcy5pc0Z1bmN0aW9uQmxvY2spIHtcbiAgICAgICAgICB0aGlzLnRyYW5zcGlsZUJsb2NrU2NvcGVkSWRlbnRpZmllcnMoY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBOb2RlLnByb3RvdHlwZS50cmFuc3BpbGUuY2FsbCh0aGlzLCBjb2RlLCB0cmFuc2Zvcm1zKTtcblxuICAgICAgICBpZiAodGhpcy5zeW50aGV0aWMpIHtcbiAgICAgICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJykge1xuICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmJvZHlbMF07XG5cbiAgICAgICAgICAgIGlmIChpbnRyb1N0YXRlbWVudEdlbmVyYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLnN0YXJ0LCBcIntcIikuaW5zZXJ0UmlnaHQodGhpcy5lbmQsIHRoaXMucGFyZW50LmdldEluZGVudGF0aW9uKCkgKyBcIn1cIik7XG5cbiAgICAgICAgICAgICAgY29kZS5pbnNlcnRSaWdodChleHByLnN0YXJ0LCBcIlxcblwiICsgaW5kZW50YXRpb24gKyBcInJldHVybiBcIik7XG4gICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChleHByLmVuZCwgXCI7XFxuXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0cmFuc2Zvcm1zLmFycm93KSB7XG4gICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChleHByLnN0YXJ0LCBcInsgcmV0dXJuIFwiKTtcbiAgICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KGV4cHIuZW5kLCBcIjsgfVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGludHJvU3RhdGVtZW50R2VuZXJhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdCh0aGlzLnN0YXJ0LCBcIntcIikuaW5zZXJ0UmlnaHQodGhpcy5lbmQsIFwifVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIGlmIChpc1VzZVN0cmljdCh0aGlzLmJvZHlbMF0pKSB7XG4gICAgICAgICAgc3RhcnQgPSB0aGlzLmJvZHlbMF0uZW5kO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3ludGhldGljIHx8IHRoaXMucGFyZW50LnR5cGUgPT09ICdSb290Jykge1xuICAgICAgICAgIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydCA9IHRoaXMuc3RhcnQgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZWZpeCA9IFwiXFxuXCIgKyBpbmRlbnRhdGlvbjtcbiAgICAgICAgdmFyIHN1ZmZpeCA9ICc7JztcbiAgICAgICAgaW50cm9TdGF0ZW1lbnRHZW5lcmF0b3JzLmZvckVhY2goZnVuY3Rpb24gKGZuLCBpKSB7XG4gICAgICAgICAgaWYgKGkgPT09IGludHJvU3RhdGVtZW50R2VuZXJhdG9ycy5sZW5ndGggLSAxKSBzdWZmaXggPSBcIjtcXG5cIjtcbiAgICAgICAgICBmbihzdGFydCwgcHJlZml4LCBzdWZmaXgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIEJsb2NrU3RhdGVtZW50LnByb3RvdHlwZS50cmFuc3BpbGVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gdHJhbnNwaWxlUGFyYW1ldGVycyhjb2RlLCB0cmFuc2Zvcm1zLCBpbmRlbnRhdGlvbiwgaW50cm9TdGF0ZW1lbnRHZW5lcmF0b3JzKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcmVudC5wYXJhbXM7XG5cbiAgICAgICAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09ICdBc3NpZ25tZW50UGF0dGVybicgJiYgcGFyYW0ubGVmdC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1zLmRlZmF1bHRQYXJhbWV0ZXIpIHtcbiAgICAgICAgICAgICAgaW50cm9TdGF0ZW1lbnRHZW5lcmF0b3JzLnB1c2goZnVuY3Rpb24gKHN0YXJ0LCBwcmVmaXgsIHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHZhciBsaHMgPSBwcmVmaXggKyBcImlmICggXCIgKyBwYXJhbS5sZWZ0Lm5hbWUgKyBcIiA9PT0gdm9pZCAwICkgXCIgKyBwYXJhbS5sZWZ0Lm5hbWU7XG5cbiAgICAgICAgICAgICAgICBjb2RlLmluc2VydFJpZ2h0KHBhcmFtLmxlZnQuZW5kLCBsaHMpLm1vdmUocGFyYW0ubGVmdC5lbmQsIHBhcmFtLnJpZ2h0LmVuZCwgc3RhcnQpLmluc2VydExlZnQocGFyYW0ucmlnaHQuZW5kLCBzdWZmaXgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09ICdSZXN0RWxlbWVudCcpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1zLnNwcmVhZFJlc3QpIHtcbiAgICAgICAgICAgICAgaW50cm9TdGF0ZW1lbnRHZW5lcmF0b3JzLnB1c2goZnVuY3Rpb24gKHN0YXJ0LCBwcmVmaXgsIHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHZhciBwZW51bHRpbWF0ZVBhcmFtID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAyXTtcblxuICAgICAgICAgICAgICAgIGlmIChwZW51bHRpbWF0ZVBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICBjb2RlLnJlbW92ZShwZW51bHRpbWF0ZVBhcmFtID8gcGVudWx0aW1hdGVQYXJhbS5lbmQgOiBwYXJhbS5zdGFydCwgcGFyYW0uZW5kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0JDEgPSBwYXJhbS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBwYXJhbS5lbmQ7IC8vIFRPRE8gaHR0cHM6Ly9naXRsYWIuY29tL1JpY2gtSGFycmlzL2J1YmxlL2lzc3Vlcy84XG5cbiAgICAgICAgICAgICAgICAgIHdoaWxlICgvXFxzLy50ZXN0KGNvZGUub3JpZ2luYWxbc3RhcnQkMSAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCQxIC09IDE7XG4gICAgICAgICAgICAgICAgICB9d2hpbGUgKC9cXHMvLnRlc3QoY29kZS5vcmlnaW5hbFtlbmRdKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmQgKz0gMTtcbiAgICAgICAgICAgICAgICAgIH1jb2RlLnJlbW92ZShzdGFydCQxLCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gcGFyYW0uYXJndW1lbnQubmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gdGhpcyQxLnNjb3BlLmNyZWF0ZUlkZW50aWZpZXIoJ2xlbicpO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHBhcmFtcy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBjb2RlLmluc2VydExlZnQoc3RhcnQsIHByZWZpeCArIFwidmFyIFwiICsgbmFtZSArIFwiID0gW10sIFwiICsgbGVuICsgXCIgPSBhcmd1bWVudHMubGVuZ3RoIC0gXCIgKyBjb3VudCArIFwiO1xcblwiICsgaW5kZW50YXRpb24gKyBcIndoaWxlICggXCIgKyBsZW4gKyBcIi0tID4gMCApIFwiICsgbmFtZSArIFwiWyBcIiArIGxlbiArIFwiIF0gPSBhcmd1bWVudHNbIFwiICsgbGVuICsgXCIgKyBcIiArIGNvdW50ICsgXCIgXVwiICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29kZS5pbnNlcnRMZWZ0KHN0YXJ0LCBwcmVmaXggKyBcInZhciBcIiArIG5hbWUgKyBcIiA9IFtdLCBcIiArIGxlbiArIFwiID0gYXJndW1lbnRzLmxlbmd0aDtcXG5cIiArIGluZGVudGF0aW9uICsgXCJ3aGlsZSAoIFwiICsgbGVuICsgXCItLSApIFwiICsgbmFtZSArIFwiWyBcIiArIGxlbiArIFwiIF0gPSBhcmd1bWVudHNbIFwiICsgbGVuICsgXCIgXVwiICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0udHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3Jtcy5wYXJhbWV0ZXJEZXN0cnVjdHVyaW5nKSB7XG4gICAgICAgICAgICAgIHZhciByZWYgPSB0aGlzJDEuc2NvcGUuY3JlYXRlSWRlbnRpZmllcigncmVmJyk7XG4gICAgICAgICAgICAgIGRlc3RydWN0dXJlKGNvZGUsIHRoaXMkMS5zY29wZSwgcGFyYW0sIHJlZiwgZmFsc2UsIGludHJvU3RhdGVtZW50R2VuZXJhdG9ycyk7XG4gICAgICAgICAgICAgIGNvZGUuaW5zZXJ0TGVmdChwYXJhbS5zdGFydCwgcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgQmxvY2tTdGF0ZW1lbnQucHJvdG90eXBlLnRyYW5zcGlsZUJsb2NrU2NvcGVkSWRlbnRpZmllcnMgPSBmdW5jdGlvbiB0cmFuc3BpbGVCbG9ja1Njb3BlZElkZW50aWZpZXJzKGNvZGUpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5zY29wZS5ibG9ja1Njb3BlZERlY2xhcmF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzJDEuc2NvcGUuYmxvY2tTY29wZWREZWNsYXJhdGlvbnNbbmFtZV07XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGRlY2xhcmF0aW9uczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IGxpc3RbaV07XG5cbiAgICAgICAgICAgIHZhciBjb250ID0gZmFsc2U7IC8vIFRPRE8gaW1wbGVtZW50IHByb3BlciBjb250aW51ZS4uLlxuXG4gICAgICAgICAgICBpZiAoZGVjbGFyYXRpb24ua2luZCA9PT0gJ2Zvci5sZXQnKSB7XG4gICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZVxuICAgICAgICAgICAgICB2YXIgZm9yU3RhdGVtZW50ID0gZGVjbGFyYXRpb24ubm9kZS5maW5kTmVhcmVzdCgnRm9yU3RhdGVtZW50Jyk7XG5cbiAgICAgICAgICAgICAgaWYgKGZvclN0YXRlbWVudC5zaG91bGRSZXdyaXRlQXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBvdXRlckFsaWFzID0gdGhpcyQxLnNjb3BlLmNyZWF0ZUlkZW50aWZpZXIobmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyQWxpYXMgPSBmb3JTdGF0ZW1lbnQucmVhc3NpZ25lZFtuYW1lXSA/IHRoaXMkMS5zY29wZS5jcmVhdGVJZGVudGlmaWVyKG5hbWUpIDogbmFtZTtcblxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uLm5hbWUgPSBvdXRlckFsaWFzO1xuICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKGRlY2xhcmF0aW9uLm5vZGUuc3RhcnQsIGRlY2xhcmF0aW9uLm5vZGUuZW5kLCBvdXRlckFsaWFzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGZvclN0YXRlbWVudC5hbGlhc2VzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgb3V0ZXI6IG91dGVyQWxpYXMsXG4gICAgICAgICAgICAgICAgICBpbm5lcjogaW5uZXJBbGlhc1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBkZWNsYXJhdGlvbi5pbnN0YW5jZXM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgYWxpYXMgPSBmb3JTdGF0ZW1lbnQuYm9keS5jb250YWlucyhpZGVudGlmaWVyKSA/IGlubmVyQWxpYXMgOiBvdXRlckFsaWFzO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUoaWRlbnRpZmllci5zdGFydCwgaWRlbnRpZmllci5lbmQsIGFsaWFzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNvbnQpIHtcbiAgICAgICAgICAgICAgdmFyIGFsaWFzJDEgPSB0aGlzJDEuc2NvcGUuY3JlYXRlSWRlbnRpZmllcihuYW1lKTtcblxuICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gYWxpYXMkMSkge1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uLm5hbWUgPSBhbGlhcyQxO1xuICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKGRlY2xhcmF0aW9uLm5vZGUuc3RhcnQsIGRlY2xhcmF0aW9uLm5vZGUuZW5kLCBhbGlhcyQxLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDAsIGxpc3QkMiA9IGRlY2xhcmF0aW9uLmluc3RhbmNlczsgaSQyIDwgbGlzdCQyLmxlbmd0aDsgaSQyICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyJDEgPSBsaXN0JDJbaSQyXTtcblxuICAgICAgICAgICAgICAgICAgaWRlbnRpZmllciQxLnJld3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShpZGVudGlmaWVyJDEuc3RhcnQsIGlkZW50aWZpZXIkMS5lbmQsIGFsaWFzJDEsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQmxvY2tTdGF0ZW1lbnQ7XG4gICAgfShOb2RlKTtcblxuICAgIGZ1bmN0aW9uIFByb2dyYW0oc291cmNlLCBhc3QsIHRyYW5zZm9ybXMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB0aGlzLnR5cGUgPSAnUm9vdCc7XG5cbiAgICAgIC8vIG9wdGlvbnNcbiAgICAgIHRoaXMuanN4ID0gb3B0aW9ucy5qc3ggfHwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQnO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLm1hZ2ljU3RyaW5nID0gbmV3IE1hZ2ljU3RyaW5nKHNvdXJjZSk7XG5cbiAgICAgIHRoaXMuYXN0ID0gYXN0O1xuICAgICAgdGhpcy5kZXB0aCA9IDA7XG5cbiAgICAgIHdyYXAodGhpcy5ib2R5ID0gYXN0LCB0aGlzKTtcbiAgICAgIHRoaXMuYm9keS5fX3Byb3RvX18gPSBCbG9ja1N0YXRlbWVudC5wcm90b3R5cGU7XG5cbiAgICAgIHRoaXMuaW5kZW50RXhjbHVzaW9uRWxlbWVudHMgPSBbXTtcbiAgICAgIHRoaXMuYm9keS5pbml0aWFsaXNlKHRyYW5zZm9ybXMpO1xuXG4gICAgICB0aGlzLmluZGVudEV4Y2x1c2lvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCA9IHRoaXMuaW5kZW50RXhjbHVzaW9uRWxlbWVudHM7IGkkMSA8IGxpc3QubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgbm9kZSA9IGxpc3RbaSQxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gbm9kZS5zdGFydDsgaSA8IG5vZGUuZW5kOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzJDEuaW5kZW50RXhjbHVzaW9uc1tpXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5ib2R5LnRyYW5zcGlsZSh0aGlzLm1hZ2ljU3RyaW5nLCB0cmFuc2Zvcm1zKTtcbiAgICB9XG5cbiAgICBQcm9ncmFtLnByb3RvdHlwZSA9IHtcbiAgICAgIGV4cG9ydDogZnVuY3Rpb24gZXhwb3J0JDEob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb2RlOiB0aGlzLm1hZ2ljU3RyaW5nLnRvU3RyaW5nKCksXG4gICAgICAgICAgbWFwOiB0aGlzLm1hZ2ljU3RyaW5nLmdlbmVyYXRlTWFwKHtcbiAgICAgICAgICAgIGZpbGU6IG9wdGlvbnMuZmlsZSxcbiAgICAgICAgICAgIHNvdXJjZTogb3B0aW9ucy5zb3VyY2UsXG4gICAgICAgICAgICBpbmNsdWRlQ29udGVudDogb3B0aW9ucy5pbmNsdWRlQ29udGVudCAhPT0gZmFsc2VcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgZmluZE5lYXJlc3Q6IGZ1bmN0aW9uIGZpbmROZWFyZXN0KCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIGZpbmRTY29wZTogZnVuY3Rpb24gZmluZFNjb3BlKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG1hdHJpeCA9IHtcbiAgICAgIGNocm9tZToge1xuICAgICAgICA0ODogMTMzMzY4OTcyNSxcbiAgICAgICAgNDk6IDEzNDIwNzg5NzUsXG4gICAgICAgIDUwOiAxNjEwNTE0NDMxLFxuICAgICAgICA1MTogMTYxMDUxNDQzMSxcbiAgICAgICAgNTI6IDIxNDczODUzNDNcbiAgICAgIH0sXG4gICAgICBmaXJlZm94OiB7XG4gICAgICAgIDQzOiAxMjA3MzA3NzQxLFxuICAgICAgICA0NDogMTIwNzMwNzc0MSxcbiAgICAgICAgNDU6IDEyMDczMDc3NDEsXG4gICAgICAgIDQ2OiAxNDc2MjY3NDg1LFxuICAgICAgICA0NzogMTQ3NjI5NjY3MSxcbiAgICAgICAgNDg6IDE0NzYyOTY2NzFcbiAgICAgIH0sXG4gICAgICBzYWZhcmk6IHtcbiAgICAgICAgODogMTA3Mzc0MTgyNCxcbiAgICAgICAgOTogMTMyODk0MDg5NFxuICAgICAgfSxcbiAgICAgIGllOiB7XG4gICAgICAgIDg6IDAsXG4gICAgICAgIDk6IDEwNzM3NDE4MjQsXG4gICAgICAgIDEwOiAxMDczNzQxODI0LFxuICAgICAgICAxMTogMTA3Mzc3MDU5MlxuICAgICAgfSxcbiAgICAgIGVkZ2U6IHtcbiAgICAgICAgMTI6IDE1OTE2MjA3MDEsXG4gICAgICAgIDEzOiAxNjA4NDAwNDc5XG4gICAgICB9LFxuICAgICAgbm9kZToge1xuICAgICAgICAnMC4xMCc6IDEwNzUwNTI2MDgsXG4gICAgICAgICcwLjEyJzogMTA5MTgzMDg1MixcbiAgICAgICAgNDogMTMyNzM5ODUyNyxcbiAgICAgICAgNTogMTMyNzM5ODUyNyxcbiAgICAgICAgNjogMTYxMDUxNDQzMVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZmVhdHVyZXMgPSBbJ2Fycm93JywgJ2NsYXNzZXMnLCAnY29sbGVjdGlvbnMnLCAnY29tcHV0ZWRQcm9wZXJ0eScsICdjb25jaXNlTWV0aG9kUHJvcGVydHknLCAnY29uc3RMb29wJywgJ2NvbnN0UmVkZWYnLCAnZGVmYXVsdFBhcmFtZXRlcicsICdkZXN0cnVjdHVyaW5nJywgJ2V4dGVuZE5hdGl2ZXMnLCAnZm9yT2YnLCAnZ2VuZXJhdG9yJywgJ2xldENvbnN0JywgJ2xldExvb3AnLCAnbGV0TG9vcFNjb3BlJywgJ21vZHVsZUV4cG9ydCcsICdtb2R1bGVJbXBvcnQnLCAnbnVtZXJpY0xpdGVyYWwnLCAnb2JqZWN0UHJvdG8nLCAnb2JqZWN0U3VwZXInLCAnb2xkT2N0YWxMaXRlcmFsJywgJ3BhcmFtZXRlckRlc3RydWN0dXJpbmcnLCAnc3ByZWFkUmVzdCcsICdzdGlja3lSZWdFeHAnLCAnc3ltYm9sJywgJ3RlbXBsYXRlU3RyaW5nJywgJ3VuaWNvZGVFc2NhcGUnLCAndW5pY29kZUlkZW50aWZpZXInLCAndW5pY29kZVJlZ0V4cCcsXG5cbiAgICAvLyBFUzIwMTZcbiAgICAnZXhwb25lbnRpYXRpb24nLFxuXG4gICAgLy8gYWRkaXRpb25hbCB0cmFuc2Zvcm1zLCBub3QgZnJvbVxuICAgIC8vIGh0dHBzOi8vZmVhdHVyZXRlc3RzLmlvXG4gICAgJ3Jlc2VydmVkUHJvcGVydGllcyddO1xuXG4gICAgdmFyIHZlcnNpb24gPSBcIjAuMTUuMlwiO1xuXG4gICAgdmFyIHJlZiA9IFthY29ybk9iamVjdFNwcmVhZCwgYWNvcm5Kc3hdLnJlZHVjZShmdW5jdGlvbiAoZmluYWwsIHBsdWdpbikge1xuICAgICAgcmV0dXJuIHBsdWdpbihmaW5hbCk7XG4gICAgfSwgYWNvcm4kMSk7XG4gICAgdmFyIHBhcnNlID0gcmVmLnBhcnNlO1xuXG4gICAgdmFyIGRhbmdlcm91c1RyYW5zZm9ybXMgPSBbJ2Rhbmdlcm91c1RhZ2dlZFRlbXBsYXRlU3RyaW5nJywgJ2Rhbmdlcm91c0Zvck9mJ107XG5cbiAgICBmdW5jdGlvbiB0YXJnZXQodGFyZ2V0KSB7XG4gICAgICB2YXIgdGFyZ2V0cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgICB2YXIgYml0bWFzayA9IHRhcmdldHMubGVuZ3RoID8gMjE0NzQ4MzY0NyA6IDEwNzM3NDE4MjQ7XG5cbiAgICAgIE9iamVjdC5rZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHZlcnNpb25zID0gbWF0cml4W2Vudmlyb25tZW50XTtcbiAgICAgICAgaWYgKCF2ZXJzaW9ucykgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbnZpcm9ubWVudCAnXCIgKyBlbnZpcm9ubWVudCArIFwiJy4gUGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0bGFiLmNvbS9SaWNoLUhhcnJpcy9idWJsZS9pc3N1ZXNcIik7XG5cbiAgICAgICAgdmFyIHRhcmdldFZlcnNpb24gPSB0YXJnZXRbZW52aXJvbm1lbnRdO1xuICAgICAgICBpZiAoISh0YXJnZXRWZXJzaW9uIGluIHZlcnNpb25zKSkgdGhyb3cgbmV3IEVycm9yKFwiU3VwcG9ydCBkYXRhIGV4aXN0cyBmb3IgdGhlIGZvbGxvd2luZyB2ZXJzaW9ucyBvZiBcIiArIGVudmlyb25tZW50ICsgXCI6IFwiICsgT2JqZWN0LmtleXModmVyc2lvbnMpLmpvaW4oJywgJykgKyBcIi4gUGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0bGFiLmNvbS9SaWNoLUhhcnJpcy9idWJsZS9pc3N1ZXNcIik7XG4gICAgICAgIHZhciBzdXBwb3J0ID0gdmVyc2lvbnNbdGFyZ2V0VmVyc2lvbl07XG5cbiAgICAgICAgYml0bWFzayAmPSBzdXBwb3J0O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciB0cmFuc2Zvcm1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUsIGkpIHtcbiAgICAgICAgdHJhbnNmb3Jtc1tuYW1lXSA9ICEoYml0bWFzayAmIDEgPDwgaSk7XG4gICAgICB9KTtcblxuICAgICAgZGFuZ2Vyb3VzVHJhbnNmb3Jtcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRyYW5zZm9ybXNbbmFtZV0gPSBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdHJhbnNmb3JtcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0oc291cmNlLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG5cbiAgICAgIHZhciBhc3Q7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFzdCA9IHBhcnNlKHNvdXJjZSwge1xuICAgICAgICAgIGVjbWFWZXJzaW9uOiA3LFxuICAgICAgICAgIHByZXNlcnZlUGFyZW5zOiB0cnVlLFxuICAgICAgICAgIHNvdXJjZVR5cGU6ICdtb2R1bGUnLFxuICAgICAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgICAgIGpzeDogdHJ1ZSxcbiAgICAgICAgICAgIG9iamVjdFNwcmVhZDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLnNuaXBwZXQgPSBnZXRTbmlwcGV0KHNvdXJjZSwgZXJyLmxvYyk7XG4gICAgICAgIGVyci50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSArIFwiXFxuXCIgKyBlcnIuc25pcHBldDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhbnNmb3JtcyA9IHRhcmdldChvcHRpb25zLnRhcmdldCB8fCB7fSk7XG4gICAgICBPYmplY3Qua2V5cyhvcHRpb25zLnRyYW5zZm9ybXMgfHwge30pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdtb2R1bGVzJykge1xuICAgICAgICAgIGlmICghKCdtb2R1bGVJbXBvcnQnIGluIG9wdGlvbnMudHJhbnNmb3JtcykpIHRyYW5zZm9ybXMubW9kdWxlSW1wb3J0ID0gb3B0aW9ucy50cmFuc2Zvcm1zLm1vZHVsZXM7XG4gICAgICAgICAgaWYgKCEoJ21vZHVsZUV4cG9ydCcgaW4gb3B0aW9ucy50cmFuc2Zvcm1zKSkgdHJhbnNmb3Jtcy5tb2R1bGVFeHBvcnQgPSBvcHRpb25zLnRyYW5zZm9ybXMubW9kdWxlcztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShuYW1lIGluIHRyYW5zZm9ybXMpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRyYW5zZm9ybSAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgICAgICB0cmFuc2Zvcm1zW25hbWVdID0gb3B0aW9ucy50cmFuc2Zvcm1zW25hbWVdO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvZ3JhbShzb3VyY2UsIGFzdCwgdHJhbnNmb3Jtcywgb3B0aW9ucykuZXhwb3J0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGV4cG9ydHMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGV4cG9ydHMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGV4cG9ydHMuVkVSU0lPTiA9IHZlcnNpb247XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICB9KTtcbiAgXG59KTtcblxudmFyIGJ1YmxlX2RlcHNfMSA9IGJ1YmxlX2RlcHMudHJhbnNmb3JtO1xuXG52YXIgX2dsb2JhbCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbiAgdmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxufSk7XG5cbnZhciBfY29yZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgdmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNC4wJyB9O1xuICBpZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxufSk7XG5cbnZhciBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QoaXQpIHtcbiAgcmV0dXJuICh0eXBlb2YgaXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGl0KSkgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgX2FuT2JqZWN0ID0gZnVuY3Rpb24gX2FuT2JqZWN0KGl0KSB7XG4gIGlmICghX2lzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgX2ZhaWxzID0gZnVuY3Rpb24gX2ZhaWxzKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxudmFyIF9kZXNjcmlwdG9ycyA9ICFfZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gNztcbiAgICB9IH0pLmEgIT0gNztcbn0pO1xuXG52YXIgZG9jdW1lbnQkMSA9IF9nbG9iYWwuZG9jdW1lbnQ7XG52YXIgaXMgPSBfaXNPYmplY3QoZG9jdW1lbnQkMSkgJiYgX2lzT2JqZWN0KGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCk7XG52YXIgX2RvbUNyZWF0ZSA9IGZ1bmN0aW9uIF9kb21DcmVhdGUoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIF9pZThEb21EZWZpbmUgPSAhX2Rlc2NyaXB0b3JzICYmICFfZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KF9kb21DcmVhdGUoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gNztcbiAgICB9IH0pLmEgIT0gNztcbn0pO1xuXG4vLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcblxuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG52YXIgX3RvUHJpbWl0aXZlID0gZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGl0LCBTKSB7XG4gIGlmICghX2lzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFfaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIV9pc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIV9pc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGYgPSBfZGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIF9hbk9iamVjdChPKTtcbiAgUCA9IF90b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgX2FuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoX2llOERvbURlZmluZSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsvKiBlbXB0eSAqL31cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIF9vYmplY3REcCA9IHtcbiAgZjogZlxufTtcblxudmFyIF9wcm9wZXJ0eURlc2MgPSBmdW5jdGlvbiBfcHJvcGVydHlEZXNjKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBfaGlkZSA9IF9kZXNjcmlwdG9ycyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIF9vYmplY3REcC5mKG9iamVjdCwga2V5LCBfcHJvcGVydHlEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgX2hhcyA9IGZ1bmN0aW9uIF9oYXMoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cbnZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xudmFyIF91aWQgPSBmdW5jdGlvbiBfdWlkKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxudmFyIF9yZWRlZmluZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgdmFyIFNSQyA9IF91aWQoJ3NyYycpLFxuICAgICAgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJyxcbiAgICAgICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR10sXG4gICAgICBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbiAgX2NvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG4gIH07XG5cbiAgKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gICAgaWYgKGlzRnVuY3Rpb24pIF9oYXModmFsLCAnbmFtZScpIHx8IF9oaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICAgIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICAgIGlmIChpc0Z1bmN0aW9uKSBfaGFzKHZhbCwgU1JDKSB8fCBfaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICAgIGlmIChPID09PSBfZ2xvYmFsKSB7XG4gICAgICBPW2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc2FmZSkge1xuICAgICAgICBkZWxldGUgT1trZXldO1xuICAgICAgICBfaGlkZShPLCBrZXksIHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoT1trZXldKSBPW2tleV0gPSB2YWw7ZWxzZSBfaGlkZShPLCBrZXksIHZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuICB9KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn0pO1xuXG52YXIgX2FGdW5jdGlvbiA9IGZ1bmN0aW9uIF9hRnVuY3Rpb24oaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcblxudmFyIF9jdHggPSBmdW5jdGlvbiBfY3R4KGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgX2FGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgICB9O1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICAgIH07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkgLyogLi4uYXJncyAqL3tcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAkZXhwb3J0KHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRixcbiAgICAgIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkcsXG4gICAgICBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TLFxuICAgICAgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QLFxuICAgICAgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkIsXG4gICAgICB0YXJnZXQgPSBJU19HTE9CQUwgPyBfZ2xvYmFsIDogSVNfU1RBVElDID8gX2dsb2JhbFtuYW1lXSB8fCAoX2dsb2JhbFtuYW1lXSA9IHt9KSA6IChfZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdLFxuICAgICAgZXhwb3J0cyA9IElTX0dMT0JBTCA/IF9jb3JlIDogX2NvcmVbbmFtZV0gfHwgKF9jb3JlW25hbWVdID0ge30pLFxuICAgICAgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KSxcbiAgICAgIGtleSxcbiAgICAgIG93bixcbiAgICAgIG91dCxcbiAgICAgIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IF9jdHgob3V0LCBfZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IF9jdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgX3JlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBfaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuX2dsb2JhbC5jb3JlID0gX2NvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7IC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7IC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbnZhciBfZXhwb3J0ID0gJGV4cG9ydDtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciBfY29mID0gZnVuY3Rpb24gX2NvZihpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcblxudmFyIF9pb2JqZWN0ID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIF9jb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cbi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG52YXIgX2RlZmluZWQgPSBmdW5jdGlvbiBfZGVmaW5lZChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xuXG52YXIgX3RvSW9iamVjdCA9IGZ1bmN0aW9uIF90b0lvYmplY3QoaXQpIHtcbiAgcmV0dXJuIF9pb2JqZWN0KF9kZWZpbmVkKGl0KSk7XG59O1xuXG4vLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBfdG9JbnRlZ2VyID0gZnVuY3Rpb24gX3RvSW50ZWdlcihpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cbi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIF90b0xlbmd0aCA9IGZ1bmN0aW9uIF90b0xlbmd0aChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKF90b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4kMSA9IE1hdGgubWluO1xudmFyIF90b0luZGV4ID0gZnVuY3Rpb24gX3RvSW5kZXgoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IF90b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbiQxKGluZGV4LCBsZW5ndGgpO1xufTtcblxuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcblxudmFyIF9hcnJheUluY2x1ZGVzID0gZnVuY3Rpb24gX2FycmF5SW5jbHVkZXMoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gX3RvSW9iamVjdCgkdGhpcyksXG4gICAgICAgIGxlbmd0aCA9IF90b0xlbmd0aChPLmxlbmd0aCksXG4gICAgICAgIGluZGV4ID0gX3RvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpLFxuICAgICAgICB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgICB9XG4gICAgfXJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBfZ2xvYmFsW1NIQVJFRF0gfHwgKF9nbG9iYWxbU0hBUkVEXSA9IHt9KTtcbnZhciBfc2hhcmVkID0gZnVuY3Rpb24gX3NoYXJlZChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG52YXIgc2hhcmVkID0gX3NoYXJlZCgna2V5cycpO1xudmFyIF9zaGFyZWRLZXkgPSBmdW5jdGlvbiBfc2hhcmVkS2V5KGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gX3VpZChrZXkpKTtcbn07XG5cbnZhciBhcnJheUluZGV4T2YgPSBfYXJyYXlJbmNsdWRlcyhmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSBfc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xuXG52YXIgX29iamVjdEtleXNJbnRlcm5hbCA9IGZ1bmN0aW9uIF9vYmplY3RLZXlzSW50ZXJuYWwob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IF90b0lvYmplY3Qob2JqZWN0KSxcbiAgICAgIGkgPSAwLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICBrZXk7XG4gIGZvciAoa2V5IGluIE8pIHtcbiAgICBpZiAoa2V5ICE9IElFX1BST1RPKSBfaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKF9oYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9cmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbnZhciBfZW51bUJ1Z0tleXMgPSAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJy5zcGxpdCgnLCcpO1xuXG4vLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcblxuXG52YXIgX29iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIF9vYmplY3RLZXlzSW50ZXJuYWwoTywgX2VudW1CdWdLZXlzKTtcbn07XG5cbnZhciBmJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgX29iamVjdEdvcHMgPSB7XG5cdGY6IGYkMVxufTtcblxudmFyIGYkMiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG52YXIgX29iamVjdFBpZSA9IHtcblx0ZjogZiQyXG59O1xuXG4vLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG5cbnZhciBfdG9PYmplY3QgPSBmdW5jdGlvbiBfdG9PYmplY3QoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChfZGVmaW5lZChpdCkpO1xufTtcblxuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcbnZhciBfb2JqZWN0QXNzaWduID0gISRhc3NpZ24gfHwgX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fSxcbiAgICAgIEIgPSB7fSxcbiAgICAgIFMgPSBTeW1ib2woKSxcbiAgICAgIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIEJba10gPSBrO1xuICB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gX3RvT2JqZWN0KHRhcmdldCksXG4gICAgICBhTGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMSxcbiAgICAgIGdldFN5bWJvbHMgPSBfb2JqZWN0R29wcy5mLFxuICAgICAgaXNFbnVtID0gX29iamVjdFBpZS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBfaW9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pLFxuICAgICAgICBrZXlzID0gZ2V0U3ltYm9scyA/IF9vYmplY3RLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IF9vYmplY3RLZXlzKFMpLFxuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH1yZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG4vLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxuXG5cbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IF9vYmplY3RBc3NpZ24gfSk7XG5cbnZhciBhc3NpZ24gPSBfY29yZS5PYmplY3QuYXNzaWduO1xuXG52YXIgX3BvbHkgPSB7IGFzc2lnbjogYXNzaWduIH07XG5cbnZhciBvcHRzID0ge1xuICBvYmplY3RBc3NpZ246ICdfcG9seS5hc3NpZ24nLFxuICB0cmFuc2Zvcm1zOiB7XG4gICAgZGFuZ2Vyb3VzRm9yT2Y6IHRydWUsXG4gICAgZGFuZ2Vyb3VzVGFnZ2VkVGVtcGxhdGVTdHJpbmc6IHRydWVcbiAgfVxufTtcblxudmFyIHRyYW5zZm9ybSQkMSA9IChmdW5jdGlvbiAoY29kZSkge1xuICByZXR1cm4gYnVibGVfZGVwc18xKGNvZGUsIG9wdHMpLmNvZGU7XG59KTtcblxudmFyIGVycm9yQm91bmRhcnkgPSBmdW5jdGlvbiBlcnJvckJvdW5kYXJ5KGVsZW1lbnQsIGVycm9yQ2FsbGJhY2spIHtcbiAgdmFyIGlzRXZhbEZ1bmMgPSB0eXBlb2YgZWxlbWVudCA9PT0gJ2Z1bmN0aW9uJztcblxuICBpZiAoaXNFdmFsRnVuYyAmJiBDb21wb25lbnQuaXNQcm90b3R5cGVPZihlbGVtZW50KSkge1xuICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IGVsZW1lbnQucHJvdG90eXBlLnJlbmRlcjtcbiAgICBlbGVtZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNFdmFsRnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiB3cmFwcGVkUEZDKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbnZhciBldmFsQ29kZSA9IGZ1bmN0aW9uIGV2YWxDb2RlKGNvZGUsIHNjb3BlKSB7XG4gIHZhciBzY29wZUtleXMgPSBPYmplY3Qua2V5cyhzY29wZSk7XG4gIHZhciBzY29wZVZhbHVlcyA9IHNjb3BlS2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBzY29wZVtrZXldO1xuICB9KTtcbiAgdmFyIHJlcyA9IG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoRnVuY3Rpb24sIFtudWxsXS5jb25jYXQoWydfcG9seScsICdSZWFjdCddLCBzY29wZUtleXMsIFtjb2RlXSkpKSgpO1xuICByZXR1cm4gcmVzLmFwcGx5KHVuZGVmaW5lZCwgW19wb2x5LCBSZWFjdF0uY29uY2F0KHNjb3BlVmFsdWVzKSk7XG59O1xuXG52YXIgZ2VuZXJhdGVFbGVtZW50ID0gZnVuY3Rpb24gZ2VuZXJhdGVFbGVtZW50KF9yZWYsIGVycm9yQ2FsbGJhY2spIHtcbiAgdmFyIF9yZWYkY29kZSA9IF9yZWYuY29kZSxcbiAgICAgIGNvZGUgPSBfcmVmJGNvZGUgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRjb2RlLFxuICAgICAgX3JlZiRzY29wZSA9IF9yZWYuc2NvcGUsXG4gICAgICBzY29wZSA9IF9yZWYkc2NvcGUgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZiRzY29wZTtcblxuICAvLyBOT1RFOiBXb3JrYXJvdW5kIGZvciBjbGFzc2VzLCBzaW5jZSBidWJsZSBkb2Vzbid0IGFsbG93IGByZXR1cm5gIHdpdGhvdXQgYSBmdW5jdGlvblxuICB2YXIgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm0kJDEoY29kZSkudHJpbSgpLnJlcGxhY2UoL152YXIgXFx3KyA9LywgJycpLnJlcGxhY2UoLzskLywgJycpO1xuXG4gIHJldHVybiBlcnJvckJvdW5kYXJ5KGV2YWxDb2RlKCdyZXR1cm4gKCcgKyB0cmFuc2Zvcm1lZCArICcpJywgc2NvcGUpLCBlcnJvckNhbGxiYWNrKTtcbn07XG5cbnZhciByZW5kZXJFbGVtZW50QXN5bmMgPSBmdW5jdGlvbiByZW5kZXJFbGVtZW50QXN5bmMoX3JlZjIsIHJlc3VsdENhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gIHZhciBfcmVmMiRjb2RlID0gX3JlZjIuY29kZSxcbiAgICAgIGNvZGUgPSBfcmVmMiRjb2RlID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYyJGNvZGUsXG4gICAgICBfcmVmMiRzY29wZSA9IF9yZWYyLnNjb3BlLFxuICAgICAgc2NvcGUgPSBfcmVmMiRzY29wZSA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmMiRzY29wZTtcblxuICB2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGVsZW1lbnQpIHtcbiAgICByZXN1bHRDYWxsYmFjayhlcnJvckJvdW5kYXJ5KGVsZW1lbnQsIGVycm9yQ2FsbGJhY2spKTtcbiAgfTtcblxuICBpZiAoIS9yZW5kZXJcXHMqXFwoLy50ZXN0KGNvZGUpKSB7XG4gICAgcmV0dXJuIGVycm9yQ2FsbGJhY2sobmV3IFN5bnRheEVycm9yKCdOby1JbmxpbmUgZXZhbHVhdGlvbnMgbXVzdCBjYWxsIGByZW5kZXJgLicpKTtcbiAgfVxuXG4gIGV2YWxDb2RlKHRyYW5zZm9ybSQkMShjb2RlKSwgX2V4dGVuZHMoe30sIHNjb3BlLCB7IHJlbmRlcjogcmVuZGVyIH0pKTtcbn07XG5cbnZhciBjc3MgPSBcIlxcbi5wcmlzbS1jb2RlIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2hpdGUtc3BhY2U6IHByZTtcXG5cXG4gIGJhY2tncm91bmQtY29sb3I6ICMxRDFGMjE7XFxuICBjb2xvcjogI0M1QzhDNjtcXG5cXG4gIHBhZGRpbmc6IDAuNXJlbTtcXG4gIG1hcmdpbjogMDtcXG5cXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgdGV4dC1zaGFkb3c6IG5vbmU7XFxuICAtd2Via2l0LWh5cGhlbnM6IG5vbmU7XFxuICAtbXMtaHlwaGVuczogbm9uZTtcXG4gIGh5cGhlbnM6IG5vbmU7XFxuICB3b3JkLXdyYXA6IG5vcm1hbDtcXG4gIHdvcmQtYnJlYWs6IG5vcm1hbDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICB3b3JkLXNwYWNpbmc6IG5vcm1hbDtcXG4gIC1tb3otdGFiLXNpemU6IDI7XFxuICAtby10YWItc2l6ZTogMjtcXG4gIHRhYi1zaXplOiAyO1xcbn1cXG5cXG4udG9rZW4uY29tbWVudCxcXG4udG9rZW4ucHJvbG9nLFxcbi50b2tlbi5kb2N0eXBlLFxcbi50b2tlbi5jZGF0YSB7XFxuICBjb2xvcjogaHNsKDMwLCAyMCUsIDUwJSk7XFxufVxcblxcbi50b2tlbi5wdW5jdHVhdGlvbiB7XFxuICBvcGFjaXR5OiAuNztcXG59XFxuXFxuLm5hbWVzcGFjZSB7XFxuICBvcGFjaXR5OiAuNztcXG59XFxuXFxuLnRva2VuLnByb3BlcnR5LFxcbi50b2tlbi50YWcsXFxuLnRva2VuLmJvb2xlYW4sXFxuLnRva2VuLm51bWJlcixcXG4udG9rZW4uY29uc3RhbnQsXFxuLnRva2VuLnN5bWJvbCB7XFxuICBjb2xvcjogaHNsKDM1MCwgNDAlLCA3MCUpO1xcbn1cXG5cXG4udG9rZW4uc2VsZWN0b3IsXFxuLnRva2VuLmF0dHItbmFtZSxcXG4udG9rZW4uc3RyaW5nLFxcbi50b2tlbi5jaGFyLFxcbi50b2tlbi5idWlsdGluLFxcbi50b2tlbi5pbnNlcnRlZCB7XFxuICBjb2xvcjogaHNsKDc1LCA3MCUsIDYwJSk7XFxufVxcblxcbi50b2tlbi5vcGVyYXRvcixcXG4udG9rZW4uZW50aXR5LFxcbi50b2tlbi51cmwsXFxuLmxhbmd1YWdlLWNzcyAudG9rZW4uc3RyaW5nLFxcbi5zdHlsZSAudG9rZW4uc3RyaW5nLFxcbi50b2tlbi52YXJpYWJsZSB7XFxuICBjb2xvcjogaHNsKDQwLCA5MCUsIDYwJSk7XFxufVxcblxcbi50b2tlbi5hdHJ1bGUsXFxuLnRva2VuLmF0dHItdmFsdWUsXFxuLnRva2VuLmtleXdvcmQge1xcbiAgY29sb3I6IGhzbCgzNTAsIDQwJSwgNzAlKTtcXG59XFxuXFxuLnRva2VuLnJlZ2V4LFxcbi50b2tlbi5pbXBvcnRhbnQge1xcbiAgY29sb3I6ICNlOTA7XFxufVxcblxcbi50b2tlbi5pbXBvcnRhbnQsXFxuLnRva2VuLmJvbGQge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcbi50b2tlbi5pdGFsaWMge1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbn1cXG5cXG4udG9rZW4uZW50aXR5IHtcXG4gIGN1cnNvcjogaGVscDtcXG59XFxuXFxuLnRva2VuLmRlbGV0ZWQge1xcbiAgY29sb3I6IHJlZDtcXG59XFxuXCI7XG5cbnZhciBwcmlzbVN0eWxpbmcgPSBSZWFjdC5jcmVhdGVFbGVtZW50KCdzdHlsZScsIHsgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBjc3MgfSB9KTtcblxudmFyIFN0eWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByaXNtU3R5bGluZztcbn0pO1xuXG52YXIgTGl2ZUNvbnRleHRUeXBlcyA9IHtcbiAgbGl2ZTogaW5kZXgkNi5zaGFwZSh7XG4gICAgY29kZTogaW5kZXgkNi5zdHJpbmcsXG4gICAgZXJyb3I6IGluZGV4JDYuc3RyaW5nLFxuXG4gICAgb25FcnJvcjogaW5kZXgkNi5mdW5jLFxuICAgIG9uQ2hhbmdlOiBpbmRleCQ2LmZ1bmMsXG5cbiAgICBlbGVtZW50OiBpbmRleCQ2Lm9uZU9mVHlwZShbaW5kZXgkNi5zdHJpbmcsIGluZGV4JDYubnVtYmVyLCBpbmRleCQ2LmVsZW1lbnQsIGluZGV4JDYuZnVuY10pXG4gIH0pXG59O1xuXG52YXIgTGl2ZVByb3ZpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTGl2ZVByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBMaXZlUHJvdmlkZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExpdmVQcm92aWRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsLmFwcGx5KF9Db21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBzY29wZSA9IF90aGlzJHByb3BzLnNjb3BlLFxuICAgICAgICAgIHRyYW5zZm9ybUNvZGUgPSBfdGhpcyRwcm9wcy50cmFuc2Zvcm1Db2RlLFxuICAgICAgICAgIG5vSW5saW5lID0gX3RoaXMkcHJvcHMubm9JbmxpbmU7XG5cbiAgICAgIF90aGlzLnRyYW5zcGlsZSh7IGNvZGU6IGNvZGUsIHNjb3BlOiBzY29wZSwgdHJhbnNmb3JtQ29kZTogdHJhbnNmb3JtQ29kZSwgbm9JbmxpbmU6IG5vSW5saW5lIH0pO1xuICAgIH0sIF90aGlzLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHsgZXJyb3I6IGVycm9yLnRvU3RyaW5nKCkgfSk7XG4gICAgfSwgX3RoaXMudHJhbnNwaWxlID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBjb2RlID0gX3JlZi5jb2RlLFxuICAgICAgICAgIHNjb3BlID0gX3JlZi5zY29wZSxcbiAgICAgICAgICB0cmFuc2Zvcm1Db2RlID0gX3JlZi50cmFuc2Zvcm1Db2RlLFxuICAgICAgICAgIF9yZWYkbm9JbmxpbmUgPSBfcmVmLm5vSW5saW5lLFxuICAgICAgICAgIG5vSW5saW5lID0gX3JlZiRub0lubGluZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG5vSW5saW5lO1xuXG4gICAgICAvLyBUcmFuc3BpbGF0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGlucHV0ID0ge1xuICAgICAgICBjb2RlOiB0cmFuc2Zvcm1Db2RlID8gdHJhbnNmb3JtQ29kZShjb2RlKSA6IGNvZGUsXG4gICAgICAgIHNjb3BlOiBzY29wZVxuICAgICAgfTtcbiAgICAgIHZhciBlcnJvckNhbGxiYWNrID0gZnVuY3Rpb24gZXJyb3JDYWxsYmFjayhlcnIpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnNldFN0YXRlKHsgZWxlbWVudDogdW5kZWZpbmVkLCBlcnJvcjogZXJyLnRvU3RyaW5nKCkgfSk7XG4gICAgICB9O1xuICAgICAgdmFyIHJlbmRlckVsZW1lbnQgPSBmdW5jdGlvbiByZW5kZXJFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnNldFN0YXRlKF9leHRlbmRzKHt9LCBzdGF0ZSwgeyBlbGVtZW50OiBlbGVtZW50IH0pKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFN0YXRlIHJlc2V0IG9iamVjdFxuICAgICAgdmFyIHN0YXRlID0geyB1bnNhZmVXcmFwcGVyRXJyb3I6IHVuZGVmaW5lZCwgZXJyb3I6IHVuZGVmaW5lZCB9O1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAobm9JbmxpbmUpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShfZXh0ZW5kcyh7fSwgc3RhdGUsIHsgZWxlbWVudDogbnVsbCB9KSk7IC8vIFJlc2V0IG91dHB1dCBmb3IgYXN5bmMgKG5vIGlubGluZSkgZXZhbHVhdGlvblxuICAgICAgICAgIHJlbmRlckVsZW1lbnRBc3luYyhpbnB1dCwgcmVuZGVyRWxlbWVudCwgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVuZGVyRWxlbWVudChnZW5lcmF0ZUVsZW1lbnQoaW5wdXQsIGVycm9yQ2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoX2V4dGVuZHMoe30sIHN0YXRlLCB7IGVycm9yOiBlcnJvci50b1N0cmluZygpIH0pKTtcbiAgICAgIH1cbiAgICB9LCBfdGhpcy5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaXZlOiBfZXh0ZW5kcyh7fSwgX3RoaXMuc3RhdGUsIHtcbiAgICAgICAgICBjb2RlOiBfdGhpcy5wcm9wcy5jb2RlLFxuICAgICAgICAgIG9uRXJyb3I6IF90aGlzLm9uRXJyb3IsXG4gICAgICAgICAgb25DaGFuZ2U6IF90aGlzLm9uQ2hhbmdlXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0sIF90ZW1wKSwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBMaXZlUHJvdmlkZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY29kZSA9IF9wcm9wcy5jb2RlLFxuICAgICAgICBzY29wZSA9IF9wcm9wcy5zY29wZSxcbiAgICAgICAgdHJhbnNmb3JtQ29kZSA9IF9wcm9wcy50cmFuc2Zvcm1Db2RlLFxuICAgICAgICBub0lubGluZSA9IF9wcm9wcy5ub0lubGluZTtcblxuXG4gICAgdGhpcy50cmFuc3BpbGUoeyBjb2RlOiBjb2RlLCBzY29wZTogc2NvcGUsIHRyYW5zZm9ybUNvZGU6IHRyYW5zZm9ybUNvZGUsIG5vSW5saW5lOiBub0lubGluZSB9KTtcbiAgfTtcblxuICBMaXZlUHJvdmlkZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKF9yZWYyKSB7XG4gICAgdmFyIGNvZGUgPSBfcmVmMi5jb2RlLFxuICAgICAgICBzY29wZSA9IF9yZWYyLnNjb3BlLFxuICAgICAgICBub0lubGluZSA9IF9yZWYyLm5vSW5saW5lLFxuICAgICAgICB0cmFuc2Zvcm1Db2RlID0gX3JlZjIudHJhbnNmb3JtQ29kZTtcblxuICAgIGlmIChjb2RlICE9PSB0aGlzLnByb3BzLmNvZGUgfHwgc2NvcGUgIT09IHRoaXMucHJvcHMuc2NvcGUgfHwgbm9JbmxpbmUgIT09IHRoaXMucHJvcHMubm9JbmxpbmUgfHwgdHJhbnNmb3JtQ29kZSAhPT0gdGhpcy5wcm9wcy50cmFuc2Zvcm1Db2RlKSB7XG4gICAgICB0aGlzLnRyYW5zcGlsZSh7IGNvZGU6IGNvZGUsIHNjb3BlOiBzY29wZSwgdHJhbnNmb3JtQ29kZTogdHJhbnNmb3JtQ29kZSwgbm9JbmxpbmU6IG5vSW5saW5lIH0pO1xuICAgIH1cbiAgfTtcblxuICBMaXZlUHJvdmlkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3Byb3BzMi5jaGlsZHJlbixcbiAgICAgICAgY2xhc3NOYW1lID0gX3Byb3BzMi5jbGFzc05hbWUsXG4gICAgICAgIGNvZGUgPSBfcHJvcHMyLmNvZGUsXG4gICAgICAgIG1vdW50U3R5bGVzaGVldCA9IF9wcm9wczIubW91bnRTdHlsZXNoZWV0LFxuICAgICAgICBub0lubGluZSA9IF9wcm9wczIubm9JbmxpbmUsXG4gICAgICAgIHRyYW5zZm9ybUNvZGUgPSBfcHJvcHMyLnRyYW5zZm9ybUNvZGUsXG4gICAgICAgIHJlc3QgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMyLCBbJ2NoaWxkcmVuJywgJ2NsYXNzTmFtZScsICdjb2RlJywgJ21vdW50U3R5bGVzaGVldCcsICdub0lubGluZScsICd0cmFuc2Zvcm1Db2RlJ10pO1xuXG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgX2V4dGVuZHMoe1xuICAgICAgICBjbGFzc05hbWU6IGNuKCdyZWFjdC1saXZlJywgY2xhc3NOYW1lKVxuICAgICAgfSwgcmVzdCksXG4gICAgICBtb3VudFN0eWxlc2hlZXQgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChTdHlsZSwgbnVsbCksXG4gICAgICBjaGlsZHJlblxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIExpdmVQcm92aWRlcjtcbn0oQ29tcG9uZW50KTtcblxuTGl2ZVByb3ZpZGVyLmNoaWxkQ29udGV4dFR5cGVzID0gTGl2ZUNvbnRleHRUeXBlcztcbkxpdmVQcm92aWRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGNvZGU6ICcnLFxuICBtb3VudFN0eWxlc2hlZXQ6IHRydWUsXG4gIG5vSW5saW5lOiBmYWxzZVxufTtcbkxpdmVQcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gIGNsYXNzTmFtZTogaW5kZXgkNi5zdHJpbmcsXG4gIGNvZGU6IGluZGV4JDYuc3RyaW5nLFxuICBzY29wZTogaW5kZXgkNi5vYmplY3QsXG4gIG1vdW50U3R5bGVzaGVldDogaW5kZXgkNi5ib29sLFxuICBub0lubGluZTogaW5kZXgkNi5ib29sLFxuICB0cmFuc2Zvcm1Db2RlOiBpbmRleCQ2LmZ1bmNcbn07XG5cbnZhciBMaXZlRWRpdG9yID0gZnVuY3Rpb24gTGl2ZUVkaXRvcihwcm9wcywgX3JlZikge1xuICB2YXIgbGl2ZSA9IF9yZWYubGl2ZTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRpdG9yLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjb2RlOiBsaXZlLmNvZGUsXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGNvZGUpIHtcbiAgICAgIGxpdmUub25DaGFuZ2UoY29kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcHMub25DaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvcHMub25DaGFuZ2UoY29kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG59O1xuXG5MaXZlRWRpdG9yLmNvbnRleHRUeXBlcyA9IExpdmVDb250ZXh0VHlwZXM7XG5MaXZlRWRpdG9yLnByb3BUeXBlcyA9IHsgb25DaGFuZ2U6IGluZGV4JDYuZnVuYyB9O1xuXG52YXIgTGl2ZUVycm9yID0gZnVuY3Rpb24gTGl2ZUVycm9yKF9yZWYsIF9yZWYyKSB7XG4gIHZhciBsaXZlID0gX3JlZjIubGl2ZTtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcmVzdCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJ10pO1xuICByZXR1cm4gbGl2ZS5lcnJvciA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2RpdicsXG4gICAgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgIGNsYXNzTmFtZTogY24oJ3JlYWN0LWxpdmUtZXJyb3InLCBjbGFzc05hbWUpXG4gICAgfSksXG4gICAgbGl2ZS5lcnJvclxuICApIDogbnVsbDtcbn07XG5cbkxpdmVFcnJvci5jb250ZXh0VHlwZXMgPSBMaXZlQ29udGV4dFR5cGVzO1xuXG52YXIgTGl2ZVByZXZpZXcgPSBmdW5jdGlvbiBMaXZlUHJldmlldyhfcmVmLCBfcmVmMikge1xuICB2YXIgZWxlbWVudCA9IF9yZWYyLmxpdmUuZWxlbWVudDtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgcmVzdCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJ10pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZGl2JyxcbiAgICBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgY2xhc3NOYW1lOiBjbigncmVhY3QtbGl2ZS1wcmV2aWV3JywgY2xhc3NOYW1lKVxuICAgIH0pLFxuICAgIHR5cGVvZiBlbGVtZW50ID09PSAnZnVuY3Rpb24nID8gY3JlYXRlRWxlbWVudChlbGVtZW50KSA6IGVsZW1lbnRcbiAgKTtcbn07XG5cbkxpdmVQcmV2aWV3LmNvbnRleHRUeXBlcyA9IExpdmVDb250ZXh0VHlwZXM7XG5cbnZhciB3aXRoTGl2ZSA9IGZ1bmN0aW9uIHdpdGhMaXZlKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgdmFyIFdpdGhMaXZlID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBpbmhlcml0cyhXaXRoTGl2ZSwgX0NvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBXaXRoTGl2ZSgpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFdpdGhMaXZlKTtcbiAgICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgV2l0aExpdmUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBsaXZlID0gdGhpcy5jb250ZXh0LmxpdmU7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIHsgbGl2ZTogbGl2ZSB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFdpdGhMaXZlO1xuICB9KENvbXBvbmVudCk7XG5cbiAgV2l0aExpdmUuY29udGV4dFR5cGVzID0gTGl2ZUNvbnRleHRUeXBlcztcblxuXG4gIHJldHVybiBXaXRoTGl2ZTtcbn07XG5cbmV4cG9ydCB7IEVkaXRvciwgTGl2ZVByb3ZpZGVyLCBMaXZlRWRpdG9yLCBMaXZlRXJyb3IsIExpdmVQcmV2aWV3LCB3aXRoTGl2ZSwgZ2VuZXJhdGVFbGVtZW50LCByZW5kZXJFbGVtZW50QXN5bmMgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWxpdmUvZGlzdC9yZWFjdC1saXZlLmVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTNcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDYiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDUgNiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIChiNjQubGVuZ3RoICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKChsZW4gKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDUgNiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gNSA2IiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MTdcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDYiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUGFnZSBmcm9tIFwiLi4vbGF5b3V0cy9tYWluXCI7XG5pbXBvcnQgeyBMaXZlUHJvdmlkZXIsIExpdmVFZGl0b3IsIExpdmVFcnJvciwgTGl2ZVByZXZpZXcgfSBmcm9tIFwicmVhY3QtbGl2ZVwiO1xuXG5jbGFzcyBDYWZmZWluYXRlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGUgPSB7IGNvZmZlZTogXCJBbWVyaWNhbm9cIiB9O1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5zdGF0ZS5jb2ZmZWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+IChcbiAgPFBhZ2U+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJjb250XCI+XG4gICAgICA8aDI+RXhhbXBsZSAxPC9oMj5cbiAgICAgIDxwPlxuICAgICAgICBNb3N0IHNpbXBsZSByZW5kZXIgcHJvcHMsIHNlbmRpbmcgdGhlIHN0YXRlIGZyb20gdGhlIHBhcmVudCB0byB0aGUgY2hpbGRcbiAgICAgIDwvcD5cbiAgICAgIDxMaXZlUHJvdmlkZXJcbiAgICAgICAgY29kZT17YGNsYXNzIENhZmZlaW5hdGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0ZSA9IHsgY29mZmVlOiBcIkFtZXJpY2Fub1wiIH07XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnN0YXRlLmNvZmZlZSk7XG4gIH1cbn1gfVxuICAgICAgPlxuICAgICAgICA8TGl2ZUVkaXRvciAvPlxuICAgICAgPC9MaXZlUHJvdmlkZXI+XG4gICAgICA8YnIgLz5cbiAgICAgIDxiciAvPlxuICAgICAgPENhZmZlaW5hdGU+e2JldmVyYWdlID0+IDxkaXY+RHJpbmtpbmcgYW4ge2JldmVyYWdlfS48L2Rpdj59PC9DYWZmZWluYXRlPlxuICAgICAgPGJyIC8+XG4gICAgICA8YnIgLz5cbiAgICAgIDxMaXZlUHJvdmlkZXJcbiAgICAgICAgY29kZT17YDxDYWZmZWluYXRlPntiZXZlcmFnZSA9PiA8ZGl2PkRyaW5raW5nIGFuIHtiZXZlcmFnZX0uPC9kaXY+fTwvQ2FmZmVpbmF0ZT5gfVxuICAgICAgPlxuICAgICAgICA8TGl2ZUVkaXRvciAvPlxuICAgICAgPC9MaXZlUHJvdmlkZXI+XG4gICAgPC9kaXY+XG5cbiAgICA8c3R5bGUganN4PntgXG4gICAgICAuY29udCB7XG4gICAgICAgIGJhY2tncm91bmQ6ICNlZWU7XG4gICAgICAgIHBhZGRpbmc6IDEwMHB4O1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIHRyYW5zaXRpb246IDEwMG1zIGVhc2UtaW4gYmFja2dyb3VuZDtcbiAgICAgIH1cbiAgICBgfTwvc3R5bGU+XG4gIDwvUGFnZT5cbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWdlcy9leGFtcGxlMS5qcz9lbnRyeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBOzs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBOzs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0xBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbEJBOzs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNIQTs7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDaEJBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNGQTs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNUQTs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNiQTs7Ozs7Ozs7QUNBQTs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSEE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoQkE7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pDQTs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBOzs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3RCQTtBQUNBOzs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqQ0E7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1JBOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNGQTs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsQkE7Ozs7Ozs7QUNBQTs7Ozs7OztBQ0FBOzs7Ozs7QUNBQTtBQUNBOzs7Ozs7O0FDREE7QUFDQTtBQUNBOzs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4QkE7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDN2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0JBOzs7Ozs7QUNBQTtBQUNBOzs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBOzs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTs7Ozs7O0FDQUE7QUFDQTtBQUNBOzs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdHRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0hBO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBOzs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM3dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3BoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN2R0E7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNIQTtBQUNBOzs7Ozs7O0FDREE7QUFDQTs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuUkE7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7Ozs7Ozs7QUFEQTtBQUFBO0FBQ0E7O0FBQUE7QUFDQTtBQURBO0FBQUE7O0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFGQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDREE7QUFDQTs7Ozs7Ozs7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFMQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTs7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRkE7QUFOQTtBQXFCQTtBQXJCQTtBQXVCQTtBQUNBO0FBREE7Ozs7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDck9BOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN6eWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUM1dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7QUFFQTtBQUFBOzs7Ozs7O0FBSUE7QUFDQTs7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBOztBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBOztBQUFBO0FBUUE7QUFSQTtBQUNBOztBQU9BO0FBRUE7QUFGQTtBQUFBO0FBRUE7O0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTs7QUFBQTtBQUNBO0FBREE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBOztBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7O0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTs7QUFBQTtBQUdBO0FBSEE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQXhCQTtBQUFBO0FBQUE7QUFEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0EiLCJzb3VyY2VSb290IjoiIn0=
            return { page: comp.default }
          })
        